<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="面经总结">
<meta property="og:type" content="article">
<meta property="og:title" content="面经总结">
<meta property="og:url" content="http://example.com/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="勺子柄の博客">
<meta property="og:description" content="面经总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210406141934323.png">
<meta property="og:image" content="http://example.com/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210406142221333.png">
<meta property="og:image" content="http://example.com/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210406144955826.png">
<meta property="og:image" content="http://example.com/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210406145829715.png">
<meta property="og:image" content="http://example.com/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210407215856506.png">
<meta property="og:image" content="http://example.com/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/log/source_posts/面经总结/image-20210520171632061.png">
<meta property="og:image" content="http://example.com/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210415132137774.png">
<meta property="og:image" content="http://example.com/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210416164524307.png">
<meta property="og:image" content="http://example.com/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210423105943552.png">
<meta property="article:published_time" content="2021-04-06T05:48:48.000Z">
<meta property="article:modified_time" content="2021-05-24T06:40:38.087Z">
<meta property="article:author" content="鲍炳江">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210406141934323.png">

<link rel="canonical" href="http://example.com/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面经总结 | 勺子柄の博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="勺子柄の博客" type="application/atom+xml">
</head>


<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">勺子柄の博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录生活中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">9</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">20</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">45</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="鲍炳江">
      <meta itemprop="description" content="不接受任何评判">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="勺子柄の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面经总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-06 13:48:48" itemprop="dateCreated datePublished" datetime="2021-04-06T13:48:48+08:00">2021-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-24 14:40:38" itemprop="dateModified" datetime="2021-05-24T14:40:38+08:00">2021-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>
            <div class="post-description">面经总结</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Mybatis一级、二级缓存"><a href="#Mybatis一级、二级缓存" class="headerlink" title="Mybatis一级、二级缓存"></a>Mybatis一级、二级缓存</h2><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>　Mybatis对缓存提供支持，但是在没有配置的默认情况下，它只开启一级缓存，一级缓存只是相对于同一个SqlSession而言。所以在参数和SQL完全一样的情况下，我们使用同一个SqlSession对象调用一个Mapper方法，往往只执行一次SQL，因为使用SelSession第一次查询后，MyBatis会将其放在缓存中，以后再查询的时候，如果没有声明需要刷新，并且缓存没有超时的情况下，SqlSession都会取出当前缓存的数据，而不会再次发送SQL到数据库。</p>
<p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210406141934323.png" alt="image-20210406141934323"></p>
<p>一级缓存的生命周期：当SqlSession调用close方法和clearCache方法或者执行更新操作 会使缓存失效</p>
<p>如何判断完全相同的两次查询</p>
<ul>
<li>传入的statementId</li>
<li>查询时要求的结果集中的结果范围<ul>
<li>sql语句和参数</li>
</ul>
</li>
</ul>
<h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>　MyBatis的二级缓存是Application级别的缓存，它可以提高对数据库查询的效率，以提高应用的性能</p>
<p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210406142221333.png" alt="image-20210406142221333"></p>
<p>SqlSessionFactory层面上的二级缓存默认是不开启的，二级缓存的开启需要进行配置，实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的。 也就是要求实现Serializable接口，配置方法很简单，只需要在映射XML文件配置就可以开启缓存了<cache>，如果我们配置了二级缓存就意味着：</cache></p>
<ul>
<li>映射语句文件中的所有select语句将会被缓存。</li>
<li>映射语句文件中的所有insert、update和delete语句会刷新缓存。</li>
<li>缓存会使用默认的Least Recently Used（LRU，最近最少使用的）算法来收回。</li>
<li>缓存会存储列表集合或对象(无论查询方法返回什么)的1024个引用</li>
<li>缓存会被视为是read/write(可读/可写)的缓存，意味着对象检索不是共享的，而且可以安全的被调用者修改，不干扰其他调用者或线程所做的潜在修改。</li>
</ul>
<p>除了在映射配置文件中设置开启缓存 还要在全局配置中开启</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个配置使全局的映射器(二级缓存)启用或禁用缓存--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        .....</span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    ....</span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Ping过程及其原理"><a href="#Ping过程及其原理" class="headerlink" title="Ping过程及其原理"></a>Ping过程及其原理</h2><p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210406144955826.png" alt="image-20210406144955826"></p>
<p>同一网段ping：如果主机A，要去 ping主机B，那么主机A，就要封装二层报文，他会先查自己的arp缓存表，如果没有B的MAC地址，就会向外发送一个ARP广播包</p>
<p>跨网段ping：如果主机A要ping主机C,那么主机A发现主机C的IP和自己不是同一网段,他就去找 <strong>网关</strong> 转发,但是他也不知道网关的MAC情况下呢?他就会向之前那个步骤一样 <strong>先发送一个ARP广播,学到网关的MAC,再发封装ICMP报文给网关路由器.**当路由器收到主机A发过来的ICMP报文,发现自己的目的地址是其本身MAC地址,根据目的的IP2.1.1.1,查路由表,发现2.1.1.1/24的路由表项,得到一个出口指针,去掉原来的MAC头部.加上自己的MAC地址向主机C转发( **如果网关也没有主机C的MAC地址,还是要向前面一个步骤一样,ARP广播一下即可相互学到….路由器2端口能学到主机D的MAC,主机D也能学到路由器2端口的MAC.</strong> .) </p>
<h2 id="ping命令使用的协议"><a href="#ping命令使用的协议" class="headerlink" title="ping命令使用的协议"></a>ping命令使用的协议</h2><p>使用的是<a target="_blank" rel="noopener" href="http://www.so.com/s?q=ICMP&ie=utf-8&src=internal_wenda_recommend_text">ICMP</a>协议，是“Internet Control Message Protocol”（Internet控制消息协议）的缩写，是<a target="_blank" rel="noopener" href="http://www.so.com/s?q=TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F&ie=utf-8&src=internal_wenda_recommend_text">TCP/IP协议族</a>的一个子协议，用于在IP主机、<a target="_blank" rel="noopener" href="http://www.so.com/s?q=%E8%B7%AF%E7%94%B1%E5%99%A8&ie=utf-8&src=internal_wenda_recommend_text">路由器</a>之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。<br>它是用来检查网络是否通畅或者网络连接速度的命令。它所利用的原理是这样的：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少。</p>
<p>ICMP是网络层协议</p>
<h2 id="dns域名解析过程"><a href="#dns域名解析过程" class="headerlink" title="dns域名解析过程"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_37964071/article/details/80500825?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&dist_request_id=1331974.5978.16185553650719277&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">dns域名解析过程</a></h2><h2 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h2><p>为什么要做主从复制？</p>
<p>1、在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p>
<p>2、做数据的热备</p>
<p>3、架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</p>
<p><strong>原理</strong></p>
<p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210406145829715.png" alt="image-20210406145829715"></p>
<ul>
<li>步骤一：主库db的更新事件(update、insert、delete)被写到binlog</li>
<li>步骤二：从库发起连接，连接到主库</li>
<li>步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库</li>
<li>步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log</li>
<li>步骤五：还会创建一个SQL线程，从relay log里面读取内容，从<strong>Exec_Master_Log_Pos</strong>位置开始执行读取到的更新事件，将更新内容写入到slave的db</li>
</ul>
<p>注：上面的解释是解释每一步做了什么，整个mysql主从复制是异步的，不是按照上面的步骤执行的。</p>
<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>序列化和反序列化的定义：</p>
<p>(1)Java序列化就是指把Java对象转换为字节序列的过程</p>
<p>​    Java反序列化就是指把字节序列恢复为Java对象的过程。</p>
<p>(2)序列化最重要的作用：在传递和保存对象时.保证对象的完整性和可传递性。对象转换为有序字节流,以便在网络上传输或者保存在本地文件中。</p>
<p>​    反序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。  </p>
<p>(3)序列化和反序列化的注意点：</p>
<p>​    ①序列化时，只对对象的状态进行保存，而不管对象的方法；</p>
<p>​    ②当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</p>
<p>​    ③当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；这是能用序列化解决深拷贝的重要原因；</p>
<p>​    ④并非所有的对象都可以序列化，至于为什么不可以，有很多原因了，比如：</p>
<p>​        安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列    化进行传输的过程中，这个对象的private等域是不受保护的；</p>
<p>​        资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现；</p>
<p>​    ⑤声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。</p>
<p>​    ⑥序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。为它赋予明确的值。显式地定义serialVersionUID有两种用途：在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</p>
<p>​    ⑦Java有很多基础类已经实现了serializable接口，比如String,Vector等。但是也有一些没有实现serializable接口的；</p>
<h2 id="JDBC原理"><a href="#JDBC原理" class="headerlink" title="JDBC原理"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qlqwjy/p/8227665.html"><strong>JDBC原理</strong></a></h2><h2 id="java三大特性"><a href="#java三大特性" class="headerlink" title="java三大特性"></a>java三大特性</h2><p><strong>封装</strong></p>
<p>封装也称信息隐藏，是指利用抽象数据类型把数据和基于数据的操作封装起来，使其成为一个不可分割的整体，数据隐藏在抽象数据内部，尽可能的隐藏数据细节，只保留一些接口使其与外界发生联系。也就是说用户无需知道内部的数据和方法的具体实现细节，只需根据留在外部的接口进行操作就行。</p>
<p>为了保证属性的安全性可以把属性的访问修饰符改为private 通过setter和getter 方法访问和复制</p>
<p><strong>继承</strong></p>
<p>多个类具有共同的属性（成员变量）与行为（成员方法）的时候，将这些共同的部分抽取出来定义到一个公共的类中，其他及各类可以与这个公共的类形成继承关系，从而在多个类中不需要重 复定义公共部分。这个公共的类就是父类，其他的类就是子类。子类可以直接访问父类的非私有化成员变量，访问父类的私有化成员变量可以使用super.get()方法。</p>
<p>继承的特点：</p>
<p>（1）子类比父类强大<br>（2）java是单继承，不能进行多继承。但是可以继承多层子类（<strong>不建议继承超过3层</strong>）<br>（3）子类继承父类，但是对父类的成员变量是无法直接操作，只能通过父类继承过来的setter和getter方法.</p>
<p><strong>多态</strong></p>
<p>java程序中定义的引用变量所指向的具体类型和通过该引用类型发出的方法在调用时不确定，该引用变量发出的方法到底调用哪个类的实现的方法，必须在程序运行期间才能决定</p>
<p>多态有两种：引用多态和方法多态</p>
<h2 id="Object类中的方法"><a href="#Object类中的方法" class="headerlink" title="Object类中的方法"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42570601/article/details/104049532">Object类中的方法</a></h2><h2 id="HashMap为什么使用拉链法解决地址冲突"><a href="#HashMap为什么使用拉链法解决地址冲突" class="headerlink" title="HashMap为什么使用拉链法解决地址冲突"></a>HashMap为什么使用拉链法解决地址冲突</h2><p>不用的key，可能会有相同的hashcode</p>
<h2 id="TCP和UDP的应用"><a href="#TCP和UDP的应用" class="headerlink" title="TCP和UDP的应用"></a>TCP和UDP的应用</h2><p>|||</p>
<p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210407215856506.png" alt="image-20210407215856506"></p>
<h2 id="数据先写Redis还是DB？redis缓存一致性问题？"><a href="#数据先写Redis还是DB？redis缓存一致性问题？" class="headerlink" title="数据先写Redis还是DB？redis缓存一致性问题？"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_20597727/article/details/88652045?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujs&dist_request_id=1330144.34982.16182132035436085&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujs">数据先写Redis还是DB？redis缓存一致性问题？</a></h2><h2 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/47fd7f86c848">redis分布式锁</a></h2><h2 id="操作系统缓存一致性问题"><a href="#操作系统缓存一致性问题" class="headerlink" title="操作系统缓存一致性问题"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/HuiH/p/12690598.html">操作系统缓存一致性问题</a></h2><h2 id="有没有了解其他的缓存中间件？"><a href="#有没有了解其他的缓存中间件？" class="headerlink" title="有没有了解其他的缓存中间件？"></a>有没有了解其他的缓存中间件？</h2><p>1、MemCached介绍<br>MemCached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。它便于快速开发，减轻开发难度，解决了大数据量缓存的很多问题，本质上，它是一个简洁的key-value存储系统</p>
<p>2、MemCached工作原理<br>主要通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度。</p>
<p>Redis与MemCached的区别<br>（1）Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等；<br>（2）Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；<br>（3）虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘；<br>（4）分布式集群部署：<br>a、memcache集群节点间的数据是独立的，不能相互通讯，但可以利用magent开源软件解决 ;<br>b、Redis高可用的，可以做一主多从，主从之间进行数据同步。 当Master宕机后，通过选举算法(Paxos、Raft)从slave中选举出新Master继续对外提供服务，主机恢复后以slave的身份重新加入<br>（5）存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）；<br>（6）灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；</p>
<h2 id="分布式-session"><a href="#分布式-session" class="headerlink" title="分布式 session"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35620501/article/details/95047642?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control">分布式 session</a></h2><h2 id="Spring-bean的循环依赖以及解决方式"><a href="#Spring-bean的循环依赖以及解决方式" class="headerlink" title="Spring-bean的循环依赖以及解决方式"></a><a target="_blank" rel="noopener" href="https://louyuting.blog.csdn.net/article/details/77940767?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs&dist_request_id=1330147.35086.16182171424877071&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs">Spring-bean的循环依赖以及解决方式</a></h2><h2 id="为什么需要三层缓存？两层或者一层行不行"><a href="#为什么需要三层缓存？两层或者一层行不行" class="headerlink" title="为什么需要三层缓存？两层或者一层行不行"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangmingan123/article/details/111178263">为什么需要三层缓存？两层或者一层行不行</a></h2><h2 id="Java进程CPU占用率高的排查和常见解决方案"><a href="#Java进程CPU占用率高的排查和常见解决方案" class="headerlink" title="Java进程CPU占用率高的排查和常见解决方案"></a><a target="_blank" rel="noopener" href="https://wangcw.blog.csdn.net/article/details/86242263?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-8.baidujs&dist_request_id=1330147.36178.16182310883074655&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-8.baidujs">Java进程CPU占用率高的排查和常见解决方案</a></h2><h2 id="给定-a、b-两个文件，各存放-50-亿个-URL，每个-URL-各占-64B，内存限制是-4G。请找出-a、b-两个文件共同的-URL"><a href="#给定-a、b-两个文件，各存放-50-亿个-URL，每个-URL-各占-64B，内存限制是-4G。请找出-a、b-两个文件共同的-URL" class="headerlink" title="给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aspirant/p/7154551.html">给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL</a></h2><h2 id="https的加密过程"><a href="#https的加密过程" class="headerlink" title="https的加密过程"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32998153/article/details/80022489">https的加密过程</a></h2><h2 id="HTTPS的数字证书验证原理"><a href="#HTTPS的数字证书验证原理" class="headerlink" title="HTTPS的数字证书验证原理"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuxingrong666/article/details/83869161?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">HTTPS的数字证书验证原理</a></h2><p>根据这篇文章回答这两个问题:客户端拿到服务端的证书后是怎么验证证书的合法性？证书有什么内容？</p>
<h2 id="InnoDB怎么解决幻读问题"><a href="#InnoDB怎么解决幻读问题" class="headerlink" title="InnoDB怎么解决幻读问题"></a>InnoDB怎么解决幻读问题</h2><p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/log\source_posts\面经总结\image-20210520171632061.png" alt="image-20210520171632061"></p>
<h2 id="Http，TCP，Socker之间的区别和联系"><a href="#Http，TCP，Socker之间的区别和联系" class="headerlink" title="Http，TCP，Socker之间的区别和联系"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jing99/p/6181488.html">Http，TCP，Socker之间的区别和联系</a></h2><h2 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/q2546/p/11394723.html">List和Set的区别</a></h2><h2 id="HashMap查询复杂度"><a href="#HashMap查询复杂度" class="headerlink" title="HashMap查询复杂度"></a>HashMap查询复杂度</h2><p>面试官问了这么一个问题：你说HashMap的get迭代了一个链表，那怎么保证HashMap的时间复杂度O(1)?链表的查找的时间复杂度又是多少？</p>
<p>HashMap的get方法源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jdk1.7</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">return</span> getForNullKey();  </span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());  </span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];  </span><br><span class="line">         e != <span class="keyword">null</span>;  </span><br><span class="line">         e = e.next) &#123;  </span><br><span class="line">        Object k;  </span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))  </span><br><span class="line">            <span class="keyword">return</span> e.value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>分四步：<br>1.判断key，根据key算出索引。<br>2.根据索引获得索引位置所对应的键值对链表。<br>3.遍历键值对链表，根据key找到对应的Entry键值对。<br>4.拿到value。<br>分析：<br>以上四步要保证HashMap的时间复杂度O(1)，需要保证每一步都是O(1)，现在看起来就第三步对链表的循环的时间复杂度影响最大，链表查找的时间复杂度为O(n)，与链表长度有关。我们要保证那个链表长度为1，才可以说时间复杂度能满足O(1)。但这么说来只有那个hash算法尽量减少冲突，才能使链表长度尽可能短，理想状态为1。因此可以得出结论：HashMap的查找时间复杂度只有在最理想的情况下才会为O(1)，而要保证这个理想状态不是我们开发者控制的。</p>
<p>在jdk1.8中 如果链表长度超过8会转换为红黑树 时间复杂度为log(n)</p>
<h2 id="数组实现扩容栈"><a href="#数组实现扩容栈" class="headerlink" title="数组实现扩容栈"></a>数组实现扩容栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个数组容器 用于存储栈元素 data.length是最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [] data;</span><br><span class="line">    <span class="comment">//栈顶标记 用于标记栈顶元素的位置 当栈为空时,top=-1,栈中有效元素的个数是top+1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//默认最大容量为10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     创建一个默认容量为10的栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data=<span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     创建一个指定容量为capacity的栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(capacity&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            capacity=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.data=<span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将元素e入栈,如果当前的栈已经满了,则扩容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 用户指定入栈的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top+<span class="number">1</span>==data.length)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] newData = Arrays.copyOf(data,top * <span class="number">2</span>);</span><br><span class="line">            data = newData;</span><br><span class="line">        &#125;</span><br><span class="line">        data[++top]=e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     从栈中弹出一个元素,如果栈已经是空,则返回-1即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回当前栈顶的元素,如果栈为空则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top==-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈为空，无法弹栈元素&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[top--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     获取当前栈顶元素，如果栈为空，则返回-1即可</span></span><br><span class="line"><span class="comment">     <span class="doctag">@return</span> 返回当前栈顶元素，如果栈为空,如果栈为空,则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top==-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[top];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     判断当前栈是否为空</span></span><br><span class="line"><span class="comment">     <span class="doctag">@return</span> true表示栈空,否则栈不为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     清空当前的栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        top=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     获取栈中有效元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap不安全的原因"><a href="#HashMap不安全的原因" class="headerlink" title="HashMap不安全的原因"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/swpu_ocean/article/details/88917958?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">HashMap不安全的原因</a></h2><h2 id="PriorityQueue原理"><a href="#PriorityQueue原理" class="headerlink" title="PriorityQueue原理"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010623927/article/details/87179364">PriorityQueue原理</a></h2><h2 id="进程有哪些状态？是如何进行切换的"><a href="#进程有哪些状态？是如何进行切换的" class="headerlink" title="进程有哪些状态？是如何进行切换的"></a>进程有哪些状态？是如何进行切换的</h2><p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210415132137774.png" alt="image-20210415132137774"></p>
<h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h2><p> 存放进程的管理和控制信息的数据结构称为进程控制块。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。</p>
<p>在不同的操作系统中对进程的控制和管理机制不同，PCB中的信息多少也不一样，通常PCB应包含如下一些信息。</p>
<p>1、进程标识符 name：每个进程都必须有一个唯一的标识符，可以是字符串，也可以是一个数字。UNIX系统中就是一个整型数。在进程创建时由系统赋予。</p>
<p>2、进程当前状态 status：说明进程当前所处的状态。为了管理的方便，系统设计时会将相同的状态的进程组成一个队列，如就绪进程队列，等待进程则要根据等待的事件组成多个等待队列，如等待打印机队列、等待磁盘I/O完成队列等等。</p>
<p>3、进程相应的程序和数据地址，以便把PCB与其程序和数据联系起来。</p>
<p>4、进程资源清单。列出所拥有的除CPU外的资源记录，如拥有的I/O设备，打开的文件列表等。</p>
<p>5、进程优先级 priority：进程的优先级反映进程的紧迫程序，通常由用户指定和系统设置。UNIX系统采用用户设置和系统计算相结合的方式确定进程的优先级 。 </p>
<p>6、CPU现场保护区 cpustatus：当进程因某种原因不能继续占用CPU时（等待打印机），释放CPU，这时就要将CPU的各种状态信息保护起来，为将来再次得到处理机恢复CPU的各种状态，继续运行。</p>
<p>7、进程同步与通信机制 用于实现进程间互斥、同步和通信所需的信号量等。</p>
<p>8、进程所在队列PCB的链接字   根据进程所处的现行状态，进程相应的PCB参加到不同队列中。PCB链接字指出该进程所在队列中下一个进程PCB的首地址。</p>
<p>9、与进程有关的其他信息。 如进程记账信息，进程占用CPU的时间等。</p>
<h2 id="为什么要划分内核态和用户态"><a href="#为什么要划分内核态和用户态" class="headerlink" title="为什么要划分内核态和用户态"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29996285/article/details/88078906?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs&dist_request_id=1331647.20720.16184648700343463&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs">为什么要划分内核态和用户态</a></h2><h2 id="操作系统用户态和内核态之间的切换过程"><a href="#操作系统用户态和内核态之间的切换过程" class="headerlink" title="操作系统用户态和内核态之间的切换过程"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/ddna/article/details/4941373?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs">操作系统用户态和内核态之间的切换过程</a></h2><h2 id="内核线程的作用"><a href="#内核线程的作用" class="headerlink" title="内核线程的作用"></a>内核线程的作用</h2><ol>
<li>周期性的将dirty内存页同步到磁盘设备上。 比如 bpflush线程周期性的把dirty数据写回磁盘</li>
<li>内存页很少的情况下，把内存page 交换到磁盘空间。 比如kswapd，系统会为每一个NUMA创建一个kswapd进程，但是在非NUMA系统上，则仅有一个kswapd</li>
<li>管理延时动作</li>
<li>实现文件系统的事物日志</li>
</ol>
<h2 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/xifeijian/article/details/8209783?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs">进程上下文切换</a></h2><h2 id="线程上下文切换和进程上下文切换的区别"><a href="#线程上下文切换和进程上下文切换的区别" class="headerlink" title="线程上下文切换和进程上下文切换的区别"></a><a target="_blank" rel="noopener" href="https://www.msdn.hk/jshtml/jswz/752.html">线程上下文切换和进程上下文切换的区别</a></h2><h2 id="进程上下文切换频繁的后果"><a href="#进程上下文切换频繁的后果" class="headerlink" title="进程上下文切换频繁的后果"></a>进程上下文切换频繁的后果</h2><p>context switch过高会导致CPU频繁在寄存器和运行队列之间奔波 ，更多的时间花在了进程切换，而不是真正工作的进程上。直接的消耗包括CPU寄存器需要保存和加载，系统调度器的代码需要执行。间接消耗在于多核cache之间的共享数据。</p>
<h2 id="大量close-wait对系统影响"><a href="#大量close-wait对系统影响" class="headerlink" title="大量close_wait对系统影响"></a>大量close_wait对系统影响</h2><p>在服务器与客户端通信过程中，因服务器发生了socket未关导致的closed_wait发生</p>
<ol>
<li>导致服务器资源消耗过大</li>
<li>如果连接数满了，服务端进程将无法新建socket来响应新的请求。</li>
<li>假设你的程序会去连接另一个服务，而未正常关闭，那么可能导致你的程序超过最大连接数的时候报异常，引起连锁反应甚至导致程序崩溃</li>
</ol>
<h2 id="三次握手第三次报文丢失怎么办"><a href="#三次握手第三次报文丢失怎么办" class="headerlink" title="三次握手第三次报文丢失怎么办"></a>三次握手第三次报文丢失怎么办</h2><p><strong>Server端</strong></p>
<p>第三次的ACK在网络中丢失，那么Server 端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。 而Server重发SYN+ACK包的次数，可以通过设置</p>
<p>/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5. 如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。</p>
<p><strong>Client 端</strong></p>
<p>在linux c 中，client 一般是通过 connect() 函数来连接服务器的，而connect()是在 TCP的三次握手的第二次握手完成后就成功返回值。也就是说 client 在接收到 SYN+ACK包，它的TCP连接状态就为 established （已连接），表示该连接已经建立。那么如果 第三次握手中的ACK包丢失的情况下，Client 向 server端发送数据，Server端将以 RST包响应，方能感知到Server的错误。</p>
<p>关于rst包：<a target="_blank" rel="noopener" href="https://blog.csdn.net/a_tu_/article/details/80389878">https://blog.csdn.net/a_tu_/article/details/80389878</a></p>
<h2 id="三次握手第二次报文丢失怎么办"><a href="#三次握手第二次报文丢失怎么办" class="headerlink" title="三次握手第二次报文丢失怎么办"></a>三次握手第二次报文丢失怎么办</h2><p>在发送完ACK+SYN报文后会启动一个定时器，超时没有收到ACK确认，会再次发送，会进行多次重试。超时时间依旧每次翻倍，重试次数可设置</p>
<h2 id="tcp的push标志位"><a href="#tcp的push标志位" class="headerlink" title="tcp的push标志位"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/javajiawei/article/details/81987949">tcp的push标志位</a></h2><p>数据包先存放在tcp接受缓冲区中 收到带有push的报文后 在发送给应用层</p>
<h2 id="TCP的发送缓冲区和接收缓冲区"><a href="#TCP的发送缓冲区和接收缓冲区" class="headerlink" title="TCP的发送缓冲区和接收缓冲区"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/kesenzhang/article/details/104881397">TCP的发送缓冲区和接收缓冲区</a></h2><h2 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_17611285/article/details/80171239">TCP头部</a></h2><h2 id="UDP头部"><a href="#UDP头部" class="headerlink" title="UDP头部"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/ASJBFJSB/article/details/80357111">UDP头部</a></h2><h2 id="偏向锁升级到轻量级锁"><a href="#偏向锁升级到轻量级锁" class="headerlink" title="偏向锁升级到轻量级锁"></a>偏向锁升级到轻量级锁</h2><ol>
<li><p>首先获取锁对象的 Markword，判断是否处于可偏向状态。（biased_lock=1、且 ThreadId 为空）</p>
</li>
<li><p>如果是可偏向状态，则通过 CAS 操作，把当前线程的 ID 写入到 MarkWord ，如果 cas 成功，表示已经获得了锁对象的偏向锁，接着执行同步代码块，如果 cas 失败，说明有其他线程已经获得了偏向锁， 这种情况说明当前锁存在竞争，需要撤销已获得偏向 锁的线程，并且把它持有的锁升级为轻量级锁（这个 操作需要等到全局安全点，也就是没有线程在执行字 节码）才能执行</p>
</li>
<li><p>如果是已偏向状态，需要检查 markword 中存储的 ThreadID 是否等于当前线程的 ThreadID a) 如果相等，不需要再次获得锁，可直接执行同步代码 块 b) 如果不相等，说明当前锁偏向于其他线程，需要撤销 偏向锁并升级到轻量级锁</p>
</li>
</ol>
<h2 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/tjiyu/article/details/52959418?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">五种IO模型</a></h2><h2 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/47fd7f86c848">Redis实现分布式锁</a></h2><h2 id="Redis主从同步"><a href="#Redis主从同步" class="headerlink" title="Redis主从同步"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/daofaziran/p/10978628.html">Redis主从同步</a></h2><h2 id="谈谈你对-Springboot-的理解？为什么要用-Springboot？"><a href="#谈谈你对-Springboot-的理解？为什么要用-Springboot？" class="headerlink" title="谈谈你对 Springboot 的理解？为什么要用 Springboot？"></a>谈谈你对 Springboot 的理解？为什么要用 Springboot？</h2><p>spring boot 是微服务框架的起点，他简化了配置过程、部署过程、监控过程。<br>它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了很多的框架，同时 将其他技术同spring结合起来。<br>为什么使用springboot：<br>其实就是简单、快速、方便！平时如果我们需要搭建一个spring web项目的时候需要怎么做呢？</p>
<p>1）配置web.xml，加载spring和spring mvc<br>2）配置数据库连接、配置spring事务<br>3）配置加载配置文件的读取，开启注解<br>4）配置日志文件<br>…<br>配置完成之后部署tomcat 调试<br>…<br>但是如果使用spring boot呢？</p>
<p>很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套web项目或者是构建一个微服务！</p>
<h2 id="springboot的配置方式有哪些"><a href="#springboot的配置方式有哪些" class="headerlink" title="springboot的配置方式有哪些"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43809795/article/details/109206340">springboot的配置方式有哪些</a></h2><h2 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h2><p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210416164524307.png" alt="image-20210416164524307"></p>
<h2 id="java垃圾回收机制"><a href="#java垃圾回收机制" class="headerlink" title="java垃圾回收机制"></a>java垃圾回收机制</h2><p>程序员不需要去关心内存动态分配和垃圾回收的问题，这一切都交给了JVM来处理.回收机制使用可达性分析算法判断哪些是垃圾对象，并把堆分为年轻代和老年代，分别用不同的垃圾回收算法进行垃圾回收</p>
<h2 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42228338/article/details/97684517?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&dist_request_id=1331978.491.16185720218088971&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">B树和B+树</a></h2><h2 id="redo日志的刷盘策略"><a href="#redo日志的刷盘策略" class="headerlink" title="redo日志的刷盘策略"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38629422/article/details/105813338">redo日志的刷盘策略</a></h2><h2 id="hashmap为何引入红黑树"><a href="#hashmap为何引入红黑树" class="headerlink" title="hashmap为何引入红黑树"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43258908/article/details/89174471">hashmap为何引入红黑树</a></h2><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/heyouxin/p/13037146.html">公平锁和非公平锁</a></h2><p>ReentrantLock怎么实现公平锁和非公平锁，底层？</p>
<h2 id="生产者消费者模式为什么使用notifyAll而不是notify-考虑了什么"><a href="#生产者消费者模式为什么使用notifyAll而不是notify-考虑了什么" class="headerlink" title="生产者消费者模式为什么使用notifyAll而不是notify 考虑了什么"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/chenchaofuck1/article/details/51660119?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.baidujs">生产者消费者模式为什么使用notifyAll而不是notify 考虑了什么</a></h2><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/yzpbright/article/details/112675352?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-1&spm=1001.2101.3001.4242">阻塞队列</a></h2><h2 id="spring事务"><a href="#spring事务" class="headerlink" title="spring事务"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mseddl/p/11577846.html">spring事务</a></h2><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6dde7f92951e">协程</a></h2><h2 id="可重复读隔离级别的实现原理"><a href="#可重复读隔离级别的实现原理" class="headerlink" title="可重复读隔离级别的实现原理"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lmj612/p/10598971.html">可重复读隔离级别的实现原理</a></h2><h2 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/jisuanji12306/article/details/86363390">线程间的通信</a></h2><h2 id="mmap为什么效率高"><a href="#mmap为什么效率高" class="headerlink" title="mmap为什么效率高"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/mg0832058/article/details/5890688?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.baidujs">mmap为什么效率高</a></h2><p>用户空间的虚拟内存中的虚拟地址 通过mmu转换为物理地址 然后再物理内存中进行查找 如果该页被缓存则直接返回 否则换页 </p>
<h2 id="虚拟内存？细说"><a href="#虚拟内存？细说" class="headerlink" title="虚拟内存？细说"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yaoxiaowen/p/7805964.html">虚拟内存？细说</a></h2><h2 id="java负数的二进制表示"><a href="#java负数的二进制表示" class="headerlink" title="java负数的二进制表示"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/zgrjkflmkyc/article/details/12185143">java负数的二进制表示</a></h2><h2 id="数据库四种锁"><a href="#数据库四种锁" class="headerlink" title="数据库四种锁"></a>数据库四种锁</h2><p>（1）共享锁(S锁, 读锁)<br>共享锁锁定的资源可以被其它用户读取，但其它用户不能修改它。在SELECT 命令执行时，SQL Server 通常会对对象进行共享锁锁定。通常加共享锁的数据页被读取完毕后，共享锁就会立即被释放。</p>
<p>（2）排他锁(X锁，写锁)<br>排他锁锁定的资源只允许进行锁定操作的程序使用，其它任何对该资源的操作均不会被接受。执行数据更新命令，即INSERT、UPDATE 或DELETE 命令时，SQL Server 会自动使用排他锁。但当对象上有其它锁存在时，无法对其加排他锁。排他锁一直到事务结束才能被释放。共享锁可以一层套一层的上锁，但排他锁只能加一个。</p>
<p>（3）乐观锁<br>总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现。</p>
<p>version方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p>（4）悲观锁<br>总是假设最坏的情况，每次取数据时都认为其他线程会修改该数据，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。根据范围，锁还可以划分成行级锁和表锁。</p>
<h2 id="隔离级别实现原理"><a href="#隔离级别实现原理" class="headerlink" title="隔离级别实现原理"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wajika/p/6680200.html">隔离级别实现原理</a></h2><h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7a5b0043b035">什么是面向对象</a></h2><p>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</p>
<p>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</p>
<p>面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们我们使用的就是面向对象了。</p>
<p>面向过程：</p>
<p>优点：性能比面向对象好，因为类调用时需要实例化，开销比较大，比较消耗资源。<br>缺点：不易维护、不易复用、不易扩展.</p>
<p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 .<br>缺点：性能比面向过程差</p>
<h2 id="如何实现负载均衡"><a href="#如何实现负载均衡" class="headerlink" title="如何实现负载均衡"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/wenjianfeng/article/details/92033268">如何实现负载均衡</a></h2><h2 id="同步队列和等待队列"><a href="#同步队列和等待队列" class="headerlink" title="同步队列和等待队列"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/makecontral/article/details/78135531">同步队列和等待队列</a></h2><h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013075736">中间人攻击</a></h2><h2 id="实现BST"><a href="#实现BST" class="headerlink" title="实现BST"></a>实现BST</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BstTree</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getMin</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">while</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getMax</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">while</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">insertIntoBST</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        root = insertIntoBST(root, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">            root.right=  insertIntoBST(root.right,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        root = deleteNode(root, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete 考虑不同分支情况， 删除操作也需要自顶向下遍历查找到待删除节点位置</span></span><br><span class="line">    <span class="comment">// 0. 待删除节点为根节点</span></span><br><span class="line">    <span class="comment">// 1. 待删除节点无左孩子，用右孩子替代删除节点</span></span><br><span class="line">    <span class="comment">// 2. 待删除节点无右孩子，用左孩子替代删除节点</span></span><br><span class="line">    <span class="comment">// 3. 待删除节点既有右孩子又有左孩子，找到右子树的最小值替换待删除节点，然后删除右子树最小值</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">            root.right= deleteNode(root.right,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">            root.left = deleteNode(root.left,val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.right ==<span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode minNode = getMin(root);</span><br><span class="line">                root.val = minNode.val;</span><br><span class="line">                root.right = deleteNode(root.right,val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchBST</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        TreeNode target = searchBST(root, val);</span><br><span class="line">        <span class="keyword">return</span> target == <span class="keyword">null</span> ? -<span class="number">1</span> : target.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &gt; root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/huangdingsheng/article/details/99843453">参考博客1</a>        <a target="_blank" rel="noopener" href="https://blog.csdn.net/sheepmu/article/details/38407221?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">参考博客2</a></p>
<h2 id="GCRoot有哪些"><a href="#GCRoot有哪些" class="headerlink" title="GCRoot有哪些"></a>GCRoot有哪些</h2><p> JVM垃圾回收的根对象的范围有以下几种：</p>
<p>（1）虚拟机栈和本地方法栈中引用的对象<br>（2）方法区中的类静态属性和常量引用的对象</p>
<h2 id="对多线程的理解"><a href="#对多线程的理解" class="headerlink" title="对多线程的理解"></a>对多线程的理解</h2><p><strong>多线程指的是在单个程序中可以同时运行多个不同的线程，执行不同的任务</strong></p>
<p>多线程并发编程是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。</p>
<p>并发编程三要素：原子性，可见性，有序性 。从这三个要素说一下如何保证多线程运行安全</p>
<h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。</p>
<p>索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。索引提供指向存储在表的指定列中的数据值的指针，然后根据您指定的排序顺序对这些指针排序。</p>
<h2 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/MoreeVan/article/details/11977115?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs">AOP原理</a></h2><h2 id="三种垃圾收集算法的优劣"><a href="#三种垃圾收集算法的优劣" class="headerlink" title="三种垃圾收集算法的优劣"></a>三种垃圾收集算法的优劣</h2><p><strong>标记清除算法</strong></p>
<p>​    优点：标记-清除算法实现起来比较容易</p>
<p>​    缺点：但是有一个比较严重的问题就是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。</p>
<p><strong>复制算法</strong></p>
<pre><code> 优点：这种算法虽然实现简单，运行高效且不容易产生内存碎片。

 缺点：但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。</code></pre>
<p><strong>标记整理算法</strong></p>
<p>​    优点：碎片少 内存利用率高</p>
<p>​    缺点：算法复杂度大，执行步骤较多</p>
<h2 id="TCP和HTTP的区别"><a href="#TCP和HTTP的区别" class="headerlink" title="TCP和HTTP的区别"></a>TCP和HTTP的区别</h2><p> http是要基于TCP连接基础上的，简单的说，TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http是用来收发数据，即实际应用上来的。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理的代理类是实现了一个InvocationHandler的接口，我们通过reflect.Proxy的类的newProxyInstance方法就可以得到这个接口的实例，然后再来作为参数传递进去，这里每一个在代理类上处理的东西也会被重定向到调用处理器上。</p>
<p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210423105943552.png" alt="image-20210423105943552"></p>
<p>如果一个对象的a方法调用b方法不会触发动态代理 因为没有调用对象的代理类 </p>
<h2 id="JVM频繁Full-GC的解决经验"><a href="#JVM频繁Full-GC的解决经验" class="headerlink" title="JVM频繁Full GC的解决经验"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangfengaiwuyan/article/details/89380008">JVM频繁Full GC的解决经验</a></h2><h2 id="为什么会有STW"><a href="#为什么会有STW" class="headerlink" title="为什么会有STW"></a>为什么会有STW</h2><p>在进行标记的时候，如果工作线程不停止的话，那么肯定会有新对象生成。这些对象是没有被标记的，里面可能有存活的对象，也可能有已经没有被引用的垃圾对象。那么在标记完后，进行回收时。要如何回收？</p>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011726984/article/details/79320004?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">CompletableFuture</a></h2><h2 id="为什么在-JDK8-中要将-HashMap-的链表转为红黑树"><a href="#为什么在-JDK8-中要将-HashMap-的链表转为红黑树" class="headerlink" title="为什么在 JDK8 中要将 HashMap 的链表转为红黑树"></a>为什么在 JDK8 中要将 HashMap 的链表转为红黑树</h2><p>因为通常情况下，链表长度很难达到8，但是特殊情况下链表长度为8，哈希表容量又很大，造成链表性能很差的时候，只能采用红黑树提高性能，这是一种应对策略。</p>
<h2 id="用-token-来验证信息和用密码登录的区别"><a href="#用-token-来验证信息和用密码登录的区别" class="headerlink" title="用 token 来验证信息和用密码登录的区别"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/ly_twt/article/details/102217361">用 token 来验证信息和用密码登录的区别</a></h2><h2 id="oss和Oauth2-0"><a href="#oss和Oauth2-0" class="headerlink" title="oss和Oauth2.0"></a>oss和Oauth2.0</h2><p>OAuth2.0</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/flashsun/p/7424071.html">https://www.cnblogs.com/flashsun/p/7424071.html</a></li>
<li>代码实现：<a target="_blank" rel="noopener" href="https://www.zifangsky.cn/1313.html">https://www.zifangsky.cn/1313.html</a></li>
</ul>
<p>OSS</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zifangsky.cn/1313.html">https://www.zifangsky.cn/1313.html</a></li>
<li>代码：<a target="_blank" rel="noopener" href="https://gitee.com/zifangsky/OAuth2.0Demo/tree/master#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D">https://gitee.com/zifangsky/OAuth2.0Demo/tree/master#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D</a></li>
</ul>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ol>
<li><p>介绍一下项目</p>
</li>
<li><p>项目对JVM内存方面的考虑？</p>
</li>
<li><p>Redis存了啥？为什么要这么存？</p>
</li>
<li><p>项目有没有安全性考虑</p>
</li>
<li><p><strong>你的优势和劣势？</strong></p>
<ol>
<li>自学能力强、抗压能力强、能理解他人 懂得换位思考、责任心强、善于决策,独立思考</li>
<li>不注重细节、喜欢争论、过于理想化、不愿意承认失败、太追求细节导致拖延、不善于决策、不愿意寻求帮助、</li>
</ol>
</li>
<li><p>业余爱好</p>
</li>
<li><p>这几年的职业规划</p>
<ol>
<li>我今年刚毕业，对于工作方面的事情还没有一个很清楚的概念，不过我会在工作中不断的学习，切实的去了解工作当中所需要的技能。<br>更了解这个行业之后，我也会有针对性的改变自己的学习计划，使自己更加适应这个行业，朝着行业的大方向去发展。</li>
</ol>
</li>
</ol>
<ol start="8">
<li></li>
</ol>

    </div>

    
    
    

	<div>
	  
		<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
	  
	</div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/26/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/" rel="prev" title="秒杀项目">
      <i class="fa fa-chevron-left"></i> 秒杀项目
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/08/%E5%B0%9A%E7%A1%85%E8%B0%B7%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="next" title="尚硅谷面试题">
      尚硅谷面试题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Mybatis%E4%B8%80%E7%BA%A7%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-number">1.</span> <span class="nav-text">Mybatis一级、二级缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-number">1.1.</span> <span class="nav-text">一级缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-number">1.2.</span> <span class="nav-text">二级缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ping%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">Ping过程及其原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ping%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.</span> <span class="nav-text">ping命令使用的协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dns%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">dns域名解析过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">主从复制的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">6.</span> <span class="nav-text">序列化和反序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDBC%E5%8E%9F%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text">JDBC原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">8.</span> <span class="nav-text">java三大特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">9.</span> <span class="nav-text">Object类中的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%8B%89%E9%93%BE%E6%B3%95%E8%A7%A3%E5%86%B3%E5%9C%B0%E5%9D%80%E5%86%B2%E7%AA%81"><span class="nav-number">10.</span> <span class="nav-text">HashMap为什么使用拉链法解决地址冲突</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">11.</span> <span class="nav-text">TCP和UDP的应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%85%88%E5%86%99Redis%E8%BF%98%E6%98%AFDB%EF%BC%9Fredis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">数据先写Redis还是DB？redis缓存一致性问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">13.</span> <span class="nav-text">redis分布式锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">14.</span> <span class="nav-text">操作系统缓存一致性问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BA%86%E8%A7%A3%E5%85%B6%E4%BB%96%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">有没有了解其他的缓存中间件？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-session"><span class="nav-number">16.</span> <span class="nav-text">分布式 session</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-bean%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F"><span class="nav-number">17.</span> <span class="nav-text">Spring-bean的循环依赖以及解决方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E5%B1%82%E7%BC%93%E5%AD%98%EF%BC%9F%E4%B8%A4%E5%B1%82%E6%88%96%E8%80%85%E4%B8%80%E5%B1%82%E8%A1%8C%E4%B8%8D%E8%A1%8C"><span class="nav-number">18.</span> <span class="nav-text">为什么需要三层缓存？两层或者一层行不行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E8%BF%9B%E7%A8%8BCPU%E5%8D%A0%E7%94%A8%E7%8E%87%E9%AB%98%E7%9A%84%E6%8E%92%E6%9F%A5%E5%92%8C%E5%B8%B8%E8%A7%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">19.</span> <span class="nav-text">Java进程CPU占用率高的排查和常见解决方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%99%E5%AE%9A-a%E3%80%81b-%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%8C%E5%90%84%E5%AD%98%E6%94%BE-50-%E4%BA%BF%E4%B8%AA-URL%EF%BC%8C%E6%AF%8F%E4%B8%AA-URL-%E5%90%84%E5%8D%A0-64B%EF%BC%8C%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6%E6%98%AF-4G%E3%80%82%E8%AF%B7%E6%89%BE%E5%87%BA-a%E3%80%81b-%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E5%85%B1%E5%90%8C%E7%9A%84-URL"><span class="nav-number">20.</span> <span class="nav-text">给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#https%E7%9A%84%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="nav-number">21.</span> <span class="nav-text">https的加密过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS%E7%9A%84%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E5%8E%9F%E7%90%86"><span class="nav-number">22.</span> <span class="nav-text">HTTPS的数字证书验证原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98"><span class="nav-number">23.</span> <span class="nav-text">InnoDB怎么解决幻读问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Http%EF%BC%8CTCP%EF%BC%8CSocker%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">24.</span> <span class="nav-text">Http，TCP，Socker之间的区别和联系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List%E5%92%8CSet%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">25.</span> <span class="nav-text">List和Set的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap%E6%9F%A5%E8%AF%A2%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">26.</span> <span class="nav-text">HashMap查询复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%AE%B9%E6%A0%88"><span class="nav-number">27.</span> <span class="nav-text">数组实现扩容栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">28.</span> <span class="nav-text">HashMap不安全的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PriorityQueue%E5%8E%9F%E7%90%86"><span class="nav-number">29.</span> <span class="nav-text">PriorityQueue原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%9F%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%87%E6%8D%A2%E7%9A%84"><span class="nav-number">30.</span> <span class="nav-text">进程有哪些状态？是如何进行切换的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-number">31.</span> <span class="nav-text">进程控制块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%92%E5%88%86%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81"><span class="nav-number">32.</span> <span class="nav-text">为什么要划分内核态和用户态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">33.</span> <span class="nav-text">操作系统用户态和内核态之间的切换过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">34.</span> <span class="nav-text">内核线程的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">35.</span> <span class="nav-text">进程上下文切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E5%92%8C%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">36.</span> <span class="nav-text">线程上下文切换和进程上下文切换的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E9%A2%91%E7%B9%81%E7%9A%84%E5%90%8E%E6%9E%9C"><span class="nav-number">37.</span> <span class="nav-text">进程上下文切换频繁的后果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E9%87%8Fclose-wait%E5%AF%B9%E7%B3%BB%E7%BB%9F%E5%BD%B1%E5%93%8D"><span class="nav-number">38.</span> <span class="nav-text">大量close_wait对系统影响</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8A%A5%E6%96%87%E4%B8%A2%E5%A4%B1%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">39.</span> <span class="nav-text">三次握手第三次报文丢失怎么办</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8A%A5%E6%96%87%E4%B8%A2%E5%A4%B1%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">40.</span> <span class="nav-text">三次握手第二次报文丢失怎么办</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp%E7%9A%84push%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="nav-number">41.</span> <span class="nav-text">tcp的push标志位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E7%9A%84%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E6%8E%A5%E6%94%B6%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">42.</span> <span class="nav-text">TCP的发送缓冲区和接收缓冲区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%A4%B4%E9%83%A8"><span class="nav-number">43.</span> <span class="nav-text">TCP头部</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP%E5%A4%B4%E9%83%A8"><span class="nav-number">44.</span> <span class="nav-text">UDP头部</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%B0%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">45.</span> <span class="nav-text">偏向锁升级到轻量级锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">46.</span> <span class="nav-text">五种IO模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">47.</span> <span class="nav-text">Redis实现分布式锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5"><span class="nav-number">48.</span> <span class="nav-text">Redis主从同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-Springboot-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Springboot%EF%BC%9F"><span class="nav-number">49.</span> <span class="nav-text">谈谈你对 Springboot 的理解？为什么要用 Springboot？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#springboot%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">50.</span> <span class="nav-text">springboot的配置方式有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVC%E6%A1%86%E6%9E%B6"><span class="nav-number">51.</span> <span class="nav-text">MVC框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">52.</span> <span class="nav-text">java垃圾回收机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B%E6%A0%91%E5%92%8CB-%E6%A0%91"><span class="nav-number">53.</span> <span class="nav-text">B树和B+树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redo%E6%97%A5%E5%BF%97%E7%9A%84%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5"><span class="nav-number">54.</span> <span class="nav-text">redo日志的刷盘策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hashmap%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">55.</span> <span class="nav-text">hashmap为何引入红黑树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">56.</span> <span class="nav-text">公平锁和非公平锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8notifyAll%E8%80%8C%E4%B8%8D%E6%98%AFnotify-%E8%80%83%E8%99%91%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">57.</span> <span class="nav-text">生产者消费者模式为什么使用notifyAll而不是notify 考虑了什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">58.</span> <span class="nav-text">阻塞队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring%E4%BA%8B%E5%8A%A1"><span class="nav-number">59.</span> <span class="nav-text">spring事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B"><span class="nav-number">60.</span> <span class="nav-text">协程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">61.</span> <span class="nav-text">可重复读隔离级别的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">62.</span> <span class="nav-text">线程间的通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mmap%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%88%E7%8E%87%E9%AB%98"><span class="nav-number">63.</span> <span class="nav-text">mmap为什么效率高</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9F%E7%BB%86%E8%AF%B4"><span class="nav-number">64.</span> <span class="nav-text">虚拟内存？细说</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E8%B4%9F%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA"><span class="nav-number">65.</span> <span class="nav-text">java负数的二进制表示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%9B%E7%A7%8D%E9%94%81"><span class="nav-number">66.</span> <span class="nav-text">数据库四种锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">67.</span> <span class="nav-text">隔离级别实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">68.</span> <span class="nav-text">什么是面向对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">69.</span> <span class="nav-text">如何实现负载均衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E5%92%8C%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="nav-number">70.</span> <span class="nav-text">同步队列和等待队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="nav-number">71.</span> <span class="nav-text">中间人攻击</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0BST"><span class="nav-number">72.</span> <span class="nav-text">实现BST</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GCRoot%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">73.</span> <span class="nav-text">GCRoot有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">74.</span> <span class="nav-text">对多线程的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95"><span class="nav-number">75.</span> <span class="nav-text">什么是索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP%E5%8E%9F%E7%90%86"><span class="nav-number">76.</span> <span class="nav-text">AOP原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8A%A3"><span class="nav-number">77.</span> <span class="nav-text">三种垃圾收集算法的优劣</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">78.</span> <span class="nav-text">TCP和HTTP的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">79.</span> <span class="nav-text">动态代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E9%A2%91%E7%B9%81Full-GC%E7%9A%84%E8%A7%A3%E5%86%B3%E7%BB%8F%E9%AA%8C"><span class="nav-number">80.</span> <span class="nav-text">JVM频繁Full GC的解决经验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89STW"><span class="nav-number">81.</span> <span class="nav-text">为什么会有STW</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CompletableFuture"><span class="nav-number">82.</span> <span class="nav-text">CompletableFuture</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8-JDK8-%E4%B8%AD%E8%A6%81%E5%B0%86-HashMap-%E7%9A%84%E9%93%BE%E8%A1%A8%E8%BD%AC%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">83.</span> <span class="nav-text">为什么在 JDK8 中要将 HashMap 的链表转为红黑树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8-token-%E6%9D%A5%E9%AA%8C%E8%AF%81%E4%BF%A1%E6%81%AF%E5%92%8C%E7%94%A8%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">84.</span> <span class="nav-text">用 token 来验证信息和用密码登录的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#oss%E5%92%8COauth2-0"><span class="nav-number">85.</span> <span class="nav-text">oss和Oauth2.0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE"><span class="nav-number">86.</span> <span class="nav-text">项目</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="鲍炳江"
      src="/images/author.jpg">
  <p class="site-author-name" itemprop="name">鲍炳江</p>
  <div class="site-description" itemprop="description">不接受任何评判</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">鲍炳江</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">744k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">11:16</span>
</div>


<!-- 新增访客统计代码 -->

<div class="busuanzi-count">
    <script async="" src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="site-uv">
      <i class="fa fa-user"></i>
      访问用户： <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人
    </span>
    <div class="powered-by"></div>
    <span class="site-uv">
      <i class="fa fa-eye"></i>
      访问次数： <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次
    </span>
    <!-- 博客字数统计 -->
    <span class="site-pv">
      <i class="fa fa-pencil"></i>
      博客全站共： <span class="post-count">277.3k</span> 字
    </span>
</div>
<!-- 新增访客统计代码 END-->


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Q8d8san4rQK6RMUMN9Cn773b-gzGzoHsz',
      appKey     : 'W6WIDWUfTyiNEDcQ490kGNaJ',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

  
 

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>