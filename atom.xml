<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>勺子柄の博客</title>
  
  <subtitle>记录生活中的点点滴滴</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-02-22T12:02:58.544Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>鲍炳江</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>org.springframework.core.io.buffer.NettyDataBufferFactory</title>
    <link href="http://example.com/2021/02/22/org-springframework-core-io-buffer-NettyDataBufferFactory/"/>
    <id>http://example.com/2021/02/22/org-springframework-core-io-buffer-NettyDataBufferFactory/</id>
    <published>2021-02-22T11:59:57.000Z</published>
    <updated>2021-02-22T12:02:58.544Z</updated>
    
    <content type="html"><![CDATA[<p>在做商城项目的时候启动网关后路由到登录页面出现了下面的错误</p><p><img src="/2021/02/22/org-springframework-core-io-buffer-NettyDataBufferFactory/log\source_posts\org-springframework-core-io-buffer-NettyDataBufferFactory\image-20210222200203003.png" alt="image-20210222200203003"></p><p>解决方法： 由于springcloud的gateway使用的是webflux,默认使用netty,所以从依赖中排除 tomcat相关的依赖 ，就可以了</p><p>安装Maven Helper插件</p><p><img src="/2021/02/22/org-springframework-core-io-buffer-NettyDataBufferFactory/log\source_posts\org-springframework-core-io-buffer-NettyDataBufferFactory\image-20210222200252334.png" alt="image-20210222200252334"></p><p>排除该依赖</p>]]></content>
    
    
    <summary type="html">org.springframework.core.io.buffer.DefaultDataBufferFactory cannot be cast to org.springframework.core.io.buffer.NettyDataBufferFactory</summary>
    
    
    
    <category term="bug" scheme="http://example.com/categories/bug/"/>
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>谷粒商城</title>
    <link href="http://example.com/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/"/>
    <id>http://example.com/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/</id>
    <published>2021-02-15T09:21:39.000Z</published>
    <updated>2021-03-12T11:43:37.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="商品服务"><a href="#商品服务" class="headerlink" title="商品服务"></a>商品服务</h1><h2 id="三级分类"><a href="#三级分类" class="headerlink" title="三级分类"></a>三级分类</h2><p>通过递归查询所有分类及其子分类</p><p>解决跨域问题：在网关服务中进行跨域配置 其他服务中的跨域配置要去掉</p><p>注意路由配置的顺序</p><p><strong>删除菜单</strong></p><p>配置全局逻辑删除规则</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> </span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>为逻辑删除字段加上注解</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果全局逻辑删除规则和像定义的规则相反 可以配置val和delval</span></span><br><span class="line">@<span class="constructor">TableLogic(<span class="params">value</span> = <span class="string">&quot;1&quot;</span>,<span class="params">delval</span> = <span class="string">&quot;0&quot;</span>)</span></span><br><span class="line"><span class="keyword">private</span> Integer showStatus;</span><br></pre></td></tr></table></figure><h2 id="品牌管理"><a href="#品牌管理" class="headerlink" title="品牌管理"></a>品牌管理</h2><p><strong>OSS</strong></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210223191828555.png" alt="image-20210223191828555"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210223212033449.png" alt="image-20210223212033449"></p><p>创建一个新的module用于存放第三方应用</p><p>导入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alicloud-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在配置文件中进行配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">alicloud:</span></span><br><span class="line">          <span class="attr">access-key:</span> <span class="string">LTAI4G5zyHGVo57wWXZSsBv6</span></span><br><span class="line">          <span class="attr">secret-key:</span> <span class="string">hNTww8jjeAHGe92BuxkEeVHDia4dAx</span></span><br><span class="line">          <span class="attr">oss:</span></span><br><span class="line">            <span class="attr">endpoint:</span> <span class="string">oss-cn-beijing.aliyuncs.com</span></span><br></pre></td></tr></table></figure><p>创建一个controller用于向oss上传文件</p><p>配置跨域</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210223210510929.png" alt="image-20210223210510929"></p><p><strong>JSR303表单校验</strong></p><p>为需要校验的字段加上注解</p><p>@Valid开启校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">save</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> BrandEntity brand, BindingResult bindingResult)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//BindingResult可以获取到校验的结果</span></span><br><span class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line">        bindingResult.getFieldErrors().forEach(item -&gt; &#123;</span><br><span class="line">            String message = item.getDefaultMessage();</span><br><span class="line">            <span class="comment">//错误的属性名</span></span><br><span class="line">            String field = item.getField();</span><br><span class="line">            map.put(field,message);</span><br><span class="line">        &#125;);</span><br><span class="line">        R.error(<span class="number">400</span>,<span class="string">&quot;提交的数据不可发&quot;</span>).put(<span class="string">&quot;data&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">    brandService.save(brand);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次都这么获取叫校验结果太麻烦 创建一个类进行统一异常处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice(&quot;com.baobingjiang.mall.product.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionControllerAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">handlerValidException</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;数据校验出现问题&#123;&#125;,异常类型&#123;&#125;&quot;</span>,e.getMessage(),e.getClass());</span><br><span class="line">        <span class="keyword">return</span> R.error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分组校验：新增和修改使用两种校验方法</p><ul><li><p>字段校验注解指定分组</p></li><li><p>在controller中使用@Validated注解</p></li><li><p>没有指定分组的注解在没有指定@Validated时才会生效</p></li></ul><p>自定义校验</p><ul><li><p>编写一个自定义的校验注解</p><ul><li><pre><code class="java">@Documented//指定校验器@Constraint(validatedBy = &#123;ListValueConstraintValidator.class&#125;)@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ListValue &#123;    //要有这三个基本属性    //错误信息去哪取    String message() default &quot;&#123;javax.validation.constraints.NotBlank.message&#125;&quot;;    //支持分组    Class&lt;?&gt;[] groups() default &#123;&#125;;    //支持负载信息    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;    int[] vals() default &#123;&#125;;&#125;<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 编写一个自定义的校验器</span><br><span class="line"></span><br><span class="line">  * ```java</span><br><span class="line">    <span class="built_in">public</span> <span class="keyword">class</span> ListValueConstraintValidator implements ConstraintValidator&lt;ListValue,<span class="type">Integer</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">Set</span>&lt;<span class="type">Integer</span>&gt; <span class="keyword">set</span> = <span class="built_in">new</span> HashSet&lt;&gt;();</span><br><span class="line">        @Override</span><br><span class="line">        <span class="built_in">public</span> <span class="type">void</span> initialize(ListValue constraintAnnotation) &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="type">int</span>[] vals = constraintAnnotation.vals(); // <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> val:vals)&#123;</span><br><span class="line">                <span class="keyword">set</span>.<span class="keyword">add</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        <span class="built_in">public</span> <span class="type">boolean</span> isValid(<span class="type">Integer</span> <span class="type">integer</span>, ConstraintValidatorContext constraintValidatorContext)    &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">set</span>.contains(<span class="type">integer</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>关联校验器和校验注解</p></li></ul><p>自定义更新两种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBrand</span><span class="params">(Long brandId, String name)</span> </span>&#123;</span><br><span class="line">    CategoryBrandRelationEntity categoryBrandRelationEntity = <span class="keyword">new</span> CategoryBrandRelationEntity();</span><br><span class="line">    categoryBrandRelationEntity.setBrandId(brandId);</span><br><span class="line">    categoryBrandRelationEntity.setBrandName(name);</span><br><span class="line">    <span class="keyword">this</span>.update(categoryBrandRelationEntity,<span class="keyword">new</span> UpdateWrapper&lt;CategoryBrandRelationEntity&gt;().eq(<span class="string">&quot;brand_id&quot;</span>,brandId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCategory</span><span class="params">(Long catId, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.baseMapper.updateCategory(catId,name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性分组"><a href="#属性分组" class="headerlink" title="属性分组"></a>属性分组</h2><p>spu和sku</p><p>使用mybatisplus的QueryWrapper条件查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String key = (String) params.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">QueryWrapper&lt;AttrGroupEntity&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;AttrGroupEntity&gt;().eq(<span class="string">&quot;catelog_id&quot;</span>,catelogId);</span><br><span class="line"><span class="keyword">if</span>(!StringUtils.isEmpty(key))&#123;</span><br><span class="line">    queryWrapper.and(obj -&gt; &#123;</span><br><span class="line">        obj.eq(<span class="string">&quot;attr_group_id&quot;</span>,key).or().like(<span class="string">&quot;attr_group_name&quot;</span>,key);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">page = <span class="keyword">this</span>.page(<span class="keyword">new</span> Query&lt;AttrGroupEntity&gt;().getPage(params),queryWrapper);</span><br></pre></td></tr></table></figure><p>配置分页插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.baobingjiang.mall.product.dao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PaginationInterceptor paginationInterceptor = <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">        <span class="comment">//如果请求的页码大于最后一页 返回首页</span></span><br><span class="line">        paginationInterceptor.setOverflow(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//设置最大单页限制数量 默认500</span></span><br><span class="line">        paginationInterceptor.setLimit(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> paginationInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义更新两种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBrand</span><span class="params">(Long brandId, String name)</span> </span>&#123;</span><br><span class="line">    CategoryBrandRelationEntity categoryBrandRelationEntity = <span class="keyword">new</span> CategoryBrandRelationEntity();</span><br><span class="line">    categoryBrandRelationEntity.setBrandId(brandId);</span><br><span class="line">    categoryBrandRelationEntity.setBrandName(name);</span><br><span class="line">    <span class="keyword">this</span>.update(categoryBrandRelationEntity,<span class="keyword">new</span> UpdateWrapper&lt;CategoryBrandRelationEntity&gt;().eq(<span class="string">&quot;brand_id&quot;</span>,brandId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCategory</span><span class="params">(Long catId, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.baseMapper.updateCategory(catId,name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Elasctic-search"><a href="#Elasctic-search" class="headerlink" title="Elasctic search"></a>Elasctic search</h1><p>es:索引-&gt;文档-&gt;属性</p><p>sql:库-&gt;表-&gt;行-&gt;属性</p><p><strong>乐观锁修改</strong></p><p>字段信息：</p><ul><li><p>if_seq_no:并发控制字段 每次更新就会+1 用来做乐观锁</p></li><li><p>if_primary_term:同上 主分片重新分配 如重启就会变化</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT <span class="regexp">/customer/</span>_doc/<span class="number">1</span>?if_primary_term = <span class="number">1</span>&amp;if_seq_no = <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用elasticsearch-rest-high-level-client操作ES 需要手动编写配置类 如果使用springdataES就不用</p><p>nested数据类型：用于嵌套数据 如果嵌套的数据不使用此类型就会扁平化处理</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210301204040670.png" alt="image-20210301204040670"><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210301204128260.png" alt="image-20210301204128260"></p><h1 id="商城服务"><a href="#商城服务" class="headerlink" title="商城服务"></a>商城服务</h1><p>使用thymeleaf渲染页面</p><p>使用nginx动静分离 </p><h1 id="性能压测"><a href="#性能压测" class="headerlink" title="性能压测"></a>性能压测</h1><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><p><strong>jmeter</strong></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210303175000122.png" alt="image-20210303175000122"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210303175105717.png" alt="image-20210303175105717"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210303175242261.png" alt="image-20210303175242261"></p><h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><p>使用nginx设置域名 </p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210304225009660.png" alt="image-20210304225009660"></p><p>网关增加设置：这条设置要放在最后 不然不能路由到具体服务</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210304225023610.png" alt="image-20210304225023610"></p><p>动静分离 </p><p>当访问静态资源例如<a href="http://mall.com/static/index/img/lunbo6.png%E4%BC%9A%E5%8E%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84html/static%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%9F%A5%E6%89%BE">http://mall.com/static/index/img/lunbo6.png会去服务器的html/static目录下查找</a></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210304225131282.png" alt="image-20210304225131282"></p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p><strong>redis</strong></p><p>导入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用jedis而不使用lettuce的原因：lettuce使用netty进行网络通信 有bug会导致堆外内存移除</p><p>解决问题</p><ul><li>缓存穿透：空结果缓存</li><li>缓存雪崩：设置随机过期时间</li><li>加锁：解决缓存击穿</li></ul><p><strong>使用Redisson作为分布式锁等功能框架</strong></p><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedissonConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean(destroyMethod = &quot;shutdown&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redissonClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.52.131:6379&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 阻塞时等待 默认加锁是<span class="number">30</span>s</span><br><span class="line"> * RLock锁有看门狗机制 如果业务超长，会自动帮我们续期，默认三十秒（续期时间为占锁之后 看门狗时间[<span class="number">30</span>] / <span class="number">3</span>）</span><br><span class="line"> * 只要业务完成 就不会为当前锁续期 即使不手动解锁 也会在<span class="number">30</span>s后自动删除</span><br><span class="line"> * 如果指定过期事件 lock.lock(<span class="number">10</span>,TimeUnit.SECONDS); 指定的时间一定要大于业务的时间 否则会出现死锁的情况</span><br><span class="line"> * 建议指定时间 省掉了续期操作</span><br><span class="line"> */</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/index/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RLock lock = redissonClient.getLock(<span class="string">&quot;my-lock&quot;</span>);</span><br><span class="line">   <span class="comment">// 阻塞式等待</span></span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缓存一致性</strong></p><ul><li>双写模式：修改数据库后 修改缓存<ul><li><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210312162006542.png" alt="image-20210312162006542"></li></ul></li><li>失效模式：修改数据库后 删除缓存<ul><li><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210312162309012.png" alt="image-20210312162309012"></li></ul></li></ul><p>解决方法</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210312162639760.png" alt="image-20210312162639760"></p><p><strong>SpringCache</strong></p><p>使用SpringCache可以方便的操作缓存</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置使用redis作为缓存</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cache</span>:</span><br><span class="line">  <span class="keyword">type</span>: redis</span><br><span class="line">  redis:</span><br><span class="line">    <span class="built_in">time</span>-<span class="keyword">to</span>-live: <span class="number">60000</span></span><br><span class="line">    <span class="keyword">cache</span>-<span class="literal">null</span>-<span class="keyword">values</span>: <span class="literal">true</span> <span class="comment">#解决缓存穿透问题</span></span><br><span class="line">    <span class="keyword">use</span>-<span class="keyword">key</span>-prefix: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210312165037949.png" alt="image-20210312165037949"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将结果放入缓存中 命名空间为category key如果不指定自动生成 value默认使用java序列化机制 默认过期时间为-1</span></span><br><span class="line"><span class="comment">//spring.cache.redis.time-to-live指定过期时间</span></span><br><span class="line"><span class="comment">//sync表示同步方法 进行加锁 解决缓存击穿问题</span></span><br><span class="line"><span class="meta">@Cacheable(value = &#123;&quot;category&quot;&#125;, key = &quot;#root.method.name&quot;, sync = true)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;CategoryEntity&gt; <span class="title">getOneLevelCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> baseMapper.selectList(<span class="keyword">new</span> QueryWrapper&lt;CategoryEntity&gt;().eq(<span class="string">&quot;cat_level&quot;</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置序列化并且让配置文件中的内容生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(CacheProperties.class)</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCacheConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 配置文件中 TTL设置没用上</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 原来:</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@ConfigurationProperties</span>(prefix = &quot;spring.cache&quot;)</span></span><br><span class="line"><span class="comment">    * public class CacheProperties</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 现在要让这个配置文件生效    : <span class="doctag">@EnableConfigurationProperties</span>(CacheProperties.class)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function">RedisCacheConfiguration <span class="title">redisCacheConfiguration</span><span class="params">(CacheProperties cacheProperties)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置kv的序列化机制</span></span><br><span class="line">      config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> StringRedisSerializer()));</span><br><span class="line">      config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer()));</span><br><span class="line">      CacheProperties.Redis redisproperties = cacheProperties.getRedis();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置配置</span></span><br><span class="line">      <span class="keyword">if</span>(redisproperties.getTimeToLive() != <span class="keyword">null</span>)&#123;</span><br><span class="line">         config = config.entryTtl(redisproperties.getTimeToLive());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(redisproperties.getKeyPrefix() != <span class="keyword">null</span>)&#123;</span><br><span class="line">         config = config.prefixKeysWith(redisproperties.getKeyPrefix());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(!redisproperties.isCacheNullValues())&#123;</span><br><span class="line">         config = config.disableCachingNullValues();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(!redisproperties.isUseKeyPrefix())&#123;</span><br><span class="line">         config = config.disableKeyPrefix();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> config;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>nacos作为注册中心和配置中心</p><p>open-feign进行远程服务调用</p><p>getway作为网关</p><p>前端为vue</p><p>商品服务</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;商品服务&quot;&gt;&lt;a href=&quot;#商品服务&quot; class=&quot;headerlink&quot; title=&quot;商品服务&quot;&gt;&lt;/a&gt;商品服务&lt;/h1&gt;&lt;h2 id=&quot;三级分类&quot;&gt;&lt;a href=&quot;#三级分类&quot; class=&quot;headerlink&quot; title=&quot;三级分类&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql笔记</title>
    <link href="http://example.com/2021/02/02/mysql%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/02/02/mysql%E7%AC%94%E8%AE%B0/</id>
    <published>2021-02-02T07:36:24.000Z</published>
    <updated>2021-02-16T05:42:53.526Z</updated>
    
    <content type="html"><![CDATA[<p>常用命令</p><ul><li><p>显示数据库 show databases ; </p></li><li><p>显示表：1)show tables; 2) show table from test;</p></li><li><p>当前所在的库：select database();</p></li><li><p>查看表的属性 desc tableName;</p></li><li><p>查看mysql版本 1)select version(); 2)在cmd输入mysql –version</p></li><li><p>注释 # ，– (后面要加一个空格)，/* */</p></li></ul><p>起别名用<strong>AS</strong> 且AS可以省略</p><p>truncate 清空数据 :truncate table user</p><p>auto_increment要搭配key（主键 唯一 外键等）使用 且一个表中只能有一个标识列且类型是数字</p><p><strong>DISTINCT</strong>去重</p><p><strong>+号</strong>的作用</p><ul><li>select 100+90 做加法操作</li><li>select ‘12’ + 90 把字符串转换为整数做加法操作 如果转换失败字符串值为0</li><li>select null + 21 结果为null</li></ul><p><strong>逻辑运算符</strong>：and,or,not</p><p><strong>分页查询limit（m,n）m是初始索引 n是要显示的条目个数 limit放在查询语句的最后</strong></p><p>**安全等于&lt;=&gt;**：可以判断null和数值 </p><ul><li>select 2 &lt;=&gt; null 结果为 0</li><li>select 2 = null 结果为空</li><li>select null &lt;=&gt; null结果为1</li></ul><p><strong>ORDER BY</strong> 【asc | desc】默认是asc ：select * from user order by salary desc</p><p><strong>IFNULL</strong>：如果不是null显示第一个参数 是null显示第二个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ifnull(commission_pct,0),commission_pct from employees</span><br></pre></td></tr></table></figure><h1 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a><strong>模糊查询</strong></h1><p><strong>LIKE</strong>：% 匹配任意多个字符 包含0个字符，_ 匹配一个或一个以上字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查询第三个字母为e第五个字母为a的员工名 不区分大小写</span><br><span class="line">select last_name from employees where last_name like &#39;__e_a%&#39;;</span><br><span class="line">#查询第二个字符为_的员工名</span><br><span class="line">select last_name from employees where last_name like &#39;_\_%&#39;;</span><br></pre></td></tr></table></figure><p><strong>BETWEEN</strong>：between a and b 包含临界值a和b</p><p><strong>IN</strong>：in列表中的值必须是互相兼容的且不能使用%</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select last_name,job_id from employees where job_id in(&#39;IT_PORT&#39;,&#39;AD_VP&#39;,&#39;AD_PRES&#39;)</span><br></pre></td></tr></table></figure><p><strong>IS NULL</strong>和<strong>IS NOT NULL</strong>：select * from user where id is null</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h2><h3 id="字母函数"><a href="#字母函数" class="headerlink" title="字母函数"></a>字母函数</h3><p>Length 获取参数值的字节个数 SELECT length(1232)</p><p>concat拼接字符串：select concat(id,’-‘,name) from user;</p><p>Upper ,Lowwer</p><p>substr:下标从1开始 包含开始位置和结束位置 一个汉字是一个符文为两个字节或三个字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select substr(&#39;today is a good day&#39;,7,2); #第三个参数可以省略</span><br></pre></td></tr></table></figure><p>insrt（A，B） : 返回子串B在主串A中第一次出现的起始索引 找不到返回0</p><p>trim , ltirm, rtirm 去掉空格 trim(x from b)去掉b首位出现的x</p><p>​           <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image006.png" alt="img"></p><p>lpad和rpad</p><p>​           <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image008.png" alt="img"></p><p>replace</p><p>​           <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image010.png" alt="img"></p><h3 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h3><p>round 四舍五入</p><p>​           <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612253586742.png" alt="img"></p><p>ceil向上取整 floor向下取整</p><p>truncate 截断：第二个参数是小数点后的位数</p><p>​           <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image004-1612253586743.png" alt="img"></p><p>mod取余 公式为：a-a/b*b</p><h2 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h2><p>IF：<code>select if(10 &gt; 5,true,false)</code></p><p>CASE</p><ul><li><pre><code class="mysql">select salary,department_id,case department_idwhen 30 then salary * 1.1when 40 then salary * 1.2when 50 then salary * 1.3else salary end as newSalaryfrom employees<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```mysql</span><br><span class="line">  <span class="keyword">select</span> salary,</span><br><span class="line">  <span class="keyword">case</span></span><br><span class="line">  <span class="keyword">when</span> salary &gt; <span class="number">20000</span> <span class="keyword">then</span> <span class="comment">&#x27;a&#x27;</span></span><br><span class="line">  <span class="keyword">when</span> salary &gt; <span class="number">15000</span> <span class="keyword">then</span> <span class="comment">&#x27;b&#x27;</span></span><br><span class="line">  <span class="keyword">when</span> salary &gt; <span class="number">10000</span> <span class="keyword">then</span> <span class="comment">&#x27;c&#x27;</span></span><br><span class="line">  <span class="keyword">else</span> <span class="comment">&#x27;d&#x27;</span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">as</span> salaryLevel</span><br><span class="line">  <span class="keyword">from</span> employees</span><br></pre></td></tr></table></figure></code></pre></li></ul><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>sum avg max min count 忽略null值 可以和distinct搭配 sum (distinct salary)</p><h1 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h1><p>查询列表必须是分组函数或group by后出现的字段</p><p>查询有奖金的每个领导手下的员工的最高工资 且最高工资大于12000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select max(salary),manager_id from employees where commission_pct !&#x3D; null group by manager_id having max(salary) &gt; 12000 #having对分组后的结果进行筛选</span><br></pre></td></tr></table></figure><p>查询每个部门每个工种的员工的平均工资</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(salary),departmeng_id,job_id from employees group by department_id,job_id;</span><br></pre></td></tr></table></figure><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p>inner可以省略</p><p><strong>等值查询</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询名字中包含e的员工名和工种名 </span><br><span class="line">select last_name,job_title from employees e inner join jobs j on e.job_id &#x3D; j.job_id where e.last_name like &#39;%e%&#39;</span><br></pre></td></tr></table></figure><p><strong>非等值连接</strong></p><p><strong>自连接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.last_name,m.last_name from employees e inner join employees m on e.manager_id &#x3D; m.manager_id</span><br></pre></td></tr></table></figure><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a><strong>外连接</strong></h2><p>查询结果为主表的全部记录 左外连接中left左边的是主表</p><p><strong>左外连接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select b.name,bo.* from beauty b left outer join boys bo on b.boyfrientd_id &#x3D; bo.id</span><br></pre></td></tr></table></figure><p><strong>右外连接</strong></p><p><strong>全外连接</strong>：全外连接=左表全部记录+右表全部记录+相关联结果=左外连接+右外连接-相关联结果（即去重复）</p><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。</p><p>可以使用union操作符实现全外连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM emp e LEFT JOIN dept d ON e.deptno&#x3D;d.deptno</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM emp e RIGHT JOIN dept d ON e.deptno&#x3D;d.deptno;</span><br></pre></td></tr></table></figure><p><strong>内连接和外连接的区别</strong></p><p>内连接：取出两张表中匹配到的数据，匹配不到的不保留</p><p>外连接：取出连接表中匹配到的数据，匹配不到的也会保留，其值为NULL</p><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>按子查询的位置可分为</p><ul><li>select后面：仅支持标量子查询</li><li>from后面：支持表子查询</li><li>where或having后面：标量子查询，列子查询，行子查询</li><li>exits后面：表子查询</li></ul><p>按结果集的行列数不同可分为</p><ul><li>标量子查询：结果集只有一行一列</li><li>行子查询：结果集中有一行多列</li><li>列子查询：结果集中有一列多行</li><li>表子查询：结果集中有多行多列</li></ul><p>where后面的标量子查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#假设只有一个last_name为adel的人</span><br><span class="line">select first_name from employees where salary &gt; (select salary from employees where last_name &#x3D; ‘adel’)</span><br></pre></td></tr></table></figure><p>where后面的行子查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询员工编号最小并且工资最高的员工信息</span><br><span class="line">select * from employees where (employee_id,salary)&#x3D;(select MIN(employee_id),MAX(salary) from employees)</span><br></pre></td></tr></table></figure><p>where后面的列子查询：使用多行比较操作符 in,not in,any/some,all</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查询location_id是1400或1700的部门编号</span><br><span class="line">select distinct department_id from departments where location_id in(1400,1700)</span><br><span class="line">#查询员工姓名，要求部门号是上面查询结果列表中的某一个</span><br><span class="line">select last_name from employees where department_id in(select distinct department_id from departments where location_id in(1400,1700))</span><br></pre></td></tr></table></figure><p>having后面的标量子查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查询最低工资大于50号部门最低工资的部门id和其最低工资</span><br><span class="line">#先查询50号部门的最低工资</span><br><span class="line">select min(salary) from employees where department_id &#x3D; 50</span><br><span class="line">#再查询每个部门的最低工资</span><br><span class="line">select min(salary),department_id from employees group by department_id</span><br><span class="line">#总查询</span><br><span class="line">select min(salary),department_id from employees group by department_id having MIN(salary) &gt; (select MIN(salary) from employees where department_id &#x3D; 50)</span><br></pre></td></tr></table></figure><p>select后面的子查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询每个部门的员工个数</span><br><span class="line">select d.*,(select count(*) from employee e where e.department_id &#x3D; d.department_id ) as count from departments d</span><br></pre></td></tr></table></figure><p>from后面的子查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查询每个部门的平均工资的工资等级</span><br><span class="line">select AVG(salary),department_id from employees group by department_id</span><br><span class="line">#连接上面的结果集和job_grades表 筛选条件平均工资 between lowest_sal and highest_sal</span><br><span class="line">select ag_dep.*,g.grade_level from(select AVG(salaru) ag.department_id from employees group by department_id) ag_dep inner join job_grades g on ag_dep.ag between lowest_sal and hisgest_sal</span><br></pre></td></tr></table></figure><p>exit后面的子查询：<code>select exists(select employee_id from employees where salary = 3000) #结果0或1</code></p><h1 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h1><p><strong>INSERT</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#方法一</span><br><span class="line">insert into study(id,name,sex) values(12,&#39;bob&#39;,&#39;male&#39;)；</span><br><span class="line">insert into study values(12,&#39;bob&#39;,null);</span><br><span class="line">#方法二</span><br><span class="line">insert into study set id &#x3D; 1,name &#x3D; &#39;bob&#39;,sex &#x3D; &#39;male&#39;;</span><br><span class="line">#方法一支持同时插入多行和子查询</span><br></pre></td></tr></table></figure><p><strong>UPDATE</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#修改单表</span><br><span class="line">update user set name &#x3D; &#39;bob&#39; where name &#x3D; &#39;zhangsan&#39;</span><br><span class="line">#修改多表:修改bob的女朋友的手机号为114</span><br><span class="line">update boys bo inner join beauty b on bo.id &#x3D; b.boyfriend_id set b.phone &#x3D; 114 where bo.boyName &#x3D; &#39;bob&#39;</span><br></pre></td></tr></table></figure><p><strong>DELETE</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#单表删除</span><br><span class="line">delete from user where id &#x3D; 1;</span><br><span class="line">#多表删除：删除bob以及他女朋友的信息</span><br><span class="line">delete b,bo from beauty b inner join boys bo on b.boyfriend_id &#x3D; bo.id where bo.boyName &#x3D; &#39;bob&#39;</span><br></pre></td></tr></table></figure><p>delete和truncate的区别：如果表中有自增长的列 delete删除后自增长的列值从断点开始而truncate从0开始。truncate没有返回值不能回滚 delete有返回值能回滚</p><h1 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h1><p><strong>库的管理</strong></p><ul><li><p>创建数据库 Create databases (if not exists) mydata;</p></li><li><p>更改库的字符集 alter database mydata character set utf8</p></li><li><p>删除库 drop database (if exists) mydata;</p></li></ul><p><strong>表的管理</strong></p><p>表的创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table user(id int,name varchar(20),sex varchar(8));</span><br></pre></td></tr></table></figure><p>表的修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#修改列名，必须要带上类型</span><br><span class="line">alter table user change column id newId int;</span><br><span class="line">#修改列的类型或约束</span><br><span class="line">alter table user modify column name char;</span><br><span class="line">#添加新列</span><br><span class="line">alter table user add column hobby varchar(20);</span><br><span class="line">#删除列</span><br><span class="line">alter table user drop column hobby;</span><br><span class="line">#修改表名</span><br><span class="line">alter table user rename to users;</span><br><span class="line">#删除表</span><br><span class="line">drop table (if exists) user;</span><br></pre></td></tr></table></figure><p>表的复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#仅复制表的结构</span><br><span class="line">create table myCopy like user;</span><br><span class="line">#复制表的结构和数据</span><br><span class="line">create  table myCopy select * from user;</span><br><span class="line">#只复制一部分数据 全部结构</span><br><span class="line">create  table myCopy select id,name from user where name &#x3D; ‘bob’;</span><br><span class="line">#仅复制某些字段</span><br><span class="line">create  table myCopy select id,name from user where 0;</span><br></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>整型：Tinyint(1字节)  Smallint（2字节） Mediumint（3字节） Int ，integer（四字节） Bigint（8字节）后面加unsigned表示无符号</p><p>小数</p><ul><li><p>浮点数 ：float(4byte) double（8byte）</p></li><li><p>定点数 ：DEC(M,D) 共M位 小数占D位 默认M=10 D=0</p></li></ul><p>较短的文本：varchar(M)和char(M)， M表示最多字符数 char可以省略M 默认为1 varchar长度可变</p><p>较长的文本: blob(较大的二进制)，text </p><p>保存较短的二进制 binary varbinary</p><p>set  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table tab_char(c1 set(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;))</span><br><span class="line">#只能插入 1，2，3，a,b,c,A,B,C</span><br><span class="line">insert into tab_char values(&#39;a&#39;);</span><br><span class="line">insert into tab_char values(&#39;a,b&#39;);</span><br><span class="line">insert into tab_char values(&#39;b,c&#39;);</span><br></pre></td></tr></table></figure><p>enum    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table tab_char(c1 enum(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;))</span><br><span class="line">#只能插入 1，2，3，a,b,c,A,B,C</span><br><span class="line">insert into tab_char values(&#39;a&#39;);</span><br></pre></td></tr></table></figure><p>字符型</p><ul><li><p>较短的文本：varchar(M)和char(M)， M表示最多字符数 char可以省略M 默认为1 varchar长度可变</p></li><li><p>较长的文本: blob(较大的二进制)，text </p></li><li><p>保存较短的二进制 binary varbinary</p></li></ul><p>日期型</p><table><thead><tr><th align="center">类型</th><th align="center">字节</th><th align="center">最小值</th><th align="center">最大值</th></tr></thead><tbody><tr><td align="center">date</td><td align="center">4</td><td align="center">1000-01-01</td><td align="center">9999-12-31</td></tr><tr><td align="center">datatime</td><td align="center">8</td><td align="center">1000-01-01 00:00:00</td><td align="center">9999-12-31 23:59:59</td></tr><tr><td align="center">stamptime</td><td align="center">4</td><td align="center">19700101000001</td><td align="center">2038年的某个时刻</td></tr><tr><td align="center">time</td><td align="center">3</td><td align="center">-838:59:59</td><td align="center">838:59:59</td></tr><tr><td align="center">year</td><td align="center">1</td><td align="center">1901</td><td align="center">2155</td></tr></tbody></table><ul><li>timestamp会根据时区变化</li></ul><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p><strong>六大约束</strong></p><p><strong>NOT NULL</strong> ：非空约束，用于保证该字段的值不能为空 </p><p><strong>DEFAULT</strong> ：默认约束，用于保证该字段有默认值 </p><p><strong>PRIMARY KEY</strong> ：主键约束，用于保证该字段的值具有唯一性，并且非空 </p><p><strong>UNIQUE</strong> : 唯一约束，用于保证该字段的值具有唯一性，可以为空     </p><p><strong>CHECK</strong>：检查约束【mysql中不支持，sql语法支持，语法不报错，但是没效果】     比如年龄、性别，可以设置一个范围     </p><p><strong>FOREIGN KEY</strong> ：外键约束，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值</p><ul><li>PRIMARY KEY 和UNIQUE的区别：都可以保证唯一 主键不允许为空，unique允许 但是只能有一个null 主键只能有一个 unique可以多个 都支持组合列 </li><li>FOREIGN KEY ：从表的外键列类型和主表的关联列的类型要求一致或兼容，主表的关联列必须是一个key，插入数据时先插入主表，删除数据时先删除从表</li></ul><p>列级约束都支持但foreign key无效</p><p>表级约束除了default,not null都支持 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create table stuinfo(</span><br><span class="line">id int,</span><br><span class="line">    stuName varchar(20),</span><br><span class="line">    gender char(1),</span><br><span class="line">    seat int,</span><br><span class="line">    age int,</span><br><span class="line">    majorId int.</span><br><span class="line">    constraint pk primary key(id), #constarint 约束名 可以省略 </span><br><span class="line">    Unique(seat),</span><br><span class="line">    check(gender &#x3D; &#39;male&#39; or gender &#x3D; &#39;female&#39;).</span><br><span class="line">    foreign key(majorid) references major(id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>修改表示添加约束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alter table stuinfo modify column stuname varchar(20) not null</span><br><span class="line">alter table stuinfo modify column id int primary key </span><br><span class="line">alter table stuinfo add primary key(id)</span><br><span class="line"> #constarin &lt;name&gt; 是为了删除方便</span><br><span class="line">alter table stuinfo add constarin fk_stuinfo_major foreign key(majorid) references user(id)</span><br></pre></td></tr></table></figure><p>修改表示删除约束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#删除非空约束和默认约束</span><br><span class="line">alter talble stuinfo modify column stuname varchar(20) null #null可以省略</span><br><span class="line">#删除主键</span><br><span class="line">alter table stuinfo drop primary key</span><br><span class="line">#删除唯一</span><br><span class="line">alter table stuinfo drop index seat</span><br><span class="line">#删除外键</span><br><span class="line">alter table stuinfo drop foreign key fk_stuinfo_major</span><br></pre></td></tr></table></figure><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是由一组SQL语句组成的逻辑处理单元</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set autocommit &#x3D; 0 #关闭自动提交</span><br><span class="line">start transaction; #开始事务</span><br><span class="line">delete from user where name &#x3D; &#39;bob&#39;</span><br><span class="line">savepoint a; #设置回滚点</span><br><span class="line">delete from user where id &#x3D; 1;</span><br><span class="line">rollback to a;</span><br><span class="line">commit; #提交事务</span><br></pre></td></tr></table></figure><p><strong>ACID属性</strong></p><p>原子性(Atomicity)：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全不执行</p><p>一致性(Consistent)：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性;事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。 </p><p>隔离性：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</p><p>持久性：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持</p><p><strong>并发问题</strong>：对于同时运行的多个事务，当这些事务访问数据库中相同的数据时,如果没有采取必要的隔离机制,就会导致各种并发问题</p><ul><li><p>脏读：对于两个事务T1,T2,T1读取了已经被T2更新但还没有被提交的字段.之后,若T2回滚,T1读取的内容就是临时且无效的.</p></li><li><p>不可重复读:对于两个事务T1,T2,T1读取了一个字段,然后T2更新了该字段.之后,T1再次读取同一个字段,值就不同了.</p></li><li><p>幻读:对于两个事务T1,T2,T1从一个表中读取了一个字段,然后T2在该表中插入了一些新的行.之后,如果T1再次读取同一个表,就会多出几行.</p></li></ul><p><strong>事务隔离级别</strong></p><p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/image-20210204153156245.png" alt="image-20210204153156245"></p><p>mysql默认隔离级别为可重复读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看当前隔离级别</span><br><span class="line">select @@tx_isolation</span><br><span class="line">#修改隔离级别</span><br><span class="line">set session transaction isolation level read uncommitted</span><br></pre></td></tr></table></figure><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图在使用时动态生成 只保存sql逻辑 不保存查询结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#创建视图</span><br><span class="line">create or replace view myview as </span><br><span class="line">select last_name,department_name,job_title from employees e join departments d on e.department_id &#x3D; d.department_id join jobs j on j.job_id &#x3D; e.job_id</span><br><span class="line">#使用视图</span><br><span class="line">select * from myview where last_name like &#39;%a%&#39;</span><br><span class="line">#修改视图</span><br><span class="line">alter vim myview as select * from employees</span><br><span class="line">#删除视图</span><br><span class="line">drop view name1,name2,name...</span><br><span class="line">#查看视图</span><br><span class="line">desc name1 或者 show create view name1</span><br><span class="line">#视图的更新 把视图当作一张表进行操（不建议更新）</span><br><span class="line">insert into myview values(‘zhangfei’)</span><br></pre></td></tr></table></figure><p>以下视图不能更新</p><ul><li><p>视图中包含 聚合函数。</p></li><li><p>视图中包含 UNION、UNION ALL、DISTINCT、 GROUP BY 和 HAVING 等关键字。</p></li><li><p>常量视图</p></li><li><p>视图中的select中包含子查询</p></li><li><p>由不可更新的视图导出的视图</p></li><li><p>创建视图时，ALGORITHM 为 TEMPTABLE 类型</p></li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h1 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h1><p>全局变量与会话变量的区别就在于，对全局变量的修改会影响到整个服务器，但是对会话变量的修改，只会影响到当前的会话</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>查看: show global variables like ‘%xxx%’ 如果不加模糊查询就是查询所有变量</p><p>查看具体的值 select @@global.&lt;系统变量名&gt;</p><p> 赋值：set global 系统变量名 = 值</p><p>作用域：服务器每次启动为所有的全局变量赋初始值 针对于所有会话有效 但不能跨重启</p><h3 id="会话变量"><a href="#会话变量" class="headerlink" title="会话变量"></a>会话变量</h3><p>查看：show 【session】 variables </p><p>查看具体值 select @@【session】变量名</p><p>赋值：set 【session】变量名=值</p><p>作用域：仅对于当前会话有效</p><p>注：以上的session可以省略</p><h2 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h2><h3 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h3><p>当前会话有效</p><p>初始化或赋值：set @变量名=值</p><p>赋值：select count(*) into @count from…</p><p>查看：select @用户变量名</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>仅仅在定义它的begin end中有效</p><p>声明：declare 变量名 类型 【default 值】</p><p>赋值：set 或select into 不用加@</p><p>查看 select 变量名</p><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>参数模式有输入in，输出out，输入兼输出inout</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">create procedure mypro(inout a int,inout b int)</span><br><span class="line">begin </span><br><span class="line">set a &#x3D; a * 2;</span><br><span class="line">set b &#x3D; b + a;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">set @a &#x3D; 1;</span><br><span class="line">set @b &#x3D; 2;</span><br><span class="line">#调用存储过程</span><br><span class="line">#如果时参数模式是in a和b的值不会被修改</span><br><span class="line">call mypro(@a,@b);</span><br><span class="line">#查看存储过程</span><br><span class="line">show create procedure mypro</span><br><span class="line">#删除存储过程</span><br><span class="line">drop procedure mypro</span><br></pre></td></tr></table></figure><h1 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#启用函数</span><br><span class="line">set global log_bin_trust_function_creators &#x3D; on</span><br><span class="line">#创建</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION genPerson(name varchar(20)) RETURNS varchar(50)</span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE str VARCHAR(50) DEFAULT &#39;&#39;;</span><br><span class="line">  SET @tableName&#x3D;name;</span><br><span class="line">  SET str&#x3D;CONCAT(&#39;create table &#39;, @tableName,&#39;(id int, name varchar(20));&#39;);</span><br><span class="line">  return str;</span><br><span class="line">end</span><br><span class="line">#执行函数</span><br><span class="line">select genPerson(&#39;student&#39;);</span><br><span class="line">#查看函数</span><br><span class="line">show create function genPerson()</span><br><span class="line">#删除函数</span><br><span class="line">drop function genPerson</span><br></pre></td></tr></table></figure><h1 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h1><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p>CASE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create procedure test_case(in score int)</span><br><span class="line">begin</span><br><span class="line">case </span><br><span class="line">when score &gt;&#x3D; 90 and score &lt;&#x3D; 100 then select &#39;A&#39;</span><br><span class="line">when score &gt;&#x3D; 80 and then select &#39;B&#39;</span><br><span class="line">when score &gt;&#x3D; 70 and then select &#39;C&#39;</span><br><span class="line">else select &#39;D&#39;</span><br><span class="line">end case;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>IF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create procedure test_case(in score int)</span><br><span class="line">begin</span><br><span class="line">if score &gt;&#x3D; 90 and score &lt;&#x3D; 100 then return &#39;A&#39;;</span><br><span class="line">elseif score &gt;&#x3D; 80 then return &#39;B&#39;</span><br><span class="line">elseif score &gt;&#x3D; 70 then return &#39;C&#39;</span><br><span class="line">else return &#39;D&#39;</span><br><span class="line">end if</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>leave相当于break iterate相当于continue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#while</span><br><span class="line">while 循环条件 do</span><br><span class="line">循环体</span><br><span class="line">end while 标签</span><br><span class="line">#loop</span><br><span class="line">loop </span><br><span class="line">循环体</span><br><span class="line">end loop 标签 </span><br><span class="line">#repeat</span><br><span class="line">repeat </span><br><span class="line">循环体</span><br><span class="line">until 结束循环的条件</span><br><span class="line">end repeat 标签</span><br><span class="line"></span><br><span class="line">#举例</span><br><span class="line">create procedure test_while(in insertCount int)</span><br><span class="line">begin</span><br><span class="line">declare i int default 1;</span><br><span class="line">a:while i&lt;&#x3D;insertCount Do</span><br><span class="line">insert into admin(username,password) values (&#39;bob&#39;,&#39;123&#39;);</span><br><span class="line">if i &gt;&#x3D; 20 then leave a;</span><br><span class="line">end if;</span><br><span class="line">set i &#x3D; i + 1;</span><br><span class="line">end while a;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h1><p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612428706122.png" alt="img"></p><p>sql执行加载顺序 </p><p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612428715733.png" alt="img"></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是帮助mysql高效获取数据的数据结构,一般是Btree 索引本身也很大 一般以索引文件的形式存储在磁盘上</p><p>优点：提高数据检索效率 降低数据库io成本 通过索引列对数据进行排序 降低数据排序的成本 降低了cpu的消耗 </p><p>缺点：降低更新表的速度<br><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612440213371.png" alt="img"></p><ul><li>非叶子节点不存储数据 只存储指引搜索方向的数据项</li></ul><p>索引分为以下几类</p><ul><li><p>单值索引：一个索引只包含单个列 </p></li><li><p>唯一索引：索引列的值必须唯一 但允许有空值 primary key ，unique</p></li><li><p>复合索引：一个索引包含多个列</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#创建索引</span><br><span class="line">CREATE [UNIQUE] INDEX indexName on tableName(columnName) #如果有unique是唯一索引 如果多个列是复合索引</span><br><span class="line">ALTER tableName ADD [UNIQUE] INDEX INDEXNAME on(columnName)</span><br><span class="line">#删除索引</span><br><span class="line">DROP INDEX indexName on tableName</span><br><span class="line">#查看索引</span><br><span class="line">SHOW INDEX FROM tableName</span><br></pre></td></tr></table></figure><p>需要创建索引的情况</p><ul><li><p>主键自动创建唯一索引</p></li><li><p>频繁作为查询条件的字段应该创建索引</p></li><li><p>查询中与其他表关联的字段，外键关系建立索引</p></li><li><p>频繁更新的字段不适合创建索引 因为更新不仅更新记录还会更新索引</p></li><li><p>where条件里用不到的字段不创建索引</p></li><li><p>单键/组合索引选择问题：高并发下倾向创建组合索引</p></li><li><p>查询中排序的字段 排序字段若通过索引去访问将大大提高查询速度</p></li><li><p>查询中统计或者分组字段</p></li></ul><p>不需要创建索引的情况</p><ul><li><p>表记录太少 </p></li><li><p>经常增删改的表</p></li><li><p>如果某个数据列包含许多重复的内容 为他建立索引没有太大实际效果</p></li></ul><h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><p>使用explain关键字可以模拟优化器执行sql查询的语句 从而知道mysql是如何处理你的sql语句的 分析你的查询语句或表结构的性能瓶颈</p><p>Explain各字段</p><ul><li><p>id：select查询的序列号 包含一组数字 表示查询中select或操作表的执行顺序如果id相同 执行顺序由上至下 id不同的话id大的优先级高 先执行</p></li><li><p>select_type：<a href="https://www.cnblogs.com/danhuangpai/p/8475458.html">https://www.cnblogs.com/danhuangpai/p/8475458.html</a></p></li><li><p>table：这行数据关于哪张表</p></li><li><p>type：查询使用的类型 性能从最好到最差 system-&gt;cosnt-&gt;eq_ref-&gt;ref-&gt;range-&gt;index-&gt;all 至少能达到range级别 最好到ref</p><ul><li>system：表中只有一条记录 等于系统表 是const类型的特例</li><li>const：表示通过索引一次就找到了 用于比较primary key 和 unique索引</li><li>eq_ref：唯一性索引扫描 用于联表查询的情况,按联表的主键或唯一键联合查询 表中只有一条记录与之匹配</li><li>ref：非唯一性索引扫描 返回匹配某个单独值 的所有行</li><li>range：检索给定范围的行 使用一个索引来选择行 key列显示了用哪个索引  </li><li>index：index和all都是全表扫描 但index从索引中读取</li><li>all：全表扫描</li></ul></li><li><p>possible_keys：显示可能应用在这张表上的索引，查询涉及到的字段上如果存在索引 该索引将被列出</p></li><li><p>key：实际使用的索引 如果为null则没用到索引 查询中如果用到覆盖索引 该索引只出现在key列表</p><ul><li><p>覆盖索引：查询的字段和建立索引的个数 顺序刚好一致 或是其子集</p><ul><li><pre><code class="mysql">create index ide_col1_col2 on mytalbe(col1,col2)select col1,col2 from mytable;<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">* 覆盖索引中<span class="keyword">select</span>的数据列只用从索引中就能够取得 不必读取数据行，mysql可以利用索引返回<span class="keyword">select</span>列表中的字段 而不必根据索引再次读取数据文件 也就是说查询列要被所建的索引覆盖</span><br><span class="line">    </span><br><span class="line">* 如果要使用覆盖索引 一定要注意<span class="keyword">select</span>列表中只取出所需要的列 不可用<span class="keyword">select</span>*，因为如果将所有字段一起做索引会导致索引文件过大 查询新能下降</span><br><span class="line">  </span><br><span class="line">* key_len：表示索引中使用的字节数 显示的值为索引字段的最大可能长度 并非实际使用长度 这个值根据表定义计算得出 不是通过表内检索得出 在不失精度的前提下 长度越短越好</span><br><span class="line"></span><br><span class="line">* <span class="keyword">ref</span>：库.表.字段或const 显示索引的哪一列被使用了，有时候会是一个常量：表示哪些列或常量被用于查找索引列上的值 只有当<span class="keyword">type</span>为<span class="keyword">ref</span>和eq_ref的时候，<span class="keyword">ref</span>这列才会有值</span><br><span class="line"></span><br><span class="line">  * ![img](mysql笔记/clip_image002<span class="number">-1612446344425.</span>png)</span><br><span class="line"></span><br><span class="line">* <span class="keyword">rows</span>：查询所需要读取的行数</span><br><span class="line"></span><br><span class="line">* Extra：不适合在其他列中显示但十分重要的额外信息</span><br><span class="line"></span><br><span class="line">  * <span class="keyword">Using</span> fileSort：在使用<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">group</span> <span class="keyword">by</span>关键字的时候 没有使用索引的排序</span><br><span class="line"></span><br><span class="line">    * ```mysql</span><br><span class="line">      <span class="keyword">create</span> <span class="keyword">index</span> idx_salary_name <span class="keyword">user</span>(salary,<span class="type">name</span>)</span><br><span class="line">      #建立索引的顺序是salary <span class="type">name</span> 使用时直接使用<span class="type">name</span> 不符合最左匹配原则 </span><br><span class="line">      <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="type">name</span>;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>using temporary：排序没有走索引、使用union、子查询连接查询、使用某些视图等原因，因此创建了一个内部临时表</p></li><li><p>using index：表示相应的select操作中使用了覆盖索引 如果同时出现using where 表示索引被用来执行索引键值的查找 如果没有using where 表明索引被用来执行读取数据而不是查找动作</p><ul><li><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612446539518.png" alt="img"></li></ul></li><li><p>using where：表明使用了where过滤 </p></li><li><p>using join buffer ：使用了连接缓存</p></li><li><p>impossible where：where子句的值总是false 不能用来获取任何元组</p></li></ul></li></ul><h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><p>​    最佳左前缀法则：如果索引了多列 查询从索引的最左前列开始并且不跳过索引中的列</p><p>​    在索引列上做任何操作（计算 函数 自动或手动转换）会使索引失效</p><p>​    范围条件右边的列索引失效</p><p>​    使用!= &lt;&gt;会使索引失效</p><p>​    like以通配符开头会使索引失效</p><p>​    字符串不加单引号使索引失效</p><p>​    用or连接会使索引失效</p><p>​    is null ，is not null 无法使用索引</p><p>​    尽量使用覆盖索引减少使用select*</p><p>​    order by中的字段要么全是升序排列 要么全是降序排列 否则会使索引失效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#首先创建复合索引c1 ~ c4</span><br><span class="line">#查询时用到了c1c2排序时用到了c3 没用到c4</span><br><span class="line">explain  select * from test where c1 &#x3D; &#39;a1&#39; and c2 &#x3D; &#39;a2&#39; and c4 &#x3D; &#39;c4&#39; order by c3</span><br><span class="line">#查询时用到了c1 c2 但不会出现fillSort因为 c2已经是常量了 所以排序时进行优化只用到了c3 </span><br><span class="line">explain  select * from test where c1 &#x3D; &#39;a1&#39; and c2 &#x3D; &#39;a2&#39; and c5 &#x3D; &#39;c5&#39; order by c3,c2</span><br><span class="line">#分组之前必排序：第二个sql没用到索引c2和c3 所以要建立临时表自己进行排序 第一个sql用c2和c3进行排序和分组</span><br><span class="line">explain  select * from test where c1 &#x3D; &#39;a1&#39; and c4 &#x3D; &#39;c4&#39; order by c2,c3</span><br><span class="line">explain  select * from test where c1 &#x3D; &#39;a1&#39; and c4 &#x3D; &#39;c4&#39; order by c3,c2</span><br></pre></td></tr></table></figure><h1 id="In和Exist"><a href="#In和Exist" class="headerlink" title="In和Exist"></a>In和Exist</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#当B表的数据集必须小于A表的数据集时，用in优于exists</span><br><span class="line">select * from A where id in (select id from B)</span><br><span class="line">等价于</span><br><span class="line">for select id from B</span><br><span class="line">for select * from A where A.id &#x3D; B.id</span><br><span class="line">#当A表的数据集必须小于B表的数据集时，用exists优于in</span><br><span class="line">#select 1也可以是 select * 因为exists结果返回bool值 实际执行会忽略select清单</span><br><span class="line">select * from A where exists (select 1 from B where B.id &#x3D; A.id)</span><br><span class="line">等价于</span><br><span class="line">for select * from A</span><br><span class="line">for select * from B Where B.id &#x3D; A.id</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>select … from table where exists(subquery) 该语法可理解为：将主查询的数据放到子查询中做认证 根据验证结果(true,false)来决定著查询的数据是否得以保留</p><h1 id="FileSort"><a href="#FileSort" class="headerlink" title="FileSort"></a>FileSort</h1><p>mysql4.1之前是双路排序：从磁盘取排序字段 在buffer进行排序 在从磁盘取其他字段 两次io</p><p>单路排序：读出所有查询的列在buffer中进行排序 然后输出 一次io</p><p>在sort_buffer中，方法B比方法A要多占用很多空间，因为方法B是把所有字段都取出,所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并)，排完再取sort_buffer容量大小，再排……从而多次lO。本来想省一次lO操作，反而导致了大量的I/O操作，反而得不偿失。可以增大sort_buffer_size和max_length_for_sort_data进行优化</p><h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><p>慢查询日志用来记录在mysql中响应速度超过阈值的语句 具体指运行时间超过long_query_time值得sql 则会被记录到慢查询日志中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#查看是否开启</span><br><span class="line">show variables like &#39;%slow_query_log%&#39;</span><br><span class="line">#查看阈值 超过这个时间显示的sql语句被记录到日志中</span><br><span class="line">show variables like &#39;%slow_query_time%&#39;</span><br><span class="line">#开启慢查询</span><br><span class="line">set global general_log &#x3D; 1</span><br><span class="line">set global log_output &#x3D; &#39;table&#39;</span><br><span class="line">#被记录到mysql库中的general_log表中 可以用以下语句进行查看</span><br><span class="line">select * from mysql.general_log</span><br></pre></td></tr></table></figure><h1 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h1><p>​    优化顺序：慢查询-&gt;explain-&gt;show profile</p><p>​    showfile是mysql提供用来分析当前会话中语句执行的资源消耗情况 默认情况关闭 可以保存最近15次的运行结果</p><p>​    查看是否支持show variables like ‘profiling%’  开启:set profiling = on</p><p>​    查看语句的执行结果 show profiles  </p><p>​    诊断sql：show profile cpu,block io for query 9; 数字是要诊断的sql对应于show profiles列表中的id</p><p>​    showfile各字段</p><p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612450485937.png" alt="img"></p><p>出现以下几种情况很危险</p><ul><li>converting heap to myisam : 查询结果太大 内存不够用忘内存上搬</li><li>creating tmp table ：创建临时表，拷贝数据到临时表 用完再删除</li><li>copying to tmp  table on disk：把内存中临时表复制到磁盘</li></ul><h1 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h1><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>偏向myisam存储引擎 开销小 加锁块 无死锁 锁定粒度大 发生锁冲突的概率最高 并发程度低</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查看表的上锁情况 </span><br><span class="line">show open tables;</span><br><span class="line">#解锁</span><br><span class="line">unlock tables;</span><br><span class="line">#读锁：上了读锁之后不能修改此表 不能访问别的表 其他用户可以读其他表和此表 但修改表时会阻塞 直到解锁</span><br><span class="line">lock table user read </span><br><span class="line">#写锁：上了读锁之后可以读写此表 不能读其他表  其他用户可以读其他表 读此表的时候阻塞 不能写此表</span><br><span class="line">lock table user write</span><br></pre></td></tr></table></figure><p>​     <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612450686998.png" alt="img"></p><p>​     <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image004-1612450686996.png" alt="img">    </p><p>​     <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image006-1612450686997.png" alt="img"></p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>行锁：偏向InnoDb存储引擎 开销大 加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低 并发度也最高</p><p>如果使用针对InnoDB的表使用行锁，被锁定字段不是主键，也没有针对它建立索引的话。行锁锁定的也是整张表。锁整张表会造成程序的执行效率会很低。</p><p>索引失效会使行锁变表锁</p><p>事务未提交时 事务所涉及的行会自动锁住 其他行不会</p><p>​        <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612450784685.png" alt="img"></p><p>解决不可重复读：在会话一中更新一条数据 在会话二中开启自动提交 再在会话一中提交 会话二中查询出的数据是更新后的数据</p><h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁;对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，</p><p>InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁_(Next-key锁）</p><p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/image-20210216134205633.png" alt="image-20210216134205633"></p><p>间隙锁的危害</p><ul><li>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。</li><li>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</li></ul><p>如何锁定一行</p><p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612450977750.png" alt="img"></p><p>如何分析行锁定</p><p>通过检查Innodb_row_lock状态变量来分析系统上的行锁的争夺情况</p><p>show status like ‘%innodb_row_lock%’</p><p>各个字段</p><p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/image-20210204230741935.png" alt="image-20210204230741935"></p>]]></content>
    
    
    <summary type="html">MySQL是一个关系型数据库</summary>
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper</title>
    <link href="http://example.com/2021/02/01/zookeeper/"/>
    <id>http://example.com/2021/02/01/zookeeper/</id>
    <published>2021-02-01T10:58:14.000Z</published>
    <updated>2021-03-04T05:36:40.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h1><ul><li>维护配置信息</li><li>分布式锁服务</li><li>集群管理</li><li>生成分布式唯一ID</li></ul><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h1><ul><li>高性能：zookeeper将全量数据存储在内存中，并直接用于客户端的所有非事务请求，尤其适用于以读为主的应用场景</li><li>高可用：zooKeeper一般以集群的方式对外提供服务，一般3~5台机器就可以组成一个可用的Zookeeper集群了，每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都相互保持着通信。只要集群中超过一半的机器都能够正常工作，那么整个集群就能够正常对外服务</li><li>严格顺序访问：对于来自客户端的每个更新请求，ZooKeeper都会分配一个全局唯一的递增编号，这个编号反映了所有事务操作的先后顺序</li></ul><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a><strong>数据模型</strong></h1><p>zookeeper的数据节点可以视为树状结构（或者目录），树中的各节点被称为 znode（即zookeeper node），一个znode可以有多个子节点。zookeeper节点在结构 上表现为树状；使用路径path来定位某个znode，比如/ns1/itcast/mysql/schema1/table1。 znode，兼具文件和目录两种特点。既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分。</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210201193107146.png" alt="image-20210201193107146"></p><p>一个znode大体上分为3各部分： 节点的数据：即znode data(节点path, 节点data)的关系就像是java map中(key, value)的关系 节点的子节点children 节点的状态stat：用来描述当前节点的创建、修改记录，包括cZxid、ctime等</p><p>在zookeeper shell中使用get命令查看指定路径节点的data、stat信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 7] get /ns-1/tenant</span><br><span class="line">cZxid = 0x6a0000000a</span><br><span class="line">ctime = Wed Mar 27 09:56:44 CST 2019</span><br><span class="line">mZxid = 0x6a0000000a</span><br><span class="line">mtime = Wed Mar 27 09:56:44 CST 2019</span><br><span class="line">pZxid = 0x6a0000000e</span><br><span class="line">cversion = 2</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 2</span><br></pre></td></tr></table></figure><p>属性说明： </p><ul><li>cZxid：数据节点创建时的事务 </li><li>ID ctime：数据节点创建时的时间 </li><li>mZxid：数据节点最后一次更新时的事务 ID</li><li>mtime：数据节点最后一次更新时的时间 </li><li>pZxid：数据节点的子节点最后一次被修改时的事务 ID </li><li>cversion：子节点的更改次数 </li><li>dataVersion：节点数据的更改次数 </li><li>aclVersion：节点的 ACL 的更改次数 </li><li>ephemeralOwner：如果节点是临时节点，则表示创建该节点的会话的 SessionID；如果节点是持久节点，则该属性值为 0 </li><li>dataLength：数据内容的长度 </li><li>numChildren：数据节点当前的子节点个数</li></ul><h1 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a><strong>节点类型</strong></h1><p>zookeeper中的节点有两种，分别为临时节点和永久节点。节点的类型在创建时即 被确定，并且不能改变。</p><ul><li>临时节点：该节点的生命周期依赖于创建它们的会话。一旦会话(Session)结束，临 时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的Znode都会绑定到 一个客户端会话，但他们对所有的客户端还是可见的。另外，ZooKeeper的临时节 点不允许拥有子节点。</li><li>持久化节点：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作 的时候，他们才能被删除</li></ul><h1 id="zookeeper单机安装"><a href="#zookeeper单机安装" class="headerlink" title="zookeeper单机安装"></a>zookeeper单机安装</h1><p>zookeeper-3.4.10.tar.gz，上传并解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 进入conf目录</span><br><span class="line">cd /home/zookeeper/zookeeper-3.4.10/conf</span><br><span class="line">// 复制配置文件</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line">// zookeeper根目录下新建data目录</span><br><span class="line">mkdir data</span><br><span class="line">// vi 修改配置文件中的dataDir</span><br><span class="line">// 此路径用于存储zookeeper中数据的内存快照、及事物日志文件</span><br><span class="line">dataDir=/home/zookeeper/zookeeper-3.4.10/data</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 进入zookeeper的bin目录</span><br><span class="line">cd /home/zookeeper/zookeeper-3.4.10/bin</span><br><span class="line">// 启动zookeeper</span><br><span class="line">./zkServer.sh start</span><br><span class="line">//启动：zkServer.sh start</span><br><span class="line">//停止：zkServer.sh stop</span><br><span class="line">//查看状态：zkServer.sh status</span><br><span class="line">登录客户端：./zkCli.sh -server localhost:2181</span><br></pre></td></tr></table></figure><h1 id="常用shell命令"><a href="#常用shell命令" class="headerlink" title="常用shell命令"></a>常用shell命令</h1><p><strong>新增节点</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create [-s] [-e] path data #其中-s 为有序节点，-e 临时节点</span><br><span class="line"><span class="meta">#</span><span class="bash">创建持久化节点</span></span><br><span class="line">create /hadoop &quot;123&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">创建持久化有序节点</span></span><br><span class="line">create -s /a &quot;a&quot; </span><br><span class="line">Created /a0000000001</span><br><span class="line">create -s /a &quot;b&quot;</span><br><span class="line">Created /b0000000002</span><br><span class="line">create -s /a &quot;c&quot;</span><br><span class="line">Created /c0000000003</span><br><span class="line"><span class="meta">#</span><span class="bash">创建临时节点 当当前会话过期后被删除[quit命令退出]</span></span><br><span class="line">create -e /tmp &quot;hhh&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">创建临时有序节点</span></span><br><span class="line">create -s -e /orderTmp &quot;ttt&quot;</span><br></pre></td></tr></table></figure><p><strong>更新节点</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set /hadoop &quot;345&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">也可以基于版本号进行更改，此时类似于乐观锁机制，当你传入的数据版本号(dataVersion) 和当前节点的数据版本号不符合时，会拒绝本次修改</span></span><br><span class="line">set /hadoop &quot;3456&quot; 1</span><br></pre></td></tr></table></figure><p><strong>删除节点</strong></p><p>与更新节点类似：delete path [version]</p><p><strong>查看节点</strong></p><p>get path</p><p><strong>查看节点状态</strong></p><p>state path:它的返回值和 get 命令类似，但不会返回 节点数据</p><p><strong>查看节点列表</strong></p><p>查看节点列表有 ls path 和 ls2 path 两个命令，后者是前者的增强，不仅可以查看指定路径下的所有节点，还可以查看当前节点的信息</p><p><strong>监听器</strong></p><p>get path [watch] ：注册的监听器能够在节点内容发生改变的时候，向客户端发出通知。需要注意的是 zookeeper 的触发器是一次性的 (One-time trigger)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] get /hadoop watch</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] set /hadoop 45678</span><br><span class="line">WATCHER::</span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDataChanged path:/hadoop #节点值改变</span><br></pre></td></tr></table></figure><p>ls\ls2 path [watch]：ls path [watch] 或 ls2 path [watch] 注册的监听器能够监听该节点下 所有子节点的增加和删除操作。也是一次性的</p><h1 id="ACL权限控制"><a href="#ACL权限控制" class="headerlink" title="ACL权限控制"></a>ACL权限控制</h1><p>zookeeper 类似文件系统，client 可以创建节点、更新节点、删除节点，那么 如何做到节点的权限的控制呢？zookeeper的access control list 访问控制列表可以做到 这一点。</p><p>acl 权限控制，使用scheme：id：permission 来标识，主要涵盖 3 个方面</p><ul><li>权限模式（scheme）：授权的策略</li><li>授权对象（id）：授权的对象</li><li>权限（permission）：授予的权限</li></ul><p>其特性如下</p><ul><li>zooKeeper的权限控制是基于每个znode节点的，需要对每个节点设置权限</li><li>每个znode支持设置多种权限控制方案和多个权限</li><li>子节点不会继承父节点的权限，客户端无权访问某节点，但可能可以访问它的子节点</li></ul><p><strong>权限模式</strong></p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210202170003037.png" alt="image-20210202170003037"></p><p><strong>授予的权限</strong></p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210202170113833.png" alt="image-20210202170113833"></p><p><strong>授权的相关命令</strong></p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210202170241887.png" alt="image-20210202170241887"></p><p>world授权模式 <code>setAcl /node1 world:anyone:cdrwa</code></p><p>IP授权模式 <code>setAcl /node2 ip:192.168.60.129:cdrwa</code></p><p>Auth授权模式 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addauth digest itcast:123456</span><br><span class="line">setAcl /node3 auth:itcast:cdrwa</span><br></pre></td></tr></table></figure><p>Digest授权模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">通过以下命令计算密文</span></span><br><span class="line">echo -n &lt;user&gt;:&lt;password&gt; | openssl dgst -binary -sha1 | openssl base64</span><br><span class="line">echo -n bob:123465 | openssl dgst -binary -sha1 | openssl base64</span><br><span class="line"><span class="meta">#</span><span class="bash">使用算出的密文添加权限</span></span><br><span class="line">setAcl /node digest:bob:qlzQzCLKhBROghkooLvb+Mlwv4A=:cdrwa</span><br><span class="line"><span class="meta">#</span><span class="bash">添加认证用户后 才可以得到数据</span></span><br><span class="line">addauth digest bob:123456</span><br><span class="line">get /node</span><br></pre></td></tr></table></figure><p><strong>超级管理员</strong></p><p>首先为超管生成密文</p><p>比如<code>echo -n super:admin | openssl dgst -binary -sha1 | openssl base64</code></p><p>么打开zookeeper目录下的/bin/zkServer.sh服务器脚本文件，找到如下一行</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210202171936529.png" alt="image-20210202171936529"></p><p>在后面添加</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210202172025240.png" alt="image-20210202172025240"></p><h1 id="javaAPI"><a href="#javaAPI" class="headerlink" title="javaAPI"></a><strong>javaAPI</strong></h1><h2 id="连接到zookeeper"><a href="#连接到zookeeper" class="headerlink" title="连接到zookeeper"></a><strong>连接到zookeeper</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperConnection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 计数器对象</span></span><br><span class="line">            CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// arg1:服务器的ip和端口</span></span><br><span class="line">            <span class="comment">// arg2:客户端与服务器之间的会话超时时间 以毫秒为单位的</span></span><br><span class="line">            <span class="comment">// arg3:连接是异步的 需要实现“监视器”对象 zookeeper集合通过监视器对象返回连接状态</span></span><br><span class="line">            ZooKeeper zooKeeper=<span class="keyword">new</span> ZooKeeper(<span class="string">&quot;192.168.52.131:2181&quot;</span>,</span><br><span class="line">                    <span class="number">5000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(event.getState()==Event.KeeperState.SyncConnected)</span><br><span class="line">                    &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;连接创建成功!&quot;</span>);</span><br><span class="line">                        countDownLatch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 主线程阻塞等待连接对象的创建成功</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="comment">// 会话编号</span></span><br><span class="line">            System.out.println(zooKeeper.getSessionId());</span><br><span class="line">            zooKeeper.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a><strong>新增节点</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方式</span></span><br><span class="line">create(String path, <span class="keyword">byte</span>[] data, List&lt;ACL&gt; acl, CreateMode createMode)</span><br><span class="line"><span class="comment">// 异步方式</span></span><br><span class="line">create(String path, <span class="keyword">byte</span>[] data, List&lt;ACL&gt; acl, CreateMode createMode，AsyncCallback.StringCallback callBack,Object ctx)</span><br></pre></td></tr></table></figure><ul><li>path - znode路径。例如/node1 </li><li>data - 要存储在指定znode路径中的数据</li><li>acl - 要创建的节点的访问控制列表。zookeeper API提供了一个静态接口 ZooDefs.Ids 来获取一些基本的acl列表。例如，ZooDefs.Ids.OPEN_ACL_UNSAFE 返回打开znode的acl列表。</li><li>createMode - 节点的类型,这是一个枚举。 </li><li>callBack-异步回调接口 </li><li>ctx-传递上下文参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKCreate</span> </span>&#123;</span><br><span class="line">    ZooKeeper zooKeeper ;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 计数器对象</span></span><br><span class="line">        CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// arg1:服务器的ip和端口</span></span><br><span class="line">        <span class="comment">// arg2:客户端与服务器之间的会话超时时间 以毫秒为单位的</span></span><br><span class="line">        <span class="comment">// arg3:连接是异步的 需要实现“监视器”对象 zookeeper集合通过监视器对象返回连接状态</span></span><br><span class="line">        zooKeeper=<span class="keyword">new</span> ZooKeeper(<span class="string">&quot;192.168.52.131:2181&quot;</span>,</span><br><span class="line">                <span class="number">5000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(event.getState()==Event.KeeperState.SyncConnected)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接创建成功!&quot;</span>);</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * Decrements the count of the latch, releasing all waiting threads if the count reaches zero.</span></span><br><span class="line"><span class="comment">                     * If the current count is greater than zero then it is decremented. If the new count is zero then all waiting threads are re-enabled for thread scheduling purposes.</span></span><br><span class="line"><span class="comment">                     * If the current count equals zero then nothing happens.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程阻塞等待连接对象的创建成功</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createSync</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * READ_ACL_UNSAFE:world:anyone:r 只读的</span></span><br><span class="line"><span class="comment">         * CREATOR_ALL_ACL:赋予了节点的创建者所有的权限，在创建者采用此ACL创建节点之前，已经被服务器所认证（例如，采用 “ digest”方案）。</span></span><br><span class="line"><span class="comment">         * OPEN_ACL_UNSAFE:world:anyone:cdrwa 任何应用程序在节点上可进行任何操作，能创建、列出和删除它的子节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node1&quot;</span>,<span class="string">&quot;i am node1&quot;</span>.getBytes(StandardCharsets.UTF_8), ZooDefs.Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAcl</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//自定义权限</span></span><br><span class="line">        <span class="comment">//world授权</span></span><br><span class="line">        List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//授权模式和授权对象</span></span><br><span class="line">        Id id = <span class="keyword">new</span> Id(<span class="string">&quot;world&quot;</span>,<span class="string">&quot;anyone&quot;</span>);</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.READ,id));</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.WRITE,id));</span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node2&quot;</span>,<span class="string">&quot;i am node2&quot;</span>.getBytes(StandardCharsets.UTF_8),acls,CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAcl2</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//ip授权</span></span><br><span class="line">        List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Id id = <span class="keyword">new</span> Id(<span class="string">&quot;ip&quot;</span>,<span class="string">&quot;192.168.52.131&quot;</span>);</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.ALL,id));</span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node2&quot;</span>,<span class="string">&quot;i am node2&quot;</span>.getBytes(StandardCharsets.UTF_8),acls,CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAcl3</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//auth授权</span></span><br><span class="line">        zooKeeper.addAuthInfo(<span class="string">&quot;digest&quot;</span>,<span class="string">&quot;admin:123456&quot;</span>.getBytes());</span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node2&quot;</span>,<span class="string">&quot;i am node2&quot;</span>.getBytes(StandardCharsets.UTF_8),ZooDefs.Ids.CREATOR_ALL_ACL,CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAcl4</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//auth授权</span></span><br><span class="line">        zooKeeper.addAuthInfo(<span class="string">&quot;digest&quot;</span>,<span class="string">&quot;admin:123456&quot;</span>.getBytes());</span><br><span class="line">        List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Id id = <span class="keyword">new</span> Id(<span class="string">&quot;auth&quot;</span>,<span class="string">&quot;bob&quot;</span>);</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.ALL,id));</span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node2&quot;</span>,<span class="string">&quot;i am node2&quot;</span>.getBytes(StandardCharsets.UTF_8),acls,CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAcl5</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//digest授权</span></span><br><span class="line">        List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Id id = <span class="keyword">new</span> Id(<span class="string">&quot;digest&quot;</span>,<span class="string">&quot;bob:qlzQzCLKhBROghkooLvb+Mlwv4A=&quot;</span>);</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.ALL,id));</span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node2&quot;</span>,<span class="string">&quot;i am node2&quot;</span>.getBytes(StandardCharsets.UTF_8),acls,CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPer</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建持久化顺序节点</span></span><br><span class="line">        String result = zooKeeper.create(<span class="string">&quot;/create/node1&quot;</span>,<span class="string">&quot;i am node1&quot;</span>.getBytes(StandardCharsets.UTF_8), ZooDefs.Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAsunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node2&quot;</span>,<span class="string">&quot;i am node2&quot;</span>.getBytes(StandardCharsets.UTF_8),ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, <span class="keyword">new</span> AsyncCallback.StringCallback()&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> rc 0代表创建成功</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> path 节点路径</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> ctx  上下文参数</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> name 节点路径</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, String name)</span> </span>&#123;</span><br><span class="line">                System.out.println(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;i am ctx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        zooKeeper.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方式</span></span><br><span class="line">set<span class="constructor">Data(String <span class="params">path</span>, <span class="params">byte</span>[] <span class="params">data</span>, <span class="params">int</span> <span class="params">version</span>)</span></span><br><span class="line"><span class="comment">// 异步方式:callback是异步回调接口 ctx传递上下文对象</span></span><br><span class="line">set<span class="constructor">Data(String <span class="params">path</span>, <span class="params">byte</span>[] <span class="params">data</span>,,<span class="params">int</span> <span class="params">version</span>,AsyncCallback.StatCallback <span class="params">callBack</span>,Object <span class="params">ctx</span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSyn</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Stat stat=zookeeper.setData(<span class="string">&quot;/set/node1&quot;</span>,<span class="string">&quot;node13&quot;</span>.getBytes(),<span class="number">2</span>);</span><br><span class="line">    System.out.println(stat.getVersion());</span><br><span class="line">    System.out.println(stat.getCtime());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsyn</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//版本号—1表示不参与更新 版本号一致才可以更新成功 每次更新版本号+1</span></span><br><span class="line">    zookeeper.setData(<span class="string">&quot;/set/node2&quot;</span>, <span class="string">&quot;node21&quot;</span>.getBytes(), -<span class="number">1</span>, <span class="keyword">new</span></span><br><span class="line">                      AsyncCallback.StatCallback() &#123;</span><br><span class="line">                          <span class="meta">@Override</span></span><br><span class="line">                          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, Stat stat)</span> </span>&#123;</span><br><span class="line">                              System.out.println(rc);</span><br><span class="line">                              System.out.println(path);</span><br><span class="line">                              System.out.println(ctx);</span><br><span class="line">                              System.out.println(stat.getVersion());</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;,<span class="string">&quot;I am Context&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 同步方式</span><br><span class="line"><span class="keyword">delete</span>(<span class="keyword">String</span> <span class="keyword">path</span>, <span class="built_in">int</span> <span class="keyword">version</span>)</span><br><span class="line">// 异步方式</span><br><span class="line"><span class="keyword">delete</span>(<span class="keyword">String</span> <span class="keyword">path</span>, <span class="built_in">int</span> <span class="keyword">version</span>, AsyncCallback.VoidCallback callBack,<span class="keyword">Object</span> ctx)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// arg2:数据版本信息 -1代表删除节点时不考虑版本信息</span></span><br><span class="line">    zooKeeper.delete(<span class="string">&quot;/delete/node1&quot;</span>,-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 异步使用方式</span></span><br><span class="line">    zooKeeper.delete(<span class="string">&quot;/delete/node2&quot;</span>, -<span class="number">1</span>, <span class="keyword">new</span></span><br><span class="line">                     AsyncCallback.VoidCallback() &#123;</span><br><span class="line">                         <span class="meta">@Override</span></span><br><span class="line">                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx)</span> </span>&#123;</span><br><span class="line">                             <span class="comment">// 0代表删除成功</span></span><br><span class="line">                             System.out.println(rc);</span><br><span class="line">                             System.out.println(path);</span><br><span class="line">                             System.out.println(ctx);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;,<span class="string">&quot;I am Context&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看节点"><a href="#查看节点" class="headerlink" title="查看节点"></a>查看节点</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方式</span></span><br><span class="line">get<span class="constructor">Data(String <span class="params">path</span>, <span class="params">boolean</span> <span class="params">b</span>, Stat <span class="params">stat</span>)</span></span><br><span class="line"><span class="comment">// 异步方式</span></span><br><span class="line">get<span class="constructor">Data(String <span class="params">path</span>, <span class="params">boolean</span> <span class="params">b</span>，AsyncCallback.DataCallback <span class="params">callBack</span>，Object <span class="params">ctx</span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// arg1:节点的路径</span></span><br><span class="line">    <span class="comment">// arg3:读取节点属性的对象</span></span><br><span class="line">    Stat stat=<span class="keyword">new</span> Stat();</span><br><span class="line">    <span class="keyword">byte</span> [] bys=zooKeeper.getData(<span class="string">&quot;/get/node1&quot;</span>,<span class="keyword">false</span>,stat);</span><br><span class="line">    <span class="comment">// 打印数据</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(bys));</span><br><span class="line">    <span class="comment">// 版本信息</span></span><br><span class="line">    System.out.println(stat.getVersion());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    zooKeeper.getData(<span class="string">&quot;/get/node1&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span></span><br><span class="line">            AsyncCallback.DataCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">byte</span>[] data, Stat stat)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 0代表读取成功</span></span><br><span class="line">                    System.out.println(rc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;I am Context&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看子节点"><a href="#查看子节点" class="headerlink" title="查看子节点"></a>查看子节点</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方式</span></span><br><span class="line">get<span class="constructor">Children(String <span class="params">path</span>, <span class="params">boolean</span> <span class="params">b</span>)</span></span><br><span class="line"><span class="comment">// 异步方式</span></span><br><span class="line">get<span class="constructor">Children(String <span class="params">path</span>, <span class="params">boolean</span> <span class="params">b</span>,AsyncCallback.ChildrenCallback <span class="params">callBack</span>,Object <span class="params">ctx</span>)</span></span><br></pre></td></tr></table></figure><ul><li>b- 是否使用连接对象中注册的监视器。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//arg2:如果watch为true，并且调用成功（没有抛出异常），将在给定路径的节点上留下一个watch。</span></span><br><span class="line">    <span class="comment">//如果成功地删除给定路径的节点或在该节点下创建/删除一个子节点的操作将触发该监视。</span></span><br><span class="line">    List&lt;String&gt; list = zooKeeper.getChildren(<span class="string">&quot;/get&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    zooKeeper.getChildren(<span class="string">&quot;/get&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span></span><br><span class="line">                          AsyncCallback.ChildrenCallback() &#123;</span><br><span class="line">                              <span class="meta">@Override</span></span><br><span class="line">                              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        List&lt;String&gt; children)</span> </span>&#123;</span><br><span class="line">                                  <span class="comment">// 0代表读取成功</span></span><br><span class="line">                                  System.out.println(rc);</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;,<span class="string">&quot;I am Context&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看节点是否存在"><a href="#查看节点是否存在" class="headerlink" title="查看节点是否存在"></a>查看节点是否存在</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方法</span></span><br><span class="line"><span class="built_in">exists</span>(<span class="keyword">String</span> path, <span class="keyword">boolean</span> b)</span><br><span class="line"><span class="comment">// 异步方法</span></span><br><span class="line"><span class="built_in">exists</span>(<span class="keyword">String</span> path, <span class="keyword">boolean</span> b，AsyncCallback.StatCallback callBack,Object ctx)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exists1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Stat stat = zookeeper.exists(<span class="string">&quot;/exists1&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    System.out.println(stat.getVersion());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exists2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    zookeeper.exists(<span class="string">&quot;/exists1&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span></span><br><span class="line">            AsyncCallback.StatCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Stat stat)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 0 判断成功</span></span><br><span class="line">                    System.out.println(rc);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;I am Context&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h1><p>​    zookeeper提供了数据的发布/订阅功能，多个订阅者可同时监听某一特定主题对 象，当该主题对象的自身状态发生变化时(例如节点内容改变、节点下的子节点列表改变 等)，会实时、主动通知所有订阅者</p><p>​    zookeeper采用了Watcher机制实现数据的发布/订阅功能。该机制在被订阅对 象发生变化时会异步通知客户端，因此客户端不必在Watcher注册后轮询阻塞，从而减轻 了客户端压力</p><h2 id="watcher架构"><a href="#watcher架构" class="headerlink" title="watcher架构"></a>watcher架构</h2><p>watcher由三部分组成：zookeeper服务端，zookeeper客户端，客户端的ZKWatchManager对象</p><p>客户端首先将Watcher注册到服务端，同时将Watcher对象保存到客户端的Watch管理器中。当ZooKeeper服务端监听的数据状态发生变化时，服务端会主动通知客户端， 接着客户端的Watch管理器会触发相关Watcher来回调相应处理逻辑，从而完成整体的数 据发布/订阅流程。</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210215104851771.png" alt="image-20210215104851771"></p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>一次性</td><td>watcher是一次性的，一旦被触发就会移除，再次使用时需要重新注册</td></tr><tr><td>客户端顺序回调</td><td>watcher回调是顺序串行化执行的，只有回调后客户端才能看到最新的数据状态。一个watcher回调逻辑不应该太多，以免影响别的watcher执行</td></tr><tr><td>轻量级</td><td>WatchEvent是最小的通信单元，结构上只包含通知状态、事件类型和节点路径，并不会告诉数据节点变化前后的具体内容</td></tr><tr><td>时效性</td><td>watcher只有在当前session彻底失效时才会无效，若在session有效期内快速重连成功，则watcher依然存在，仍可接收到通知</td></tr></tbody></table><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>Watcher是一个接口，任何实现了Watcher接口的类就是一个新的Watcher。 Watcher内部包含了两个枚举类：KeeperState、EventType</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210215105441596.png" alt="image-20210215105441596"></p><p>Watcher通知状态(KeeperState)：KeeperState是客户端与服务端连接状态发生变化时对应的通知类型。路径为 org.apache.zookeeper.Watcher.Event.KeeperState，是一个枚举类，其枚举属性 如下</p><table><thead><tr><th>枚举属性</th><th>说明</th></tr></thead><tbody><tr><td>SyncConnected</td><td>客户端与服务器正常连接时</td></tr><tr><td>Disconnected</td><td>客户端与服务器断开连接时</td></tr><tr><td>Expired</td><td>会话session失效时</td></tr><tr><td>AuthFailed</td><td>身份认证失败时</td></tr></tbody></table><p>Watcher事件类型(EventType)：EventType是数据节点(znode)发生变化时对应的通知类型。EventType变化时 KeeperState永远处于SyncConnected通知状态下；当KeeperState发生变化时， EventType永远为None。其路径为org.apache.zookeeper.Watcher.Event.EventType，是一个枚举类，枚举属性如下</p><table><thead><tr><th>枚举属性</th><th>说明</th></tr></thead><tbody><tr><td>None</td><td>无</td></tr><tr><td>NodeCreated</td><td>Watcher监听的数据节点被创建时</td></tr><tr><td>NodeDeleted</td><td>Watcher监听的数据节点被删除时</td></tr><tr><td>NodeDataChanged</td><td>Watcher监听的数据节点内容发生变更时(无论内容数据 是否变化)</td></tr><tr><td>NodeChildrenChanged</td><td>Watcher监听的数据节点的子节点列表发生变更时</td></tr></tbody></table><h2 id="捕获相应的事件"><a href="#捕获相应的事件" class="headerlink" title="捕获相应的事件"></a>捕获相应的事件</h2><p>建立zookeeper的watcher监听</p><table><thead><tr><th>注册方式</th><th>Created</th><th>ChildChanged</th><th>Changed</th><th>Deleted</th></tr></thead><tbody><tr><td>zk.exists(“/nodex”,watcher)</td><td>可监控</td><td></td><td>可监控</td><td>可监控</td></tr><tr><td>zk.getData(“/nodex”,watcher)</td><td></td><td></td><td>可监控</td><td>可监控</td></tr><tr><td>zk.getChildren(“/nodex”,watcher)</td><td></td><td>可监控</td><td></td><td>可监控</td></tr></tbody></table><h2 id="注册watcher的方法"><a href="#注册watcher的方法" class="headerlink" title="注册watcher的方法"></a>注册watcher的方法</h2><h3 id="客户端与服务器的连接状态"><a href="#客户端与服务器的连接状态" class="headerlink" title="客户端与服务器的连接状态"></a>客户端与服务器的连接状态</h3><p>事件类型为none时 不同的通知状态的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.watcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKConnectionWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器对象</span></span><br><span class="line">    <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 连接对象</span></span><br><span class="line">    <span class="keyword">static</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 事件类型</span></span><br><span class="line">            <span class="keyword">if</span> (event.getType() == Event.EventType.None) &#123;</span><br><span class="line">                <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接创建成功!&quot;</span>);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == Event.KeeperState.Disconnected) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;断开连接！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == Event.KeeperState.Expired) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;会话超时!&quot;</span>);</span><br><span class="line">                    zooKeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;192.168.52.131:2181&quot;</span>, <span class="number">5000</span>, <span class="keyword">new</span> ZKConnectionWatcher());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == Event.KeeperState.AuthFailed) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;认证失败！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zooKeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;192.168.52.131:2181&quot;</span>, <span class="number">5000</span>, <span class="keyword">new</span> ZKConnectionWatcher());</span><br><span class="line">            <span class="comment">// 阻塞线程等待连接的创建</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="comment">// 会话id</span></span><br><span class="line">            System.out.println(zooKeeper.getSessionId());</span><br><span class="line">            <span class="comment">// 添加授权用户</span></span><br><span class="line">            zooKeeper.addAuthInfo(<span class="string">&quot;digest1&quot;</span>,<span class="string">&quot;itcast1:1234561&quot;</span>.getBytes());</span><br><span class="line">            <span class="keyword">byte</span> [] bs=zooKeeper.getData(<span class="string">&quot;/node1&quot;</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bs));</span><br><span class="line">            Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">            zooKeeper.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检查节点是否存在"><a href="#检查节点是否存在" class="headerlink" title="检查节点是否存在"></a>检查节点是否存在</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用连接对象的监视器</span></span><br><span class="line"><span class="function"><span class="title">exists</span><span class="params">(String path, boolean b)</span></span></span><br><span class="line"><span class="comment">// 自定义监视器</span></span><br><span class="line"><span class="function"><span class="title">exists</span><span class="params">(String path, Watcher w)</span></span></span><br><span class="line"></span><br><span class="line">path- znode路径。</span><br><span class="line">b- 是否使用连接对象中注册的监视器。</span><br><span class="line">w-监视器对象。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKWatcherExists</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String IP = <span class="string">&quot;192.168.52.131:2181&quot;</span>;</span><br><span class="line">    ZooKeeper zooKeeper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 连接zookeeper客户端</span></span><br><span class="line">        zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">6000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接对象的参数!&quot;</span>);</span><br><span class="line">                <span class="comment">// 连接成功</span></span><br><span class="line">                <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        zooKeeper.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherExists1</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// arg1:节点的路径</span></span><br><span class="line">        <span class="comment">// arg2:使用连接对象中的watcher</span></span><br><span class="line">        <span class="comment">//启动之后 再创建watcher1节点 控制台会显示出结果</span></span><br><span class="line">        zooKeeper.exists(<span class="string">&quot;/watcher1&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherExists2</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// arg1:节点的路径</span></span><br><span class="line">        <span class="comment">// arg2:自定义watcher对象</span></span><br><span class="line">        zooKeeper.exists(<span class="string">&quot;/watcher1&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;自定义watcher&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherExists3</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// watcher一次性</span></span><br><span class="line">        Watcher watcher = <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;自定义watcher&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    zooKeeper.exists(<span class="string">&quot;/watcher1&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        zooKeeper.exists(<span class="string">&quot;/watcher1&quot;</span>, watcher);</span><br><span class="line">        Thread.sleep(<span class="number">80000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherExists4</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 注册多个监听器对象</span></span><br><span class="line">        zooKeeper.exists(<span class="string">&quot;/watcher1&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        zooKeeper.exists(<span class="string">&quot;/watcher1&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(<span class="number">80000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看节点-1"><a href="#查看节点-1" class="headerlink" title="查看节点"></a>查看节点</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用连接对象的监视器</span></span><br><span class="line">get<span class="constructor">Data(String <span class="params">path</span>, <span class="params">boolean</span> <span class="params">b</span>, Stat <span class="params">stat</span>)</span></span><br><span class="line"><span class="comment">// 自定义监视器</span></span><br><span class="line">get<span class="constructor">Data(String <span class="params">path</span>, Watcher <span class="params">w</span>, Stat <span class="params">stat</span>)</span></span><br><span class="line"></span><br><span class="line">path- znode路径。</span><br><span class="line">b- 是否使用连接对象中注册的监视器。</span><br><span class="line">w-监视器对象。</span><br><span class="line">stat- 返回znode的元数据。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKWatcherGetData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String IP = <span class="string">&quot;192.168.60.130:2181&quot;</span>;</span><br><span class="line">    ZooKeeper zooKeeper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 连接zookeeper客户端</span></span><br><span class="line">        zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">6000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接对象的参数!&quot;</span>);</span><br><span class="line">                <span class="comment">// 连接成功</span></span><br><span class="line">                <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        zooKeeper.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetData1</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// arg1:节点的路径</span></span><br><span class="line">        <span class="comment">// arg2:使用连接对象中的watcher</span></span><br><span class="line">        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetData2</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// arg1:节点的路径</span></span><br><span class="line">        <span class="comment">// arg2:自定义watcher对象</span></span><br><span class="line">        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;自定义watcher&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">null</span>);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetData3</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 一次性</span></span><br><span class="line">        Watcher watcher = <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;自定义watcher&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    <span class="keyword">if</span>(event.getType()==Event.EventType.NodeDataChanged) &#123;</span><br><span class="line">                        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, watcher, <span class="keyword">null</span>);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetData4</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 注册多个监听器对象</span></span><br><span class="line">        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    <span class="keyword">if</span>(event.getType()==Event.EventType.NodeDataChanged) &#123;</span><br><span class="line">                        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">null</span>);</span><br><span class="line">        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    <span class="keyword">if</span>(event.getType()==Event.EventType.NodeDataChanged) &#123;</span><br><span class="line">                        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">null</span>);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看子节点-1"><a href="#查看子节点-1" class="headerlink" title="查看子节点"></a>查看子节点</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get<span class="constructor">Children(String <span class="params">path</span>, <span class="params">boolean</span> <span class="params">b</span>)</span></span><br><span class="line"></span><br><span class="line">get<span class="constructor">Children(String <span class="params">path</span>, Watcher <span class="params">w</span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKWatcherGetChild</span> </span>&#123;</span><br><span class="line">    String IP = <span class="string">&quot;192.168.60.130:2181&quot;</span>;</span><br><span class="line">    ZooKeeper zooKeeper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch connectedSemaphore = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 连接zookeeper客户端</span></span><br><span class="line">        zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">6000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接对象的参数!&quot;</span>);</span><br><span class="line">                <span class="comment">// 连接成功</span></span><br><span class="line">                <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                    connectedSemaphore.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        connectedSemaphore.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        zooKeeper.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetChild1</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// arg1:节点的路径</span></span><br><span class="line">        <span class="comment">// arg2:使用连接对象中的watcher</span></span><br><span class="line">        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetChild2</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// arg1:节点的路径</span></span><br><span class="line">        <span class="comment">// arg2:自定义watcher</span></span><br><span class="line">        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;自定义watcher&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetChild3</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 一次性</span></span><br><span class="line">        Watcher watcher = <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;自定义watcher&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    <span class="keyword">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">                        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, watcher);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetChild4</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 多个监视器对象</span></span><br><span class="line">        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    <span class="keyword">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">                        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    <span class="keyword">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">                        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用zookeeper作为配置中心"><a href="#使用zookeeper作为配置中心" class="headerlink" title="使用zookeeper作为配置中心"></a>使用zookeeper作为配置中心</h2><p>设计思路： </p><ol><li>连接zookeeper服务器 </li><li>读取zookeeper中的配置信息，注册watcher监听器，存入本地变量 3</li><li>. 当zookeeper中的配置信息发生变化时，通过watcher的回调方法捕获数据变化事件 4. 重新获取配置信息</li></ol><p>首先要在zookeeper中创建相关的节点 存放配置信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfigCenter</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  zk的连接串</span></span><br><span class="line">    String IP = <span class="string">&quot;192.168.52.131:2181&quot;</span>;</span><br><span class="line">    <span class="comment">//  计数器对象</span></span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 连接对象</span></span><br><span class="line">    <span class="keyword">static</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于本地化存储配置信息</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 捕获事件状态</span></span><br><span class="line">            <span class="keyword">if</span> (event.getType() == EventType.None) &#123;</span><br><span class="line">                <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == Event.KeeperState.Disconnected) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接断开!&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == Event.KeeperState.Expired) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接超时!&quot;</span>);</span><br><span class="line">                    <span class="comment">// 超时后服务器端已经将连接释放，需要重新连接服务器端</span></span><br><span class="line">                    zooKeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;192.168.60.130:2181&quot;</span>, <span class="number">6000</span>,</span><br><span class="line">                            <span class="keyword">new</span> ZKConnectionWatcher());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == Event.KeeperState.AuthFailed) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;验证失败!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当配置信息发生变化时</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType() == EventType.NodeDataChanged) &#123;</span><br><span class="line">                initValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyConfigCenter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接zookeeper服务器，读取配置信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建连接对象</span></span><br><span class="line">            zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">5000</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 阻塞线程，等待连接的创建成功</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="comment">// 读取配置信息</span></span><br><span class="line">            <span class="keyword">this</span>.url = <span class="keyword">new</span> String(zooKeeper.getData(<span class="string">&quot;/config/url&quot;</span>, <span class="keyword">true</span>, <span class="keyword">null</span>));</span><br><span class="line">            <span class="keyword">this</span>.username = <span class="keyword">new</span> String(zooKeeper.getData(<span class="string">&quot;/config/username&quot;</span>, <span class="keyword">true</span>, <span class="keyword">null</span>));</span><br><span class="line">            <span class="keyword">this</span>.password = <span class="keyword">new</span> String(zooKeeper.getData(<span class="string">&quot;/config/password&quot;</span>, <span class="keyword">true</span>, <span class="keyword">null</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyConfigCenter myConfigCenter = <span class="keyword">new</span> MyConfigCenter();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;url:&quot;</span>+myConfigCenter.getUrl());</span><br><span class="line">                System.out.println(<span class="string">&quot;username:&quot;</span>+myConfigCenter.getUsername());</span><br><span class="line">                System.out.println(<span class="string">&quot;password:&quot;</span>+myConfigCenter.getPassword());</span><br><span class="line">                System.out.println(<span class="string">&quot;########################################&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成分布式唯一ID"><a href="#生成分布式唯一ID" class="headerlink" title="生成分布式唯一ID"></a>生成分布式唯一ID</h2><p>设计思路： </p><p>1.连接zookeeper服务器 </p><p>2.指定路径生成临时有序节点 </p><p>3.取序列号及为分布式环境下的唯一ID</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GloballyUniqueId</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  zk的连接串</span></span><br><span class="line">    String IP = <span class="string">&quot;192.168.52.131:2181&quot;</span>;</span><br><span class="line">    <span class="comment">//  计数器对象</span></span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//  用户生成序号的节点</span></span><br><span class="line">    String defaultPath = <span class="string">&quot;/uniqueId&quot;</span>;</span><br><span class="line">    <span class="comment">//  连接对象</span></span><br><span class="line">    ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 捕获事件状态</span></span><br><span class="line">            <span class="keyword">if</span> (event.getType() == Event.EventType.None) &#123;</span><br><span class="line">                <span class="keyword">if</span> (event.getState() == KeeperState.SyncConnected) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == KeeperState.Disconnected) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接断开!&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == KeeperState.Expired) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接超时!&quot;</span>);</span><br><span class="line">                    <span class="comment">// 超时后服务器端已经将连接释放，需要重新连接服务器端</span></span><br><span class="line">                    zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">6000</span>,</span><br><span class="line">                            <span class="keyword">new</span> ZKConnectionWatcher());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == KeeperState.AuthFailed) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;验证失败!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GloballyUniqueId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//打开连接</span></span><br><span class="line">            zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">5000</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 阻塞线程，等待连接的创建成功</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成id的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUniqueId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String path = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建临时有序节点</span></span><br><span class="line">            path = zooKeeper.create(defaultPath, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// /uniqueId0000000001</span></span><br><span class="line">        <span class="keyword">return</span> path.substring(<span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GloballyUniqueId globallyUniqueId = <span class="keyword">new</span> GloballyUniqueId();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            String id = globallyUniqueId.getUniqueId();</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>设计思路：</p><p>1.每个客户端往/Locks下创建临时有序节点如/Locks/Lock_000000001 </p><p>2.客户端取得/Locks下子节点，并进行排序，判断排在最前面的是否为自己，如果自己的 锁节点在第一位，代表获取锁成功 </p><p>3.如果自己的锁节点不在第一位，则监听自己前一位的锁节点。例如，自己锁节点 Lock_000000001那么则监听锁几点Lock_000000002</p><p> 4.当前一位锁节点（Lock_000000001）对应的客户端完成执行完成，释放了锁，将会触发监听客户端（Lock_000000002）的逻辑</p><p> 5.监听客户端重新执行第2步逻辑，判断自己是否获得了锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  zk的连接串</span></span><br><span class="line">    String IP = <span class="string">&quot;192.168.60.130:2181&quot;</span>;</span><br><span class="line">    <span class="comment">//  计数器对象</span></span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//ZooKeeper配置信息</span></span><br><span class="line">    ZooKeeper zooKeeper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_ROOT_PATH = <span class="string">&quot;/Locks&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_NODE_NAME = <span class="string">&quot;Lock_&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String lockPath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开zookeeper连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">5000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getType() == Event.EventType.None) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;连接成功!&quot;</span>);</span><br><span class="line">                            countDownLatch.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建锁节点</span></span><br><span class="line">        createLock();</span><br><span class="line">        <span class="comment">//尝试获取锁</span></span><br><span class="line">        attemptLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建锁节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//判断Locks是否存在，不存在创建</span></span><br><span class="line">        Stat stat = zooKeeper.exists(LOCK_ROOT_PATH, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (stat == <span class="keyword">null</span>) &#123;</span><br><span class="line">            zooKeeper.create(LOCK_ROOT_PATH, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建临时有序节点</span></span><br><span class="line">        lockPath = zooKeeper.create(LOCK_ROOT_PATH + <span class="string">&quot;/&quot;</span> + LOCK_NODE_NAME, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        System.out.println(<span class="string">&quot;节点创建成功:&quot;</span> + lockPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监视器对象，监视上一个节点是否被删除</span></span><br><span class="line">    Watcher watcher = <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (event.getType() == Event.EventType.NodeDeleted) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attemptLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Locks节点下的所有子节点</span></span><br><span class="line">        List&lt;String&gt; list = zooKeeper.getChildren(LOCK_ROOT_PATH, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 对子节点进行排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="comment">// /Locks/Lock_000000001</span></span><br><span class="line">        <span class="keyword">int</span> index = list.indexOf(lockPath.substring(LOCK_ROOT_PATH.length() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取锁成功!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 上一个节点的路径</span></span><br><span class="line">            String path = list.get(index - <span class="number">1</span>);</span><br><span class="line">            Stat stat = zooKeeper.exists(LOCK_ROOT_PATH + <span class="string">&quot;/&quot;</span> + path, watcher);</span><br><span class="line">            <span class="keyword">if</span> (stat == <span class="keyword">null</span>) &#123;</span><br><span class="line">                attemptLock();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (watcher) &#123;</span><br><span class="line">                    watcher.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                attemptLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//删除临时有序节点</span></span><br><span class="line">            zooKeeper.delete(<span class="keyword">this</span>.lockPath,-<span class="number">1</span>);</span><br><span class="line">            zooKeeper.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;锁已经释放:&quot;</span>+<span class="keyword">this</span>.lockPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyLock myLock = <span class="keyword">new</span> MyLock();</span><br><span class="line">            myLock.createLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h1><p>事务需要跨多个分布式节点时，为了保证事务的ACID特性，需要选举出一个协调者来协调分布式各个节点的调度，基于这个思想衍生了多种一致性协议</p><h2 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h2><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210302193523354.png" alt="image-20210302193523354"></p><p>参与者提交后返回ack协调者再次提交 保证了一致性</p><p>中断事务：当有的参与者在任意阶段没有返回ack 参与者和协调者会回滚</p><p>二阶段提交存在的问题</p><ul><li>同步阻塞：二阶段提交过程中 所有参与事务的节点处于同步阻塞状态 无法进行其他操作</li><li>单点问题：一旦协调者出现单点故障 无法保证事务的一致性操作</li><li>脑裂导致数据不一致：如果分布式节点出现网络分区，某些参与者未收到commit提交命令或者选举了其他节点作为协调者。则出现部分参与者完成数据提交。未收到commit的命令的参与者则无法进行事务提交，整个分布式系统便出现了数据不一致性现象。</li></ul><h2 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h2><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210302194659679.png" alt="image-20210302194659679"></p><p>阶段一：CanCommit</p><ol><li>事务询问</li><li>各参与者向协调者反馈事务询问的相应</li></ol><p>阶段二：PreCommit</p><p>根据阶段一的反馈结果分为两种情况</p><ol><li>执行事务预提交<ul><li>发送预提交请求：协调者向所有参与者发送preCommit请求，进入prepared阶段</li><li>事务预提交：各参与者节点接受到preCommit请求后，执行事务操作</li><li>各参与者节点向协调者反馈事务执行</li></ul></li><li>中断事务：任意一个参与者节点反馈给协调者响应No时，或者在等待超时后，协调者还未收到参与者的反馈，就中断事务，中断事务分为两步<ul><li>协调者向各个参与者节点发送abort请求</li><li>参与者收到abort请求，或者等待超时时间后，中断事务</li></ul></li></ol><p>阶段三：doCommit</p><ol><li>执行提交</li><li>中断事务</li></ol><p>三阶段中引入了超时时间解决了同步阻塞问题</p><p>当协调者故障的时候 参与者如果长时间接收不到参与者请求之后 会自动提交事务，解决了单点故障问题</p><p>无法解决脑裂问题</p><h2 id="paxos算法"><a href="#paxos算法" class="headerlink" title="paxos算法"></a>paxos算法</h2><p>paxos算法:基于消息传递且具有高度容错性的一种算法，是目前公认的解决分布式一致性问题最有效的算法</p><p>解决问题:在分布式系统中，如果产生容机或者网络异常情况，快速的正确的在集群内部对某个数据的值达成一致，并且不管发生任何异常，都不会破坏整个系统的一致性;</p><p>半数原则:少数服从多数</p><p>paxos中的四个角色</p><ul><li>client:系统外部角色，请求发起者，不参与决策</li><li>proposer:提案提议者</li><li>acceptor:提案的表决者，即是否accept该提案，只有超过半数以上的acceptor接受了提案，该提案才被认为被””选定”</li><li>learners:提案的学习者，当提案被选定后，其同步执行提案，不参与决策 </li></ul><p>两个阶段</p><ul><li>prepare阶段：<ul><li>proposer提出一个提案，编号为N,发送给所有的acceptor。</li><li>每个表决者都保存自己的accept的最大提案编号maxN，当表决者收到prepare(N)请求时，会比较N与maxN的值，若N小于maxN,则提案已过时，拒绝prepare(N)请求。若N大于等于maxN，则接受提案，并将该表决者曾经接受过的编号最大的提案Proposal(myid,maxN,value)反馈给提议者:其中myid表示表决者acceptor的标识id，maxN表示接受过的最大提案编号maxN,value表示提案内容。若当前表决者未曾accept任何提议，会将proposal(myid,null,null)反馈给提议者。</li></ul></li><li>accept阶段：<ul><li>提议者proposal发出prepare(N),若收到超过半数表决者acceptor的反馈，proposal将真正的提案内容proposal(N,value)发送给所有表决者。</li><li>表决者acceptor接受提议者发送的proposal(N,value)提案后，会将自己曾经accept过的最大提案编号maxN和反馈过的prepare的最大编号比较，若N大于这两个编号，则当前表决者accept该提案，并反馈给提议者。否则拒绝该提议。</li><li>若提议者没有收到半数以上的表决者accept反馈，则重新进入prepare阶段，递增提案编号，重新提出prepare请求。若收到半数以上的accept，则其他未向提议者反馈的表决者称为learner，主动同步提议者的提案。</li></ul></li></ul><p>正常流程</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210302213055055.png" alt="image-20210302213055055"></p><p>单点故障，部分节点失败</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210302213116146.png" alt="image-20210302213116146"></p><ul><li>虽然有一个acceptor挂掉 但是满足半数原则 仍可以继续执行</li></ul><p>proposer失败</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210302213218757.png" alt="image-20210302213218757"></p><ul><li>会重新创建一个proposer 并且编号+1</li></ul><p>活锁问题</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210302213549531.png" alt="image-20210302213549531"></p><p>当proposer1请求1的时候 proposer2请求2  当proposer1再请求的时候 编号小于2 重新执行第一阶段 请求3 这样两个proposer互相改变请求条件 谁都不能提交提议</p><p>解决方法： 执行时间错开</p><h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>由于paxos算法实现起来较难，存在活锁和全序问题（无法保证两次最终提交的顺序)，所以zookeeper并没有使用paxos作为一致性协议，而是使用了ZAB协议。</p><p>ZAB (zookeeper atomic broadcast) :是一种支持崩溃恢复的原子广播协议，基于Fast paxos实现</p><p>ZooKeeper使用单一主进程Leader用于处理客户端所有事务请求,，即写请求。当服务器数据发生变更好，集群采用ZAB原子广播协议，以事务提交proposal的形式广播到所有的副本进程，每一个事务分配一个全局的递增的事务编号xid。</p><p>若客户端提交的请求为读请求时，则接受请求的节点直接根据自己保存的数据响应。若是写请求，且当前节点不是leader，那么该节点就会将请求转发给leader，leader会以提案的方式广播此写请求，如果超过半数的节点同意写请求，则该写请求就会提交。leader会通知所有的订阅者同步数据。</p><p>zab协议 的全称是 Zookeeper Atomic Broadcast （zookeeper原子广播）。 zookeeper 是通过 zab协议来保证分布式事务的最终一致性</p><p>基于zab协议，zookeeper集群中的<strong>角色</strong>主要有以下三类，如下表所示：</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210216193555107.png" alt="image-20210216193555107"></p><p>zab广播模式<strong>工作原理</strong>，通过类似两阶段提交协议的方式解决数据一致性：</p><p>一旦进入广播模式，集群中非leader节点接受到事务请求，首先会将事务请求转发给服务器，leader服务器为其生成对应的事务提案proposal,并发送给集群中其他节点，如果过半则事务提交;</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210216194010598.png" alt="image-20210216194010598"></p><ol><li><p>leader接受到消息后，消息通过全局唯一的64位自增事务id，zxid标识</p></li><li><p>leader发送给follower的提案是有序的，leader会创建一个FIFO队列，将提案顺序写入队列中发送给follower</p></li><li><p>follower接受到提案后，会比较提案zxid和本地事务日志最大的zxid，若提案zxid比本地事务id大，将提案记录到本地日志中，反馈ack给leader，否则拒绝</p></li><li><p>leader接收到过半ack后，leader向所有的follower发送commit，通知每个follower执行本地事务</p></li></ol><p><strong>zookeeper两种模式</strong></p><ul><li>恢复模式<ul><li>当服务启动或领导崩溃后，zk进入恢复状态，选举leader，leader选出后，将完成leader和其他机器的数据同步，当大多数server完成和leader的同步后，恢复模式结束</li></ul></li><li>广播模式<ul><li>一旦Leader已经和多数的Follower进行了状态同步后，进入广播模式。进入广播模式后，如果有新加入的服务器，会自动从leader中同步数据。leader在接收客户端请求后，会生成事务提案广播给其他机器，有超过半数以上的follower同意该提议后，再提交事务。</li><li>再zab的二阶段提交中，移除了事务中断的逻辑，follower要么ack要么放弃，leader无需等待所有的follower的ack(因为有半数原则的支持)</li></ul></li></ul><p><strong>zxid</strong></p><p>zxid是64位长度的Long类型，其中高32位表示纪元epoch，低32位表示事务标识xid。即zxid由两部分构成: epoch和xid</p><p>每个leader都会具有不同的epoch值，表示一个纪元，每一个新的选举开启时都会生成一个新的epoch，新的leader产生，会更新所有的zkSeiezookeeper的leader选举</p><p><strong>服务器状态</strong></p><p>looking：寻找leader状态。当服务器处于该状态时，它会认为当前集群中没有 leader，因此需要进入leader选举状态。</p><p>leading： 领导者状态。表明当前服务器角色是leader。</p><p>following： 跟随者状态。表明当前服务器角色是follower。</p><p>observing：观察者状态。表明当前服务器角色是observer。</p><p><strong>服务器启动时期的leader选举</strong></p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210303153439976.png" alt="image-20210303153439976"></p><p>如果leader挂掉，集群中其他follower会将状态改为looking重新进行选举</p>]]></content>
    
    
    <summary type="html">zooKeeper是一个经典的分布式数据—致性解决方案，致力于为分布式应用提供一个高性能、高可用，且具有严格顺序访问控制能力的分布式协调存储服务</summary>
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>解决chrome访问https网站出现您的连接不是私密的问题</title>
    <link href="http://example.com/2021/01/29/%E8%A7%A3%E5%86%B3chrome%E8%AE%BF%E9%97%AEhttps%E7%BD%91%E7%AB%99%E5%87%BA%E7%8E%B0%E6%82%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%98%AF%E7%A7%81%E5%AF%86%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/01/29/%E8%A7%A3%E5%86%B3chrome%E8%AE%BF%E9%97%AEhttps%E7%BD%91%E7%AB%99%E5%87%BA%E7%8E%B0%E6%82%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%98%AF%E7%A7%81%E5%AF%86%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-01-29T06:49:22.000Z</published>
    <updated>2021-02-03T15:00:53.508Z</updated>
    
    <content type="html"><![CDATA[<p>今天访问博客codebob111.github.io的时候chrome显示连接不是私密连接 无法访问</p><p><img src="%E8%A7%A3%E5%86%B3chrome%E8%AE%BF%E9%97%AEhttps%E7%BD%91%E7%AB%99%E5%87%BA%E7%8E%B0%E6%82%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%98%AF%E7%A7%81%E5%AF%86%E7%9A%84%E9%97%AE%E9%A2%98/image-20210129145042596.png" alt="image-20210129145042596"></p><p>在网上看了好多博客 最后终于找到了解决方法 开启使用安全dns并勾上第二个选项</p><p><img src="%E8%A7%A3%E5%86%B3chrome%E8%AE%BF%E9%97%AEhttps%E7%BD%91%E7%AB%99%E5%87%BA%E7%8E%B0%E6%82%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%98%AF%E7%A7%81%E5%AF%86%E7%9A%84%E9%97%AE%E9%A2%98/image-20210129145207994.png" alt="image-20210129145207994"></p>]]></content>
    
    
    <summary type="html">解决chrome访问https网站出现您的连接不是私密连接的问题</summary>
    
    
    
    <category term="bug" scheme="http://example.com/categories/bug/"/>
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>pig_note</title>
    <link href="http://example.com/2021/01/25/pig-note/"/>
    <id>http://example.com/2021/01/25/pig-note/</id>
    <published>2021-01-25T13:04:21.000Z</published>
    <updated>2021-02-03T13:50:25.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="getway"><a href="#getway" class="headerlink" title="getway"></a>getway</h1><h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><p>PigRequestGlobalFilter,对全部的微服务提供了安全过滤（这个后边会讲）和全局StripPrefix=1配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PigRequestGlobalFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 1. 清洗请求头中from 参数</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      因为部分内部feign调用 是没有token的,例如定时任务去调用upms的接口，所以需要在请求头中加了from in的标志</span></span><br><span class="line"><span class="comment">      ,upms看到这个from就放行了，但外部可能会人工恶意传入 所以网关要给清洗掉</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      ServerHttpRequest request = exchange.getRequest().mutate()</span><br><span class="line">            .headers(httpHeaders -&gt; httpHeaders.remove(SecurityConstants.FROM)).build();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 重写StripPrefix(截取前缀)=1 : 假如我们通过 Spring Cloud Gateway 访问/aaa/bbb/ccc/ddd的时候如果StripPrefix=2</span></span><br><span class="line">      <span class="comment">// 那么当网关服务向后转发请求时，会去掉/aaa/bbb 微服务收到的就是/ccc/ddd</span></span><br><span class="line">      <span class="comment">// 记录修改前的url</span></span><br><span class="line">      addOriginalRequestUrl(exchange, request.getURI());</span><br><span class="line">      String rawPath = request.getURI().getRawPath(); <span class="comment">// /auth/oauth/token</span></span><br><span class="line">      String newPath = <span class="string">&quot;/&quot;</span> + Arrays.stream(StringUtils.tokenizeToStringArray(rawPath, <span class="string">&quot;/&quot;</span>)).skip(<span class="number">1L</span>)</span><br><span class="line">            .collect(Collectors.joining(<span class="string">&quot;/&quot;</span>));  <span class="comment">// /oauth/token</span></span><br><span class="line">      ServerHttpRequest newRequest = request.mutate().path(newPath).build();</span><br><span class="line">      exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, newRequest.getURI());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> chain.filter(exchange.mutate().request(newRequest.mutate().build()).build());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网关降级"><a href="#网关降级" class="headerlink" title="网关降级"></a>网关降级</h2><p>以UMPS路由配置为例</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">locator:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="comment">#UPMS 模块</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pig-upms</span>      <span class="comment"># 唯一的服务ID</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://pig-upms</span> <span class="comment"># 注册中心的服务名称，实现负载均衡</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/admin/**</span>  <span class="comment">#所有业务的请求前缀</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hystrix</span>           <span class="comment">#断路器降级策略</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">            <span class="attr">fallbackUri:</span> <span class="string">&#x27;forward:/fallback&#x27;</span> <span class="comment"># 降级接口的地址</span></span><br></pre></td></tr></table></figure><p>Spring Cloud Gateway 会自动寻找配置Hystrix的Filter，这个功能是内置的，然后回调我们提供的fallbackUr</p><p>降级入口。这里的意思类似于SpringMVC 定义一个 @GetMapping(“/fallback”) 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouterFunctionConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HystrixFallbackHandler hystrixFallbackHandler;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ImageCodeHandler imageCodeHandler;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RouterFunction <span class="title">routerFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RouterFunctions.route(</span><br><span class="line">      RequestPredicates.path(<span class="string">&quot;/fallback&quot;</span>)</span><br><span class="line">        .and(RequestPredicates.accept(MediaType.TEXT_PLAIN)), hystrixFallbackHandler)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="auth"><a href="#auth" class="headerlink" title="auth"></a>auth</h1><p>Spring Security Oauth2 以redis的方式存储Token</p>]]></content>
    
    
    <summary type="html">学习pig项目过程中的记录和总结</summary>
    
    
    
    <category term="项目" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="心得" scheme="http://example.com/tags/%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-23T06:51:39.849Z</published>
    <updated>2021-03-12T23:20:46.281Z</updated>
    
    <content type="html"><![CDATA[<p>title: 面试题总结<br>date: 2021-01-23 14:51:39<br>tag: 面试<br>categories: 学习<br>description: 整理的高频面试题和知识点</p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p><strong>七层协议 五层协议 四层协议</strong> </p><p>应用层：通过应用进程之间的交互完成特定的网络应用</p><p><strong>运输层</strong>：为两台计算机之间进程的通信提供通用的数据传输服务</p><p>网络层：计算机网络中进行通讯的两个计算机之间的有很多数据链路和通讯子网，网络层负责找到合适的网间路由和链路节点，确保数据及时传输</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210123145701309.png" alt="image-20210123145701309"></p><p><strong>为什么需要三次握手</strong></p><p>三次握手的最主要目的是保证连接是双工的。为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次握手。</p><p><strong>第2次握手传回了ACK，为什么还要传回SYN？</strong></p><p>接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信</p><p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。 ACK(Acknowledgement)是应答消息</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭</p><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210123150815077.png" alt="image-20210123150815077"></p><p><strong>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</strong></p><p>这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK 和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了，但是你还可以给对方发送数据，也有这么种可能，你还有一些数据在传给对方的途中，所以你不能立马关闭连接,也即你可能还需要把在传输途中的数据给对方之后，又或者，你还有一些数据需要传输给对方后，（再关闭连接）再发送FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的。</p><p><strong>为什么 TIME_WAIT 状态还需要等 2MSL（Maximum Segment Lifetime）后才能返回到 CLOSED 状态？</strong></p><p>因为我们必须要假想网络是不可靠的，你无法保证你最后发送的 ACK 报文会一定被对方收到，因此对方处于 LAST_ACK 状态下的 SOCKET 可能会因为超时未收到 ACK 报文，而重发 FIN 报文，所以这个 TIME_WAIT 状态的作用就是用来重发可能丢失的 ACK 报文</p><p><strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong></p><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h2 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a>tcp和udp的区别</h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210124134700276.png" alt="image-20210124134700276"></p><h2 id="tcp协议如何保证可靠传输"><a href="#tcp协议如何保证可靠传输" class="headerlink" title="tcp协议如何保证可靠传输"></a>tcp协议如何保证可靠传输</h2><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块并为每一个包进行编号，接收方对数据包进行排序，丢弃重复的数据，把有序数据传送给应用层。</li><li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP发送端不允许发送超过接收端缓冲区大小的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 利用滑动窗口实现流量控制。</li><li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li><li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h2 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h2><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p><h3 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C?id=%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85arq%E5%8D%8F%E8%AE%AE">停止等待ARQ协议</a></h3><ul><li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</li><li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li></ul><p><strong>优点：</strong> 简单</p><p><strong>缺点：</strong> 信道利用率低，等待时间长</p><p><strong>1) 无差错情况:</strong></p><p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p><p><strong>2) 出现差错情况（超时重传）:</strong></p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p><p><strong>3) 确认丢失和确认迟到</strong></p><ul><li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li><li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li></ul><h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C?id=%E8%BF%9E%E7%BB%ADarq%E5%8D%8F%E8%AE%AE">连续ARQ协议</a></h3><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p><p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p><p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p><a href="https://blog.csdn.net/qq_41431406/article/details/97926927">https://blog.csdn.net/qq_41431406/article/details/97926927</a></p><h2 id="从输入url到页面加载完成发生了什么"><a href="#从输入url到页面加载完成发生了什么" class="headerlink" title="从输入url到页面加载完成发生了什么"></a>从输入url到页面加载完成发生了什么</h2><p><a href="https://www.cnblogs.com/liutianzeng/p/10456865.html">https://www.cnblogs.com/liutianzeng/p/10456865.html</a></p><h2 id="同源策略和跨域"><a href="#同源策略和跨域" class="headerlink" title="同源策略和跨域"></a>同源策略和跨域</h2><p>同源策略：如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的<strong>源</strong></p><p>同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源</p><p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p><p>跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制。</p><p>跨域解决方法</p><p>例如<a href="http://www.123.com/index.html%E9%9C%80%E8%A6%81%E8%B0%83%E7%94%A8www.456.com/server.php%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%86%99%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3www.123.com/server.php%EF%BC%8C%E7%94%B1%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%E5%9C%A8%E5%90%8E%E7%AB%AF%E5%8E%BB%E8%B0%83%E7%94%A8www.456.com/server.php%E5%B9%B6%E6%8B%BF%E5%88%B0%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E8%BF%94%E5%9B%9E%E7%BB%99index.html%EF%BC%8C%E8%BF%99%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%90%86%E7%9A%84%E6%A8%A1%E5%BC%8F%E3%80%82%E7%9B%B8%E5%BD%93%E4%BA%8E%E7%BB%95%E8%BF%87%E4%BA%86%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%EF%BC%8C%E8%87%AA%E7%84%B6%E5%B0%B1%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E3%80%82">www.123.com/index.html需要调用www.456.com/server.php，可以写一个接口www.123.com/server.php，由这个接口在后端去调用www.456.com/server.php并拿到返回值，然后再返回给index.html，这就是一个代理的模式。相当于绕过了浏览器端，自然就不存在跨域问题。</a></p><h2 id="长连接和短链接"><a href="#长连接和短链接" class="headerlink" title="长连接和短链接"></a>长连接和短链接</h2><p>所谓，短连接说的就是 server 端 与 client 端建⽴连接之后，读写完成之后就关闭掉连接，如果下⼀次再要互相发送消息，就要重新连接。短连接的优点很明显，就是管理和实现都比较简单，缺点也很明显，每⼀次的读写都要建⽴连接必然会带来⼤量⽹络资源的消耗，并且连接的建⽴也需要耗费时间。<br>⻓连接说的就是 client 向 server 双⽅建⽴连接之后，即使 client 与 server 完成⼀次读写，它们之间的连接并不会主动关闭，后续的读写操作会继续使⽤这个连接。⻓连接的可以省去较多的 TCP 建⽴和关闭的操作，降低对⽹络资源的依赖，节约时间。对于频繁请求资源的客户来说，⾮常适⽤⻓连接。</p><h2 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a>Session和Cookie</h2><p><a href="https://blog.csdn.net/qq_28296925/article/details/80921585">https://blog.csdn.net/qq_28296925/article/details/80921585</a></p><h2 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h2><p>URI是：协议+主机（不含端口）+具体路径（不一定含文件）；URL是：协议+主机（默认是80，或是别的端口）+具体文件路径（还必须是对应到路径下面的具体文件名称）。所以URI是粗框架，URL是详细定位。。。比如URI：<a href="http://www.123.com/123/%EF%BC%8C%E8%AF%A5%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%8F%AF%E8%83%BD%E6%9C%89index.html%E5%92%8Cindex.htm%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%89%E3%80%82%E3%80%82%E3%80%82%E6%AF%94%E5%A6%82URL:http://www.123.com/123/index.html%EF%BC%88%E5%94%AF%E4%B8%80%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%89">http://www.123.com/123/，该目录下可能有index.html和index.htm（两个文件）。。。比如URL:http://www.123.com/123/index.html（唯一的文件）</a></p><h2 id="Http和Https的区别"><a href="#Http和Https的区别" class="headerlink" title="Http和Https的区别"></a>Http和Https的区别</h2><ol><li><p><strong>端口</strong> ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p></li><li><p>安全性和资源消耗：</p><p>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p><ul><li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li><li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li></ul></li></ol><h2 id="带宽和吞吐量"><a href="#带宽和吞吐量" class="headerlink" title="带宽和吞吐量"></a>带宽和吞吐量</h2><p>两者的单位都是Mbps.当我们讨论通信链路的带宽时，一般是指链路上每秒所能传送的<a href="http://baike.baidu.com/view/3021024.htm">比特数</a>，它取决于链路时钟速率和信道编码在计算机网络中又称为线速。我们可以说<a href="http://baike.baidu.com/view/848.htm">以太网</a>的带宽是10Mbps。但是，我们需要区分链路上的可用带宽（带宽）与实际链路中每秒所能传送的比特数（吞吐量）。我们倾向于用“吞吐量”一次来表示一个系统的测试性能。这样，因为实现受各种低效率因素的影响，所以由一段带宽为10Mbps的链路连接的一对节点可能只达到2Mbps的吞吐量。这样就意味着，一个主机上的应用能够以2Mbps的速度向另外的一个主机发送数据。</p><h2 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h2><p>A类地址(1~126)：网络号占前8位，以0开头，主机号占后24位。</p><p>B类地址(128~191)：网络号占前16位，以10开头，主机号占后16位。</p><p>C类地址(192~223)：网络号占前24位，以110开头，主机号占后8位。</p><p>D类地址(224~239)：以1110开头，保留位多播地址。</p><p>E类地址(240~255)：以1111开头，保留位今后使用。</p><h2 id="客户端不断进行请求链接会怎样？DDos-Distributed-Denial-of-Service-攻击？"><a href="#客户端不断进行请求链接会怎样？DDos-Distributed-Denial-of-Service-攻击？" class="headerlink" title="客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？"></a>客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？</h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210126124355659.png" alt="image-20210126124355659"></p><h2 id="Get与POST的区别"><a href="#Get与POST的区别" class="headerlink" title="Get与POST的区别"></a>Get与POST的区别</h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210126124446349.png" alt="image-20210126124446349"></p><h2 id="网络层的ARP协议工作原理"><a href="#网络层的ARP协议工作原理" class="headerlink" title="网络层的ARP协议工作原理"></a>网络层的ARP协议工作原理</h2><p>网络层的ARP协议完成了IP地址与物理地址的映射。首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p><h2 id="物理层的三个基本问题"><a href="#物理层的三个基本问题" class="headerlink" title="物理层的三个基本问题"></a>物理层的三个基本问题</h2><p><strong>封装成帧</strong>：在一段数据前后添加首部和尾部，其中包含控制信息 还起到帧定界的功能</p><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210127140125472.png" alt="image-20210127140125472"></p><ul><li>mtu：最大传送单元</li></ul><p><strong>透明传输</strong>：如果数据中出现像SOH，EOT这样的帧定界控制字符，使用转义符进行转移，接收端收到数据后再去掉转义符</p><p><strong>差错检测</strong>：<strong>使用循环冗余检测传输过程中是否有差错</strong></p><h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="netty是什么"><a href="#netty是什么" class="headerlink" title="netty是什么?"></a>netty是什么?</h2><ol><li>Netty 是⼀个 基于 NIO 的 client-server(客户端服务器)框架，使⽤它可以快速简单地开发⽹<br>络应⽤程序。</li><li>它极⼤地简化并优化了 TCP 和 UDP 套接字服务器等⽹络编程,并且性能以及安全性等很多⽅⾯</li></ol><p>-甚⾄都要更好。<br>3. ⽀持多种协议 如 FTP，SMTP，HTTP 以及各种⼆进制和基于⽂本的传统协议。</p><h2 id="netty应用场景"><a href="#netty应用场景" class="headerlink" title="netty应用场景"></a>netty应用场景</h2><p>Netty 主要⽤来做⽹络通信 :</p><ol><li>作为 RPC 框架的⽹络通信⼯具 ： 我们在分布式系统中，不同服务节点之间经常需要相互调<br>⽤，这个时候就需要 RPC 框架了。不同服务节点之间的通信是如何做的呢？可以使⽤ Netty 来<br>做。⽐如我调⽤另外⼀个节点的⽅法的话，⾄少是要让对⽅知道我调⽤的是哪个类中的哪个⽅法<br>以及相关参数吧！</li><li>实现⼀个⾃⼰的 HTTP 服务器 ：通过 Netty 我们可以⾃⼰实现⼀个简单的 HTTP 服务器，这个<br>⼤家应该不陌⽣。说到 HTTP 服务器的话，作为 Java 后端开发，我们⼀般使⽤ Tomcat 比较<br>多。⼀个最基本的 HTTP 服务器可要以处理常⻅的 HTTP Method 的请求，⽐如 POST 请求、GET<br>请求等等。</li><li>实现⼀个即时通讯系统 ： 使⽤ Netty 我们可以实现⼀个可以聊天类似微信的即时通讯系统</li><li><strong>实现消息推送系统</strong> ：市⾯上有很多消息推送系统都是基于 Netty 来做的。</li></ol><h2 id="netty的核心组件"><a href="#netty的核心组件" class="headerlink" title="netty的核心组件"></a>netty的核心组件</h2><p><strong>Channel</strong></p><p>Channel 接⼝是 Netty 对⽹络操作的抽象类，它除了包括基本的 I/O 操作，如bind() 、 connect() 、 read() 、 write() 等。</p><p>比较常⽤的 Channel 接⼝实现类是 NioServerSocketChannel （服务端）和NioSocketChannel （客户端）</p><p><strong>EventLoop</strong></p><p>EventLoop 的主要作⽤是负责监听⽹络事件并调⽤事件处理器进⾏相关 I/O 操作的处理。</p><p>那 Channel 和 EventLoop 直接有啥联系呢？<br>EventLoop 负责处理注册到其上的 Channel的 I/O 操作，两者配合参与 I/O 操作。</p><p><strong>ChannelFuture</strong></p><p>Netty 是异步⾮阻塞的，所有的 I/O 操作都为异步的。<br>因此，我们不能⽴刻知道操作是否执⾏成功，但是，你可以通过 ChannelFuture 接⼝的addListener() ⽅法注册⼀个ChannelFutureListener ，当操作执⾏成功或者失败时，监听就会⾃动触发返回结果。</p><p>并且，你还可以通过 ChannelFuture 的 channel() ⽅法获取关联的 Channel</p><p>另外，我们还可以通过 ChannelFuture 接⼝的 sync() ⽅法让异步的操作变成同步的。</p><p><strong>ChannelHandler 和 ChannelPipeline</strong></p><p>ChannelHandler 是消息的具体处理器。他负责处理读写操作、客户端连接等事情。<br>ChannelPipeline 为 ChannelHandler 的链，提供了⼀个容器并定义了⽤于沿着链传播⼊站和出站事件流的 API 。当 Channel 被创建时，它会被⾃动地分配到它专属的 ChannelPipeline 。</p><h2 id="Netty-的零拷贝实现？"><a href="#Netty-的零拷贝实现？" class="headerlink" title="Netty 的零拷贝实现？"></a>Netty 的零拷贝实现？</h2><p>在 OS 层⾯上的 Zero-copy 通常指避免在 ⽤户态(User-space) 与 内核态(Kernel-space)之间来回拷⻉数据。⽽在 Netty 层⾯ ，零拷⻉主要体现在对于数据操作的优化。<br>Netty 中的零拷⻉体现在以下⼏个⽅⾯</p><ol><li>使⽤ Netty 提供的 CompositeByteBuf 类, 可以将多个 ByteBuf 合并为⼀个逻辑上的<br>ByteBuf , 避免了各个 ByteBuf 之间的拷⻉。</li><li>ByteBuf ⽀持 slice 操作, 因此可以将 ByteBuf 分解为多个共享同⼀个存储区域的<br>ByteBuf , 避免了内存的拷⻉。</li><li>通过 FileRegion 包装的 FileChannel.tranferTo 实现⽂件传输, 可以直接将⽂件缓冲<br>区的数据发送到⽬标 Channel , 避免了通过传统循环 write的⽅式导致的内存拷⻉问题.</li></ol><h2 id="netty心跳机制"><a href="#netty心跳机制" class="headerlink" title="netty心跳机制"></a>netty心跳机制</h2><p>⼼跳机制的⼯作原理是: 在 client 与 server 之间在⼀定时间内没有数据交互时, 即处于 idle 状态时, 客户端或服务器就会发送⼀个特殊的数据包给对⽅, 当接收⽅收到这个数据报⽂后, 也⽴即发送⼀个特殊的数据报⽂, 回应发送⽅, 此即⼀个 PING-PONG 交互。所以, 当某⼀端收到⼼跳消息后, 就知道了对⽅仍然在线, 这就确保 TCP 连接的有效性.</p><p>TCP 实际上⾃带的就有⻓连接选项，本身是也有⼼跳包机制，也就是 TCP 的选项： SO_KEEPALIVE 。但是，TCP 协议层⾯的⻓连接灵活性不够。所以，⼀般情况下我们都是在应⽤层协议上实现⾃定义⼼跳机制的，也就是在 Netty 层⾯通过编码实现。通过 Netty 实现⼼跳机制的话，核⼼类是IdleStateHandler 。</p><h2 id="Netty-支持哪些心跳类型设置？"><a href="#Netty-支持哪些心跳类型设置？" class="headerlink" title="Netty 支持哪些心跳类型设置？"></a>Netty 支持哪些心跳类型设置？</h2><p>readerIdleTime：为读超时时间（即测试端一定时间内未接受到被测试端消息）。</p><p>writerIdleTime：为写超时时间（即测试端一定时间内向被测试端发送消息）。</p><p>allIdleTime：所有类型的超时时间。</p><h2 id="TCP-粘包-拆包的原因及解决方法？"><a href="#TCP-粘包-拆包的原因及解决方法？" class="headerlink" title="TCP 粘包/拆包的原因及解决方法？"></a><strong>TCP 粘包/拆包的原因及解决方法？</strong></h2><ul><li>TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</li><li>TCP粘包/分包的原因：<ul><li>应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；</li><li>进行MSS大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包</li><li>以太网帧的payload（净荷）大于MTU（1500字节）进行ip分片。</li></ul></li><li>解决方法<ul><li>消息定长：FixedLengthFrameDecoder类</li><li>包尾增加特殊字符分割：行分隔符类：LineBasedFrameDecoder或自定义分隔符类 ：DelimiterBasedFrameDecoder</li><li>将消息分为消息头和消息体，消息头中带有长度信息：LengthFieldBasedFrameDecoder类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</li></ul></li></ul><h2 id="Netty-和-Tomcat-的区别"><a href="#Netty-和-Tomcat-的区别" class="headerlink" title="Netty 和 Tomcat 的区别"></a>Netty 和 Tomcat 的区别</h2><ul><li>作用不同：Tomcat 是 Servlet 容器，可以视为 Web 服务器，而 Netty 是异步事件驱动的网络应用程序框架和工具用于简化网络编程，例如TCP和UDP套接字服务器。</li><li>协议不同：Tomcat 是基于 http 协议的 Web 服务器，而 Netty 能通过编程自定义各种协议，因为 Netty 本身自己能编码/解码字节流，所有 Netty 可以实现，HTTP 服务器、FTP 服务器、UDP 服务器、RPC 服务器、WebSocket 服务器、Redis 的 Proxy 服务器、MySQL 的 Proxy 服务器等等。</li></ul><h2 id="Netty的线程模型？"><a href="#Netty的线程模型？" class="headerlink" title="Netty的线程模型？"></a><strong>Netty的线程模型？</strong></h2><p>Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件，由对应的Handler处理。</p><h2 id="同步与异步、阻塞与非阻塞的区别？"><a href="#同步与异步、阻塞与非阻塞的区别？" class="headerlink" title="同步与异步、阻塞与非阻塞的区别？"></a>同步与异步、阻塞与非阻塞的区别？</h2><p>同步：发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。例如普通B/S模式（同步）：提交请求-&gt;等待服务器处理-&gt;处理完毕返回 这个期间客户端浏览器不能干任何事。</p><p>异步：当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。例如 ajax请求（异步）: 请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕</p><p>阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回,它还会抢占cpu去执行其他逻辑，也会主动检测io是否准备好。</p><p>非阻塞：指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p><h2 id="select、poll、epoll之间的区别"><a href="#select、poll、epoll之间的区别" class="headerlink" title="select、poll、epoll之间的区别"></a>select、poll、epoll之间的区别</h2><p>(1)select==&gt;时间复杂度O(n)</p><p>它仅仅知道了，有I/O事件发生了，却并不知道是哪几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</p><p>(2)poll==&gt;时间复杂度O(n)</p><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，原因是它是基于链表来存储的.</p><p>(3)epoll==&gt;时间复杂度O(1)</p><p><strong>epoll可以理解为event poll</strong>，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。<strong>（复杂度降低到了O(1)）</strong></p><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。<strong>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。 </p><h2 id="netty执行流程"><a href="#netty执行流程" class="headerlink" title="netty执行流程"></a>netty执行流程</h2><ol><li>创建ServerBootStrap实例</li><li>设置并绑定Reactor线程池：EventLoopGroup，EventLoop就是处理所有注册到本线程的Selector上面的Channel</li><li>设置并绑定服务端的channel</li><li>创建处理网络事件的ChannelPipeline和handler，网络事件以流的形式在其中流转，handler完成多数的功能定制：比如编解码 SSl安全认证</li><li>绑定并启动监听端口</li><li>当轮训到准备就绪的channel后，由Reactor线程：NioEventLoop执行pipline中的方法，最终调度并执行channelHandler</li></ol><h2 id="为什么要⽤-Netty-呢"><a href="#为什么要⽤-Netty-呢" class="headerlink" title="为什么要⽤ Netty 呢"></a>为什么要⽤ Netty 呢</h2><p>因为 Netty 具有下⾯这些优点，并且相⽐于直接使⽤ JDK ⾃带的 NIO 相关的 API 来说更加易⽤。</p><ul><li>统⼀的 API，⽀持多种传输类型，阻塞和⾮阻塞的。</li><li>简单⽽强⼤的线程模型。</li><li>⾃带编解码器解决 TCP 粘包/拆包问题。</li><li>⾃带各种协议栈。</li><li>真正的⽆连接数据包套接字⽀持。</li><li>⽐直接使⽤ Java 核⼼ API 有更⾼的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制。</li><li>安全性不错，有完整的 SSL/TLS 以及 StartTLS ⽀持。</li><li>社区活跃</li><li>成熟稳定，经历了⼤型项⽬的使⽤和考验，⽽且很多开源项⽬都使⽤到了 Netty， ⽐如我们经常接触的 Dubbo、RocketMQ 等等。</li></ul><h2 id="Bootstrap-和-ServerBootstrap-了解么？"><a href="#Bootstrap-和-ServerBootstrap-了解么？" class="headerlink" title="Bootstrap 和 ServerBootstrap 了解么？"></a>Bootstrap 和 ServerBootstrap 了解么？</h2><ol><li>Bootstrap 通常使⽤ connet() ⽅法连接到远程的主机和端⼝，作为⼀个 Netty TCP 协议通信中的客户端。另外， Bootstrap 也可以通过 bind() ⽅法绑定本地的⼀个端⼝，作为UDP 协议通信中的⼀端。</li><li>ServerBootstrap 通常使⽤ bind() ⽅法绑定本地的端⼝上，然后等待客户端的连接。</li><li>Bootstrap 只需要配置⼀个线程组— EventLoopGroup ,⽽ ServerBootstrap 需要配置两个线程组— EventLoopGroup ，⼀个⽤于接收连接，⼀个⽤于具体的事件处理。</li></ol><h2 id="Netty-服务端和客户端的启动过程"><a href="#Netty-服务端和客户端的启动过程" class="headerlink" title="Netty 服务端和客户端的启动过程"></a><strong>Netty 服务端和客户端的启动过程</strong></h2><p><strong>服务端</strong></p><ul><li>创建两个NioEventLoopGroup对象实例：一个处理连接请求 一个处理读写操作</li><li>创建一个服务端启动引导类/辅助类</li><li>通过group方法给引导类配置两大线程组，确定了线程模型</li><li>通过channel方法给引导类指定IO模型为NIO(NIOSeverSocketChannel)</li></ul><p><strong>客户端</strong></p><ul><li>创建一个NioEventLoopGroup对象实例</li><li>创建服务端启动的引导类</li><li>通过group方法给引导类配置线程组</li><li>通过channel方法给引导类指定IO模型为NIO(NIOSocketChannel)</li><li>通过childHandler()给引导类创建一个ChannelInitializer然后指定了客户端消息的业务处理逻辑对象</li><li>调用BootStrap的Connect方法进行连接</li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><ol><li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong></li><li><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> </li><li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li></ol><h2 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h2><p>在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成</p><p>这些系统调用按功能大致可分为如下几类：</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li><li>文件管理。完成文件的读、写、创建及删除等功能。</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li>进程通信。完成进程之间的消息传递或信号传递等功能。</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。 </li></ul><h2 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h2><p> 线程是进程划分成的更小的运行单位，一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的<strong>程序计数器</strong>、**虚拟机栈 和 **本地方法栈。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><p><a href="https://www.jianshu.com/p/c1015f5ffa74">https://www.jianshu.com/p/c1015f5ffa74</a></p><h2 id="线程间同步方式"><a href="#线程间同步方式" class="headerlink" title="线程间同步方式"></a>线程间同步方式</h2><ol><li>**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li><li><strong>信号量(Semphares)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li><li><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操</li></ol><h2 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h2><ul><li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li><li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li><li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li></ul><h2 id="内存管理主要是做什么？"><a href="#内存管理主要是做什么？" class="headerlink" title="内存管理主要是做什么？"></a><strong>内存管理主要是做什么？</strong></h2><p>负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），地址转换也就是将逻辑地址转换成相应的物理地址</p><p><strong>操作系统的内存管理机制了解吗？内存管理有哪几种方式?</strong></p><p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 <strong>块式管理</strong> 。同样地，非连续分配管理方式允许一个程序使用的内存是离散的，常见的如<strong>页式管理</strong> 和 <strong>段式管理</strong>。</p><ol><li><strong>块式管理</strong> ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</li><li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li><li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li><li><strong>段页式管理机制</strong>：结合了段式管理和页式管理的优点。段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 段与段之间以及段的内部的内存都是离散的。</li></ol><h2 id="介绍下页表管理机制中的快表和多级页表"><a href="#介绍下页表管理机制中的快表和多级页表" class="headerlink" title="介绍下页表管理机制中的快表和多级页表"></a>介绍下页表管理机制中的快表和多级页表</h2><p>在分页内存管理中，很重要的两点是：</p><ol><li>虚拟地址到物理地址的转换要快。</li><li>解决虚拟地址空间大，页表也会很大的问题。</li></ol><p><strong>块表</strong></p><p>为了解决虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p><p>使用快表之后的地址转换流程是这样的：</p><ol><li>根据虚拟地址中的页号查快表；</li><li>如果该页在快表中，直接从快表中读取相应的物理地址；</li><li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li><li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li></ol><p>看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。</p><p><strong>多级页表</strong></p><p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，具体可以查看下面这篇文章</p><ul><li>多级页表如何节约内存：<a href="https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html">https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html</a></li></ul><h2 id="分页机制和分段机制有哪些共同点和区别"><a href="#分页机制和分段机制有哪些共同点和区别" class="headerlink" title="分页机制和分段机制有哪些共同点和区别"></a><strong>分页机制和分段机制有哪些共同点和区别</strong></h2><ol><li>共同点<ul><li>分页机制和分段机制都是为了提高内存利用率，较少内存碎片。</li><li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li></ul></li><li>区别<ul><li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li><li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li></ul></li></ol><h2 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a><strong>逻辑地址和物理地址</strong></h2><p>我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中的地址，更具体一点来说就是内存地址寄存器中的地址。</p><h2 id="CPU-寻址了解吗"><a href="#CPU-寻址了解吗" class="headerlink" title="CPU 寻址了解吗?"></a>CPU 寻址了解吗?</h2><p>现代处理器使用的是一种称为 <strong>虚拟寻址(Virtual Addressing)</strong> 的寻址方式。虚拟寻址就是CPU 利用他的内存管理单元将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</p><h2 id="为什么需要虚拟地址空间"><a href="#为什么需要虚拟地址空间" class="headerlink" title="为什么需要虚拟地址空间?"></a>为什么需要虚拟地址空间?</h2><p>没有虚拟地址空间的时候，<strong>程序直接访问和操作的是物理内存</strong> 。但是这样有什么问题呢？</p><ol><li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。</li><li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li></ol><p>通过虚拟地址访问内存有以下优势：</p><ul><li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的内存缓冲区。</li><li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li><li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li></ul><h2 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a><strong>什么是虚拟内存</strong></h2><p> <strong>虚拟内存</strong> 可以让程序拥有超过系统物理内存大小的可用内存空间。另外，<strong>为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</strong>。这样会更加有效地管理内存并减少出错。</p><p>定义：具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充得一种存储器系统。其逻辑容量由内存之和和外存之和决定。</p><p>与传统存储器比较虚拟存储器有以下三个主要特征：</p><ul><li>多次性，是指无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行。</li><li>对换性，是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出。</li><li>虚拟性，是指从逻辑上扩充内存的容量，使用户所看到的内存容量，远大于实际的内存容量。</li></ul><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。</p><p>局部性原理表现在以下两个方面：</p><ol><li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li><li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li></ol><p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p><h2 id="虚拟内存技术的实现"><a href="#虚拟内存技术的实现" class="headerlink" title="虚拟内存技术的实现"></a><strong>虚拟内存技术的实现</strong></h2><p><strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</strong> 虚拟内存的实现有以下三种方式：</p><ol><li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li><li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li><li><strong>请求段页式存储管理</strong></li></ol><h2 id="面置换算法的作用-常见的页面置换算法有哪些"><a href="#面置换算法的作用-常见的页面置换算法有哪些" class="headerlink" title="面置换算法的作用?常见的页面置换算法有哪些?"></a><strong>面置换算法的作用?常见的页面置换算法有哪些?</strong></h2><p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。</p><p><strong>缺页中断</strong> 就是要访问的<strong>页</strong>不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p><p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法</p><ul><li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li><li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li><li><strong>LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li><li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</li></ul><h2 id="中断和轮询的特点"><a href="#中断和轮询的特点" class="headerlink" title="中断和轮询的特点"></a>中断和轮询的特点</h2><p>​    对I/O设备的程序轮询的方式，是早期的计算机系统对I/O设备的一种管理方式。它定时对各种设备轮流询问一遍有无处理要求。轮流询问之后，有要求的就加以处理。在处理I/O设备的要求之后，处理机返回继续工作。尽管轮询需要时间，但轮询要比I/O设备的速度要快得多，所以一般不会发生不能及时处理的问题。当然，再快的处理机，能处理的输入输出设备的数量也是有一定限度的。而且，程序轮询毕竟占据了CPU相当一部分处理时间，因此程序轮询是一种效率较低的方式，现代计算机系统中已很少应用。<br>　　轮询效率低，等待时间很长，CPU利用率不高；中断容易遗漏一些问题，CPU利用率高。</p><h2 id="什么是临界区、如何解决冲突"><a href="#什么是临界区、如何解决冲突" class="headerlink" title="什么是临界区、如何解决冲突"></a>什么是临界区、如何解决冲突</h2><p>​    每个进程中访问临界资源的那段程序称为临界区，每次只准许一个进程进入临界区。如已有进程进入自己的临界区，则其他试图进入临界区的进程必须等待。进入临界区的进程要在有限时间内退出，以便其他进程能及时进入自己的临界区。如果不能进入自己的临界区，就应该让出CPU，避免进程出现忙等等现象。</p><h2 id="为什么进程上下文切换比线程上下文切换代价高？"><a href="#为什么进程上下文切换比线程上下文切换代价高？" class="headerlink" title="为什么进程上下文切换比线程上下文切换代价高？"></a><strong>为什么进程上下文切换比线程上下文切换代价高？</strong></h2><p>进程切换分两步：</p><p>1.切换页目录以使用新的地址空间</p><p>2.切换内核栈和硬件上下文</p><p>对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。</p><p>切换的性能消耗：</p><p>1、线程上下文切换和进程上下问切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。</p><p>2、另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor’s Translation Lookaside Buffer (TLB)）</p><h2 id="用户态和核心态-内核态）之间的区别是什么呢？"><a href="#用户态和核心态-内核态）之间的区别是什么呢？" class="headerlink" title="用户态和核心态(内核态）之间的区别是什么呢？"></a><strong>用户态和核心态(内核态）之间的区别是什么呢？</strong></h2><p>​    <strong>权限不一样。</strong></p><ul><li><strong>用户态的进程能存取它们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据）</strong>。</li><li><strong>核心态下的进程能够存取内核和用户地址的某些机器指令是特权指令，在用户态下执行特权指令会引起错误。</strong></li></ul><h2 id="守护、僵尸、孤儿进程的概念"><a href="#守护、僵尸、孤儿进程的概念" class="headerlink" title="守护、僵尸、孤儿进程的概念"></a>守护、僵尸、孤儿进程的概念</h2><ul><li><strong>守护进程</strong>：运行在后台的一种特殊进程，<strong>独立于控制终端并周期性地执行某些任务</strong>。</li><li><strong>僵尸进程</strong>：一个进程 fork 子进程，子进程退出，而父进程没有wait/waitpid子进程，那么<strong>子进程的进程描述符仍保存在系统中</strong>，这样的进程称为僵尸进程。</li><li><strong>孤儿进程</strong>：一个<strong>父进程退出，而它的一个或多个子进程还在运行</strong>，这些子进程称为孤儿进程。（孤儿进程将由 init 进程收养并对它们完成状态收集工作）</li></ul><h2 id="内存管理有哪几种方式-块式、页式、段式、段页式"><a href="#内存管理有哪几种方式-块式、页式、段式、段页式" class="headerlink" title="内存管理有哪几种方式(块式、页式、段式、段页式)."></a><strong>内存管理有哪几种方式(块式、页式、段式、段页式).</strong></h2><p>​    内存管理有块式管理，页式管理，段式和段页式管理。现在常用段页式管理。</p><p>​    块式管理：把主存分为一大块、一大块的，当所需的程序片断不在主存时就分配一块主存空间，把程序片断load入主存，就算所需的程序片度只有几个字节也只能把这一块分配给它。这样会造成很大的浪费，平均浪费了50％的内存空间，但是易于管理。</p><p>​    页式管理：把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，显然这种方法的空间利用率要比块式管理高很多。</p><p>​    段式管理：把主存分为一段一段的，每一段的空间又要比一页一页的空间小很多，这种方法在空间利用率上又比页式管理高很多，但是也有另外一个缺点。一个程序片断可能会被分为几十段，这样很多时间就会被浪费在计算每一段的物理地址上。</p><p>​    段页式管理：结合了段式管理和页式管理的优点。将程序分成若干段，每个段分成若干页。段页式管理每取一数据，要访问3次内存。</p><h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="数据库三大范式是什么"><a href="#数据库三大范式是什么" class="headerlink" title="数据库三大范式是什么"></a>数据库三大范式是什么</h2><p>第一范式：每个列都不可以再拆分。</p><p>第二范式：在第一范式的基础上，属性完全依赖于主键。要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主键</p><p>第三范式：在第二范式的基础上，属性不依赖于其它非主属性   属性直接依赖于主键</p><ul><li><p>数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a–&gt;b–&gt;c  属性之间含有这样的关系，是不符合第三范式的。</p><p>比如Student表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）</p><p>这样一个表结构，就存在上述关系。 学号–&gt; 所在院校 –&gt; (院校地址，院校电话)</p><p>这样的表结构，我们应该拆开来，如下。</p><p>  （学号，姓名，年龄，性别，所在院校）–（所在院校，院校地址，院校电话）</p></li></ul><p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p><h2 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h2><ol><li><strong>是否支持行级锁</strong> : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li><li><strong>是否支持事务和崩溃后的安全恢复： MyISAM</strong> 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是<strong>InnoDB</strong> 提供事务支持，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li><li><strong>是否支持外键：</strong> MyISAM不支持，而InnoDB支持。</li><li><strong>是否支持MVCC</strong> ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;MVCC可以使用乐观(optimistic)锁和悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。推荐阅读：<a href="https://www.jianshu.com/p/8845ddca3b23">MySQL-InnoDB-MVCC多版本并发控制</a></li></ol><h2 id="大表优化策略"><a href="#大表优化策略" class="headerlink" title="大表优化策略"></a>大表优化策略</h2><h3 id="1-限定数据的范围"><a href="#1-限定数据的范围" class="headerlink" title="1. 限定数据的范围"></a>1. 限定数据的范围</h3><p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</p><h3 id="2-读-写分离"><a href="#2-读-写分离" class="headerlink" title="2. 读/写分离"></a>2. 读/写分离</h3><p>经典的数据库拆分方案，主库负责写，从库负责读；</p><h3 id="3-垂直分区"><a href="#3-垂直分区" class="headerlink" title="3. 垂直分区"></a>3. 垂直分区</h3><p><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p><p><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。 <img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9E%82%E7%9B%B4%E5%88%86%E5%8C%BA.png" alt="数据库垂直分区"></p><ul><li><strong>垂直拆分的优点：</strong>使列数据变小，在查询时减少读取的Block数，减少I/O次数，简化表的结构，易于维护。</li><li><strong>垂直拆分的缺点：</strong> 主键会出现冗余，并会引起Join操作，会让事务变得更加复杂；</li></ul><h3 id="4-水平分区"><a href="#4-水平分区" class="headerlink" title="4. 水平分区"></a>4. 水平分区</h3><p><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p><p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86.png" alt="数据库水平拆分"></p><p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</p><p>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p><p><strong>下面补充一下数据库分片的两种常见方案：</strong></p><ul><li><strong>客户端代理：</strong> <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li><li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li></ul><p>参考文章：<a href="https://segmentfault.com/a/1190000006158186">mysql大表优化方案</a></p><h2 id="一条SQL语句执行得很慢的原因有哪些？"><a href="#一条SQL语句执行得很慢的原因有哪些？" class="headerlink" title="一条SQL语句执行得很慢的原因有哪些？"></a>一条SQL语句执行得很慢的原因有哪些？</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN#rd">click here</a></p><h2 id="数据库高性能优化规范"><a href="#数据库高性能优化规范" class="headerlink" title="数据库高性能优化规范"></a>数据库高性能优化规范</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN#rd">click here</a></p><h2 id="一条SQL语句在MySQL中如何执行的"><a href="#一条SQL语句在MySQL中如何执行的" class="headerlink" title="一条SQL语句在MySQL中如何执行的"></a>一条SQL语句在MySQL中如何执行的</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd">click here</a></p><h2 id="MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别？"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h2><p>binlog原理：<a href="https://blog.csdn.net/lzhcoder/article/details/88814364">https://blog.csdn.net/lzhcoder/article/details/88814364</a></p><p>有三种格式，statement，row和mixed。</p><ul><li>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li><li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li><li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li></ul><p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p><h2 id="mysql有哪些数据类型"><a href="#mysql有哪些数据类型" class="headerlink" title="mysql有哪些数据类型"></a>mysql有哪些数据类型</h2><table><thead><tr><th><strong>分类</strong></th><th><strong>类型名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>整数类型</strong></td><td>tinyInt</td><td>很小的整数(8位二进制)</td></tr><tr><td></td><td>smallint</td><td>小的整数(16位二进制)</td></tr><tr><td></td><td>mediumint</td><td>中等大小的整数(24位二进制)</td></tr><tr><td></td><td>int(integer)</td><td>普通大小的整数(32位二进制)</td></tr><tr><td><strong>小数类型</strong></td><td>float</td><td>单精度浮点数</td></tr><tr><td></td><td>double</td><td>双精度浮点数</td></tr><tr><td></td><td>decimal(m,d)</td><td>压缩严格的定点数</td></tr><tr><td><strong>日期类型</strong></td><td>year</td><td>YYYY 1901~2155</td></tr><tr><td></td><td>time</td><td>HH:MM:SS -838:59:59~838:59:59</td></tr><tr><td></td><td>date</td><td>YYYY-MM-DD 1000-01-01~9999-12-3</td></tr><tr><td></td><td>datetime</td><td>YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59</td></tr><tr><td></td><td>timestamp</td><td>YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC</td></tr><tr><td><strong>文本、二进制类型</strong></td><td>CHAR(M)</td><td>M为0~255之间的整数</td></tr><tr><td></td><td>VARCHAR(M)</td><td>M为0~65535之间的整数</td></tr><tr><td></td><td>TINYBLOB</td><td>允许长度0~255字节</td></tr><tr><td></td><td>BLOB</td><td>允许长度0~65535字节</td></tr><tr><td></td><td>MEDIUMBLOB</td><td>允许长度0~167772150字节</td></tr><tr><td></td><td>LONGBLOB</td><td>允许长度0~4294967295字节</td></tr><tr><td></td><td>TINYTEXT</td><td>允许长度0~255字节</td></tr><tr><td></td><td>TEXT</td><td>允许长度0~65535字节</td></tr><tr><td></td><td>MEDIUMTEXT</td><td>允许长度0~167772150字节</td></tr><tr><td></td><td>LONGTEXT</td><td>允许长度0~4294967295字节</td></tr><tr><td></td><td>VARBINARY(M)</td><td>允许长度0~M个字节的变长字节字符串</td></tr><tr><td></td><td>BINARY(M)</td><td>允许长度0~M个字节的定长字节字符串</td></tr></tbody></table><p>还有set和enum</p><h2 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h2><p>MyISAM引擎也使用B+树作为索引结果，不过叶节点的data域存放的是数据记录的地址</p><ul><li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li><li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li><li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li><li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li></ul><h2 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h2><p>如果没有特别的需求，使用默认的<code>Innodb</code>即可。</p><p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p><p>Innodb：更新操作频率高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</p><h2 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a>索引有哪些优缺点？</h2><p>索引的优点</p><ul><li>创建索引可以大大加快数据的检索速度</li><li>通过使用索引，提高查询性能</li></ul><p>索引的缺点</p><ul><li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li><li>空间方面：索引需要占物理空间</li></ul><h2 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a>索引有哪几种类型？</h2><p><strong>主键索引:</strong> 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p><p><strong>唯一索引:</strong> 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p><ul><li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column);</code> 创建唯一索引</li><li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column1,column2);</code> 创建唯一组合索引</li></ul><p><strong>普通索引:</strong> 基本的索引类型，没有唯一性的限制，允许为NULL值。</p><ul><li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name (column);</code>创建普通索引</li><li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);</code>创建组合索引</li></ul><p><strong>全文索引：</strong> 是目前搜索引擎使用的一种关键技术。</p><ul><li>可以通过<code>ALTER TABLE table_name ADD FULLTEXT (column);</code>创建全文索引</li></ul><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><p>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有<strong>Hash索引</strong>，<strong>B+树索引</strong>等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p><p>1）B树索引</p><p>mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzI0LzE2NjBjMGYxNGRhY2Y2ZjU?x-oss-process=image/format,png" alt="img"></p><p>查询方式：</p><p>主键索引区:PI(关联保存的时数据的地址)按主键查询,</p><p>普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快</p><ul><li>主键索引的叶子结点存放了整行记录，普通索引的叶子结点存放了主键ID和其他建立索引的字段，查询的时候需要做一次回表查询<br>一定要回表查询么？<br>不一定，当查询的字段刚好是索引的字段或者索引的一部分，就可以不用回表，这也是索引覆盖的原理</li></ul><p>B+tree性质：</p><p>1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</p><p>2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p>3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</p><p>4.）B+树中，数据对象的插入和删除仅在叶节点上进行。</p><p>5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p><p>2）哈希索引</p><p>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzI0LzE2NjBjMGYxNThhNzZmOTQ?x-oss-process=image/format,png" alt="img"></p><h2 id="创建索引的原则（重中之重）"><a href="#创建索引的原则（重中之重）" class="headerlink" title="创建索引的原则（重中之重）"></a>创建索引的原则（重中之重）</h2><p>索引虽好，但也不是无限制的使用，最好符合一下几个原则</p><p>1） 根据最左前缀匹配原则创建和使用组合索</p><p>2）较频繁作为查询条件的字段才去创建索引，更新频繁字段不适合创建索引</p><p>3）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p><p>4）定义有外键的数据列一定要建立索引。</p><p>5）基数较小的类，索引效果较差，没有必要在此列建立索引</p><p>6）对于定义为text、image和bit的数据类型的列不要建立索引。</p><p>7）适合索引的列是出现在where，join,order by 子句中的列</p><p>8）使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</p><p>9）不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</p><h2 id="创建索引的三种方式，删除索引"><a href="#创建索引的三种方式，删除索引" class="headerlink" title="创建索引的三种方式，删除索引"></a>创建索引的三种方式，删除索引</h2><p>一种方式：在执行CREATE TABLE时创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(字段名 数据类型 [完整性约束条件],</span><br><span class="line">                  [<span class="keyword">UNIQUE</span> | FULLTEXT | SPATIAL] <span class="keyword">INDEX</span> | <span class="keyword">KEY</span></span><br><span class="line">                  [索引名](字段名<span class="number">1</span> [(长度)] [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>])</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_index2 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> auto_increment PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">first_name <span class="built_in">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">last_name <span class="built_in">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">id_card <span class="built_in">VARCHAR</span> (<span class="number">18</span>),</span><br><span class="line">information <span class="built_in">text</span>,</span><br><span class="line"><span class="keyword">KEY</span> <span class="keyword">name</span> (first_name, last_name),</span><br><span class="line">FULLTEXT <span class="keyword">KEY</span> (information),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (id_card)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>UNIQUE：可选。表示索引为唯一性索引。</li><li>FULLTEXT；可选。表示索引为全文索引。</li><li>SPATIAL：可选。表示索引为空间索引。</li><li>INDEX和KEY：用于指定字段为索引，两者选择其中之一就可以了，作用是一样的。</li><li>索引名：可选。给创建的索引取一个新名称。</li><li>字段名1：指定索引对应的字段的名称，该字段必须是前面定义好的字段。</li><li>长度：可选。指索引的长度，必须是字符串类型才可以使用。</li><li>ASC：可选。表示升序排列。</li><li>DESC：可选。表示降序排列。</li></ul><p>第二种方式：使用ALTER TABLE命令去增加索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name (column_list);</span><br></pre></td></tr></table></figure><p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p><p>第三种方式：使用CREATE INDEX命令创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name (column_list);</span><br></pre></td></tr></table></figure><p>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p><p>删除索引</p><p>根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code></p><h2 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h2><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p><ol><li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li><li>然后删除其中无用数据（此过程需要不到两分钟）</li><li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li></ol><h2 id="Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢?"></a>Hash索引和B+树所有有什么区别或者说优劣呢?</h2><p>首先要知道Hash索引和B+树索引的底层实现原理：</p><p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</p><p>那么可以看出他们有以下的不同：</p><ul><li><p>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p></li><li><p>hash索引不支持使用索引进行排序，原理同上。</p></li><li><p>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。</p></li><li><p>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</p></li><li><p>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</p></li></ul><h2 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h2><ul><li><p>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</p></li><li><p>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzIxLzE2NWZiNjgyZTc1OWNmMTI?x-oss-process=image/format,png" alt="img"></p></li></ul><h2 id="数据库为什么使用B-树而不是B树"><a href="#数据库为什么使用B-树而不是B树" class="headerlink" title="数据库为什么使用B+树而不是B树"></a>数据库为什么使用B+树而不是B树</h2><ul><li>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</li><li>B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</li><li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li><li>解决元素遍历的效率高问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</li><li>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</li></ul><ul><li>B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据。在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</li></ul><h2 id="事务的四大特性ACID"><a href="#事务的四大特性ACID" class="headerlink" title="事务的四大特性ACID"></a>事务的四大特性ACID</h2><ol><li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li><li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><h2 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h2><ul><li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li><li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li><li>幻读(Phantom Read):在一个事务的两次查询中数据数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的</li></ul><h2 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h2><p>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻影读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h2 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h2><p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p><p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p><p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p><p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别<strong>锁定整个范围的键</strong>，并一直持有锁，直到事务完成。</p><h2 id="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"><a href="#按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法" class="headerlink" title="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"></a>按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</h2><p>在关系型数据库中，可以<strong>按照锁的粒度把数据库锁分</strong>为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p><p><strong>MyISAM和InnoDB存储引擎使用的锁：</strong></p><ul><li>MyISAM采用表级锁(table-level locking)。</li><li>InnoDB支持行级锁(row-level locking)和表级锁 页级锁，默认为行级锁</li></ul><p>行级锁，表级锁和页级锁对比</p><p><strong>行级锁</strong> 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p><p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p><p><strong>表级锁</strong> 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p><p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p><p><strong>页级锁</strong> 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p><p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p><h2 id="从锁的类别上分MySQL都有哪些锁呢？"><a href="#从锁的类别上分MySQL都有哪些锁呢？" class="headerlink" title="从锁的类别上分MySQL都有哪些锁呢？"></a>从锁的类别上分MySQL都有哪些锁呢？</h2><p><strong>从锁的类别上来讲</strong>，有共享锁和排他锁。</p><p>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p><p>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p><h2 id="MySQL中InnoDB引擎的行锁是怎么实现的？"><a href="#MySQL中InnoDB引擎的行锁是怎么实现的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是怎么实现的？"></a>MySQL中InnoDB引擎的行锁是怎么实现的？</h2><p>答：InnoDB是基于索引来完成行锁</p><p>例: select * from tab_with_index where id = 1 for update;</p><p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起</p><h2 id="数据库的乐观锁和悲观锁是什么？怎么实现的？"><a href="#数据库的乐观锁和悲观锁是什么？怎么实现的？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？怎么实现的？"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h2><p>乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p><p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：一般会使用版本号机制或CAS算法实现。</p><p><strong>两种锁的使用场景</strong></p><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p><p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p><h2 id="视图有哪些特点？"><a href="#视图有哪些特点？" class="headerlink" title="视图有哪些特点？"></a>视图有哪些特点？</h2><p>视图的特点如下:</p><ul><li>视图是由基本表(实表)产生的表(虚表)。</li></ul><ul><li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。当视图来自多个基本表时，不允许添加和删除数据。</li><li>视图的建立和删除不影响基本表 更新影响基本表。</li></ul><h2 id="视图的使用场景有哪些？"><a href="#视图的使用场景有哪些？" class="headerlink" title="视图的使用场景有哪些？"></a>视图的使用场景有哪些？</h2><p>视图根本用途：简化sql查询，提高开发效率。兼容老的表结构。</p><p>下面是视图的常见使用场景：</p><ul><li>简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</li><li>使用表的部分组成部分而不是整个表；</li><li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ul><h2 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h2><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p><p><strong>优点</strong></p><p>1）存储过程是预编译过的，执行效率高。</p><p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p><p>3）安全性高，执行存储过程需要有一定权限的用户。</p><p>4）存储过程可以重复使用，减少数据库开发人员的工作量。</p><p><strong>缺点</strong></p><p>1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</p><p>2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p><p>3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p><p>4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p><h2 id="什么是触发器？触发器的使用场景有哪些？"><a href="#什么是触发器？触发器的使用场景有哪些？" class="headerlink" title="什么是触发器？触发器的使用场景有哪些？"></a>什么是触发器？触发器的使用场景有哪些？</h2><p>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</p><p>使用场景</p><ul><li>可以通过数据库中的相关表实现级联更改。</li><li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li></ul><p>六种触发器</p><ul><li>Before Insert</li><li>After Insert</li><li>Before Update</li><li>After Update</li><li>Before Delete</li><li>After Delete</li></ul><h2 id="SQL语句主要分为哪几类"><a href="#SQL语句主要分为哪几类" class="headerlink" title="SQL语句主要分为哪几类"></a>SQL语句主要分为哪几类</h2><p>数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER</p><p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p><p>数据查询语言DQL（Data Query Language）SELECT</p><p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p><p>数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE</p><p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p><p>数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p><p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p><h2 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a>超键、候选键、主键、外键分别是什么？</h2><ul><li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li>候选键：是最小超键，即没有冗余元素的超键。</li><li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li><li>外键：在一个表中存在的另一个表的主键称此表的外键。</li></ul><h2 id="六大约束"><a href="#六大约束" class="headerlink" title="六大约束"></a>六大约束</h2><ul><li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li><li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li><li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li><li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li><li>CHECK: 用于控制字段的值范围。</li><li>DEFAULT:默认值</li></ul><h2 id="mysql中-in-和-exists-区别"><a href="#mysql中-in-和-exists-区别" class="headerlink" title="mysql中 in 和 exists 区别"></a>mysql中 in 和 exists 区别</h2><p>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，再对内表进行查询</p><ol><li>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</li><li>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</li></ol><h2 id="char和varchar"><a href="#char和varchar" class="headerlink" title="char和varchar"></a>char和varchar</h2><p><strong>char的特点</strong></p><ul><li>char表示定长字符串，长度是固定的；</li><li>如果插入数据的长度小于char的固定长度时，则用空格填充；</li><li>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</li><li>对于char来说，最多能存放的字符个数为255，和编码无关</li></ul><p><strong>varchar的特点</strong></p><ul><li>varchar表示可变长字符串，长度是可变的；</li><li>插入的数据是多长，就按照多长来存储；</li><li>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li><li>对于varchar来说，最多能存放的字符个数为65532</li></ul><p>总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。</p><h2 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h2><table><thead><tr><th></th><th>Delete</th><th>Truncate</th><th>Drop</th></tr></thead><tbody><tr><td>类型</td><td>属于DML</td><td>属于DDL</td><td>属于DDL</td></tr><tr><td>回滚</td><td>可回滚</td><td>不可回滚</td><td>不可回滚</td></tr><tr><td>删除内容</td><td>表结构还在，删除表的全部或者一部分数据行</td><td>表结构还在，删除表中的所有数据</td><td>从数据库中删除表，所有的数据行，索引和权限也会被删除</td></tr><tr><td>删除速度</td><td>删除速度慢，需要逐行删除</td><td>删除速度快</td><td>删除速度最快</td></tr></tbody></table><h2 id="对慢查询怎么优化"><a href="#对慢查询怎么优化" class="headerlink" title="对慢查询怎么优化"></a>对慢查询怎么优化</h2><p>所以优化也是针对这三个方向来的，</p><ul><li>首先分析语句，看看是否加载了额外的数据。可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li><li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li><li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li></ul><h2 id="为什么要尽量设定一个主键？"><a href="#为什么要尽量设定一个主键？" class="headerlink" title="为什么要尽量设定一个主键？"></a>为什么要尽量设定一个主键？</h2><p>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p><h2 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a>主键使用自增ID还是UUID？</h2><p>推荐使用自增ID，不要使用UUID。</p><p>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成性能的下降。</p><h2 id="字段为什么要求定义为not-null？"><a href="#字段为什么要求定义为not-null？" class="headerlink" title="字段为什么要求定义为not null？"></a>字段为什么要求定义为not null？</h2><p>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</p><h2 id="如果要存储用户的密码散列，应该使用什么字段进行存储？"><a href="#如果要存储用户的密码散列，应该使用什么字段进行存储？" class="headerlink" title="如果要存储用户的密码散列，应该使用什么字段进行存储？"></a>如果要存储用户的密码散列，应该使用什么字段进行存储？</h2><p>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</p><h2 id="优化WHERE子句"><a href="#优化WHERE子句" class="headerlink" title="优化WHERE子句"></a>优化WHERE子句</h2><ul><li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li><li>应尽量避免在 where 子句中对字段进行范围查询，范围查询后的索引失效</li><li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line"><span class="comment">-- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</li><li>应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">or</span> <span class="keyword">num</span>=<span class="number">20</span></span><br><span class="line"><span class="comment">-- 可以这样查询：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure><ul><li>in 和 not in 也要慎用，否则会导致全表扫描，如：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line"><span class="comment">-- 对于连续的数值，能用 between 就不要用 in 了：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li>下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</li><li>如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span></span><br><span class="line"><span class="comment">-- 可以改为强制查询使用索引：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">with</span>(<span class="keyword">index</span>(索引名)) <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span></span><br></pre></td></tr></table></figure><ul><li>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>/<span class="number">2</span>=<span class="number">100</span></span><br><span class="line"><span class="comment">-- 应改为:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">100</span>*<span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>应尽量避免在where子句中对字段进行函数操作， 这将导致引擎放弃使用索引而进行全表扫描。如：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">1</span>,<span class="number">3</span>)=’abc’</span><br><span class="line"><span class="comment">-- name以abc开头的id应改为:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> ‘abc%’</span><br></pre></td></tr></table></figure><h2 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h2><p>当 cpu 飙升到 500%时，先用操作系统命令 top 观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</p><p>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</p><p>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</p><p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</p><h2 id="大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？"><a href="#大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？" class="headerlink" title="大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？"></a>大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？</h2><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><ol><li><p><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</p></li><li><p><strong>读/写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</p></li><li><p><strong>缓存：</strong> 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</p></li><li><p>还有就是通过分库分表的方式进行优化，主要有垂直分表和水平分表</p></li></ol><h2 id="MySQL的主从复制原理以及流程"><a href="#MySQL的主从复制原理以及流程" class="headerlink" title="MySQL的主从复制原理以及流程"></a>MySQL的主从复制原理以及流程</h2><p>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p><p><strong>主从复制的作用</strong></p><ol><li>主数据库出现问题，可以切换到从数据库。</li><li>可以进行数据库层面的读写分离。</li><li>可以在从数据库上进行日常备份。</li></ol><p><strong>MySQL主从复制解决了的问题</strong></p><ul><li>数据分布：在不同地理位置分布数据备份</li><li>负载均衡：降低单个服务器的压力</li><li>高可用和故障切换：帮助应用程序避免单点失败</li><li>升级测试：可以用更高版本的MySQL作为从库</li></ul><p><strong>MySQL主从复制工作原理</strong></p><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210221154803247.png" alt="image-20210221154803247"></p><p>Binary log：主数据库的二进制日志</p><p>Relay log：从服务器的中继日志</p><p>第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</p><p>第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。</p><p>第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</p><h2 id="MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年-怎么优化？"><a href="#MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年-怎么优化？" class="headerlink" title="MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？"></a>MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？</h2><p>a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。<br>b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。<br>c.  mysql库主从读写分离。<br>d. 找规律分表，减少单表中的数据量提高查询速度。<br>e. 添加缓存机制，比如memcached，apc等。<br>f. 不经常改动的页面，生成静态页面。<br>g. 书写高效率的SQL。</p><h2 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h2><p>MVCC叫做多版本并发控制，实际上就是保存了数据在某个时间节点的快照。</p><p>表中每行实际上隐藏了两列，创建时间版本号，过期(删除)时间版本号，每开始一个新的事务，版本号都会自动递增。</p><p>推荐阅读：<a href="https://blog.csdn.net/qq_27469549/article/details/99639880">https://blog.csdn.net/qq_27469549/article/details/99639880</a></p><h2 id="分表后的ID怎么保证唯一性的呢？"><a href="#分表后的ID怎么保证唯一性的呢？" class="headerlink" title="分表后的ID怎么保证唯一性的呢？"></a>分表后的ID怎么保证唯一性的呢？</h2><p>因为我们主键默认都是自增的，那么分表之后的主键在不同表就肯定会有冲突了。有几个办法考虑：</p><ol><li>设定步长，比如1-1024张表我们分别设定1-1024的基础步长，这样主键落到不同的表就不会冲突了。</li><li>分布式ID，自己实现一套分布式ID生成算法或者使用开源的比如雪花算法这种。</li><li>分表后不使用主键作为查询依据，而是每张表单独新增一个字段作为唯一主键使用，比如订单表订单号是唯一的，不管最终落在哪张表都基于订单号作为查询依据，更新也一样</li></ol><h2 id="事务是如何通过日志来实现的，说得越深入越好。"><a href="#事务是如何通过日志来实现的，说得越深入越好。" class="headerlink" title="事务是如何通过日志来实现的，说得越深入越好。"></a>事务是如何通过日志来实现的，说得越深入越好。</h2><p>InnoDB的日志分为redo log和undo log，redo恢复提交事务修改的页操作，而undo回滚记录到某个特定的版本。所以，<strong>redo通常是物理日志</strong>，记录的是页的物理修改操作；<strong>undo是逻辑日志</strong>，根据每行记录进行记录。</p><p>推荐阅读：<a href="https://blog.csdn.net/No_Game_No_Life_/article/details/106718599">https://blog.csdn.net/No_Game_No_Life_/article/details/106718599</a></p><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h2><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>答：程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p><h2 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h2><ul><li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><h2 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a>一句话简单了解堆和方法区</h2><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h2 id="为什么要使用并发编程"><a href="#为什么要使用并发编程" class="headerlink" title="为什么要使用并发编程"></a>为什么要使用并发编程</h2><ol><li><p>可以将多核CPU的计算能力发挥到极致，提升性能</p></li><li><p>方便进行业务拆分，提升系统并发能力和性能：多线程并发编程是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。</p></li></ol><h2 id="并发编程有什么缺点"><a href="#并发编程有什么缺点" class="headerlink" title="并发编程有什么缺点"></a>并发编程有什么缺点</h2><p>可能会有内存泄漏、上下文切换、线程安全、死锁等问题。</p><h2 id="并发编程三要素是什么？"><a href="#并发编程三要素是什么？" class="headerlink" title="并发编程三要素是什么？"></a>并发编程三要素是什么？</h2><p>并发编程三要素（线程的安全性问题体现在）：</p><p>原子性：一个或多个操作要么全部执行成功要么全部执行失败。</p><p>可见性：一个线程对共享变量的修改,另一个线程能够立刻看到。（synchronized,volatile）</p><p>有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）</p><h2 id="在-Java-程序中怎么保证多线程的运行安全？"><a href="#在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="在 Java 程序中怎么保证多线程的运行安全？"></a>在 Java 程序中怎么保证多线程的运行安全？</h2><p>出现线程安全问题的原因：</p><ul><li>线程切换带来的原子性问题</li><li>缓存导致的可见性问题</li><li>编译优化带来的有序性问题</li></ul><p>解决办法：</p><ul><li>JDK Atomic开头的原子类、synchronized、LOCK可以解决原子性问题</li><li>synchronized、volatile、LOCK可以解决可见性问题</li><li>Happens-Before 规则可以解决有序性问题</li></ul><h2 id="并行-并发和串行有什么区别？"><a href="#并行-并发和串行有什么区别？" class="headerlink" title="并行 并发和串行有什么区别？"></a>并行 并发和串行有什么区别？</h2><ul><li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</li><li>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”。</li><li>串行：有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行所以不存在线程不安全情况，也就不存在临界区的问题。</li></ul><h2 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h2><p>一个任务切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><p>一下原因导致上下文切换</p><ul><li>线程的时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了sleep,yield,wait,join,park,synchronized,lock等方法</li></ul><h2 id="守护线程和用户线程有什么区别呢？"><a href="#守护线程和用户线程有什么区别呢？" class="headerlink" title="守护线程和用户线程有什么区别呢？"></a>守护线程和用户线程有什么区别呢？</h2><p>守护线程和用户线程</p><ul><li><strong>用户 (User) 线程</strong>：运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</li><li><strong>守护 (Daemon) 线程</strong>：运行在后台，为其他前台线程服务。也可以说守护线程是 JVM 中非守护线程的 <strong>“佣人”</strong>。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</li></ul><p>main 函数所在的线程就是一个用户线程啊，main 函数启动的同时在 JVM 内部同时还启动了好多守护线程，比如垃圾回收线程。</p><p>比较明显的区别之一是用户线程结束，JVM 退出，不管这个时候有没有守护线程运行。而守护线程不会影响 JVM 的退出。</p><p><strong>注意事项：</strong></p><ol><li><code>setDaemon(true)</code>必须在<code>start()</code>方法前执行，否则会抛出 <code>IllegalThreadStateException</code> 异常</li><li>在守护线程中产生的新线程也是守护线程</li><li>不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑</li><li>守护 (Daemon) 线程中不能依靠 finally 块的内容来确保执行关闭或清理资源的逻辑。因为我们上面也说过了一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作，所以守护 (Daemon) 线程中的 finally 语句块可能无法被执行。</li></ol><h2 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h2><p>死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p><h2 id="形成死锁的四个必要条件是什么"><a href="#形成死锁的四个必要条件是什么" class="headerlink" title="形成死锁的四个必要条件是什么"></a>形成死锁的四个必要条件是什么</h2><ol><li>互斥条件：线程(进程)对于所分配到的资源具有排它性，即一个资源只能被一个线程(进程)占用，直到被该线程(进程)释放</li><li>请求与保持条件：一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</li><li>非抢占条件：线程(进程)已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件：当发生死锁时，所等待的线程(进程)必定会形成一个环路（类似于死循环），造成永久阻塞</li></ol><h2 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁"></a>如何避免线程死锁</h2><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p><p><strong>破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p><p><strong>破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p><p><strong>破坏非抢占条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><h2 id="创建线程有哪几种方式？"><a href="#创建线程有哪几种方式？" class="headerlink" title="创建线程有哪几种方式？"></a>创建线程有哪几种方式？</h2><p>创建线程有四种方式：</p><ul><li><p>继承 Thread 类；</p><ul><li><pre><code class="java">public class MyThread extends Thread &#123;    @Override    public void run() &#123;        System.out.println(Thread.currentThread().getName() + &quot; run()方法正在执行...&quot;);    &#125;&#125;public class TheadTest &#123;    public static void main(String[] args) &#123;        MyThread myThread = new MyThread();             myThread.start();        System.out.println(Thread.currentThread().getName() + &quot; main()方法执行结束&quot;);    &#125;&#125;<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 实现 Runnable 接口；</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public <span class="keyword">class</span> MyRunnable implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run<span class="literal">()</span> &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot; run()方法执行中...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">class</span> RunnableTest &#123;</span><br><span class="line">        public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">            MyRunnable myRunnable = <span class="keyword">new</span> <span class="constructor">MyRunnable()</span>;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">myRunnable</span>)</span>;</span><br><span class="line">            thread.start<span class="literal">()</span>;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot; main()方法执行完成&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>实现 Callable 接口；</p><ul><li><pre><code class="java">public class MyCallable implements Callable&lt;Integer&gt; &#123;    @Override    public Integer call() &#123;        System.out.println(Thread.currentThread().getName() + &quot; call()方法执行中...&quot;);        return 1;    &#125;&#125;public class CallableTest &#123;    public static void main(String[] args) &#123;        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new MyCallable());        Thread thread = new Thread(futureTask);        thread.start();        try &#123;            Thread.sleep(1000);            System.out.println(&quot;返回结果 &quot; + futureTask.get());        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; catch (ExecutionException e) &#123;            e.printStackTrace();        &#125;        System.out.println(Thread.currentThread().getName() + &quot; main()方法执行完成&quot;);    &#125;&#125;<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用 Executors 工具类创建线程池</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(Thread.currentThread().getName() + <span class="string">&quot; run()方法执行中...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadExecutorTest</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">            ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">            MyRunnable runnableTest = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                executorService.execute(runnableTest);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;线程任务开始执行&quot;</span>);</span><br><span class="line">            executorService.<span class="built_in">shutdown</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h2 id="runnable-和-callable-有什么区别"><a href="#runnable-和-callable-有什么区别" class="headerlink" title="runnable 和 callable 有什么区别"></a>runnable 和 callable 有什么区别</h2><p>相同点</p><ul><li>都是接口</li><li>都可以编写多线程程序</li><li>都采用Thread.start()启动线程</li></ul><p>主要区别</p><ul><li>Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果<ul><li>Future 接口表示异步任务，是一个可能还没有完成的异步任务的结果。所以说 Callable用于产生结果，Future 用于获取结果。</li><li>FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。</li></ul></li><li>Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法可以抛出异常，也可以获取异常信息</li></ul><p><strong>注</strong>：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。.</p><h2 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h2><p>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</p><p>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p><h2 id="线程的五种状态"><a href="#线程的五种状态" class="headerlink" title="线程的五种状态"></a>线程的五种状态</h2><p>新建，可运行，运行，阻塞，死亡</p><h2 id="Java-中用到的线程调度算法是什么？"><a href="#Java-中用到的线程调度算法是什么？" class="headerlink" title="Java 中用到的线程调度算法是什么？"></a>Java 中用到的线程调度算法是什么？</h2><p>有两种调度模型：分时调度模型和抢占式调度模型。</p><p>分时调度模型是指平均分配每个线程占用的 CPU 的时间片，让所有的线程轮流获得 cpu 的使用权</p><p>Java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。</p><h2 id="线程的调度策略"><a href="#线程的调度策略" class="headerlink" title="线程的调度策略"></a>线程的调度策略</h2><p>线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线程的运行：</p><p>（1）线程体中调用了 yield 方法让出了对 cpu 的占用权利</p><p>（2）线程体中调用了 sleep 方法使线程进入睡眠状态</p><p>（3）线程由于 IO 操作受到阻塞</p><p>（4）另外一个更高优先级线程出现</p><p>（5）在支持时间片的系统中，该线程的时间片用完</p><h2 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a>sleep() 和 wait() 有什么区别？</h2><p>两者都可以暂停线程的执行</p><ul><li>类的不同：sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。</li><li>是否释放锁：sleep() 不释放锁；wait() 释放锁。</li><li>用途不同：Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。</li><li>用法不同：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。</li></ul><h2 id="为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？"><a href="#为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？" class="headerlink" title="为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？"></a>为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</h2><p>Java中，任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。</p><p>有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。</p><h2 id="为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？"></a>为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</h2><p>当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</p><h2 id="Thread-类中的-yield-方法有什么作用？"><a href="#Thread-类中的-yield-方法有什么作用？" class="headerlink" title="Thread 类中的 yield 方法有什么作用？"></a>Thread 类中的 yield 方法有什么作用？</h2><p>使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。</p><p>当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。</p><h2 id="线程的-sleep-方法和-yield-方法有什么区别？"><a href="#线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="线程的 sleep()方法和 yield()方法有什么区别？"></a>线程的 sleep()方法和 yield()方法有什么区别？</h2><p>（1） sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</p><p>（2） 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；</p><p>（3）sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；</p><p>（4）sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。</p><h2 id="Java-中-interrupted-和-isInterrupted-方法的区别？"><a href="#Java-中-interrupted-和-isInterrupted-方法的区别？" class="headerlink" title="Java 中 interrupted 和 isInterrupted 方法的区别？"></a>Java 中 interrupted 和 isInterrupted 方法的区别？</h2><p>interrupt：用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。</p><p>注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p><p>interrupted：是静态方法，查看当前中断信号是true还是false并且清除中断信号。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了。</p><p>isInterrupted：查看当前中断信号是true还是false</p><h2 id="阻塞-非阻塞-同步-异步的区别"><a href="#阻塞-非阻塞-同步-异步的区别" class="headerlink" title="阻塞 非阻塞 同步 异步的区别"></a>阻塞 非阻塞 同步 异步的区别</h2><p>同步与异步是对应于调用者与被调用者，它们是线程之间的关系，两个线程之间要么是同步的，要么是异步的     </p><ul><li>同步操作时，调用者需要等待被调用者返回结果，才会进行下一步操作     </li><li>而异步则相反，调用者不需要等待被调用者返回调用，即可进行下一步操作，被调用者通常依靠事件、回调等机制来通知调用者结果</li></ul><p>阻塞与非阻塞是对同一个线程来说的，在某个时刻，线程要么处于阻塞，要么处于非阻塞  </p><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态：     </p><ul><li><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。 </p></li><li><p>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p></li></ul><h2 id="如何在两个线程间共享数据？"><a href="#如何在两个线程间共享数据？" class="headerlink" title="如何在两个线程间共享数据？"></a>如何在两个线程间共享数据？</h2><p>在两个线程间共享变量即可实现共享。</p><p>一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。</p><h2 id="同步方法和同步块，哪个是更好的选择？"><a href="#同步方法和同步块，哪个是更好的选择？" class="headerlink" title="同步方法和同步块，哪个是更好的选择？"></a>同步方法和同步块，哪个是更好的选择？</h2><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p><p>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</p><h2 id="Java-如何实现多线程之间的通讯和协作？"><a href="#Java-如何实现多线程之间的通讯和协作？" class="headerlink" title="Java 如何实现多线程之间的通讯和协作？"></a>Java 如何实现多线程之间的通讯和协作？</h2><p>可以通过中断 和 共享变量的方式实现线程间的通讯和协作</p><p>Java中线程通信协作的最常见的两种方式：</p><p>一.syncrhoized加锁的线程的<strong>Object类</strong>的wait()/notify()/notifyAll()</p><p>二.ReentrantLock类加锁的线程的<strong>Condition类的</strong>await()/signal()/signalAll()</p><p>线程间直接的数据交换：</p><p>三.通过管道进行线程间通信：1）字节流；2）字符流</p><h2 id="什么是线程同步和线程互斥？有什么区别"><a href="#什么是线程同步和线程互斥？有什么区别" class="headerlink" title="什么是线程同步和线程互斥？有什么区别"></a>什么是线程同步和线程互斥？有什么区别</h2><p>线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作并处于等待状态，直到该线程完成操作</p><p>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</p><p>区别：</p><ol><li>互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</li><li>同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。</li><li>同步其实已经实现了互斥，所以同步是一种更为复杂的互斥。</li><li>互斥是一种特殊的同步。</li></ol><h2 id="在监视器-Monitor-内部，是如何做线程同步的？"><a href="#在监视器-Monitor-内部，是如何做线程同步的？" class="headerlink" title="在监视器(Monitor)内部，是如何做线程同步的？"></a>在监视器(Monitor)内部，是如何做线程同步的？</h2><p>在 java 虚拟机中，每个对象( Object 和 class )通过某种逻辑关联监视器,每个监视器和一个对象引用相关联，为了实现监视器的互斥功能，每个对象都关联着一把锁。</p><p>一旦方法或者代码块被 <strong>synchronized</strong> 修饰，那么这个部分就放入了监视器的监视区域，<strong>确保一次只能有一个线程执行该部分的代码</strong>，线程在获取锁之前不允许执行该部分的代码</p><h2 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h2><p>线程优先级是一个 int 变量(从 1-10)，1 代表最低优先级，10 代表最高优先级。Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</p><h2 id="线程类的构造方法、静态块是被哪个线程调用的"><a href="#线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="线程类的构造方法、静态块是被哪个线程调用的"></a>线程类的构造方法、静态块是被哪个线程调用的</h2><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被 new这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用的。</p><h2 id="Java-线程数过多会造成什么异常？"><a href="#Java-线程数过多会造成什么异常？" class="headerlink" title="Java 线程数过多会造成什么异常？"></a>Java 线程数过多会造成什么异常？</h2><ul><li><p>线程的生命周期开销非常高</p></li><li><p>消耗过多的 CPU</p><p>资源如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU资源时还将产生其他性能的开销。</p></li><li><p>降低JVM稳定性</p><p>在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError 异常。</p></li></ul><h2 id="synchronized-的作用？"><a href="#synchronized-的作用？" class="headerlink" title="synchronized 的作用？"></a>synchronized 的作用？</h2><p>在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 可以修饰类、方法、变量。</p><h2 id="说说自己是怎么使用-synchronized-关键字，在项目中用到了吗"><a href="#说说自己是怎么使用-synchronized-关键字，在项目中用到了吗" class="headerlink" title="说说自己是怎么使用 synchronized 关键字，在项目中用到了吗"></a>说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</h2><p><strong>synchronized关键字最主要的三种使用方式：</strong></p><ul><li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li><li><strong>修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例</li><li><strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><p><strong>总结：</strong> synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！</p><p>下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。</p><p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。</p><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h2 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h2><h2 id="当一个线程进入一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B？"><a href="#当一个线程进入一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B？" class="headerlink" title="当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？"></a>当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？</h2><p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁</p><h2 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h2><ul><li>首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类；</li><li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li><li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到</li></ul><h2 id="synchronized-和-ReentrantLock-区别是什么？"><a href="#synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="synchronized 和 ReentrantLock 区别是什么？"></a>synchronized 和 ReentrantLock 区别是什么？</h2><p>synchronized 是关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量</p><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p><p>相同点：两者都是可重入锁</p><p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p><p>主要区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。</li><li>二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的park 方法加锁，synchronized 操作的是对象头中 mark word</li></ul><h2 id="Java-中能创建-volatile-数组吗？"><a href="#Java-中能创建-volatile-数组吗？" class="headerlink" title="Java 中能创建 volatile 数组吗？"></a>Java 中能创建 volatile 数组吗？</h2><p>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。</p><h2 id="synchronized-和-volatile-的区别是什么？"><a href="#synchronized-和-volatile-的区别是什么？" class="headerlink" title="synchronized 和 volatile 的区别是什么？"></a>synchronized 和 volatile 的区别是什么？</h2><p>synchronized 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。</p><p>volatile 表示变量在 CPU 的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性；禁止指令重排序。</p><p><strong>区别</strong></p><ul><li>volatile 是变量修饰符；synchronized 可以修饰类、方法</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li><li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li><li><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong></li></ul><h2 id="不可变对象，对写并发应用有什么帮助？"><a href="#不可变对象，对写并发应用有什么帮助？" class="headerlink" title="不可变对象，对写并发应用有什么帮助？"></a>不可变对象，对写并发应用有什么帮助？</h2><p>不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p><h2 id="Lock接口是什么？对比同步它有什么优势？"><a href="#Lock接口是什么？对比同步它有什么优势？" class="headerlink" title="Lock接口是什么？对比同步它有什么优势？"></a>Lock接口是什么？对比同步它有什么优势？</h2><p>Lock 接口用来实现锁功能，比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p><p>它的优势有：</p><p>（1）可以使锁更公平</p><p>（2）可以使线程在等待锁的时候响应中断</p><p>（3）可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</p><p>（4）可以在不同的范围，以不同的顺序获取和释放锁</p><h2 id="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><a href="#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？" class="headerlink" title="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"></a>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h2><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。</p><p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p><h2 id="什么是-CAS"><a href="#什么是-CAS" class="headerlink" title="什么是 CAS"></a>什么是 CAS</h2><p>cas 是一种基于锁的操作，而且是乐观锁。</p><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。CAS是通过无限循环来获取数据的，如果在第一轮循环中，a 线程获取地址里面的值被b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。</p><h2 id="CAS-的会产生什么问题？"><a href="#CAS-的会产生什么问题？" class="headerlink" title="CAS 的会产生什么问题？"></a>CAS 的会产生什么问题？</h2><p>1、ABA 问题：</p><p>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。</p><p>2、循环时间长开销大：</p><p>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。</p><p>3、只能保证一个共享变量的原子操作：</p><p>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。</p><h2 id="AQS-原理"><a href="#AQS-原理" class="headerlink" title="AQS 原理"></a>AQS 原理</h2><p><strong>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><blockquote><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p></blockquote><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p><h2 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h2><ul><li>Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：<ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li><strong>Share</strong>（共享）：多个线程可同时执行，如Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock </li></ul><h2 id="什么是ConcurrentHashMap？"><a href="#什么是ConcurrentHashMap？" class="headerlink" title="什么是ConcurrentHashMap？"></a>什么是ConcurrentHashMap？</h2><p>ConcurrentHashMap是Java中的一个<strong>线程安全且高效的HashMap实现</strong></p><p>JDK1.8后，ConcurrentHashMap抛弃了原有的<strong>Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性</strong>。</p><h2 id="CopyOnWriteArrayList-是什么，可以用于什么应用场景？有哪些优缺点？"><a href="#CopyOnWriteArrayList-是什么，可以用于什么应用场景？有哪些优缺点？" class="headerlink" title="CopyOnWriteArrayList 是什么，可以用于什么应用场景？有哪些优缺点？"></a>CopyOnWriteArrayList 是什么，可以用于什么应用场景？有哪些优缺点？</h2><p>查看源码</p><p>CopyOnWriteArrayList 是一个并发容器。有很多人称它是线程安全的，我认为这句话不严谨，缺少一个前提条件，那就是非复合场景下操作它是线程安全的。</p><p>CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出 ConcurrentModificationException。在CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。</p><p>CopyOnWriteArrayList 的使用场景</p><p>通过源码分析，我们看出它的优缺点比较明显，所以使用场景也就比较明显。就是合适读多写少的场景。</p><p>CopyOnWriteArrayList 的缺点</p><ol><li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。</li><li>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的，虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。</li><li>由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次 add/set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。</li></ol><p>CopyOnWriteArrayList 的设计思想</p><ol><li>读写分离，读和写分开</li><li>最终一致性</li><li>使用另外开辟空间的思路，来解决并发冲突</li></ol><p>其他并发容器：ConcurrentLinkedQueue，ArrayBlockingQueue，LinkedBlockingQueue</p><h2 id="ThreadLocal-是什么？"><a href="#ThreadLocal-是什么？" class="headerlink" title="ThreadLocal 是什么？"></a>ThreadLocal 是什么？</h2><p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p><h2 id="ThreadLocal内存泄漏分析与解决方案"><a href="#ThreadLocal内存泄漏分析与解决方案" class="headerlink" title="ThreadLocal内存泄漏分析与解决方案"></a>ThreadLocal内存泄漏分析与解决方案</h2><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p><h2 id="什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"><a href="#什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？" class="headerlink" title="什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"></a>什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。</p><p>这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p><p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>JDK7 提供了 7 个阻塞队列。分别是：</p><p>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</p><p>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</p><p>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</p><p>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</p><p>SynchronousQueue：一个不存储元素的阻塞队列。</p><p>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</p><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p><h2 id="什么是线程池？有哪几种创建方式？"><a href="#什么是线程池？有哪几种创建方式？" class="headerlink" title="什么是线程池？有哪几种创建方式？"></a>什么是线程池？有哪几种创建方式？</h2><p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：</p><p>（1）newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><p>（2）newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。如果希望在服务器上使用线程池，建议使用 newFixedThreadPool方法来创建线程池，这样能获得更好的性能。</p><p>（3） newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。</p><p>（4）newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p><h2 id="线程池有什么优点？"><a href="#线程池有什么优点？" class="headerlink" title="线程池有什么优点？"></a>线程池有什么优点？</h2><ul><li>降低资源消耗：重用存在的线程，减少对象创建销毁的开销。</li><li>提高响应速度。可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li><li>附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。</li></ul><p>综上所述使用线程池框架 Executor 能更好的管理线程、提供系统资源使用率。</p><h2 id="线程池都有哪些状态？"><a href="#线程池都有哪些状态？" class="headerlink" title="线程池都有哪些状态？"></a>线程池都有哪些状态？</h2><ul><li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li><li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</li><li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li><li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li><li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li></ul><h2 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit() 和 execute() 方法有什么区别？"></a>线程池中 submit() 和 execute() 方法有什么区别？</h2><p>接收参数：execute()只能执行 Runnable 类型的任务。submit()可以执行 Runnable 和 Callable 类型的任务。</p><p>返回值：submit()方法可以返回持有计算结果的 Future 对象，而execute()没有</p><p>异常处理：submit()方便Exception处理</p><h2 id="你知道怎么创建线程池吗？"><a href="#你知道怎么创建线程池吗？" class="headerlink" title="你知道怎么创建线程池吗？"></a>你知道怎么创建线程池吗？</h2><p>创建线程池的方式有多种，这里你只需要答 ThreadPoolExecutor 即可。</p><p>ThreadPoolExecutor() 是最原始的线程池创建，也是阿里巴巴 Java 开发手册中明确规范的创建线程池的方式。</p><p>ThreadPoolExecutor构造函数重要参数分析</p><p><strong><code>ThreadPoolExecutor</code></strong> <strong>3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code></strong> ：核心线程数，线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code></strong> ：线程池中允许存在的工作线程的最大数量</li><li>**<code>workQueue</code>**：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数:</p><ol><li>**<code>keepAliveTime</code>**：线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> ：<code>keepAliveTime</code> 参数的时间单位。</li><li>**<code>threadFactory</code>**：为线程池提供创建新线程的线程工厂</li><li><strong><code>handler</code></strong> ：线程池任务队列超过 maxinumPoolSize 之后的拒绝策略</li></ol><h2 id="什么是原子操作？"><a href="#什么是原子操作？" class="headerlink" title="什么是原子操作？"></a>什么是原子操作？</h2><p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。</p><p>int++并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程有可能会读到之前的值，这就会引发错误。</p><h2 id="Atomic原理"><a href="#Atomic原理" class="headerlink" title="Atomic原理"></a>Atomic原理</h2><p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。</p><p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><h2 id="在-Java-中-CycliBarriar-和-CountdownLatch-有什么区别？"><a href="#在-Java-中-CycliBarriar-和-CountdownLatch-有什么区别？" class="headerlink" title="在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？"></a>在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？</h2><p>CountDownLatch与CyclicBarrier都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：</p><ul><li>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；CountDownLatch强调一个线程等多个线程完成某件事情。CyclicBarrier是多个线程互等，等大家都完成，再携手共进。</li><li>调用CountDownLatch的countDown方法后，当前线程并不会阻塞，会继续往下执行；而调用CyclicBarrier的await方法，会阻塞当前线程，直到CyclicBarrier指定的线程全部都到达了指定点的时候，才能继续往下执行；</li><li>CountDownLatch方法比较少，操作比较简单，而CyclicBarrier提供的方法更多，比如能够通过getNumberWaiting()，isBroken()这些方法获取当前多个线程的状态，并且CyclicBarrier的构造方法可以传入barrierAction，指定当所有线程都到达时执行的业务功能；</li><li>CountDownLatch是不能复用的，而CycliBarria是可以复用的。</li></ul><h2 id="Semaphore-有什么作用"><a href="#Semaphore-有什么作用" class="headerlink" title="Semaphore 有什么作用"></a>Semaphore 有什么作用</h2><p>Semaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n=1，相当于变成了一个 synchronized 了。</p><h2 id="什么是线程间交换数据的工具Exchanger"><a href="#什么是线程间交换数据的工具Exchanger" class="headerlink" title="什么是线程间交换数据的工具Exchanger"></a>什么是线程间交换数据的工具Exchanger</h2><p>Exchanger是一个用于线程间协作的工具类，用于两个线程间交换数据。它提供了一个交换的同步点，在这个同步点两个线程能够交换数据。交换数据是通过exchange方法来实现的，如果一个线程先执行exchange方法，那么它会同步等待另一个线程也执行exchange方法，这个时候两个线程就都达到了同步点，两个线程就可以交换数据。</p><h2 id="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？"><a href="#现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？" class="headerlink" title="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？"></a>现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</h2><p>这个线程问题通常会在第一轮或电话面试阶段被问到，目的是检测你对”join”方法是否熟悉。这个多线程问题比较简单，可以用join方法实现。</p><p>notify&amp;wait方法</p><h2 id="什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？"><a href="#什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？" class="headerlink" title="什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？"></a>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？</h2><p>线程调度器是一个操作系统服务，它负责为<em>Runnable</em>状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的<em>Runnable</em>线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</p><h2 id="你如何确保main-方法所在的线程是Java程序最后结束的线程？"><a href="#你如何确保main-方法所在的线程是Java程序最后结束的线程？" class="headerlink" title="你如何确保main()方法所在的线程是Java程序最后结束的线程？"></a>你如何确保main()方法所在的线程是Java程序最后结束的线程？</h2><p>我们可以使用Thread类的joint()方法来确保所有程序创建的线程在main()方法退出前结束</p><h2 id="为什么Thread类的sleep-和yield-方法是静态的？"><a href="#为什么Thread类的sleep-和yield-方法是静态的？" class="headerlink" title="为什么Thread类的sleep()和yield()方法是静态的？"></a>为什么Thread类的sleep()和yield()方法是静态的？</h2><p>Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。</p><h2 id="什么是Java-Timer类？如何创建一个有特定时间间隔的任务？"><a href="#什么是Java-Timer类？如何创建一个有特定时间间隔的任务？" class="headerlink" title="什么是Java Timer类？如何创建一个有特定时间间隔的任务？"></a>什么是Java Timer类？如何创建一个有特定时间间隔的任务？</h2><p>java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。</p><p>java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。</p><h2 id="synchronized锁的优化了解吗"><a href="#synchronized锁的优化了解吗" class="headerlink" title="synchronized锁的优化了解吗"></a><strong>synchronized锁的优化了解吗</strong></h2><ul><li>synchronized在JDK1.6进行了锁的优化，也就是当一个线程多次访问一个同步代码块的时候，此时会记录该线程的threadId也就是，当你再来访问的时候，我就只需判断threadId就行了，效率高，这属于偏向锁。</li><li>当有多个线程来的时候，那么这个锁就会升级为轻量级锁，也就是通过CAS，来进行尝试获取锁，是一种自旋锁的状态。如果在短时间内可以获得锁，不会堵塞，而且节约了CUP上下文切换的时间。</li><li>如果长时间没有获取到锁，在那一直死循环，会消耗CUP的资源，经过一个时间段后会升级为重量级锁，会发生阻塞。其中锁升级是不可逆的。</li></ul><h2 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h2><p><strong>成员变量和静态变量是否线程安全</strong></p><ul><li>如果它们被共享了，根据它们的状态是否能够改变，分两种情况<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><p><strong>局部变量是否线程安全</strong></p><ul><li>局部变量是线程安全的</li><li>但局部变量引用的对象则未必<ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul><p><strong>局部变量的暴露引用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadSafe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUMBER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOOP_NUMBER = <span class="number">200</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadSafeSubClass test = <span class="keyword">new</span> ThreadSafeSubClass();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                test.method1(LOOP_NUMBER);</span><br><span class="line">            &#125;, <span class="string">&quot;Thread&quot;</span> + (i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title">ThreadSafe</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>method1中的list对象逃离了该方法的作用范围 主线程创建了两个新的线程执行method3 他们对list共享从而引发线程安全问题 </li></ul><h2 id="为什么无锁效率高"><a href="#为什么无锁效率高" class="headerlink" title="为什么无锁效率高"></a>为什么无锁效率高</h2><ul><li>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。</li><li>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持</li></ul><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="简单介绍一下redis"><a href="#简单介绍一下redis" class="headerlink" title="简单介绍一下redis"></a>简单介绍一下redis</h2><p>简单来说 <strong>Redis 就是一个使用 C 语言开发的数据库</strong>，不过与传统数据库不同的是 <strong>Redis 的数据是存在内存中的</strong> ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。</p><p>另外，<strong>Redis 除了做缓存之外，Redis 也经常用来做分布式锁，甚至是消息队列。</strong></p><p><strong>Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。</strong></p><p>Redis用作分布式缓存：分布式缓存主要解决的是单机缓存的容量受服务器限制并且无法保存通用的信息。因为，本地缓存只在当前服务里有效，比如如果你部署了两个相同的服务，他们两者之间的缓存数据是无法共同的。</p><h2 id="为什么要用缓存"><a href="#为什么要用缓存" class="headerlink" title="为什么要用缓存"></a>为什么要用缓存</h2><p><strong>高性能</strong> ：操作缓存就是直接操作内存，所以速度相当快。不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p><p><strong>高并发</strong></p><h2 id="既然是单线程，那怎么监听大量的客户端连接呢？"><a href="#既然是单线程，那怎么监听大量的客户端连接呢？" class="headerlink" title="既然是单线程，那怎么监听大量的客户端连接呢？"></a><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></h2><p>Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发生。</p><p>这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p><h2 id="Redis-没有使用多线程？为什么不使用多线程？"><a href="#Redis-没有使用多线程？为什么不使用多线程？" class="headerlink" title="Redis 没有使用多线程？为什么不使用多线程？"></a>Redis 没有使用多线程？为什么不使用多线程？</h2><p><strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong></p><p>大体上来说，<strong>Redis 6.0 之前主要还是单线程处理。</strong></p><p><strong>那，Redis6.0 之前 为什么不使用多线程？</strong></p><p>我觉得主要原因有下面 3 个：</p><ol><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ol><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈</p><p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了， 执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p><h2 id="Redis-给缓存数据设置过期时间有啥用？"><a href="#Redis-给缓存数据设置过期时间有啥用？" class="headerlink" title="Redis 给缓存数据设置过期时间有啥用？"></a>Redis 给缓存数据设置过期时间有啥用？</h2><p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，会导致Out of memory。</p><p>并且很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在1分钟内有效，用户登录的 token 可能只在 1 天内有效。</p><h2 id="Redis是如何判断数据是否过期的呢？"><a href="#Redis是如何判断数据是否过期的呢？" class="headerlink" title="Redis是如何判断数据是否过期的呢？"></a>Redis是如何判断数据是否过期的呢？</h2><p>Redis 通过一个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是一个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。</p><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210221190028319.png" alt="image-20210221190028319"></p><h2 id="过期的数据的删除策略了解么？"><a href="#过期的数据的删除策略了解么？" class="headerlink" title="过期的数据的删除策略了解么？"></a>过期的数据的删除策略了解么？</h2><p>果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p><p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p><ol><li><strong>惰性删除</strong> ：只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。</li><li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期key操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li></ol><p>定期删除对内存更加友好，惰性删除对CPU更加友好。两者各有千秋，所以Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p><p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就Out of memory了。</p><p>怎么解决这个问题呢？答案就是： <strong>Redis 内存淘汰机制。</strong></p><h2 id="Redis-内存淘汰机制"><a href="#Redis-内存淘汰机制" class="headerlink" title="Redis 内存淘汰机制"></a><strong>Redis 内存淘汰机制</strong></h2><p>Redis 提供 6 种数据淘汰策略：</p><ol><li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li><li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0 版本后增加以下两种：</p><ol><li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li><li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li></ol><h2 id="Redis-持久化机制-怎么保证-Redis-挂掉之后再重启数据可以进行恢复"><a href="#Redis-持久化机制-怎么保证-Redis-挂掉之后再重启数据可以进行恢复" class="headerlink" title="Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)"></a>Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)</h2><p><strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。</p><p><strong>快照</strong></p><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p><p>快照持久化是 Redis 默认采用的持久化方式</p><p><strong>追加文件</strong></p><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。</p><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><p><strong>Redis 4.0 对于持久化机制的优化</strong></p><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p><p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>Redis 可以通过 <strong>MULTI，EXEC，DISCARD 和 WATCH</strong> 等命令来实现事务(transaction)功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line">&gt; INCR bar</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>使用 <a href="https://redis.io/commands/multi">MULTI</a>命令后可以输入多个命令。Redis不会立即执行这些命令，而是将它们放到队列，当调用了<a href="https://redis.io/commands/exec">EXEC</a>命令将执行所有命令。</p><p><strong>Redis 是不支持 roll back 的，因而不满足ACID中的原子性的（而且不满足持久性）。</strong></p><h2 id="什么是缓存穿透？解决办法？"><a href="#什么是缓存穿透？解决办法？" class="headerlink" title="什么是缓存穿透？解决办法？"></a>什么是缓存穿透？解决办法？</h2><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层</p><p><strong>缓存无效 key</strong></p><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p><p><strong>布隆过滤器</strong></p><p>把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210221191234025.png" alt="image-20210221191234025"></p><p>布隆过滤器可能误判 来看看他的原理</p><p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p><p>关于布隆过滤器：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md">https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md</a></p><h2 id="什么是缓存雪崩？解决方法？"><a href="#什么是缓存雪崩？解决方法？" class="headerlink" title="什么是缓存雪崩？解决方法？"></a>什么是缓存雪崩？解决方法？</h2><p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p><p>还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong></p><p><strong>解决方法</strong></p><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li></ol><h2 id="如何保证缓存和数据库数据的一致性？"><a href="#如何保证缓存和数据库数据的一致性？" class="headerlink" title="如何保证缓存和数据库数据的一致性？"></a>如何保证缓存和数据库数据的一致性？</h2><p>下面单独对 <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</p><p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p><p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p><ol><li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li><strong>增加cache更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li></ol><h2 id="缓存常用的3种读写策略"><a href="#缓存常用的3种读写策略" class="headerlink" title="缓存常用的3种读写策略"></a><strong>缓存常用的3种读写策略</strong></h2><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/3%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5">https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/3%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5</a></p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="RestController-vs-Controller"><a href="#RestController-vs-Controller" class="headerlink" title="@RestController vs @Controller"></a>@RestController vs @Controller</h2><p>单独使用 <code>@Controller</code> 不加 <code>@ResponseBody</code>的话一般使用在要返回一个视图的情况，这种情况属于比较传统的Spring MVC 的应用，对应于前后端不分离的情况。</p><p><code>@RestController</code>只返回对象，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Controller</span> + <span class="variable">@ResponseBody</span> = <span class="variable">@RestController</span></span><br></pre></td></tr></table></figure><h2 id="谈谈自己对于-Spring-IoC-和-AOP-的理解"><a href="#谈谈自己对于-Spring-IoC-和-AOP-的理解" class="headerlink" title="谈谈自己对于 Spring IoC 和 AOP 的理解"></a>谈谈自己对于 Spring IoC 和 AOP 的理解</h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p><strong>控制反转（Inversion of Control）</strong> 就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的<strong>依赖注入（Dependency Injection）</strong></p><p><strong>所谓依赖注入，就是把底层类作为参数传入上层类，实现上层类对下层类的“控制</strong>”。</p><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong></p><p><strong>IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p><p><strong>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的</strong></p><p>推荐阅读：<a href="https://www.zhihu.com/question/23277575/answer/169698662">https://www.zhihu.com/question/23277575/answer/169698662</a></p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却被业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>,在需要用到的地方直接使用即可,便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p><h2 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h2><p>了解一下aop原理</p><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p><h2 id="Spring-中的-bean-的作用域有哪些"><a href="#Spring-中的-bean-的作用域有哪些" class="headerlink" title="Spring 中的 bean 的作用域有哪些?"></a>Spring 中的 bean 的作用域有哪些?</h2><ul><li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li><li>prototype : 每次请求都会创建一个新的 bean 实例。</li><li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li><li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li><li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li></ul><h2 id="Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="Spring 中的单例 bean 的线程安全问题了解吗？"></a>Spring 中的单例 bean 的线程安全问题了解吗？</h2><p>的确是存在安全问题的。因为，当多个线程操作同一个对象的时候，对这个对象的成员变量的写操作会存在线程安全问题。</p><p>但是，一般情况下，我们常用的 <code>Controller</code>、<code>Service</code>、<code>Dao</code> 这些 Bean 是无状态的。无状态的 Bean 不能保存数据，因此是线程安全的。</p><p>常见的有 2 种解决办法：</p><ol><li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li><li>改变 Bean 的作用域为 “prototype”：每次请求都会创建一个新的 bean 实例，自然不会存在线程安全问题。</li></ol><h2 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h2><ol><li>作用对象不同: <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了Spring这是某个类的示例，当我需要用它的时候还给我。</li><li><code>@Bean</code> 注解比 <code>Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li></ol><h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a><a href="https://www.cnblogs.com/javazhiyin/p/10905294.html">bean的生命周期</a></h2><h2 id="spring框架中用到了哪些设计模式"><a href="#spring框架中用到了哪些设计模式" class="headerlink" title="*spring框架中用到了哪些设计模式"></a>*spring框架中用到了哪些设计模式</h2><p>关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN#rd">《面试官:“谈谈Spring中都用到了那些设计模式?”。》</a> 。</p><ul><li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li></ul><h2 id="管理事务的方式有几种"><a href="#管理事务的方式有几种" class="headerlink" title="管理事务的方式有几种"></a>管理事务的方式有几种</h2><ol><li><p><strong>Spring 有几种实现事务的方式？</strong></p><p>答：Spring 实现事务有两种方式：编程式事务和声明式事务。</p><p>编程式事务，使用 TransactionTemplate 或 PlatformTransactionManager 实现，示例代码如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// Spring编码式事务，回调机制</span></span><br><span class="line">    transactionTemplate.execute(<span class="keyword">new</span> TransactionCallback&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function">Object <span class="title">doInTransaction</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                userMapper.insertSelective(user);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 异常，设置为回滚</span></span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有异常，调用 status.setRollbackOnly() 回滚事务，否则正常执行 doInTransaction() 方法，正常提交事务。<br>如果事务控制的方法不需要返回值，就可以使用 TransactionCallbackWithoutResult（TransactionCallback 接口的抽象实现类）示例代码如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Spring编码式事务，回调机制</span></span><br><span class="line">    transactionTemplate.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                userMapper.insertSelective(user);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 异常，设置为回滚</span></span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>声明式事务，底层是建立在 Spring AOP 的基础上，在方式执行前后进行拦截，并在目标方法开始执行前创建新事务或加入一个已存在事务，最后在目标方法执行完后根据情况提交或者回滚事务。<br>声明式事务的优点：不需要编程，减少了代码的耦合，在配置文件中配置并在目标方法上添加 @Transactional 注解来实现，示例代码如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line"><span class="built_in">public</span> <span class="type">void</span> save() &#123;</span><br><span class="line">    <span class="keyword">User</span> <span class="keyword">user</span> = <span class="built_in">new</span> <span class="keyword">User</span>(&quot;laowang&quot;);</span><br><span class="line">    userMapper.insertSelective(<span class="keyword">user</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        throw <span class="built_in">new</span> RuntimeException(&quot;异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>抛出异常，事务会自动回滚，如果方法正常执行，则会自动提交事务。</p></li></ol><h2 id="你更倾向用那种事务管理类型？"><a href="#你更倾向用那种事务管理类型？" class="headerlink" title="你更倾向用那种事务管理类型？"></a>你更倾向用那种事务管理类型？</h2><p>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p><h2 id="spring事务的隔离级别有哪几种"><a href="#spring事务的隔离级别有哪几种" class="headerlink" title="spring事务的隔离级别有哪几种"></a>spring事务的隔离级别有哪几种</h2><p><strong>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</strong></p><ul><li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong> 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li><li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li><li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li><li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li><li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h2 id="Spring-中有哪几种事务传播行为"><a href="#Spring-中有哪几种事务传播行为" class="headerlink" title="Spring 中有哪几种事务传播行为?"></a>Spring 中有哪几种事务传播行为?</h2><p><strong>支持当前事务的情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li></ul><p><strong>不支持当前事务的情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><p><strong>其他情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li></ul><h2 id="Transactional-rollbackFor-Exception-class-注解了解吗？"><a href="#Transactional-rollbackFor-Exception-class-注解了解吗？" class="headerlink" title="@Transactional(rollbackFor = Exception.class)注解了解吗？"></a>@Transactional(rollbackFor = Exception.class)注解了解吗？</h2><p>当<code>@Transactional</code>注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p><p>在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</p><h2 id="如何使用JPA在数据库中非持久化一个字段？"><a href="#如何使用JPA在数据库中非持久化一个字段？" class="headerlink" title="如何使用JPA在数据库中非持久化一个字段？"></a>如何使用JPA在数据库中非持久化一个字段？</h2><p>假如我们有有下面一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Entity(name=<span class="string">&quot;USER&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(name=&quot;USER_NAME&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(name=&quot;PASSWORD&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String secrect;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想让<code>secrect</code> 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String transient1; <span class="comment">// not persistent because of static</span></span><br><span class="line"><span class="keyword">final</span> String transient2 = “Satish”; <span class="comment">// not persistent because of final</span></span><br><span class="line"><span class="keyword">transient</span> String transient3; <span class="comment">// not persistent because of transient</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line">String transient4; <span class="comment">// not persistent because of @TransientCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>一般使用后面两种方式比较多，我个人使用注解的方式比较多。</p><h2 id="Spring-IoC-的实现机制"><a href="#Spring-IoC-的实现机制" class="headerlink" title="Spring IoC 的实现机制"></a>Spring IoC 的实现机制</h2><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</p><p>可以把IOC容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言的的反射编程，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。</p><h2 id="BeanFactory-和-ApplicationContext有什么区别？"><a href="#BeanFactory-和-ApplicationContext有什么区别？" class="headerlink" title="BeanFactory 和 ApplicationContext有什么区别？"></a>BeanFactory 和 ApplicationContext有什么区别？</h2><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p><p>依赖关系</p><p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p><p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p><ul><li>继承MessageSource，因此支持国际化。</li><li>统一的资源文件访问方式。</li><li>提供在监听器中注册bean的事件。</li><li>同时加载多个配置文件。</li><li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li></ul><p><strong>加载方式</strong></p><p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p><p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p><p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p><p><strong>创建方式</strong></p><p>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p><p><strong>注册方式</strong></p><p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p><h2 id="ApplicationContext通常的实现是什么？"><a href="#ApplicationContext通常的实现是什么？" class="headerlink" title="ApplicationContext通常的实现是什么？"></a>ApplicationContext通常的实现是什么？</h2><p><strong>FileSystemXmlApplicationContext</strong> ：此容器从一个XML文件中加载beans的定义，必须把XML Bean配置文件的全路径名提供给它的构造函数。</p><p><strong>ClassPathXmlApplicationContext</strong>：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</p><p><strong>WebXmlApplicationContext</strong>：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</p><h2 id="怎么理解-Spring-中的依赖注入？"><a href="#怎么理解-Spring-中的依赖注入？" class="headerlink" title="怎么理解 Spring 中的依赖注入？"></a><strong>怎么理解 Spring 中的依赖注入？</strong></h2><p>答：依赖注入是指组件之间的依赖关系由容器在运行期决定，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是<strong>为了提升组件重用的频率</strong>，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><h2 id="有哪些不同类型的依赖注入实现方式？"><a href="#有哪些不同类型的依赖注入实现方式？" class="headerlink" title="有哪些不同类型的依赖注入实现方式？"></a>有哪些不同类型的依赖注入实现方式？</h2><p>依赖注入是时下最流行的IoC实现方式，依赖注入分为接口注入（Interface Injection），Setter方法注入（Setter Injection）和构造器注入（Constructor Injection）三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。</p><p><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p><p><strong>Setter方法注入</strong>：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="keyword">class</span>=&quot;top.bigking.bean.Book&quot; id=&quot;book&quot;&gt;</span><br><span class="line">          &lt;constructor-arg <span class="keyword">index</span>=&quot;0&quot; <span class="keyword">value</span>=&quot;1&quot;/&gt;</span><br><span class="line">          &lt;constructor-arg <span class="keyword">index</span>=&quot;1&quot; <span class="keyword">value</span>=&quot;哈利波特&quot;/&gt;</span><br><span class="line">          &lt;constructor-arg <span class="keyword">index</span>=&quot;2&quot; <span class="keyword">value</span>=&quot;18.8&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean <span class="keyword">class</span>=&quot;top.bigking.bean.Book&quot; id=&quot;book&quot;&gt;</span><br><span class="line"> &lt;property <span class="type">name</span>=&quot;id&quot; <span class="keyword">value</span>=&quot;1&quot;/&gt;</span><br><span class="line">         &lt;property <span class="type">name</span>=&quot;bookname&quot; <span class="keyword">value</span>=&quot;哈利波特&quot; /&gt;</span><br><span class="line">         &lt;property <span class="type">name</span>=&quot;price&quot; <span class="keyword">value</span>=&quot;18.8&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="构造器依赖注入和-Setter方法注入的区别"><a href="#构造器依赖注入和-Setter方法注入的区别" class="headerlink" title="构造器依赖注入和 Setter方法注入的区别"></a>构造器依赖注入和 Setter方法注入的区别</h2><table><thead><tr><th><strong>构造函数注入</strong></th><th><strong>setter</strong> <strong>注入</strong></th></tr></thead><tbody><tr><td>没有部分注入</td><td>有部分注入</td></tr><tr><td>不会覆盖 setter 属性</td><td>会覆盖 setter 属性</td></tr><tr><td>任意修改都会创建一个新实例</td><td>任意修改不会创建一个新实例</td></tr><tr><td>适用于设置很多属性</td><td>适用于设置少量属性</td></tr></tbody></table><h2 id="使用-Autowired注解自动装配的过程是怎样的？"><a href="#使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="使用@Autowired注解自动装配的过程是怎样的？"></a>使用@Autowired注解自动装配的过程是怎样的？</h2><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。</p><p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p><ul><li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li><li>如果查询的结果不止一个，那么@Autowired会根据名称进行匹配；</li><li>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。</li></ul><h2 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h2><p>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</p><p>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</p><p>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</p><p>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p><h2 id="Autowired和-Resource之间的区别"><a href="#Autowired和-Resource之间的区别" class="headerlink" title="@Autowired和@Resource之间的区别"></a>@Autowired和@Resource之间的区别</h2><p>@Autowired可用于：构造函数、成员变量、Setter方法</p><p>@Autowired和@Resource之间的区别</p><ul><li>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</li><li>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</li></ul><h2 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h2><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：</p><ul><li>类级别：映射请求的 URL</li><li>方法级别：映射 URL 以及 HTTP 请求方法</li></ul><h2 id="解释一下Spring-AOP里面的几个名词"><a href="#解释一下Spring-AOP里面的几个名词" class="headerlink" title="解释一下Spring AOP里面的几个名词"></a>解释一下Spring AOP里面的几个名词</h2><ul><li>通知（Advice）: AOP 框架中的增强处理。通知描述了切面何时执行以及如何执行增强处理。</li><li>连接点（join point）: 连接点表示应用执行过程中能够插入切面的一个点，这个点可以是方法的调用、异常的抛出。在 Spring AOP 中，连接点总是方法的调用。</li><li>切点（PointCut）: 可以插入增强处理的连接点。</li><li>切面（Aspect）: 切面是通知和切点的结合。</li><li>引入（Introduction）：引入允许我们向现有的类添加新的方法或者属性。</li><li>织入（Weaving）: 将增强处理添加到目标对象中，并创建一个被增强的对象，这个过程就是织入。</li></ul><p>连接点和切点的区别</p><ul><li><p>连接点：连接点是一个虚拟的概念，可以理解为所有满足切点扫描条件的所有的时机。</p></li><li><p>具体举个例子：比如开车经过一条高速公路，这条高速公路上有很多个出口（连接点），但是我们不会每个出口都会出去，只会选择我们需要的那个出口（切点）开出去。</p></li></ul><h2 id="Spring通知有哪些类型？"><a href="#Spring通知有哪些类型？" class="headerlink" title="Spring通知有哪些类型？"></a>Spring通知有哪些类型？</h2><p>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p><p>Spring切面可以应用5种类型的通知：</p><ol><li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li><li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li><li>返回通知（After-returning ）：在目标方法成功执行之后调用通知；</li><li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li><li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li></ol><p>同一个aspect，不同advice的执行顺序：</p><p>①没有异常情况下的执行顺序：</p><p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterReturning</p><p>②有异常情况下的执行顺序：异常通知会出现在返回通知后面</p><p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterThrowing:异常发生<br>java.lang.RuntimeException: 异常发生</p><h2 id="Value-注解的作用是什么？"><a href="#Value-注解的作用是什么？" class="headerlink" title="@Value 注解的作用是什么？"></a><strong>@Value 注解的作用是什么？</strong></h2><p>答：基于 @Value 的注解可以读取 properties 配置文件</p><h2 id="Spring-的-JdbcTemplate-对象和-JDBC-有什么区别？"><a href="#Spring-的-JdbcTemplate-对象和-JDBC-有什么区别？" class="headerlink" title="Spring 的 JdbcTemplate 对象和 JDBC 有什么区别？"></a><strong>Spring 的 JdbcTemplate 对象和 JDBC 有什么区别？</strong></h2><p>答：Spring 的 JdbcTemplate 是对 JDBC API 的封装，提供更多的功能和更便利的操作，比如 JdbcTemplate 拥有：</p><ul><li>线程安全</li><li>实例化操作比较简单，仅需要传递 DataSource；</li><li>自动完成资源的创建和释放工作；</li><li>创建一次 JdbcTemplate，到处可用，避免重复开发。</li></ul><h2 id="关于MVC"><a href="#关于MVC" class="headerlink" title="关于MVC"></a>关于MVC</h2><p>MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。</p><h2 id="MVC工作原理"><a href="#MVC工作原理" class="headerlink" title="MVC工作原理"></a>MVC工作原理</h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210224151018792.png" alt="image-20210224151018792"></p><p>上图的一个笔误的小问题：Spring MVC 的入口函数也就是前端控制器 <code>DispatcherServlet</code> 的作用是接收请求，响应结果。</p><p><strong>流程说明（重要）：</strong></p><ol><li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li><li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li><li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li><li><code>HandlerAdapter</code> 会根据 <code>Handler </code>来调用真正的处理器来处理请求，并处理相应的业务逻辑。</li><li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li><li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li><li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li><li>把 <code>View</code> 返回给请求者（浏览器）</li></ol><h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><h2 id="为什么不从页面使用js给es发送请求-这样就不用后端了？"><a href="#为什么不从页面使用js给es发送请求-这样就不用后端了？" class="headerlink" title="为什么不从页面使用js给es发送请求 这样就不用后端了？"></a>为什么不从页面使用js给es发送请求 这样就不用后端了？</h2><ol><li>ES属于后端集群服务器 端口一般不对外暴漏 防止出现安全隐患</li><li>js支持率低</li></ol><h2 id="shard和replica机制"><a href="#shard和replica机制" class="headerlink" title="shard和replica机制"></a>shard和replica机制</h2><p>index包含多个shard.<br>每个shard都是一个最小工作单元，承载部分数据，lucene实例，完整的建立索引和处理请求的能力.<br>增减节点时，shard会自动在nodes中负载均衡.<br>primary shard和replica shard，每个document肯定只存在于某一个primary shard以及其对应的replica shard中，不可能存在于多个primary shard.<br>replica shard是primary shard的副本，负责容错，以及承担读请求负载.<br>primary shard的数量在创建索引的时候就固定了，replica shard的数量可以随时修改.<br>primary shard不能和自己的replica shard放在同一个节点上（否则节点宕机，primary shard和副本都丢失，起不到容错的作用），但是可以和其他primary shard的replica shard放在同一个节点上.</p><h2 id="ES路由算法"><a href="#ES路由算法" class="headerlink" title="ES路由算法"></a>ES路由算法</h2><p>document创建的时候路由就需要决定放在哪个shard  一个document只能存在于一个shard上</p><p>路由算法：shard = hash(routing) % number_of_primary_shards</p><p>举例</p><p>一个index有3个primary shard，P0，P1，P2<br>每次增删改查一个document的时候，都会带过来一个routing number（默认就是这个document的_id（可能是手动指定，也可能是自动生成））<br>routing = _id，假设_id=1</p><p>会将这个routing值，传入一个hash函数中，产出一个routing值的hash值，hash(routing) = 21<br>然后将hash函数产出的值对这个index的primary shard的数量求余数，21 % 3 = 0<br>就决定了，这个document就放在P0上。</p><h2 id="ES写过程"><a href="#ES写过程" class="headerlink" title="ES写过程"></a>ES写过程</h2><ul><li>客户端选择一个 node作为 <code>coordinating node</code>（协调节点）发送请求</li><li><code>coordinating node</code> 对 document 进行路由，将请求转发给对应的 node</li><li>实际的 node 上的 <code>primary shard</code> 处理请求，然后将数据同步到相应node上的<code>replica shard</code>。</li><li><code>coordinating node</code> 如果发现 <code>primary shard</code> 和所有 <code>replica shard</code> 都搞定之后，就返回响应结果给客户端。</li></ul><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210302130227926.png" alt="image-20210302130227926"></p><p>底层原理：</p><ol><li>在到达primary shard的时候 ，数据先写入内存buffer ，此时在buffer里的数据是不会被搜索到的。同时生成一个translog日志文件 ， 将数据写入translog里</li><li>如果内存buffer空间快满了，就会将数据refresh到一个新的segment file文件中，而且es里每隔1s就会将buffer里的数据写入到一个新的segment file中，这个segment file就存储最最近1s中buffer写入的数据，如果buffer里面没有数据，就不会执行refresh操作，当建立segment file文件的时候，就同时建立好了倒排索引库。</li><li>在buffer refresh到segment之前 ，会先进入到一个叫os cache中，只要被执行了refresh操作，就代表这个数据可以被搜索到了。数据被输入os cache中，buffer就会被清空了，所以为什么叫es是准实时的？NRT，near real-time，准实时。默认是每隔1秒refresh一次的，所以es是准实时的，因为写入的数据1秒之后才能被看到。还可以通过es的restful api或者java api，手动执行一次refresh操作，就是手动将buffer中的数据刷入os cache中，让数据立马就可以被搜索到。</li><li>就这样新的数据不断进入buffer和translog，不断将buffer数据写入一个又一个新的segment file中去，每次refresh完buffer清空，translog保留。随着这个过程推进，translog会变得越来越大。当translog达到一定长度的时候，就会触发commit操作。translog也是先进入os cache中，然后每隔5s持久化到translog到磁盘中，</li><li>commit操作，第一步，就是将buffer中现有数据refresh到os cache中去，清空buffer 每隔30分钟flush</li><li>es也有可能会数据丢失 ，有5s的数据停留在buffer、translog os cache, segment file os cache中，如果此时宕机，这5s的数据就会丢失，如果项目要求比较高，不能丢失数据，就可以设置参数，每次写入一条数据写入buffer，同时写入translog磁盘文件中，但这样做会使es的性能降低。</li><li>如果是删除操作，commit操作的时候就会生成一个.del文件，将这个document标识为deleted状态，在搜索的搜索的时候就不会被搜索到了。</li><li>如果是更新操作，就是将原来的document标识为deleted状态，然后新写入一条数据</li><li>buffer每次refresh一次，就会产生一个segment file，所以默认情况下是1秒钟一个segment file，segment file会越来越多，当躲到一定程度的时候，es就会自动触发merge(合并)造作，将所有segment file文件 merge成一个segment file，并同时物理删除掉标识为deleted的doc</li></ol><h2 id="ES索引文档过程"><a href="#ES索引文档过程" class="headerlink" title="ES索引文档过程"></a>ES索引文档过程</h2><ul><li>客户端选择一个 node作为 <code>coordinating node</code>发送请求</li><li><code>coordinate node</code> 对 <code>doc id</code> 进行哈希路由，将请求转发到对应的 node，此时会使用 <code>round-robin</code>随机轮询算法，在 <code>primary shard</code> 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li><li>接收请求的 node 返回 document 给 <code>coordinate node</code>。</li><li><code>coordinate node</code> 返回 document 给客户端。</li></ul><h2 id="es-搜索数据过程"><a href="#es-搜索数据过程" class="headerlink" title="es 搜索数据过程"></a>es 搜索数据过程</h2><p>是指search，search和普通doc id get的背后逻辑不一样</p><p>es 最强大的是做全文检索，就是比如你有三条数据：</p><ul><li><code>java真好玩儿啊</code></li><li><code>java好难学啊</code></li><li><code>j2ee特别牛</code></li></ul><p>你根据 <code>java</code> 关键词来搜索，将包含 <code>java</code>的 <code>document</code> 给搜索出来。es 就会给你返回：java真好玩儿啊，java好难学啊。</p><ul><li><p>搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch；</p></li><li><p>在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。PS：在搜索的时候是会查询Filesystem Cache的，但是有部分数据还在Memory Buffer，所以搜索是近实时的。</p></li><li><p>每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</p></li><li><p>接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并 丰富 文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。</p></li></ul><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>倒排索引，就是建立词语与文档的对应关系（词语在什么文档出现，出现了多少次，在什么位置出现）</p><p>搜索的时候，根据搜索关键词，直接在索引中找到对应关系，搜索速度快。</p><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210302131654376.png" alt="image-20210302131654376"></p><p>doc:表示哪个文档，frep：表示出现的频率，pos：表示出现的位置</p><h2 id="为什么要使用Elasticsearch"><a href="#为什么要使用Elasticsearch" class="headerlink" title="为什么要使用Elasticsearch?"></a>为什么要使用Elasticsearch?</h2><p> 　　因为在我们商城中的数据，将来会非常多，所以采用以往的模糊查询，模糊查询前置配置，会放弃索引，导致商品查询是全表扫面，在百万级别的数据库中，效率非常低下，而我们使用ES做一个全文索引，我们将经常查询的商品的某些字段，比如说商品名，描述、价格还有id这些字段我们放入我们索引库里，可以提高查询速度。</p><h2 id="ES选举机制"><a href="#ES选举机制" class="headerlink" title="ES选举机制"></a><a href="https://www.cnblogs.com/zziawanblog/p/6577383.html">ES选举机制</a></h2><p>​    对所有可以成为master的节点（node.master: true）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。<br>​    如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。</p><h2 id="Elasticsearch是如何避免脑裂现象的"><a href="#Elasticsearch是如何避免脑裂现象的" class="headerlink" title="Elasticsearch是如何避免脑裂现象的"></a>Elasticsearch是如何避免脑裂现象的</h2><p>当集群中master候选的个数不小于3个（node.master: true）。可以通过discovery.zen.minimum_master_nodes 这个参数的设置来避免脑裂，设置为(N/2)+1。</p><p>当候选数量为两个时，只能修改为唯一的一个master候选，其他作为data节点，避免脑裂问题。   </p><h2 id="在并发情况下，Elasticsearch如果保证读写一致？"><a href="#在并发情况下，Elasticsearch如果保证读写一致？" class="headerlink" title="在并发情况下，Elasticsearch如果保证读写一致？"></a>在并发情况下，Elasticsearch如果保证读写一致？</h2><ul><li>可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；</li><li>另外对于写操作，一致性级别支持quorum/one/all，默认为quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本 败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</li><li>对于读操作，可以设置replication为sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置replication为async时，也可以通过设置搜索请求参数_preference为primary来查询主分片，确保文档是最新版本。</li></ul><h2 id="es-在数据量很大的情况下（数十亿级别）如何提高查询效率"><a href="#es-在数据量很大的情况下（数十亿级别）如何提高查询效率" class="headerlink" title="es 在数据量很大的情况下（数十亿级别）如何提高查询效率"></a><a href="https://www.jianshu.com/p/fa510352ce1a">es 在数据量很大的情况下（数十亿级别）如何提高查询效率</a></h2><h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><h2 id="什么是dubbo"><a href="#什么是dubbo" class="headerlink" title="什么是dubbo"></a>什么是dubbo</h2><p>是一款高性能、轻量级的开源Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p><h2 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC?"></a>什么是 RPC?</h2><p>RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求当然可以，但是可能会比较麻烦。 RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。</p><h2 id="RPC原理是什么"><a href="#RPC原理是什么" class="headerlink" title="RPC原理是什么?"></a>RPC原理是什么?</h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210304142357573.png" alt="image-20210304142357573"></p><ol><li>服务消费方（client）调用以本地调用方式调用服务；</li><li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li><li>client stub找到服务地址，并将消息发送到服务端；</li><li>server stub收到消息后进行解码；</li><li>server stub根据解码结果调用本地的服务；</li><li>本地服务执行并将结果返回给server stub；</li><li>server stub将返回结果打包成消息并发送至消费方；</li><li>client stub接收到消息，并进行解码；</li><li>服务消费方得到最终结果。</li></ol><h2 id="为什么要用dubbo"><a href="#为什么要用dubbo" class="headerlink" title="为什么要用dubbo"></a>为什么要用dubbo</h2><ol><li><strong>负载均衡</strong>——同一个服务部署在不同的机器时该调用哪一台机器上的服务。</li><li><strong>服务调用链路生成</strong>——随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。</li><li><strong>服务访问压力以及时长统计、资源调度和治理</strong>——基于访问压力实时管理集群容量，提高集群利用率。</li><li><strong>服务降级</strong>——某个服务挂掉之后调用备用服务。</li></ol><p>另外，Dubbo 除了能够应用在分布式系统中，也可以应用在现在比较火的微服务系统中。不过，由于 Spring Cloud 在微服务中应用更加广泛，所以，我觉得一般我们提 Dubbo 的话，大部分是分布式系统的情况。</p><h2 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h2><p>分布式重要的就是面向服务，说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上。</p><h2 id="为什么要分布式"><a href="#为什么要分布式" class="headerlink" title="为什么要分布式"></a>为什么要分布式</h2><p>每个团队可以负责一个服务的开发，这样提升了开发效率。另外，代码根据业务拆分之后更加便于维护和扩展。</p><p>另外，我觉得将系统拆分成分布式之后不光便于系统扩展和维护，更能提高整个系统的性能。</p><h2 id="dubbo架构"><a href="#dubbo架构" class="headerlink" title="dubbo架构"></a>dubbo架构</h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210304142742968.png" alt="image-20210304142742968"></p><p><strong>调用关系说明：</strong></p><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><p><strong>重要知识点总结：</strong></p><ul><li><strong>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小</strong></li><li><strong>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示</strong></li><li><strong>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外</strong></li><li><strong>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</strong></li><li><strong>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表</strong></li><li><strong>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者</strong></li><li><strong>服务提供者无状态，任意一台宕掉后，不影响使用</strong></li><li><strong>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</strong></li></ul><h2 id="dubbo的负载均衡策略"><a href="#dubbo的负载均衡策略" class="headerlink" title="dubbo的负载均衡策略"></a>dubbo的负载均衡策略</h2><p><strong>Random LoadBalance(默认，基于权重的随机负载均衡机制)</strong></p><ul><li><strong>随机，按权重设置随机概率。</strong></li><li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li></ul><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-7/77722327.jpg" alt="基于权重的随机负载均衡机制"></p><p><strong>RoundRobin LoadBalance(不推荐，基于权重的轮询负载均衡机制)</strong></p><ul><li>轮循，按公约后的权重设置轮循比率。</li><li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li></ul><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-7/97933247.jpg" alt="基于权重的轮询负载均衡机制"></p><p><strong>LeastActive LoadBalance</strong></p><ul><li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</li><li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li></ul><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210304143246234.png" alt="image-20210304143246234"></p><p><strong>ConsistentHash LoadBalance</strong></p><ul><li><strong>一致性 Hash，相同参数的请求总是发到同一提供者。(如果你需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性hash策略。)</strong></li><li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。<img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210304143304760.png" alt="image-20210304143304760"></li></ul><p><strong>xml 配置方式</strong></p><p>服务端服务级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service <span class="class"><span class="keyword">interface</span></span>=<span class="string">&quot;...&quot;</span> loadbalance=<span class="string">&quot;roundrobin&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>客户端服务级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference <span class="class"><span class="keyword">interface</span></span>=<span class="string">&quot;...&quot;</span> loadbalance=<span class="string">&quot;roundrobin&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>服务端方法级别</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service <span class="class"><span class="keyword">interface</span></span>=<span class="string">&quot;...&quot;</span>&gt;</span><br><span class="line">    &lt;dubbo:method name=<span class="string">&quot;...&quot;</span> loadbalance=<span class="string">&quot;roundrobin&quot;</span>/&gt;</span><br><span class="line">&lt;/dubbo:service&gt;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>客户端方法级别</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference <span class="class"><span class="keyword">interface</span></span>=<span class="string">&quot;...&quot;</span>&gt;</span><br><span class="line">    &lt;dubbo:method name=<span class="string">&quot;...&quot;</span> loadbalance=<span class="string">&quot;roundrobin&quot;</span>/&gt;</span><br><span class="line">&lt;/dubbo:reference&gt;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>注解配置方式：</strong></p><p>消费方基于基于注解的服务级别配置方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reference(loadbalance = &quot;roundrobin&quot;)</span></span><br><span class="line">HelloService helloService;</span><br></pre></td></tr></table></figure><h2 id="zookeeper宕机与dubbo直连的情况"><a href="#zookeeper宕机与dubbo直连的情况" class="headerlink" title="zookeeper宕机与dubbo直连的情况"></a>zookeeper宕机与dubbo直连的情况</h2><p>在实际生产中，假如zookeeper注册中心宕掉，一段时间内服务消费方还是能够调用提供方的服务的，实际上它使用的本地缓存进行通讯，这只是dubbo健壮性的一种体现。</p><p><strong>dubbo的健壮性表现：</strong></p><ol><li>监控中心宕掉不影响使用，只是丢失部分采样数据</li><li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li><li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li><li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</li><li>服务提供者无状态，任意一台宕掉后，不影响使用</li><li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li></ol><p><strong>xml配置方式：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.zang.gmall.service.UserService&quot;</span> <span class="attr">url</span>=<span class="string">&quot;dubbo://localhost:20880&quot;</span> /&gt;</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>注解方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reference(url = &quot;127.0.0.1:20880&quot;)</span>   </span><br><span class="line">HelloService helloService;</span><br></pre></td></tr></table></figure><h2 id="Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？"><a href="#Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？" class="headerlink" title="Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？"></a>Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？</h2><p><strong>答</strong>：可以通信的，启动dubbo时，消费者会从zk拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用；</p><h2 id="Dubbo在安全机制方面是如何解决的"><a href="#Dubbo在安全机制方面是如何解决的" class="headerlink" title="Dubbo在安全机制方面是如何解决的"></a>Dubbo在安全机制方面是如何解决的</h2><p><strong>答：</strong> Dubbo通过Token令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo还提供服务黑白名单，来控制服务所允许的调用方。</p><h2 id="dubbo通信协议dubbo协议为什么要消费者比提供者个数多"><a href="#dubbo通信协议dubbo协议为什么要消费者比提供者个数多" class="headerlink" title="dubbo通信协议dubbo协议为什么要消费者比提供者个数多"></a>dubbo通信协议dubbo协议为什么要消费者比提供者个数多</h2><p>答： 因dubbo协议采用单一长连接，假设网络为千兆网卡(1024Mbit=128MByte)，<br>根据测试经验数据每条连接最多只能压满7MByte(不同的环境可能不一样，供参考)，理论上1个服务提供者需要20个服务消费者才能压满网卡。</p><h2 id="dubbo通信协议dubbo协议为什么采用异步单一长连接"><a href="#dubbo通信协议dubbo协议为什么采用异步单一长连接" class="headerlink" title="dubbo通信协议dubbo协议为什么采用异步单一长连接"></a>dubbo通信协议dubbo协议为什么采用异步单一长连接</h2><p>答： 因为服务的现状大都是服务提供者少，通常只有几台机器，而服务的消费者多，可能整个网站都在访问该服务，如果采用常规的hessian服务，服务提供者很容易就被压跨，通过单一连接，保证单一消费者不会压死提供者，长连接，减少连接握手验证等，并使用异步IO，复用线程池，防止C10K问题。</p><h1 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h1><h2 id="ZooKeeper-是什么？"><a href="#ZooKeeper-是什么？" class="headerlink" title="ZooKeeper 是什么？"></a>ZooKeeper 是什么？</h2><p>ZooKeeper 是一个开源的分布式协调服务。它是一个为分布式应用提供一致性服务的软件，分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。</p><p>Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据</p><h2 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h2><p>client端会对某个znode建立一个watcher事件，当该znode发生变化时，这些client会收到zk的通知，然后client可以根据znode变化来做出业务上的改变等。</p><h2 id="Zookeeper-怎么保证主从节点的状态同步？"><a href="#Zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="Zookeeper 怎么保证主从节点的状态同步？"></a>Zookeeper 怎么保证主从节点的状态同步？</h2><p>Zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。</p><p>恢复模式<br>当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p><p>广播模式<br>一旦 leader 已经和多数的 follower 进行了状态同步后，它就可以开始广播消息了，即进入广播状态。这时候当一个 server 加入 ZooKeeper 服务中，它会在恢复模式下启动，发现 leader，并和 leader 进行状态同步。待到同步结束，它也参与消息广播。ZooKeeper 服务一直维持在 Broadcast 状态，直到 leader 崩溃了或者 leader 失去了大部分的 followers 支持。</p><h2 id="四种类型的数据节点-Znode"><a href="#四种类型的数据节点-Znode" class="headerlink" title="四种类型的数据节点 Znode"></a>四种类型的数据节点 Znode</h2><p>（1）PERSISTENT-持久节点</p><p>（2）EPHEMERAL-临时节点</p><p>（3）PERSISTENT_SEQUENTIAL-持久顺序节点</p><p>（4）EPHEMERAL_SEQUENTIAL-临时顺序节点</p><h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><table><thead><tr><th>注册方式</th><th>Created</th><th>ChildChanged</th><th>Changed</th><th>Deleted</th></tr></thead><tbody><tr><td>zk.exists(“/nodex”,watcher)</td><td>可监控</td><td></td><td>可监控</td><td>可监控</td></tr><tr><td>zk.getData(“/nodex”,watcher)</td><td></td><td></td><td>可监控</td><td>可监控</td></tr><tr><td>zk.getChildren(“/nodex”,watcher)</td><td></td><td>可监控</td><td></td><td>可监控</td></tr></tbody></table><h2 id="Watcher-机制-–-数据变更通知"><a href="#Watcher-机制-–-数据变更通知" class="headerlink" title="Watcher 机制 – 数据变更通知"></a>Watcher 机制 – 数据变更通知</h2><p>Zookeeper 允许客户端向服务端的某个 Znode 注册一个 Watcher 监听，当服务端的一些指定事件触发了这个 Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据 Watcher 通知状态和事件类型做出业务上的改变。</p><p>工作机制：</p><p>（1）客户端注册 watcher</p><p>（2）服务端处理 watcher</p><p>（3）客户端回调 watcher</p><h2 id="服务器角色"><a href="#服务器角色" class="headerlink" title="服务器角色"></a>服务器角色</h2><p>Leader</p><p>（1）事务请求的唯一调度和处理者，保证集群事务处理的顺序性</p><p>（2）集群内部各服务的调度者</p><p>Follower</p><p>（1）处理客户端的非事务请求，转发事务请求给 Leader 服务器</p><p>（2）参与事务请求 Proposal 的投票</p><p>（3）参与 Leader 选举投票</p><p>Observer</p><p>（1）3.0 版本以后引入的一个服务器角色，在不影响集群事务处理能力的基础上提升集群的非事务处理能力</p><p>（2）处理客户端的非事务请求，转发事务请求给 Leader 服务器</p><p>（3）不参与任何形式的投票</p><h2 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h2><p>（1）LOOKING：寻 找 Leader 状态。当服务器处于该状态时，它会认为当前集群中没有 Leader，因此需要进入 Leader 选举状态。</p><p>（2）FOLLOWING：跟随者状态。表明当前服务器角色是 Follower。</p><p>（3）LEADING：领导者状态。表明当前服务器角色是 Leader。</p><p>（4）OBSERVING：观察者状态。表明当前服务器角色是 Observer。</p><h2 id="zookeeper-是如何保证事务的顺序一致性的？"><a href="#zookeeper-是如何保证事务的顺序一致性的？" class="headerlink" title="zookeeper 是如何保证事务的顺序一致性的？"></a>zookeeper 是如何保证事务的顺序一致性的？</h2><p>zookeeper 采用了全局递增的事务id来标识，所有的 proposal（提议）都在被提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（ 时期; 纪元; 世; 新时代）用来标识 leader 周期，如果有新的 leader 产生出来，epoch会自增，低 32 位用来递增计数。当新产生 proposal 的时候，会依据数据库的两阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。</p><h2 id="分布式集群中为什么会有-Master主节点？"><a href="#分布式集群中为什么会有-Master主节点？" class="headerlink" title="分布式集群中为什么会有 Master主节点？"></a>分布式集群中为什么会有 Master主节点？</h2><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行 leader 选举。</p><h2 id="zk节点宕机如何处理？"><a href="#zk节点宕机如何处理？" class="headerlink" title="zk节点宕机如何处理？"></a>zk节点宕机如何处理？</h2><p>Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保证当一个节点宕机时，其他节点会继续提供服务。</p><p>如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数据是有多个副本的，数据并不会丢失；</p><p>如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。</p><p>ZK 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZK节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。</p><h2 id="集群最少要几台机器，集群规则是怎样的？集群中有-3-台服务器，其中一个节点宕机，这个时候-Zookeeper-还可以使用吗？"><a href="#集群最少要几台机器，集群规则是怎样的？集群中有-3-台服务器，其中一个节点宕机，这个时候-Zookeeper-还可以使用吗？" class="headerlink" title="集群最少要几台机器，集群规则是怎样的？集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗？"></a>集群最少要几台机器，集群规则是怎样的？集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗？</h2><p>集群规则为 2N+1 台，N&gt;0，即 3 台。可以继续使用，单数服务器只要没超过一半的服务器宕机就可以</p><h2 id="Zookeeper-对节点的-watch-监听通知是永久的吗？为什么不是永久的"><a href="#Zookeeper-对节点的-watch-监听通知是永久的吗？为什么不是永久的" class="headerlink" title="Zookeeper 对节点的 watch 监听通知是永久的吗？为什么不是永久的?"></a>Zookeeper 对节点的 watch 监听通知是永久的吗？为什么不是永久的?</h2><p>不是。官方声明：一个 Watch 事件是一个一次性的触发器，当被设置了 Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端，以便通知它们。</p><p>为什么不是永久的，举个例子，如果服务端变动频繁，而监听的客户端很多情况下，每次变动都要通知到所有的客户端，给网络和服务器造成很大压力。</p><h2 id="获取分布式锁"><a href="#获取分布式锁" class="headerlink" title="获取分布式锁"></a>获取分布式锁</h2><p>在获取分布式锁的时候在locker节点下创建临时顺序节点，释放锁的时候删除该临时节点。客户端调用createNode方法在locker下创建临时顺序节点，<br>然后调用getChildren(“locker”)来获取locker下面的所有子节点，注意此时不用设置任何Watcher。客户端获取到所有的子节点path之后，如果发现自己创建的节点在所有创建的子节点序号最小，那么就认为该客户端获取到了锁。如果发现自己创建的节点并非locker所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到*<strong>比自己小的那个节点*</strong>，然后对其调用*<strong>exist()*</strong>方法，同时对其注册事件监听器。之后，让这个被关注的节点删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是locker子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。当前这个过程中还需要许多的逻辑判断。</p><h2 id="队列管理"><a href="#队列管理" class="headerlink" title="队列管理"></a>队列管理</h2><p>两种类型的队列：<br>1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。<br>2、队列按照 FIFO 方式进行入队和出队操作。<br>第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。<br>第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建<strong>PERSISTENT_SEQUENTIAL</strong>节点，创建成功时<strong>Watcher</strong>通知等待的队列，队列删除序列号最小的节点用以消费。此场景下Zookeeper的znode用于消息存储，znode存储的数据就是消息队列中的消息内容，SEQUENTIAL序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以不必担心队列消息的丢失问题</p><h2 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h2><p>Zookeeper作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。数据复制的好处： 1、容错：一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作； 2、提高系统的扩展能力 ：把负载分布到多个节点上，或者增加节点来提高系统的负载能力； 3、提高性能：让客户端本地访问就近的节点，提高用户访问速度。 </p><p>从客户端读写访问的透明度来看，数据复制集群系统分下面两种：</p><p> 1、写主(WriteMaster) ：对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离； </p><p>2、写任意(Write Any)：对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。</p><p> 对zookeeper来说，它采用的方式是写任意。通过增加机器，读的吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立observer的原因），而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。</p><h2 id="选举leader"><a href="#选举leader" class="headerlink" title="选举leader"></a>选举leader</h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210307130548201.png" alt="image-20210307130548201"></p><h2 id="一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗？"><a href="#一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗？" class="headerlink" title="一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗？"></a>一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗？</h2><p>ZooKeeper不能确保任何客户端能够获取（即Read Request）到一样的数据，除非客户端自己要求，方法是客户端在获取数据之前调用sync方法进行同步。 </p><h2 id="能否为临时节点创建子节点？"><a href="#能否为临时节点创建子节点？" class="headerlink" title="能否为临时节点创建子节点？"></a>能否为临时节点创建子节点？</h2><p>ZooKeeper中不能为临时节点创建子节点，如果需要创建子节点，应该将要创建子节点的节点创建为永久性节点。</p><h2 id="创建的临时节点什么时候会被删除，是连接一断就删除吗？"><a href="#创建的临时节点什么时候会被删除，是连接一断就删除吗？" class="headerlink" title="创建的临时节点什么时候会被删除，是连接一断就删除吗？"></a>创建的临时节点什么时候会被删除，是连接一断就删除吗？</h2><p>连接断了之后，ZK不会马上移除临时数据，只有当SESSIONEXPIRED之后，才会把这个会话建立的临时数据移除。</p><h2 id="ZooKeeper集群中服务器之间是怎样通信的？"><a href="#ZooKeeper集群中服务器之间是怎样通信的？" class="headerlink" title="ZooKeeper集群中服务器之间是怎样通信的？"></a>ZooKeeper集群中服务器之间是怎样通信的？</h2><p>Leader服务器会和每一个Follower/Observer服务器都建立TCP连接，同时为每个F/O都创建一个叫做LearnerHandler的实体。LearnerHandler主要负责Leader和F/O之间的网络通讯，包括数据同步，请求转发和Proposal提议的投票等。Leader服务器保存了所有F/O的LearnerHandler。</p><h2 id="ZooKeeper使用的ZAB协议与Paxo算法的异同？"><a href="#ZooKeeper使用的ZAB协议与Paxo算法的异同？" class="headerlink" title="ZooKeeper使用的ZAB协议与Paxo算法的异同？"></a>ZooKeeper使用的ZAB协议与Paxo算法的异同？</h2><p>Paxos算法是分布式选举算法，Zookeeper使用的 ZAB协议（Zookeeper原子广播），两者的异同如下：</p><pre><code>① 相同之处：     比如都有一个Leader，用来协调N个Follower的运行；Leader要等待超半数的Follower做出正确反馈之后才进行提案；二者都有一个值来代表Leader的周期。 ② 不同之处：     ZAB用来构建高可用的分布式数据主备系统（Zookeeper），Paxos是用来构建分布式一致性状态机系统。</code></pre><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h2><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p><p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p><ul><li><code>@Configuration</code>：允许在上下文中注册额外的 bean 或导入其他配置类</li></ul><p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</p><p>@ComponentScan：扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。如下图所示，容器中将排除<code>TypeExcludeFilter</code>和<code>AutoConfigurationExcludeFilter</code>。</p><h2 id="Spring-Boot-自动配置原理是什么？"><a href="#Spring-Boot-自动配置原理是什么？" class="headerlink" title="Spring Boot 自动配置原理是什么？"></a>Spring Boot 自动配置原理是什么？</h2><p>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，</p><p>@EnableAutoConfiguration 给容器导入META-INF/spring.factories 里定义的自动配置类。</p><p>筛选有效的自动配置类。</p><p>每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能</p><p>推荐阅读：<a href="https://www.cnblogs.com/javaguide/p/springboot-auto-config.html">https://www.cnblogs.com/javaguide/p/springboot-auto-config.html</a></p><p>面试回答：<a href="https://www.bilibili.com/video/BV1ak4y117dH?p=2">https://www.bilibili.com/video/BV1ak4y117dH?p=2</a></p><h2 id="你如何理解-Spring-Boot-配置加载顺序？"><a href="#你如何理解-Spring-Boot-配置加载顺序？" class="headerlink" title="你如何理解 Spring Boot 配置加载顺序？"></a>你如何理解 Spring Boot 配置加载顺序？</h2><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p><p>1）properties文件；</p><p>2）YAML文件；</p><p>3）系统环境变量；</p><p>4）命令行参数；</p><h2 id="spring-boot-核心配置文件是什么？bootstrap-properties-和-application-properties-有何区别"><a href="#spring-boot-核心配置文件是什么？bootstrap-properties-和-application-properties-有何区别" class="headerlink" title="spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?"></a>spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</h2><p>spring boot 核心的两个配置文件：</p><p>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；<br>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</p><h2 id="比较一下-Spring-Security-和-Shiro-各自的优缺点"><a href="#比较一下-Spring-Security-和-Shiro-各自的优缺点" class="headerlink" title="比较一下 Spring Security 和 Shiro 各自的优缺点 ?"></a>比较一下 Spring Security 和 Shiro 各自的优缺点 ?</h2><p>Shiro 和 Spring Security 相比，主要有如下一些特点：</p><p>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架<br>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单<br>Spring Security 功能强大；Shiro 功能简单</p><h2 id="Spring-Boot-中如何解决跨域问题"><a href="#Spring-Boot-中如何解决跨域问题" class="headerlink" title="Spring Boot 中如何解决跨域问题 ?"></a>Spring Boot 中如何解决跨域问题 ?</h2><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目中前后端分离部署，所以需要解决跨域的问题。<br>我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。<br>当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。<br>我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(urlBasedCorsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是csrf攻击"><a href="#什么是csrf攻击" class="headerlink" title="什么是csrf攻击"></a>什么是csrf攻击</h2><p>CSRF 攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。</p><h2 id="Spring-Boot-中的-starter-到底是什么"><a href="#Spring-Boot-中的-starter-到底是什么" class="headerlink" title="Spring Boot 中的 starter 到底是什么 ?"></a>Spring Boot 中的 starter 到底是什么 ?</h2><p>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter</p><h2 id="spring-boot-starter-parent-有什么用"><a href="#spring-boot-starter-parent-有什么用" class="headerlink" title="spring-boot-starter-parent 有什么用 ?"></a>spring-boot-starter-parent 有什么用 ?</h2><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p><p>定义了 Java 编译版本为 1.8 。<br>使用 UTF-8 格式编码。<br>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。<br>执行打包操作的配置。<br>自动化的资源过滤。<br>自动化的插件配置。<br>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</p><h2 id="Spring-Boot工厂模式的加载"><a href="#Spring-Boot工厂模式的加载" class="headerlink" title="Spring Boot工厂模式的加载"></a>Spring Boot工厂模式的加载</h2><p>Spring Framework内部使用一种工厂加载机制(Factory Loading Mechanism)。这种机制使用SpringFactoriesLoader完成，SpringFactoriesLoader使用loadFactories方法加载并实例化从META-INF目录里的spring.factories文件出来的工厂，这些spring.factories文件都是从classpath里的jar包里找出来的。</p><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h2><ul><li><code>$&#123;&#125;</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为<code>com.mysql.jdbc.Driver</code>。</li><li><code>#&#123;&#125;</code>是 sql 的参数占位符，MyBatis 会将 sql 中的<code>#&#123;&#125;</code>替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue)，<code>#&#123;item.name&#125;</code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 <code>param.getItem().getName()</code>。</li></ul><h2 id="最佳实践中，通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#最佳实践中，通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"></a>最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h2><p>答：Dao 接口，就是人们常说的 <code>Mapper</code>接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中<code>MappedStatement</code>的 id 值，接口方法内的参数，就是传递给 sql 的参数。<code>Mapper</code>接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个<code>MappedStatement</code>，举例：<code>com.mybatis3.mappers.StudentDao.findStudentById</code>，可以唯一找到 namespace 为<code>com.mybatis3.mappers.StudentDao</code>下面<code>id = findStudentById</code>的<code>MappedStatement</code>。在 MyBatis 中，每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，都会被解析为一个<code>MappedStatement</code>对象。</p><p>Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p><p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行<code>MappedStatement</code>所代表的 sql，然后将 sql 执行结果返回。</p><h2 id="Mybatis是如何进行分页的，分页插件的原理是什么"><a href="#Mybatis是如何进行分页的，分页插件的原理是什么" class="headerlink" title="Mybatis是如何进行分页的，分页插件的原理是什么"></a>Mybatis是如何进行分页的，分页插件的原理是什么</h2><p>答：MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页，可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p><p>举例：<code>select _ from student</code>，拦截 sql 后重写为：<code>select t._ from （select \* from student）t limit 0，10</code></p><h2 id="MyBatis-的插件运行原理，以及如何编写一个插件"><a href="#MyBatis-的插件运行原理，以及如何编写一个插件" class="headerlink" title="MyBatis 的插件运行原理，以及如何编写一个插件"></a>MyBatis 的插件运行原理，以及如何编写一个插件</h2><p>答：MyBatis 仅可以编写针对 <code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>StatementHandler</code>、<code>Executor</code> 这 4 种接口的插件，MyBatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 <code>InvocationHandler</code> 的 <code>invoke()</code>方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>实现 MyBatis 的 Interceptor 接口并复写<code> intercept()</code>方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p><p>推荐阅读：<a href="https://www.cnblogs.com/felordcn/p/13473844.html">https://www.cnblogs.com/felordcn/p/13473844.html</a></p><h2 id="MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？"><a href="#MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？" class="headerlink" title="MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？"></a>MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</h2><p>MyBatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，MyBatis 提供了 9 种动态 sql 标签 <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>。</p><p>其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p><h2 id="MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h2><p>第一种是使用<code>&lt;resultMap&gt;</code>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，MyBatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，MyBatis 一样可以正常工作。</p><p>有了列名与属性名的映射关系后，MyBatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><h2 id="MyBatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别"><a href="#MyBatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别" class="headerlink" title="MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别"></a>MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别</h2><p>能，MyBatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 <code>selectOne()</code>修改为 <code>selectList()</code>即可；多对多查询，其实就是一对多查询，只需要把 <code>selectOne()</code>修改为 <code>selectList()</code>即可。</p><p>关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。</p><p>那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是<code>&lt;resultMap&gt;</code>标签内的<code>&lt;id&gt;</code>子标签，指定了唯一确定一条记录的 id 列，MyBatis 根据列值来完成 100 条记录的去重复功能，<code>&lt;id&gt;</code>可以有多个，代表了联合主键的语意。</p><p>同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。</p><p>举例：下面 join 查询出来 6 条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列，MyBatis 去重复处理后，结果为 1 个老师 6 个学生，而不是 6 个老师 6 个学生。</p><p>t_id t_name s_id</p><p>| 1 | teacher | 38 | | 1 | teacher | 39 | | 1 | teacher | 40 | | 1 | teacher | 41 | | 1 | teacher | 42 | | 1 | teacher | 43 |</p><h2 id="mybatis支持延迟加载吗？原理是什么"><a href="#mybatis支持延迟加载吗？原理是什么" class="headerlink" title="mybatis支持延迟加载吗？原理是什么"></a>mybatis支持延迟加载吗？原理是什么</h2><p>MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false。</code></p><p>它的原理是，使用<code> CGLIB</code> 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 <code>a.getB().getName()</code>，拦截器 <code>invoke()</code>方法发现 <code>a.getB()</code>是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 <code>a.getB().getName()</code>方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是 MyBatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的</p><h2 id="MyBatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？"><a href="#MyBatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？" class="headerlink" title="MyBatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？"></a>MyBatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？</h2><p>不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。</p><p>原因就是 namespace+id 是作为 <code>Map&lt;String, MappedStatement&gt;</code>的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。</p><h2 id="MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h2><p>MyBatis 有三种基本的 Executor 执行器，**<code>SimpleExecutor</code>、<code>ReuseExecutor</code>、<code>BatchExecutor</code>。**</p><p><strong><code>SimpleExecutor</code>：</strong>每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。</p><p><strong>``ReuseExecutor`：</strong>执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</p><p><strong><code>BatchExecutor</code>：</strong>执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</p><p>作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。</p><p>推荐阅读：<a href="https://blog.csdn.net/HUDCHSDI/article/details/108071789?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/HUDCHSDI/article/details/108071789?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242</a></p><h2 id="模糊查询like语句"><a href="#模糊查询like语句" class="headerlink" title="模糊查询like语句"></a>模糊查询like语句</h2><p>在Java代码中添加sql通配符</p><pre><code>string wildcardname = “%smi%”; list&lt;name&gt; names = mapper.selectlike(wildcardname);&lt;select id=”selectlike”&gt;  select * from foo where bar like #&#123;value&#125; &lt;/select&gt;</code></pre><p>在sql语句中拼接通配符，会引起sql注入</p><pre><code>string wildcardname = “smi”; list&lt;name&gt; names = mapper.selectlike(wildcardname);&lt;select id=”selectlike”&gt;  select * from foo where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;&lt;/select&gt;</code></pre><h2 id="如何批量插入"><a href="#如何批量插入" class="headerlink" title="如何批量插入"></a>如何批量插入</h2><p>首先,创建一个简单的insert语句: </p><pre><code>&lt;insert id=”insertname”&gt;  insert into names (name) values (#&#123;value&#125;) &lt;/insert&gt;</code></pre><p>然后在java代码中像下面这样执行批处理插入: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; names = <span class="keyword">new</span> arraylist(); </span><br><span class="line">names.add(“fred”); </span><br><span class="line">names.add(“barney”); </span><br><span class="line">names.add(“betty”); </span><br><span class="line">names.add(“wilma”); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里 executortype.batch </span></span><br><span class="line">sqlsession sqlsession = sqlsessionfactory.opensession(executortype.batch); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> namemapper mapper = sqlsession.getmapper(namemapper.class); </span><br><span class="line"> <span class="keyword">for</span> (string name : names) &#123; </span><br><span class="line"> mapper.insertname(name); </span><br><span class="line"> &#125; </span><br><span class="line"> sqlsession.commit(); </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line"> sqlsession.close(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h2><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。 </p><h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><p>一级缓存：一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p><p>二级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它指的是Mybatis中sqlSessionFactory对象的缓存。由同一SqlSessionFactory对象创建的SqlSession共享其缓存。存放的是数据不是对象</p><p>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p><h2 id="传递多个参数"><a href="#传递多个参数" class="headerlink" title="传递多个参数"></a>传递多个参数</h2><p><strong>顺序传参法</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">User</span> selectUser(String <span class="type">name</span>, <span class="type">int</span> deptId);</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">select</span> id=&quot;selectUser&quot; resultMap=&quot;UserResultMap&quot;&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">    <span class="keyword">where</span> user_name = #&#123;<span class="number">0</span>&#125; <span class="keyword">and</span> dept_id = #&#123;<span class="number">1</span>&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>@Param注解传参法</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">User</span> selectUser(@Param(&quot;userName&quot;) String <span class="type">name</span>, <span class="type">int</span> @Param(&quot;deptId&quot;) deptId);</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">select</span> id=&quot;selectUser&quot; resultMap=&quot;UserResultMap&quot;&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">    <span class="keyword">where</span> user_name = #&#123;userName&#125; <span class="keyword">and</span> dept_id = #&#123;deptId&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>Map传参法</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectUser</span>(<span class="params">Map&lt;String, Object&gt; <span class="keyword">params</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">select</span> id=<span class="string">&quot;selectUser&quot;</span> parameterType=<span class="string">&quot;java.util.Map&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> user</span><br><span class="line">    <span class="keyword">where</span> user_name = <span class="meta">#&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>Java Bean传参法</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">User</span> selectUser(<span class="keyword">User</span> <span class="keyword">user</span>);</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">select</span> id=&quot;selectUser&quot; parameterType=&quot;com.jourwon.pojo.User&quot; resultMap=&quot;UserResultMap&quot;&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">    <span class="keyword">where</span> user_name = #&#123;userName&#125; <span class="keyword">and</span> dept_id = #&#123;deptId&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>#{}里面的名称对应的是User类里面的成员属性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;title: 面试题总结&lt;br&gt;date: 2021-01-23 14:51:39&lt;br&gt;tag: 面试&lt;br&gt;categories: 学习&lt;br&gt;description: 整理的高频面试题和知识点&lt;/p&gt;
&lt;h1 id=&quot;计算机网络&quot;&gt;&lt;a href=&quot;#计算机网络&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>清除maven为下载成功的jar包</title>
    <link href="http://example.com/2021/01/12/%E6%B8%85%E9%99%A4maven%E4%B8%BA%E4%B8%8B%E8%BD%BD%E6%88%90%E5%8A%9F%E7%9A%84jar%E5%8C%85/"/>
    <id>http://example.com/2021/01/12/%E6%B8%85%E9%99%A4maven%E4%B8%BA%E4%B8%8B%E8%BD%BD%E6%88%90%E5%8A%9F%E7%9A%84jar%E5%8C%85/</id>
    <published>2021-01-12T11:15:44.000Z</published>
    <updated>2021-02-03T13:51:27.454Z</updated>
    
    <content type="html"><![CDATA[<p>导入项目如果中途退出或者发生中断 刚下载一半的jar包会下载失败 需要手动清除</p><p>创建一个txt文件 把这段内容复制进入</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> REPOSITORY_PATH=D:\maven_repository</span><br><span class="line"><span class="comment">rem 正在搜索...</span></span><br><span class="line"><span class="keyword">for</span> /f &quot;delims=&quot; <span class="variable">%%i</span> <span class="keyword">in</span> (&#x27;<span class="built_in">dir</span> /b /s &quot;<span class="variable">%REPOSITORY_PATH%</span>\*lastUpdated*&quot;&#x27;) <span class="keyword">do</span> (</span><br><span class="line">    <span class="built_in">del</span> /s /q <span class="variable">%%i</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">rem 搜索完毕</span></span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure><p>修改文件后缀为.bat 点击运行</p>]]></content>
    
    
    <summary type="html">清除maven未下载成功的jar包</summary>
    
    
    
    <category term="bug" scheme="http://example.com/categories/bug/"/>
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>tcp/ip详解卷一:协议</title>
    <link href="http://example.com/2021/01/05/tcp-ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80-%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2021/01/05/tcp-ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80-%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-01-05T07:36:48.569Z</published>
    <updated>2021-02-03T14:47:50.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="互联网的地址"><a href="#互联网的地址" class="headerlink" title="互联网的地址"></a>互联网的地址</h2><p>五类ip地址</p><p><img src="/2021/01/05/tcp-ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80-%E5%8D%8F%E8%AE%AE/image-20210106201011718.png" alt="image-20210106201011718"></p><p>各类ip地址的范围</p><p><img src="/2021/01/05/tcp-ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80-%E5%8D%8F%E8%AE%AE/image-20210106201115334.png" alt="image-20210106201115334"></p><h2 id="客户-服务器模型"><a href="#客户-服务器模型" class="headerlink" title="客户-服务器模型"></a>客户-服务器模型</h2><p>大部分网络应用程序在编写时都假设一端是客户，另一端是服务器，其目的是为了让服务器为客户提供一些特定的服务。<br>可以将这种服务分为两种类型：重复型或并发型。重复型服务器通过以下步骤进行交互：</p><p>I1.等待一个客户请求的到来。<br>I2.处理客户请求。<br>I3.发送响应给发送请求的客户。<br>I4.返回I1步。</p><p>重复型服务器主要的问题发生在I2状态。在这个时候，它不能为其他客户机提供服务。相应地，并发型服务器采用以下步骤：<br>C1.等待一个客户请求的到来。<br>C2.启动一个新的服务器来处理这个客户的请求。在这期间可能生成一个新的进程、任务或线程，并依赖底层操作系统的支持。这个步骤如何进行取决于操作系统。生成的新服务器对客户的全部请求进行处理。处理结束后，终止这个新服务器。<br>C3.返回C1步。<br>并发服务器的优点在于它是利用生成其他服务器的方法来处理客户的请求。也就是说，每个客户都有它自己对应的服务器。如果操作系统允许多任务，那么就可以同时为多个客户服务。</p><p>一般来说，TCP服务器是并发的，而UDP服务器是重复的，但也存在一些例外</p><h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><p><strong>以太网的帧格式</strong></p><p><img src="/2021/01/05/tcp-ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80-%E5%8D%8F%E8%AE%AE/image-20210107220050740.png" alt="image-20210107220050740"></p><ul><li>CRC字段用于帧内后续字节差错的循环冗余码检验</li></ul><h2 id="SLIP：串行线路IP"><a href="#SLIP：串行线路IP" class="headerlink" title="SLIP：串行线路IP"></a><strong>SLIP：串行线路IP</strong></h2><p>SLIP的全称是SerialLineIP。它是一种在串行线路上对IP数据报进行封装的简单形式</p><p>SLIP协议定义的帧格式：<br>1)IP数据报以一个称作END（0xc0）的特殊字符结束。同时，为了防止数据报到来之前的线路噪声被当成数据报内容，大多数实现在数据报的开始处也传一个END字符（如果有线路噪声，那么END字符将结束这份错误的报文。这样当前的报文得以正确地传输，而前一个错误报文交给上层后，会发现其内容毫无意义而被丢弃）。<br>2)如果IP报文中某个字符为END，那么就要连续传输两个字节0xdb和0xdc来取代它。0xdb这个特殊字符被称作SLIP的ESC字符，但是它的值与ASCII码的ESC字符（0x1b）不同。<br>3)如果IP报文中某个字符为SLIP的ESC字符，那么就要连续传输两个字节0xdb和0xdd来取代它。下图的例子就是含有一个END字符和一个ESC字符的IP报文。在这个例子中，在串行线路上传输的总字节数是原IP报文长度再加4个字节。</p><p><img src="/2021/01/05/tcp-ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80-%E5%8D%8F%E8%AE%AE/image-20210107230510162.png" alt="image-20210107230510162"></p><p>SLIP的缺陷：</p><p>1)每一端必须知道对方的IP地址。没有办法把本端的IP地址通知给另一端。</p><p>2)数据帧中没有类型字段（类似于以太网中的类型字段）。如果一条串行线路用于SLIP，那么它不能同时使用其他协议。</p><p>3)SLIP没有在数据帧中加上检验和（类似于以太网中的CRC字段）。如果SLIP传输的报文被线路噪声影响而发生错误，只能通过上层协议来发现（另一种方法是，新型的调制解调器可以检测并纠正错误报文）。这样，上层协议提供某种形式的CRC就显得很重要。</p><h2 id="压缩的SLIP：CompressSLIP"><a href="#压缩的SLIP：CompressSLIP" class="headerlink" title="压缩的SLIP：CompressSLIP"></a><strong>压缩的SLIP：CompressSLIP</strong></h2><p>由于串行线路的速率通常较低（19200b/s或更低），而且通信经常是交互式的（如Telnet和Rlogin，二者都使用TCP），因此在SLIP线路上有许多小的TCP分组进行交换。为了传送1个字节的数据需要20个字节的IP首部和20个字节的TCP首部，总数超过40个字节</p><p>CSLIP一般能把上面的40个字节压缩到3或5个字节。它能在CSLIP的每一端维持多达16个TCP连接，并且知道其中每个连接的首部中的某些字段一般不会发生变化。对于那些发生变化的字段，大多数只是一些小的数字和的改变。这些被压缩的首部大大地缩短了交互响应时间。</p><h2 id="PPP-点对点协议"><a href="#PPP-点对点协议" class="headerlink" title="PPP:点对点协议"></a><strong>PPP:点对点协议</strong></h2><p>PPP，点对点协议修改了SLIP协议中的所有缺陷。</p><p>PPP包括以下三个部分：<br>1)在串行链路上封装IP数据报的方法。PPP既支持数据为8位和无奇偶检验的异步模式（如大多数计算机上都普遍存在的串行接口），还支持面向比特的同步链接。<br>2)建立、配置及测试数据链路的链路控制协议（LCP：LinkControlProtocol）。它允许通信双方进行协商，以确定不同的选项。<br>3)针对不同网络层协议的网络控制协议（NCP：NetworkControlProtocol）体系。当前RFC定义的网络层有IP、OSI网络层、DECnet以及AppleTalk。例如，IPNCP允许双方商定是否对报文首部进行压缩，类似于CSLIP（缩写词NCP也可用在TCP的前面）。</p><h2 id="PPP数据帧的格式"><a href="#PPP数据帧的格式" class="headerlink" title="PPP数据帧的格式"></a><strong>PPP数据帧的格式</strong></h2><p>每一帧都以标志字符0x7e开始和结束。紧接着是一个地址字节，值始终是0xff，然后是一个值为0x03的控制字节。</p><p><img src="/2021/01/05/tcp-ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80-%E5%8D%8F%E8%AE%AE/image-20210107235728957.png" alt="image-20210107235728957"></p><p>由于标志字符的值是0x7e，因此当该字符出现在信息字段中时，PPP需要对它进行转义。在同步链路中，该过程是通过一种称作比特填充的硬件技术来完成的。在异步链路中，特殊字符0x7d用作转义字符。当它出现在PPP数据帧中时，那么紧接着的字符的第6个比特要取其补码，具体实现过程如下：<br>1)当遇到字符0x7e时，需连续传送两个字符：0x7d和0x5e，以实现标志字符的转义。<br>2)当遇到转义字符0x7d时，需连续传送两个字符：0x7d和0x5d，以实现转义字符的转义。<br>3)默认情况下，如果字符的值小于0x20（比如，一个ASCII控制字符），一般都要进行转义。例如，遇到字符0x01时需连续传送0x7d和0x21两个字符（这时，第6个比特取补码后变为1，而前面两种情况均把它变为0）。<br>这样做的原因是防止它们出现在双方主机的串行接口驱动程序或调制解调器中，因为有时它们会把这些控制字符解释成特殊的含义。另一种可能是用链路控制协议来指定是否需要对这32个字符中的某一些值进行转义。默认情况下是对所有的32个字符都进行转义。</p><p>与SLIP类似，由于PPP经常用于低速的串行链路，因此减少每一帧的字节数可以降低应用程序的交互时延。利用链路控制协议，大多数的产品通过协商可以省略标志符和地址字段，并且把协议字段由2个字节减少到1个字节。如果我们把PPP的帧格式与前面的SLIP的帧格式进行比较会发现，PPP只增加了3个额外的字节：1个字节留给协议字段，另2个给CRC字段使用。另外，使用IP网络控制协议，大多数的产品可以通过协商采用VanJacobson报文首部压缩方法（对应于CSLIP压缩），减小IP和TCP首部长度。总的来说，PPP比SLIP具有下面这些优点：(1)PPP支持在单根串行线路上运行多种协议，不只是IP协议；(2)每一帧都有循环冗余检验；(3)通信双方可以进行IP地址的动态协商(使用IP网络控制协议)；(4)与CSLIP类似，对TCP和IP报文首部进行压缩；(5)链路控制协议可以对多个数据链路选项进行设置。为这些优点付出的代价是在每一帧的首部增加3个字节，当建立链路时要发送几帧协商数据，以及更为复杂的实现。</p><p>PPP取代SLIP是大势所趋</p><h2 id="环回接口"><a href="#环回接口" class="headerlink" title="环回接口"></a>环回接口</h2><p>大多数的产品都支持环回接口（ Loopback Interface），以允许运行在同一台主机上的客户程序和服务器程序通过 T C P / I P进行通信。A类网络号1 2 7就是为环回接口预留的。根据惯例，大多数系统把I P地址1 2 7 . 0 . 0 . 1分配给这个接口，并命名为 l o c a l h o s t。一个传给环回接口的 I P数据报不能在任何网络上出现。我们想象，一旦传输层检测到目的端地址是环回地址时，应该可以省略部分传输层和所有网络层的逻辑操作。但是大多数的产品还是照样完成传输层和网络层的所有过程，只是当I P数据报离开网络层时把它返回给自己。</p><p>环回接口处理ip数据报的简单过程</p><p><img src="/2021/01/05/tcp-ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80-%E5%8D%8F%E8%AE%AE/image-20210109201930597.png" alt="image-20210109201930597"></p><p>图中需要指出的关键点是：</p><ol><li>传给环回地址（一般是1 2 7 . 0 . 0 . 1）的任何数据均作为I P输入。</li><li>传给广播地址或多播地址的数据报复制一份传给环回接口，然后送到以太网上。这是因为广播传送和多播传送的定义包含主机本身。<br>3 ) 任何传给该主机I P地址的数据均送到环回接口。</li></ol><h2 id="最大传输单元MTU"><a href="#最大传输单元MTU" class="headerlink" title="最大传输单元MTU"></a>最大传输单元MTU</h2><p>MTU：数据帧的最大长度</p><p>如果 I P层有一个数据报要传，而且数据的长度比链路层的 M T U还大，那么 I P层就需要进行分片</p><h2 id="路径MTU"><a href="#路径MTU" class="headerlink" title="路径MTU"></a>路径MTU</h2><p>当在同一个网络上的两台主机互相进行通信时，该网络的 M T U是非常重要的。但是如果两台主机之间的通信要通过多个网络，那么每个网络的链路层就可能有不同的 M T U。重要的不是两台主机所在网络的 M T U的值，重要的是两台通信主机路径中的最小 M T U。它被称作路径M T U。<br>两台主机之间的路径 M T U不一定是个常数。它取决于当时所选择的路由。而选路不一定是对称的（从A到B的路由可能与从B到A的路由不同），因此路径M T U在两个方向上不一定是一致的。</p><h1 id="IP-网际协议"><a href="#IP-网际协议" class="headerlink" title="IP:网际协议"></a>IP:网际协议</h1><p>IP提供不可靠、无连接的数据报传送服务</p><p>不可靠（u n r e l i a b l e）的意思是它不能保证 I P数据报能成功地到达目的地。 I P仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区， I P有一个简单的错误处理算法：丢弃该数据报，然后发送 I C M P消息报给信源端。任何要求的可靠性必须由上层来提供（如T C P）</p><p>无连接（c o n n e c t i o n l e s s）这个术语的意思是 I P并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。这也说明， I P数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是 A，然后是B），每个数据报都是独立地进行路由选择，可能选择不同的路线，因此 B可能在A到达之前先到达。</p><h2 id="ip首部"><a href="#ip首部" class="headerlink" title="ip首部"></a>ip首部</h2><p><img src="/2021/01/05/tcp-ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80-%E5%8D%8F%E8%AE%AE/image-20210110191848168.png" alt="image-20210110191848168"></p>]]></content>
    
    
    <summary type="html">计算机网络的深入学习（未完待续）</summary>
    
    
    
    <category term="计算机基础" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode</title>
    <link href="http://example.com/2020/12/28/leetcode/"/>
    <id>http://example.com/2020/12/28/leetcode/</id>
    <published>2020-12-28T06:25:28.000Z</published>
    <updated>2021-03-04T00:55:56.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(x))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(x),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h2><p>参考答案：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/</a></p><p>解法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> m = nums2.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = n + m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> aStart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bStart = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= sum / <span class="number">2</span>;i++)&#123;</span><br><span class="line">            left = right;</span><br><span class="line">            <span class="keyword">if</span>(aStart &lt; n &amp;&amp; (bStart &gt;= m || nums1[aStart] &lt; nums2[bStart]))&#123;</span><br><span class="line">                right = nums1[aStart++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = nums2[bStart++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            ans = (left + right) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解法二：使用二分法 假设我们要找第 <code>k</code> 小数，我们可以每次循环排除掉 <code>k/2</code> 个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums1.length;</span><br><span class="line">    <span class="keyword">int</span> m = nums2.length;</span><br><span class="line">    <span class="keyword">int</span> left = (n + m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> right = (n + m + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。</span></span><br><span class="line">    <span class="keyword">return</span> (getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, left) + getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, right)) * <span class="number">0.5</span>;  </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = end1 - start1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = end2 - start2 + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1 </span></span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> getKth(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = start1 + Math.min(len1, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = start2 + Math.min(len2, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h2><p>参考答案：<a href="https://leetcode-cn.com/problems/container-with-most-water/solution/container-with-most-water-shuang-zhi-zhen-fa-yi-do/">https://leetcode-cn.com/problems/container-with-most-water/solution/container-with-most-water-shuang-zhi-zhen-fa-yi-do/</a></p><p>消除状态：每次都移动较短的板 水槽面积才可能变大 若移动长板 下个水槽的面积一定小于当前水槽面积。所以无论是移动短板或者长板，我们都只关注移动后的新短板会不会变长，而每次移动的木板都只有三种情况，比原短板短，比原短板长，与原短板相等；如向内移动长板，对于新的木板：1.比原短板短，则新短板更短。2.与原短板相等或者比原短板长，则新短板不变。所以，向内移动长板，一定不能使新短板变长。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> j = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            res = height[i] &gt; height[j] ? Math.max(res,(j - i) * height[j--]) : Math.max(res, (j - i) * height[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h2><p>参考答案：<a href="https://leetcode-cn.com/problems/3sum/solution/3sumpai-xu-shuang-zhi-zhen-yi-dong-by-jyd/">https://leetcode-cn.com/problems/3sum/solution/3sumpai-xu-shuang-zhi-zhen-yi-dong-by-jyd/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">      Arrays.sort(nums);</span><br><span class="line">      List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">//固定 3 个指针中最左（最小）数字的指针 k，双指针 i，j 分设在数组索引 (k, len(nums)) 两端，通过双指针交替向中间移动，记录对于每个固定指针 k 的所有满足 nums[k] + nums[i] + nums[j] == 0 的 i,j 组合：</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;nums.length - <span class="number">2</span>;k++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(nums[k] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">//防止重复</span></span><br><span class="line">          <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">int</span> i = k + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">              <span class="keyword">int</span> sum = nums[i] + nums[k] + nums[j];</span><br><span class="line">              <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                  <span class="comment">//防止重复</span></span><br><span class="line">                  <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);</span><br><span class="line">              &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                  <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(nums[i],nums[j],nums[k])));</span><br><span class="line">                  <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);</span><br><span class="line">                  <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)</p><h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h2><p>参考答案：官方解题</p><p>以排列 [4,5,2,6,3,1][4,5,2,6,3,1] 为例：</p><p>我们能找到的符合条件的一对「较小数」与「较大数」的组合为 22 与 33，满足「较小数」尽量靠右，而「较大数」尽可能小。</p><p>当我们完成交换后排列变为 [4,5,3,6,2,1][4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6][4,5,3,1,2,6]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//如果是倒序的数组 i的值为-1 直接reserve</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;   </span><br><span class="line">            swap(nums ,i ,j);</span><br><span class="line">        &#125;</span><br><span class="line">        reserve(nums, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i ,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reserve</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            swap(nums,i++,j--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><p>参考答案：官方解题</p><p>有序数组就考虑使用二分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">//如果左面是有序的</span></span><br><span class="line">            <span class="comment">//为什么是&lt;=:(l+r)/2是把小数部分都省去了的结果，因此当l=0,r=1时会出现l==(l+r)/2。nums[left]&lt;nums[mid]，虽然可以判断出mid左边是升序的，但当mid=0时，就会到了else中，而else中mid右边有序的，不可能成立，所以要在这个位置加个等号。</span></span><br><span class="line">            <span class="keyword">if</span>(nums[left] &lt;= nums[mid])&#123;</span><br><span class="line">                <span class="comment">//如果target在这个范围内</span></span><br><span class="line">                <span class="keyword">if</span>(nums[left] &lt;= target&amp;&amp;nums[mid] &gt;= target)&#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//如果右面是有序的</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt;= target &amp;&amp; nums[right] &gt;= target)&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right = mid -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><p>参考解题：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/</a></p><p>参考博客：<a href="https://www.zhihu.com/question/36132386/answer/712269942">https://www.zhihu.com/question/36132386/answer/712269942</a></p><p>​                   <a href="https://leetcode-cn.com/leetbook/read/learning-algorithms-with-leetcode/xs41qg/">https://leetcode-cn.com/leetbook/read/learning-algorithms-with-leetcode/xs41qg/</a></p><p>​                   <a href="https://blog.csdn.net/shaomingmin/article/details/105901635">https://blog.csdn.net/shaomingmin/article/details/105901635</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> firstPosition = FirstPosition(nums,target);</span><br><span class="line">        <span class="keyword">if</span>(firstPosition == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastPosition = LastPosition(nums,target);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;firstPosition,lastPosition&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">FirstPosition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//因为是闭区间且循环终止条件是 `&lt;` 所以nums[left]被漏掉 需要做一次特殊判断</span></span><br><span class="line">        <span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">LastPosition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt;target) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left-<span class="number">1</span>] == target ? left-<span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FindLastPosition方法中需要上取整的原因</p><p><img src="/2020/12/28/leetcode/log\source_posts\leetcode\image-20210104141114097.png" alt="image-20210104141114097"></p><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h2><p>参考解题：<a href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/</a></p><p>代码1：无剪枝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        dfs(candidates,target,<span class="number">0</span>,len,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> begin,<span class="keyword">int</span> len,Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin;i &lt; len;i++)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            <span class="comment">//数组元素可以重复使用所以begin还是i</span></span><br><span class="line">            dfs(candidates,target-candidates[i],i,len,path,res);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剪枝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//剪枝的前提是排序</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        dfs(candidates,target,<span class="number">0</span>,len,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> begin,<span class="keyword">int</span> len,Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="comment">//目标值比当前数组值小 则进行剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(target &lt; candidates[i])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            dfs(candidates,target-candidates[i],i,len,path,res);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a></h2><p>参考解题；<a href="https://leetcode-cn.com/problems/rotate-image/solution/ji-qiao-ti-zai-zeng-song-yi-wei-xing-shi-377z/">https://leetcode-cn.com/problems/rotate-image/solution/ji-qiao-ti-zai-zeng-song-yi-wei-xing-shi-377z/</a></p><p>答案中拓展了一维数组旋转的方法</p><p><img src="/2020/12/28/leetcode/log\source_posts\leetcode\image-20210106135604308.png" alt="image-20210106135604308"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; mid;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][n - <span class="number">1</span> - j];</span><br><span class="line">                matrix[i][n - <span class="number">1</span> - j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a></h2><p>参考答案：<a href="https://leetcode-cn.com/problems/maximum-subarray/solution/hua-jie-suan-fa-53-zui-da-zi-xu-he-by-guanpengchn/">https://leetcode-cn.com/problems/maximum-subarray/solution/hua-jie-suan-fa-53-zui-da-zi-xu-he-by-guanpengchn/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sum += num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum = num;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h2><p>参考解题：<a href="https://leetcode-cn.com/problems/jump-game/solution/55-by-ikaruga/">https://leetcode-cn.com/problems/jump-game/solution/55-by-ikaruga/</a></p><ol><li>如果某一个作为 <strong>起跳点</strong> 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 <strong>起跳点</strong>。</li><li>可以对每一个能作为 <strong>起跳点</strong> 的格子都尝试跳一次，把 <strong>能跳到最远的距离</strong> 不断更新。</li><li>如果可以一直跳到最后，就成功了。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; i) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k = Math.max(k,nums[i] + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a></h2><p>tag:数组，排序</p><p>参考答案：<a href="https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/">https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        Arrays.sort(intervals,<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; merged = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = intervals[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(merged.size() == <span class="number">0</span> || merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] &lt; left)&#123;</span><br><span class="line">                merged.add(intervals[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(right,merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[merged.size()][]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h2><p>参考答案：<a href="https://leetcode-cn.com/problems/unique-paths/solution/dong-tai-gui-hua-by-powcai-2/">https://leetcode-cn.com/problems/unique-paths/solution/dong-tai-gui-hua-by-powcai-2/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(arr,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                arr[j] += arr[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h2><p>归并排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortInList</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用快慢指针把链表一分为二</span></span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newList = slow.next;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    ListNode left = sortInList(head);</span><br><span class="line">    ListNode right = sortInList(newList);</span><br><span class="line">    ListNode lhead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode res= lhead;</span><br><span class="line">    <span class="keyword">while</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left.val &lt; right.val)&#123;</span><br><span class="line">            lhead.next = left;</span><br><span class="line">            left = left.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            lhead.next = right;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        lhead = lhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    lhead.next = left != <span class="keyword">null</span>? left:right;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈和排序"><a href="#栈和排序" class="headerlink" title="栈和排序"></a>栈和排序</h2><p><img src="/2020/12/28/leetcode/log\source_posts\leetcode\image-20210304082245336.png" alt="image-20210304082245336"></p><p><img src="https://uploadfiles.nowcoder.com/images/20210205/9980465_1612514040325/CD16117538EE2394B4BF8476B630C8D8" alt="图片说明"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] solve (<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">boolean</span> [] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">10</span>];</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; a.length;i++)&#123;     <span class="comment">//此处不能用n 循环内会改变n</span></span><br><span class="line">        stack.push(a[i]);</span><br><span class="line">        vis[a[i]] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span> &amp;&amp; vis[n]) n--;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; n &lt;= stack.peek())&#123;</span><br><span class="line">            res[index++] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        res[index++] = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大数"><a href="#最大数" class="headerlink" title="最大数"></a>最大数</h2><p><img src="/2020/12/28/leetcode/log\source_posts\leetcode\image-20210304083606985.png" alt="image-20210304083606985"></p><p><img src="https://uploadfiles.nowcoder.com/images/20201217/9980465_1608181272700/31F22EFF4011B9068F5C9D00BB183892" alt="图片说明"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        list.add(String.valueOf(num));</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (o2+o1).compareTo(o1+o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(list.get(<span class="number">0</span>).equals(<span class="string">&quot;0&quot;</span>)) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">        res.append(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录刷题中看到的比较好的解题并对刷过的题进行分类</summary>
    
    
    
    <category term="错题本" scheme="http://example.com/categories/%E9%94%99%E9%A2%98%E6%9C%AC/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>springCloud_mall</title>
    <link href="http://example.com/2020/12/13/springCloud-mall/"/>
    <id>http://example.com/2020/12/13/springCloud-mall/</id>
    <published>2020-12-13T14:53:24.000Z</published>
    <updated>2021-02-03T14:49:45.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集成Druid"><a href="#集成Druid" class="headerlink" title="集成Druid"></a>集成Druid</h1><p>project:springboot_druid</p><p>Druid阿里巴巴开源的一个java数据库连接池，是Java语言中最好的数据库连接池，Druid能够提供强大的监控和扩展功能；集成它能够方便我们对数据库连接进行监控和分析</p><p>application.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.52.131:3306/mall?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">Bbj0611..</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">initial-size:</span> <span class="number">5</span> <span class="comment">#连接池初始化大小</span></span><br><span class="line">      <span class="attr">min-idle:</span> <span class="number">10</span> <span class="comment">#最小空闲连接数</span></span><br><span class="line">      <span class="attr">max-active:</span> <span class="number">20</span> <span class="comment">#最大连接数</span></span><br><span class="line">      <span class="attr">web-stat-filter:</span></span><br><span class="line">        <span class="attr">exclusions:</span> <span class="string">&quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;</span> <span class="comment">#不统计这些请求数据</span></span><br><span class="line">      <span class="attr">stat-view-servlet:</span> <span class="comment">#访问监控网页的登录用户名和密码</span></span><br><span class="line">        <span class="attr">login-username:</span> <span class="string">druid</span></span><br><span class="line">        <span class="attr">login-password:</span> <span class="string">druid</span></span><br></pre></td></tr></table></figure><h1 id="集成admin"><a href="#集成admin" class="headerlink" title="集成admin"></a>集成admin</h1><p>参考博客：<a href="https://www.cnblogs.com/forezp/p/10242004.html">https://www.cnblogs.com/forezp/p/10242004.html</a></p><h1 id="MINIO"><a href="#MINIO" class="headerlink" title="MINIO"></a>MINIO</h1><p>安装</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="regexp">//</span>dl.minio.org.cn<span class="regexp">/server/mi</span>nio<span class="regexp">/release/</span>linux-amd64/minio</span><br><span class="line">chmod +x minio</span><br><span class="line">.<span class="regexp">/minio server /</span>data</span><br></pre></td></tr></table></figure><p>默认账号名和密码为:minioadmin</p><h1 id="nacos"><a href="#nacos" class="headerlink" title="nacos"></a>nacos</h1><p>下载地址:<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p>解压后 启动：<code>sh startup.sh -m standalone</code></p><p>启动失败解决方法：<a href="https://www.cnblogs.com/rookiemzl/p/13814919.html">https://www.cnblogs.com/rookiemzl/p/13814919.html</a></p><p>访问地址： <a href="http://192.168.52.131:8848/nacos/">http://192.168.52.131:8848/nacos/</a></p><p>默认账号和密码：nacos</p><p><strong>nacos可以作为配置中心</strong></p><p>项目：springcloud-learning-&gt;nacos-config-client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/configInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个页面需要参数config.info 但是配置文件里没有</p><p>在nacos中创建一个配置</p><p><img src="/2020/12/13/springCloud-mall/image-20201214094003249.png" alt="image-20201214094003249"></p><p>并在bootstarp中配置获取路径</p><p><img src="/2020/12/13/springCloud-mall/image-20201214094027256.png" alt="image-20201214094027256"></p><h1 id="Gateway集成Oauth2-0"><a href="#Gateway集成Oauth2-0" class="headerlink" title="Gateway集成Oauth2.0"></a>Gateway集成Oauth2.0</h1><p><img src="https://pic4.zhimg.com/80/v2-93c28c22643361ecd5f265e33de6be03_1440w.png" alt="img"></p><p><strong>密码验证获取token</strong></p><p>使用postman根据密码授权模式获取token</p><p><img src="/2020/12/13/springCloud-mall/image-20210129210526873.png" alt="image-20210129210526873"></p><p>/mall-auth/oauth/token被设置在网关的白名单中 可以不用认证直接访问</p><p>访问服务的时候 在headers上加上token</p><p><img src="/2020/12/13/springCloud-mall/image-20210129210553051.png" alt="image-20210129210553051"></p><p>token在auth被密钥加密 在gateway中被公钥解密</p>]]></content>
    
    
    <summary type="html">学习mall-swarm项目过程中的记录和总结</summary>
    
    
    
    <category term="项目" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="心得" scheme="http://example.com/tags/%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>netty</title>
    <link href="http://example.com/2020/12/10/netty/"/>
    <id>http://example.com/2020/12/10/netty/</id>
    <published>2020-12-10T15:43:03.000Z</published>
    <updated>2021-02-03T14:42:59.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p><strong>介绍</strong></p><p>BIO(同步阻塞IO模式):服务器实现模式为 一个连接对应一个线程，即客户端有连接请求时服务端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销</p><p>适用于连接数目较少且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中</p><p><strong>工作流程</strong></p><ul><li>服务端启动一个ServerSocket</li><li>客户端启动socket对服务器进行通信，默认情况下服务器需要对每个客户 建立一个线程与之通讯</li><li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝</li><li>如果有响应，客户端线程会等待请求结束后，再继续执行</li></ul><p><img src="/2020/12/10/netty/image-20201211180810904.png" alt="，"></p><p><strong>实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            pool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    handler(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getId());</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = inputStream.read(buff)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在linux中进行连接：<code>telnet 192.168.52.1 6666</code></p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>NIO(同步非阻塞IO模式):服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接时如果有IO请求就进行处理</p><p>适用于连接数目较多且连接比较短的架构 </p><p>AIO适合连接数目多且连接比较长的架构</p><p>三大核心：selector-&gt;channel-&gt;buffer</p><p><img src="/2020/12/10/netty/image-20201212231552096.png" alt="image-20201212231552096"></p><p>一个selector对应一个线程，buffer和channel之间是双向绑定的 客户端只能和buffer进行交互</p><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>缓冲区本质是一个可以读写数据的内存块</p><p><strong>类型</strong></p><p><img src="/2020/12/10/netty/image-20201212233528926.png" alt="image-20201212233528926"></p><p><strong>方法</strong></p><p><img src="/2020/12/10/netty/image-20201212233156593.png" alt="image-20201212233156593"></p><p><strong>实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntBuffer buffer = IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;buffer.capacity();i++)&#123;</span><br><span class="line">            buffer.put(i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读写转换</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(buffer.hasRemaining())&#123;</span><br><span class="line">            System.out.println(buffer.mark());</span><br><span class="line">            System.out.println(buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/woshijpf/articles/3723364.html">java.nio.Buffer flip()方法的用法详解</a></p><p><strong>ByteBuffer(二进制数据)</strong></p><p><img src="/2020/12/10/netty/image-20201212233406121.png" alt="image-20201212233406121"></p><p>ByteBuffer支持类型化的put和int  put什么类型就应该get什么类型 不然会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//参数是bytes</span></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">20</span>);</span><br><span class="line">    byteBuffer.putInt(<span class="number">4</span>);</span><br><span class="line">    byteBuffer.putLong(<span class="number">5L</span>);</span><br><span class="line">    </span><br><span class="line">byteBuffer.flip();</span><br><span class="line">    </span><br><span class="line">    byteBuffer.getInt();</span><br><span class="line">    byteBuffer.getLong();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将一个buffer转换成只读的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    byteBuffer.putInt(<span class="number">4</span>);</span><br><span class="line">    byteBuffer.putLong(<span class="number">5L</span>);</span><br><span class="line"></span><br><span class="line">    byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">    ByteBuffer readOnlyBuffer =  byteBuffer.asReadOnlyBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(readOnlyBuffer.hasRemaining())&#123;</span><br><span class="line">        System.out.println(readOnlyBuffer.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MappedByteBuffer可以直接在堆外内存中修改文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;D:\\data\\test.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Maps a region of this channel&#x27;s file directly into memory.</span></span><br><span class="line"><span class="comment">     * 参数1:文件以什么模式被映射到内存</span></span><br><span class="line"><span class="comment">     * 参数2:The position within the file at which the mapped region is to star</span></span><br><span class="line"><span class="comment">     * 参数3:The size of the region to be map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line">    mappedByteBuffer.put(<span class="number">0</span>,(<span class="keyword">byte</span>)<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">    mappedByteBuffer.put(<span class="number">2</span>,(<span class="keyword">byte</span>)<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    randomAccessFile.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buffer的分散和聚集：通过多个buffer完成读写操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScatteringAndGathering</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Scattering:将数据依次写入到buffer</span></span><br><span class="line">    <span class="comment">//Gathering:将数据依次从buffer中读取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="number">7000</span>);</span><br><span class="line">        <span class="comment">//绑定端口到socket并启动</span></span><br><span class="line">        serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建buffer数据</span></span><br><span class="line">        ByteBuffer[] byteBuffers = <span class="keyword">new</span> ByteBuffer[<span class="number">2</span>];</span><br><span class="line">        byteBuffers[<span class="number">0</span>] = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">        byteBuffers[<span class="number">1</span>] = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待客户端连接</span></span><br><span class="line">        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">        <span class="keyword">int</span> messageLength = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> byteRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> byteWrite = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(byteRead &lt; messageLength)&#123;</span><br><span class="line">                <span class="keyword">long</span> n = socketChannel.read(byteBuffers);</span><br><span class="line">                byteRead += n;</span><br><span class="line">                System.out.println(<span class="string">&quot;byteRead=&quot;</span>+byteRead);</span><br><span class="line">                Arrays.asList(byteBuffers).stream().map(buffer-&gt; <span class="string">&quot;position=&quot;</span>+buffer.position()+<span class="string">&quot;, limit&quot;</span>+buffer.limit()).forEach(System.out::println);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(byteWrite &lt; messageLength)&#123;</span><br><span class="line">                <span class="keyword">long</span> n = socketChannel.write(byteBuffers);</span><br><span class="line">                byteWrite += n;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(buffer -&gt;buffer.clear());</span><br><span class="line">            System.out.println(<span class="string">&quot;byteWrite=&quot;</span>+byteWrite);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>类似于流 但是可以同时进行读写 可以实现异步读写数据 可以从缓冲读数据 也可以写数据到缓冲</p><p>常见的channel有：FileChannel(用于文件读写),DatagramChannel(用于UDP的数据读写),ServerSocketChannel,SockerChannel(TCP数据读写)</p><p><strong>FileChannel类的常用方法</strong></p><p><img src="/2020/12/10/netty/image-20201213001353087.png" alt="image-20201213001353087"></p><p>读文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\data\\test.txt&quot;</span>);</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="keyword">int</span> len = (<span class="keyword">int</span>) file.length();</span><br><span class="line">        ByteBuffer.allocate(len);</span><br><span class="line">        FileChannel channel = fileInputStream.getChannel();</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(len);</span><br><span class="line">        channel.read(byteBuffer);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(byteBuffer.array(),<span class="number">0</span>,len));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\data\\test.txt&quot;</span>);</span><br><span class="line">        FileChannel fileChannel = fileOutputStream.getChannel();</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(message.length());</span><br><span class="line">        byteBuffer.put(message.getBytes());</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        fileChannel.write(byteBuffer);</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读写文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用一个buffer完成文件读取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadAndBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//copy test.txt to test2.txt</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\data\\test.txt&quot;</span>);</span><br><span class="line">        FileChannel readChannel = fileInputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\data\\test2.txt&quot;</span>);</span><br><span class="line">        FileChannel writeChannel = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            len = readChannel.read(byteBuffer);</span><br><span class="line">            <span class="keyword">if</span>(len == -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            writeChannel.write(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用transferFrom直接拷贝文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\data\\test.txt&quot;</span>);</span><br><span class="line">        FileChannel readChannel = fileInputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\data\\test2.txt&quot;</span>);</span><br><span class="line">        FileChannel writeChannel = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        writeChannel.transferFrom(readChannel,<span class="number">0</span>,readChannel.size());</span><br><span class="line"></span><br><span class="line">        readChannel.close();</span><br><span class="line">        writeChannel.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h3><p>selector执行select的方法时会获取到所有selectionkey，可以通过selectionkey知道当前的channel发生了什么事件 从而去操作相关的channel</p><p><strong>常用方法</strong></p><ul><li>open：得到一个选择器对象</li><li>select：监控所有注册的通道，当其中有io操作可以进行时，将对应的selectionKey加入到内部集合中并返回。该方法不带参数的时候  当没有事件时会阻塞 带参数的时候 可以设置超时时间，selectNow立即获取selectionkey不进行等待</li><li>selectedKeys：从内部集合中得到所有的selectionkey</li><li>wakeup：唤醒selector</li></ul><p><strong>Selector，SelectionKey，SocketChannel，ServerSocketChannel之间的关系</strong></p><ul><li>当客户端连接时，会通过ServerSocketChannel得到SocketChannel</li><li>selector通过select方法 返回有事件发生的通道个数</li><li>将SocketChannel通过register方法注册到Selector上，一个selector可以注册多个channel</li><li>注册后返回一个SelectionKey，会和Selector关联</li><li>进一步得到各个SelectionKey(有事件发生的)</li><li>再通过SelectionKey反向获取SocketChannel</li><li>通过得到的channel完成业务处理</li></ul><p><img src="/2020/12/10/netty/image-20201228190103175.png" alt="image-20201228190103175"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//绑定端口</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line"><span class="comment">//设置为非堵塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//把serverSocketChannel注册到selector</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(selector.select(<span class="number">1000</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;等待了1s,无连接&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey next = iterator.next();</span><br><span class="line">                <span class="comment">//如果有新的客户端连接</span></span><br><span class="line">                <span class="keyword">if</span>(next.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">//为该客户端生成一个SocketChannel</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    <span class="comment">//将socketChannel注册到selector关注事件为write 并关联一个buffer 这个buffer是位于selector和SocketChannel之间的</span></span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(next.isReadable())&#123;</span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel)next.channel();</span><br><span class="line">                    <span class="comment">//获取channel关联的buffer</span></span><br><span class="line">                    ByteBuffer byteBuffer = (ByteBuffer) next.attachment();</span><br><span class="line">                    socketChannel.read(byteBuffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;from客户端:&quot;</span>+<span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//移除当前selectionKey 防止多线程重复操作</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//如果链接不成功</span></span><br><span class="line">        <span class="keyword">if</span>(!socketChannel.connect(inetSocketAddress))&#123;</span><br><span class="line">            <span class="keyword">while</span>(!socketChannel.finishConnect())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;因为连接需要时间 客户端不会阻塞 我可以做其他工作&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="comment">//根据字节数组大小生成buffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(s.getBytes());</span><br><span class="line"></span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SelectionKey定义的四种事件：<a href="https://www.cnblogs.com/liuxiuhao/p/5785027.html">https://www.cnblogs.com/liuxiuhao/p/5785027.html</a></p><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p><a href="https://blog.csdn.net/weixin_37782390/article/details/103833306">sendfile和mmap的区别以及什么是零拷贝</a></p><p>nio实现零拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroCopyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="number">7001</span>);</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        ServerSocket socket = serverSocketChannel.socket();</span><br><span class="line">        socket.bind(inetSocketAddress);</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            <span class="keyword">int</span> readCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(-<span class="number">1</span> != readCount)&#123;</span><br><span class="line">                socketChannel.read(byteBuffer);</span><br><span class="line">                <span class="comment">//倒带:position = 0 清除mark</span></span><br><span class="line">                byteBuffer.rewind();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroCopyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>,<span class="number">7001</span>));</span><br><span class="line">        String filename = <span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(filename).getChannel();</span><br><span class="line">        <span class="comment">//linux:一次transferTo方法就可以完成传输</span></span><br><span class="line">        <span class="comment">//windows: 一次transferTo只能传输8m</span></span><br><span class="line">        <span class="keyword">long</span> count = fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br><span class="line">        fileChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><h2 id="传统阻塞IO服务模型"><a href="#传统阻塞IO服务模型" class="headerlink" title="传统阻塞IO服务模型"></a>传统阻塞IO服务模型</h2><p><img src="/2020/12/10/netty/image-20210103141453740.png" alt="image-20210103141453740"></p><h2 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h2><p><img src="/2020/12/10/netty/image-20210103141349608.png" alt="image-20210103141349608"></p><p><img src="/2020/12/10/netty/image-20210103141723787.png" alt="image-20210103141723787"></p><p><img src="/2020/12/10/netty/image-20210103141852408.png" alt="image-20210103141852408"></p><p>根据Reactor的数量和处理资源池线程的数量不同 实现可以分为三种</p><ul><li>单Reactor单线程</li><li>单Reactor多线程</li><li>主从Reactor多线程</li></ul><h3 id="单Reactor单线程模式"><a href="#单Reactor单线程模式" class="headerlink" title="单Reactor单线程模式"></a>单Reactor单线程模式</h3><p><img src="/2020/12/10/netty/image-20210103142745489.png" alt="image-20210103142745489"></p><p>前面的NIO群聊系统就是这种类型</p><p>优缺点分析</p><p><img src="/2020/12/10/netty/image-20210103142901882.png" alt="image-20210103142901882"></p><h3 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程"></a>单Reactor多线程</h3><p><img src="/2020/12/10/netty/image-20210103143433032.png" alt="image-20210103143433032"></p><p>优缺点</p><p><img src="/2020/12/10/netty/image-20210103144843844.png" alt="image-20210103144843844"></p><h3 id="主从Reactor多线程"><a href="#主从Reactor多线程" class="headerlink" title="主从Reactor多线程"></a>主从Reactor多线程</h3><p><img src="/2020/12/10/netty/image-20210103144856459.png" alt="image-20210103144856459"></p><p><img src="/2020/12/10/netty/image-20210103145238171.png" alt="image-20210103145238171"></p><p>netty就是基于这种模型</p><h2 id="netty模型"><a href="#netty模型" class="headerlink" title="netty模型"></a>netty模型</h2><p><img src="/2020/12/10/netty/image-20210105203951914.png" alt="image-20210105203951914"></p><p><img src="/2020/12/10/netty/image-20210105205010494.png" alt="image-20210105205010494"></p><ul><li>该图中WorkerGroup中的NioEventGroup应为NioEventLoop</li><li>每个NioEventLoop都有一个selector 用于监听绑定在其上的多个socket网络通道（channel） 还包含一个taskQueue</li><li>每个NioChannel只会绑定再唯一的NioEventLoop上 每个NioChannel都绑定有一个自己的ChannelPipeline</li><li>NioEventLoop串行化执行 读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送</li></ul><h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="入门实例"><a href="#入门实例" class="headerlink" title="入门实例"></a>入门实例</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        <span class="comment">//NioEventLoopGroup含有的子线程(NioEventLoop)的个数默认为cpu核心线程数 * 2</span></span><br><span class="line">        <span class="comment">//NioEventLoopGroup()传入参数可以指定子线程个数</span></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//创建服务端的启动服务并配置参数</span></span><br><span class="line">           ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">           bootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                   .channel(NioServerSocketChannel.class)<span class="comment">//使用NioSocketChannel作为服务器的通道实现</span></span><br><span class="line">                   .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>)<span class="comment">//设置线程队列得到连接个数</span></span><br><span class="line">               <span class="comment">//handler对应bossGroup，childHandler对应workerGroup</span></span><br><span class="line">               <span class="comment">//handler()是发生在初始化的时候，childHandler()是发生在客户端连接之后。</span></span><br><span class="line">                   .handler(<span class="keyword">null</span>)</span><br><span class="line">                   .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;()&#123;<span class="comment">//创建一个通道测试对象</span></span><br><span class="line">                       <span class="comment">//给pipeline设置处理器</span></span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                           <span class="comment">//传入自定义的handler</span></span><br><span class="line">                           ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">           System.out.println(<span class="string">&quot;server is ready&quot;</span>);</span><br><span class="line">           <span class="comment">//启动服务器，绑定一个端口并同步 生成了一个ChannelFuture对象</span></span><br><span class="line">           ChannelFuture channelFuture = bootstrap.bind(<span class="number">8888</span>).sync();</span><br><span class="line">           <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">           channelFuture.channel().closeFuture().sync();</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           bossGroup.shutdownGracefully();</span><br><span class="line">           workerGroup.shutdownGracefully();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端发来的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx:上下文对象 含有管道pipeline，通道channel，地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg:就是客户端发送的数据 默认是object类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//ByteBuf比Nio中的ByteBuffer性能更高</span></span><br><span class="line">        ByteBuf byteBuf = (ByteBuf)msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送的消息:&quot;</span>+byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端地址:&quot;</span>+ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取数据完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//把数据写到缓冲区并刷新(从缓冲区发送到管道)</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,client&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span>&#123;</span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        EventLoopGroup eventExecutors = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(eventExecutors).channel(NioSocketChannel.class)<span class="comment">//设置客户端通道的实现类</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;client is ready&quot;</span>);</span><br><span class="line">            <span class="comment">//启动客户端去连接服务端</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>).sync();</span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当通道就绪就会触发该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,server&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当通道有读取事件时会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf byteBuf = (ByteBuf)msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器回复的消息:&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器的地址:&quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="taskQueue"><a href="#taskQueue" class="headerlink" title="taskQueue"></a>taskQueue</h2><p>如果pipeline中的handler处理一个时间较长的任务时 可以把该任务交给该channel对应的NioEvenLoop的TaskQueue异步执行 防止阻塞</p><p><img src="/2020/12/10/netty/image-20210106144955073.png" alt="image-20210106144955073"></p><p>修改NettyServerHandler中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//ByteBuf比Nio中的ByteBuffer性能更高</span></span><br><span class="line"><span class="comment">//        ByteBuf byteBuf = (ByteBuf)msg;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;客户端发送的消息:&quot;+byteBuf.toString(CharsetUtil.UTF_8));</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;客户端地址:&quot;+ctx.channel().remoteAddress());</span></span><br><span class="line"><span class="comment">//模拟耗时任务</span></span><br><span class="line">        Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,client,bbb&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;go on...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取数据完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//把数据写到缓冲区并刷新(从缓冲区发送到管道)</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,client,aaa&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>客户端先需要等待10s才能得到bbb 在得到aaa</p><p>解决方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">                ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,client,bbb&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;go on...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端不会阻塞 立马输出go on 客户端也立刻得到aaa</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">                ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,client,bbb&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">                ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,client,ccc&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;go on...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在队列中再增加一个任务 ccc会间隔20s才被收到 taskQueue只有一个线程处理任务</p><h2 id="scheduledTaskQueue"><a href="#scheduledTaskQueue" class="headerlink" title="scheduledTaskQueue"></a>scheduledTaskQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">                ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,client,bbb&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//延时执行</span></span><br><span class="line">    ctx.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,client,ccc&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(<span class="string">&quot;go on...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scheduleTaskQueue和taskQueue是两个线程</p><h2 id="异步模型"><a href="#异步模型" class="headerlink" title="异步模型"></a>异步模型</h2><p><img src="/2020/12/10/netty/image-20210107142433930.png" alt="image-20210107142433930"></p><p>工作原理</p><p><img src="/2020/12/10/netty/image-20210107143303168.png" alt="image-20210107143303168"></p><p>在使用Netty进行编程时，拦截操作和转换出入站数据只需要您提供callback或利用future即可。这使得链式操作简单、高效,并有利于编写可重用的、通用的代码</p><p><strong>Future-Listener机制</strong></p><p><img src="/2020/12/10/netty/image-20210107143917889.png" alt="image-20210107143917889"></p><p><img src="/2020/12/10/netty/image-20210107144247867.png" alt="image-20210107144247867"></p><ul><li>绑定端口是异步操作 当绑定操作处理完 将会调用相应的监听器处理逻辑</li></ul><h2 id="http服务程序实例"><a href="#http服务程序实例" class="headerlink" title="http服务程序实例"></a>http服务程序实例</h2><p>要求：服务器回复消息给客户端 并对特定请求资源过滤</p><p>新写法：把ChannelInitializer提取出来作为一个单独的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务端的启动服务并配置参数</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)<span class="comment">//使用NioSocketChannel作为服务器的通道实现</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> HttpServerInitializer());</span><br><span class="line">            <span class="comment">//启动服务器，绑定一个端口并同步 生成了一个ChannelFuture对象</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(<span class="number">8888</span>).sync();</span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//向管道加入处理器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到管道</span></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="comment">//加入一个netty 提供的 httpServerCodec（coder和encoder）</span></span><br><span class="line">        <span class="comment">//HttpServerCodec是netty提供的处理http的编解码器</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;MyHttpServerCodec&quot;</span>,<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        <span class="comment">//增加自定义的handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;handler&quot;</span>,<span class="keyword">new</span> HttpServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleChannelInboundHandler是ChannelInboundHandlerAdapter的子类</span></span><br><span class="line"><span class="comment">//HttpObject:客户端和服务端相互通讯的数据被封装成 HttpObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//如果不是httpRequest请求</span></span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> HttpRequest)&#123;</span><br><span class="line">            System.out.println(msg.getClass());</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress());</span><br><span class="line">            <span class="comment">//回复信息给浏览器</span></span><br><span class="line">            ByteBuf content = Unpooled.copiedBuffer(<span class="string">&quot;hello,i am server&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">            <span class="comment">//构造一个http的响应</span></span><br><span class="line">            DefaultFullHttpResponse httpResponse = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line">            httpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            httpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH,content.readableBytes());</span><br><span class="line">            <span class="comment">//返回response</span></span><br><span class="line">            ctx.writeAndFlush(httpResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动服务 在浏览器中访问localhost:8888 根据控制台打印的信息 可以判断出浏览器发出了两次请求</p><p><img src="/2020/12/10/netty/image-20210107152203610.png" alt="image-20210107152203610"></p><p>过滤掉favicon.ico的请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//如果是httpRequest请求</span></span><br><span class="line">    <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> HttpRequest)&#123;</span><br><span class="line">        System.out.println(msg.getClass());</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">        HttpRequest httpRequest = (HttpRequest)msg;</span><br><span class="line">        <span class="comment">//获取uri</span></span><br><span class="line">        URI uri = <span class="keyword">new</span> URI(httpRequest.uri());</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath()))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回复信息给浏览器</span></span><br><span class="line">        ByteBuf content = Unpooled.copiedBuffer(<span class="string">&quot;hello,i am server&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">        <span class="comment">//构造一个http的响应</span></span><br><span class="line">        DefaultFullHttpResponse httpResponse = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line">        httpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">        httpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH,content.readableBytes());</span><br><span class="line">        <span class="comment">//返回response</span></span><br><span class="line">        ctx.writeAndFlush(httpResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Netty核心模块"><a href="#Netty核心模块" class="headerlink" title="Netty核心模块"></a>Netty核心模块</h2><p>Bootstrap,ServerBootstrap</p><p><img src="/2020/12/10/netty/image-20210107154223866.png" alt="image-20210107154223866"></p><p>Future,ChannelFuture</p><p><img src="/2020/12/10/netty/image-20210107154759707.png" alt="image-20210107154759707"></p><p>Channel</p><p><img src="/2020/12/10/netty/image-20210107154914489.png" alt="image-20210107154914489"></p><p><img src="/2020/12/10/netty/image-20210107154925428.png" alt="image-20210107154925428"></p><p>Selector</p><p><img src="/2020/12/10/netty/image-20210107155214479.png" alt="image-20210107155214479"></p><p>ChannelHandler</p><p><img src="/2020/12/10/netty/image-20210107155510137.png" alt="image-20210107155510137"></p><p><img src="/2020/12/10/netty/image-20210107155716574.png" alt="image-20210107155716574"></p><p><img src="/2020/12/10/netty/image-20210107155955429.png" alt="image-20210107155955429"></p><p>ChannelPipeline</p><p><img src="/2020/12/10/netty/image-20210109140931439.png" alt="image-20210109140931439"></p><p><img src="/2020/12/10/netty/image-20210109141324593.png" alt="image-20210109141324593"></p><p><img src="/2020/12/10/netty/image-20210109141802136.png" alt="image-20210109141802136"></p><p>ChannelHandlerContext</p><p><img src="/2020/12/10/netty/image-20210109141930634.png" alt="image-20210109141930634"></p><p>ChannelOption</p><p><img src="/2020/12/10/netty/image-20210109142440513.png" alt="image-20210109142440513"></p><p>EventLoop</p><p><img src="/2020/12/10/netty/image-20210109142715578.png" alt="image-20210109142715578"></p><p><img src="/2020/12/10/netty/image-20210109143347566.png" alt="image-20210109143347566"></p><h2 id="Unpooled类"><a href="#Unpooled类" class="headerlink" title="Unpooled类"></a>Unpooled类</h2><p><img src="/2020/12/10/netty/image-20210109143543585.png" alt="image-20210109143543585"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个ByteBuf对象 该对象包含一个数组byte[10]</span></span><br><span class="line">        ByteBuf byteBuf = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            byteBuf.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不需要读写转换 因为ByteBuf中有两个指针readerIndex和writerIndex表示下一个要写入和要读的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; byteBuf.capacity();i++)&#123;</span><br><span class="line">            <span class="comment">//该方法不会引起readIndex的变化</span></span><br><span class="line">            System.out.println(byteBuf.getByte(i));</span><br><span class="line">            <span class="comment">//根据readIndex读取</span></span><br><span class="line">            System.out.println(byteBuf.readByte());</span><br><span class="line">            <span class="comment">//readIndex,writeIndex,capacity将byteBuf划分为三个区间</span></span><br><span class="line">            <span class="comment">//0-readIndex:已读区间</span></span><br><span class="line">            <span class="comment">//readIndex-writeIndex:可读区间</span></span><br><span class="line">            <span class="comment">//writeIndex-capacity:可写区间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="群聊系统"><a href="#群聊系统" class="headerlink" title="群聊系统"></a>群聊系统</h2><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//获取到pipeLine</span></span><br><span class="line">                            ChannelPipeline channelPipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//加入解码器和编码器</span></span><br><span class="line">                            channelPipeline.addLast(<span class="string">&quot;decoder&quot;</span>,<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            channelPipeline.addLast(<span class="string">&quot;encoder&quot;</span>,<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            <span class="comment">//加入自己的业务处理handler</span></span><br><span class="line">                            channelPipeline.addLast(<span class="keyword">new</span> ServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;netty服务器启动&quot;</span>);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(port).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GroupChatServer(<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//管理所有的channel</span></span><br><span class="line">    <span class="comment">//GlobalEventExecutor.INSTANCE)是全局事件执行器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelGroup channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接建立后 该方法第一个被执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将当前客户加入聊天的信息推送给其他在线的客户端</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">//该方法会将channelGroup中所有channel遍历并发送消息</span></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;客户端&quot;</span> + channel.remoteAddress() + <span class="string">&quot;加入聊天&quot;</span>);</span><br><span class="line">        <span class="comment">//将当前Channel加入到channelGroup</span></span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示channel处于活跃状态 提示xx上线</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress()+<span class="string">&quot;上线了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示channel处于非活跃状态 提示xx下线</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress()+<span class="string">&quot;下线了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//断开连接:提示在线用户xx离开</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//当前ChannelGroup容量会-1</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;客户端&quot;</span>+channel.remoteAddress()+<span class="string">&quot;离开了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据并转发给其他人</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">//根据不同情况 回送不同的消息</span></span><br><span class="line">        channelGroup.forEach(ch -&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(channel != ch)&#123;</span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;客户&quot;</span>+channel.remoteAddress() + <span class="string">&quot;发送了消息&quot;</span>+msg);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;自己发送了消息&quot;</span>+msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        NioEventLoopGroup eventExecutors = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(eventExecutors).channel(NioSocketChannel.class).handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ChannelPipeline channelPipeline = ch.pipeline();</span><br><span class="line">                    channelPipeline.addLast(<span class="string">&quot;decoder&quot;</span>,<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                    channelPipeline.addLast(<span class="string">&quot;encoder&quot;</span>,<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                    channelPipeline.addLast(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();</span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            System.out.println(channel.localAddress());</span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">                String msg = scanner.nextLine();</span><br><span class="line">                channel.writeAndFlush(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GroupChatClient(<span class="string">&quot;localhost&quot;</span>,<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="心跳检测案例"><a href="#心跳检测案例" class="headerlink" title="心跳检测案例"></a>心跳检测案例</h2><p>有数据交互的时候用SimpleChannelInboundHanlder没有的时候用ChannelInboundHandlerAdapter </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG))<span class="comment">//日志</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//IdleStateHandler是netty提供的处理空闲状态的处理器</span></span><br><span class="line">                            <span class="comment">//readerIdleTime表示多长时间没读 会发送一个心跳检测包检测是否连接</span></span><br><span class="line">                            <span class="comment">//readerIdleTime表示多长时间没写 会发送一个心跳检测包检测是否连接</span></span><br><span class="line">                            <span class="comment">//readerIdleTime表示多长时间没读写 会发送一个心跳检测包检测是否连接</span></span><br><span class="line">                            <span class="comment">//当IdleStatement触发后 就会传递给管道的下一个handler 通过userEventTriggered处理</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>, TimeUnit.SECONDS));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> Handler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture channelFuture = <span class="keyword">null</span>;</span><br><span class="line">            channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line">            IdleStateEvent stateEvent = (IdleStateEvent) evt;</span><br><span class="line">            String eventType = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (stateEvent.state())&#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;读空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;读写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot;++超时时间++&quot;</span> + eventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebSocket长连接"><a href="#WebSocket长连接" class="headerlink" title="WebSocket长连接"></a>WebSocket长连接</h2><p>实例要求：</p><ul><li>http协议是无状态的，浏览器和服务器间的请求响应一次，下一次会重新创建连接</li><li>要求：实现基于webSocket的长连接的全双工的交互</li><li>改变http协议多次请求的约束，实现长连接后，服务器可以发送消息给浏览器</li><li>客户端浏览器和服务器会相互感知</li></ul><p>server</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG))<span class="comment">//日志</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//因为基于http协议 所以要使用http的编码器和解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                            <span class="comment">//http数据在传输过程中是分段的 HttpObjectAggregator可以将数据聚合起来</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">8192</span>));</span><br><span class="line">                            <span class="comment">//浏览器请求时 ws://localhost:7000/hello 表示请求的url</span></span><br><span class="line">                            <span class="comment">//WebSocketServerProtocolHandler的核心功能是将http协议升级为ws协议 保持长连接</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">&quot;/hello&quot;</span>));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> Handler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture channelFuture = <span class="keyword">null</span>;</span><br><span class="line">            channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TextWebSocketFrame表示一个文本帧 数据是以帧的形式传播的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器收到的消息:&quot;</span>+msg.text());</span><br><span class="line">        <span class="comment">//回复消息给浏览器</span></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(msg.text()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().id().asLongText());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//服务器关闭会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().id().asLongText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(cause.getMessage());</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> socket;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//判断当前浏览器是否支持WS</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(<span class="built_in">window</span>.WebSocket)&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//与服务器地址必须对应</span></span></span><br><span class="line"><span class="javascript">            socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:7000/hello&quot;</span>)</span></span><br><span class="line"><span class="javascript">            <span class="comment">//相当于channelRead0 可以接收服务器会送的消息</span></span></span><br><span class="line"><span class="javascript">            socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">&quot;responseText&quot;</span>).value += event.data;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="comment">//连接开启</span></span></span><br><span class="line"><span class="javascript">            socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">&quot;responseText&quot;</span>).value = <span class="string">&quot;连接开启&quot;</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="comment">//连接关闭</span></span></span><br><span class="line"><span class="javascript">            socket.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">&quot;responseText&quot;</span>).value += <span class="string">&quot;连接关闭&quot;</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;当前浏览器不支持ws&quot;</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//发送消息</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">message</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//先判断socket是否创建</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(!<span class="built_in">window</span>.socket)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span></span></span><br><span class="line"><span class="javascript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line">                if(socket.readyState == WebSocket.OPEN)&#123;</span><br><span class="line">                    socket.send(message)</span><br><span class="line"><span class="javascript">                &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                    alert(<span class="string">&quot;连接未开启&quot;</span>)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;发送消息&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;send(this.form.message.value)&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;responseText&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;清空&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编码解码机制"><a href="#编码解码机制" class="headerlink" title="编码解码机制"></a>编码解码机制</h2><p><img src="/2020/12/10/netty/image-20210114171347281.png" alt="image-20210114171347281"></p><p><img src="/2020/12/10/netty/image-20210114171547184.png" alt="image-20210114171547184"></p><h2 id="ProToBuf"><a href="#ProToBuf" class="headerlink" title="ProToBuf"></a>ProToBuf</h2><p>protobuf是一种轻便高效的结构化数据存储方式，可以用于结构化数据串行化(序列化)，以message的方式管理数据，支持跨平台跨语言，高性能高可靠性</p><p>运行过程</p><p><img src="/2020/12/10/netty/image-20210114201233174.png" alt="image-20210114201233174"></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h3><p>编写proto文件</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">//版本</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;StudentPojo&quot;</span>; <span class="comment">//生成的外部类名，同时也是文件名</span></span><br><span class="line"><span class="comment">//使用message管理对象 会在StudentPojo外部类中生成一个内部类 它是真正要发送的pojo对象</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="comment">//proto类型与java类型的对应请查看官方文档 1表示属性序号 不是值</span></span><br><span class="line">  <span class="built_in">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下载protoc 把.proto文件放到protoc.exe同目录下 执行命令:protoc.exe –java_out=. Student.proto</p><p><strong>改写simple中的代码</strong></p><p>在client中加入encoder</p><p><img src="/2020/12/10/netty/image-20210114230945733.png" alt="image-20210114230945733"></p><p>在clientHandler中创建对象并发送</p><p><img src="/2020/12/10/netty/image-20210114231007239.png" alt="image-20210114231007239"></p><p>server中加入decoder</p><p><img src="/2020/12/10/netty/image-20210114231222528.png" alt="image-20210114231222528"></p><p>serverHandler中进行接收</p><p>方式一</p><p><img src="/2020/12/10/netty/image-20210114232038708.png" alt="image-20210114232038708"></p><p>方式二</p><h3 id="传输多种类型"><a href="#传输多种类型" class="headerlink" title="传输多种类型"></a>传输多种类型</h3><p>编写一个含有多个类型的proto文件</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">//版本</span></span><br><span class="line"><span class="keyword">option</span> optimize_for = SPEED; <span class="comment">//加快解析</span></span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;protobuf&quot;</span>; <span class="comment">//指定生成的包</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;DataInfo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MyMessage</span></span>&#123;</span><br><span class="line">  <span class="comment">//定义一个枚举类型</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">DataType</span></span>&#123;</span><br><span class="line">    StudentType = <span class="number">0</span>;</span><br><span class="line">    TeacherType = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//定义属性</span></span><br><span class="line">  DataType data_type = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//表示枚举类型只能出现其中一个</span></span><br><span class="line">  <span class="keyword">oneof</span> dataBody&#123;</span><br><span class="line">    Student student = <span class="number">2</span>;</span><br><span class="line">    Teacher teacher = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="comment">//proto类型与java类型的对应请查看官方文档 1表示属性序号 不是值</span></span><br><span class="line">  <span class="built_in">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改ClientHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//随机发送数据</span></span><br><span class="line">    <span class="keyword">int</span> nextInt = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">    DataInfo.MyMessage myMessage = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(nextInt == <span class="number">0</span>)&#123;</span><br><span class="line">        myMessage = DataInfo.MyMessage.newBuilder().setDataType(DataInfo.MyMessage.DataType.StudentType).setStudent(DataInfo.Student.newBuilder().setId(<span class="number">3</span>).setName(<span class="string">&quot;bob&quot;</span>).build()).build();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        myMessage = DataInfo.MyMessage.newBuilder().setDataType(DataInfo.MyMessage.DataType.TeacherType).setTeacher(DataInfo.Teacher.newBuilder().setAge(<span class="number">23</span>).setName(<span class="string">&quot;bob&quot;</span>).build()).build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ctx.writeAndFlush(myMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 修改server</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ch</span><span class="selector-class">.pipeline</span>()<span class="selector-class">.addLast</span>(&quot;<span class="selector-tag">decoder</span>&quot;,<span class="selector-tag">new</span> <span class="selector-tag">ProtobufDecoder</span>(<span class="selector-tag">DataInfo</span><span class="selector-class">.MyMessage</span><span class="selector-class">.getDefaultInstance</span>()));</span><br></pre></td></tr></table></figure><p>修改serverHandler</p><p><img src="/2020/12/10/netty/image-20210115142725948.png" alt="image-20210115142725948"></p><h2 id="入站与出栈机制"><a href="#入站与出栈机制" class="headerlink" title="入站与出栈机制"></a>入站与出栈机制</h2><p><img src="/2020/12/10/netty/image-20210115143455187.png" alt="image-20210115143455187"></p><h2 id="Handler链调用机制"><a href="#Handler链调用机制" class="headerlink" title="Handler链调用机制"></a>Handler链调用机制</h2><p>package：netty.handler</p><p><img src="/2020/12/10/netty/image-20210115144700212.png" alt="image-20210115144700212"></p><p>使用自定义编解码器来说明handler调用机制 ，客户端和服务端分别可以发送和接收long类型的数据</p><p><strong>Server</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ServerInitializer());</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(<span class="number">8888</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//入站的handler进行解码</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ByteToLongDecoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LongToByteEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;从客户端&quot;</span> + channelHandlerContext.channel().remoteAddress() + <span class="string">&quot;读取到long &quot;</span> + aLong);</span><br><span class="line">        System.out.println(<span class="string">&quot;给客户端发送数据&quot;</span>);</span><br><span class="line">        channelHandlerContext.writeAndFlush(<span class="number">54545L</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//该方法根据接受的数据 被多次调用 如果list内容不为空则将他传入给下一个handler处理 该handler的方法也会被调用多次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(byteBuf.readableBytes() &gt;= <span class="number">8</span>)&#123;</span><br><span class="line">            list.add(byteBuf.readLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, Long aLong, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(aLong);</span><br><span class="line">        byteBuf.writeLong(aLong);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>client</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        EventLoopGroup eventExecutors = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(eventExecutors).channel(NioSocketChannel.class)<span class="comment">//设置客户端通道的实现类</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> ClientInitializer());</span><br><span class="line">            System.out.println(<span class="string">&quot;client is ready&quot;</span>);</span><br><span class="line">            <span class="comment">//启动客户端去连接服务端</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>).sync();</span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">        <span class="comment">//加入一个出站的handler进行解码</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LongToByteEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ByteToLongDecoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息&quot;</span> + aLong);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(<span class="number">1234546L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//MessageToByteEncoder中有一个write方法该方法判断数据是否为Long类型如果不是不进行encoder直接发送</span></span><br><span class="line"><span class="comment">//        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;sdfsafdsadfsdf&quot;, CharsetUtil.UTF_8));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他常用编解码器"><a href="#其他常用编解码器" class="headerlink" title="其他常用编解码器"></a>其他常用编解码器</h2><p><strong>ReplayingDecoder</strong></p><p><img src="/2020/12/10/netty/image-20210116135659701.png" alt="image-20210116135659701"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToLongDecoder2</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//内部自动进行判断</span></span><br><span class="line">        list.add(byteBuf.readLong());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其他解码器</strong></p><p><img src="/2020/12/10/netty/image-20210116140257726.png" alt="image-20210116140257726"></p><h2 id="TCP粘包和拆包"><a href="#TCP粘包和拆包" class="headerlink" title="TCP粘包和拆包"></a>TCP粘包和拆包</h2><p>package：netty.tcp</p><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h3><p><img src="/2020/12/10/netty/image-20210116141719207.png" alt="image-20210116141719207"></p><p><img src="/2020/12/10/netty/image-20210116141840005.png" alt="image-20210116141840005"></p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.readableBytes()];</span><br><span class="line">        byteBuf.readBytes(buffer);</span><br><span class="line">        String s = <span class="keyword">new</span> String(buffer, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端收到消息&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">120</span>;i++)&#123;</span><br><span class="line">            ByteBuf buffer = Unpooled.copiedBuffer(<span class="string">&quot;hello world&quot;</span> + i, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            ctx.writeAndFlush(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.readableBytes()];</span><br><span class="line">        byteBuf.readBytes(buffer);</span><br><span class="line">        String message = <span class="keyword">new</span> String(buffer, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器收到数据&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回送数据</span></span><br><span class="line">        ByteBuf buf = Unpooled.copiedBuffer(UUID.randomUUID().toString(),Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        channelHandlerContext.writeAndFlush(buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义协议解决粘包拆包问题"><a href="#自定义协议解决粘包拆包问题" class="headerlink" title="自定义协议解决粘包拆包问题"></a>自定义协议解决粘包拆包问题</h3><p>package:netty.protocolTcp</p><p><img src="/2020/12/10/netty/image-20210116145332644.png" alt="image-20210116145332644"></p><h2 id="服务器启动源码分析"><a href="#服务器启动源码分析" class="headerlink" title="服务器启动源码分析"></a>服务器启动源码分析</h2><p><strong>EchoServer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> SSL = System.getProperty(<span class="string">&quot;ssl&quot;</span>) != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="string">&quot;port&quot;</span>, <span class="string">&quot;8007&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Configure SSL.</span></span><br><span class="line">        <span class="keyword">final</span> SslContext sslCtx;</span><br><span class="line">        <span class="keyword">if</span> (SSL) &#123;</span><br><span class="line">            SelfSignedCertificate ssc = <span class="keyword">new</span> SelfSignedCertificate();</span><br><span class="line">            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sslCtx = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bossGroup用于接收tcp请求,将请求交割workerGroup，workerGroup会获取真正的连接，然后和连接通信</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline p = ch.pipeline();</span><br><span class="line">                            <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">                            p.addLast(serverHandler);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start the server.</span></span><br><span class="line">            ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Shut down all event loops to terminate all threads.</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>EventLoopGroup</strong>是事件循环组 含有多个EventLoop 可以注册channel 默认线程数:核心线程数 * 2 </p><p>通过debug查看 断点：EventLoopGroup workerGroup = new NioEventLoopGroup()</p><p><img src="/2020/12/10/netty/image-20210117125453180.png" alt="image-20210117125453180"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">NettyRuntime</span>.</span></span>available<span class="constructor">Processors()</span>获取核心线程数</span><br></pre></td></tr></table></figure><p><img src="/2020/12/10/netty/image-20210117130022398.png" alt="image-20210117130022398"></p><p>线程放在数组EventExcutor中：继续debug到方法MultithreadEventExecutorGroup中</p><p><img src="/2020/12/10/netty/image-20210117133132513.png" alt="image-20210117133132513"></p><p>参数说明：</p><ul><li>Executor：如果传入null则采用Netty默认的线程工厂和默认的执行器ThreadPerTaskExecutor</li><li>chooserFactory：单例new  EventExecutorChooserFactory ()</li><li>在创建执行器时传入的固定参数</li></ul><p><img src="/2020/12/10/netty/image-20210117130829226.png" alt="image-20210117130829226"></p><p>为每个单例线程池添加一个关闭监听器</p><p><img src="/2020/12/10/netty/image-20210117133602412.png" alt="image-20210117133602412"></p><p>将所有单例线程池添加到HashSet中</p><p><img src="/2020/12/10/netty/image-20210117133644923.png" alt="image-20210117133644923"></p><p>children的类型是EventExecutor他是NioEventLoop的父接口</p><p><img src="/2020/12/10/netty/image-20210117131059365.png" alt="image-20210117131059365"></p><p><strong>ServerBootStrap</strong>是一个引导类 用于启动服务器和引导整个程序的初始化。和ServerChannel有关联</p><p>首先变量b调用了group方法把两个group放入自己的字段</p><p>然后添加了一个channel 参数为Class，引导类通过这个class对象用ChannelFactory反射创建Channel </p><p>debug到AbstartBootstrap中</p><p><img src="/2020/12/10/netty/image-20210117132618131.png" alt="image-20210117132618131"></p><p>option方法传入tcp参数 放在LinkedHashMap中</p><p>handler方法传入一个handler这个handler专属于ServerSocketChannel而不是SocketChannel</p><p>childHandler传入一个handler 这个handler在每个客户端连接时调用供SocketChannel使用</p><p><strong>bind</strong>:底层调用了dobind，dobind中有两个核心方法initAndRegister()和doBind0</p><p>在iniAndResigter中创建了NioServerSocketChannel，channelFactory.newChannel()做了以下操作</p><ul><li>(1)通过NIO的SelectorProvider的openServerSocketChannel方法得到JDK的通道。目的是让Netty包装JDK的 channel。<br>(2)创建了一个唯一的ChannelId，创建了一个NioMessageUnsecurity，用于操作消息，创建了DefaultChannelPipeline 管道，是个双向链表结构，用于过滤所有的进出的消息。<br>(3创建了一个NioServerSocketChannelConfig对象，用于对外展示一些配置.</li></ul><p>init()方法：</p><ul><li>设置了NioServerSocketChannel的TCP属性</li><li>对NioServerSocketChannel的ChannelPipeline添加ChannelInitialize处理器</li><li>pipeLine是一个双向链表 本身初始化了head和tail 调用addLast方法是将handler插入到tail的前面 tail永远在最后面做一些系统的固定工作</li></ul><p>pipeLine的addLast方法</p><p><img src="/2020/12/10/netty/image-20210118123748135.png" alt="image-20210118123748135"></p><p>dobind0():bind会调用NioServerSocketChannel中的dobind方法</p><p><img src="/2020/12/10/netty/image-20210118125013825.png" alt="image-20210118125013825"></p><p>执行完后 服务启动完成 进入NioEventLoop对事件实行循环监听</p><h2 id="服务器接收客户端请求源码分析"><a href="#服务器接收客户端请求源码分析" class="headerlink" title="服务器接收客户端请求源码分析"></a>服务器接收客户端请求源码分析</h2><p>NioEventLoop的processSelectedKey方法</p><p><img src="/2020/12/10/netty/image-20210118130702064.png" alt="image-20210118130702064"></p><p>查看SelectionKey：当接受一个连接的时候readyOps是16</p><p><img src="/2020/12/10/netty/image-20210118130739324.png" alt="image-20210118130739324"></p><p>在unsafe.read()处标断点 debug 启动 在浏览器访问localhost:8007</p><p>read方法</p><p><img src="/2020/12/10/netty/image-20210118131430679.png" alt="image-20210118131430679"></p><p>doReadMessage方法</p><p><img src="/2020/12/10/netty/image-20210118131506713.png" alt="image-20210118131506713"></p><p>pipeline.fireChannelRead方法</p><p><img src="/2020/12/10/netty/image-20210118132243964.png" alt="image-20210118132243964"></p><p>channelRead方法</p><p><img src="/2020/12/10/netty/image-20210118135049425.png" alt="image-20210118135049425"></p><p><img src="/2020/12/10/netty/image-20210118132559863.png" alt="image-20210118132559863"></p><p><img src="/2020/12/10/netty/image-20210118140151220.png" alt="image-20210118140151220"></p><p>register底层调用</p><p><img src="/2020/12/10/netty/image-20210118140217227.png" alt="image-20210118140217227"></p><p>next返回一个Executor它是workGroup子线程中的一个</p><p>regiter把channel再次包装 </p><p><img src="/2020/12/10/netty/image-20210118140308861.png" alt="image-20210118140308861"></p><p>最后调用的是AbstractChannel中的register</p><p><img src="/2020/12/10/netty/image-20210118140655725.png" alt="image-20210118140655725"></p><p>最后调用doBeginRead开始监听读</p><h2 id="pipeline源码分析"><a href="#pipeline源码分析" class="headerlink" title="pipeline源码分析"></a>pipeline源码分析</h2><p>每当ServerSocket创建一个连接的时候 都会创建一个socket 每个新建的socket都会被分配一个ChannelPipeline 每个ChannelPipeline都会包含多个Context context是对handler的封装</p><p>入站出站是根据context的状态进行判断 找到链中相应的handler</p><p><img src="/2020/12/10/netty/image-20210122133352078.png" alt="image-20210122133352078"></p><p><img src="/2020/12/10/netty/image-20210122133737141.png" alt="image-20210122133737141"></p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC—远程过程调用，是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程，当两个或多个应用程序都分布在不同的服务器上，它们之间的调用都像是本地方法调用一样(如图)</p><p><img src="/2020/12/10/netty/image-20210122140307335.png" alt="image-20210122140307335"></p><h2 id="基于Netty实现DubboRPC"><a href="#基于Netty实现DubboRPC" class="headerlink" title="基于Netty实现DubboRPC"></a>基于Netty实现DubboRPC</h2>]]></content>
    
    
    <summary type="html">Netty是一个异步的，基于事件驱动的网络应用框架，用以快速开发高性能 高可靠性的网络IO程序，本质是一个NIO框架 适用于服务器通讯相关的多种应用场景</summary>
    
    
    
    <category term="高并发" scheme="http://example.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="http://example.com/2020/12/01/redis/"/>
    <id>http://example.com/2020/12/01/redis/</id>
    <published>2020-12-01T10:13:56.000Z</published>
    <updated>2021-02-18T07:49:49.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><strong>redis-benchmark</strong>可以进行性能测试</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>1</td><td><strong>-h</strong></td><td>指定服务器主机名</td><td>127.0.0.1</td></tr><tr><td>2</td><td><strong>-p</strong></td><td>指定服务器端口</td><td>6379</td></tr><tr><td>3</td><td><strong>-s</strong></td><td>指定服务器 socket</td><td></td></tr><tr><td>4</td><td><strong>-c</strong></td><td>指定并发连接数</td><td>50</td></tr><tr><td>5</td><td><strong>-n</strong></td><td>指定请求数</td><td>10000</td></tr><tr><td>6</td><td><strong>-d</strong></td><td>以字节的形式指定 SET/GET 值的数据大小</td><td>2</td></tr><tr><td>7</td><td><strong>-k</strong></td><td>1=keep alive 0=reconnect</td><td>1</td></tr><tr><td>8</td><td><strong>-r</strong></td><td>SET/GET/INCR 使用随机 key, SADD 使用随机值</td><td></td></tr><tr><td>9</td><td><strong>-P</strong></td><td>通过管道传输 <numreq> 请求</numreq></td><td>1</td></tr><tr><td>10</td><td><strong>-q</strong></td><td>强制退出 redis。仅显示 query/sec 值</td><td></td></tr><tr><td>11</td><td><strong>–csv</strong></td><td>以 CSV 格式输出</td><td></td></tr><tr><td>12</td><td><strong>-l</strong></td><td>生成循环，永久执行测试</td><td></td></tr><tr><td>13</td><td><strong>-t</strong></td><td>仅运行以逗号分隔的测试命令列表。</td><td></td></tr><tr><td>14</td><td><strong>-I</strong></td><td>Idle 模式。仅打开 N 个 idle 连接并等待。</td><td></td></tr></tbody></table><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6379</span> -t <span class="keyword">set</span>,lpush -n <span class="number">10000</span> -q</span><br></pre></td></tr></table></figure><p>默认有16个数据库 可以使用select n 进行切换</p><p>清空当前数据库：flushdb</p><p>清空所有数据库：flushall</p><p>查看所有key：keys * </p><p>判断key是否存在：exists name</p><p>设置过期时间 单位秒：expire name n</p><p>查看key的剩余时间：ttl name</p><p>查看key的类型：type name</p><p>移动key到其他数据库：move name n</p><p>删除key：del name</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>数字和字符串都用String存储</p><p>set</p><p>get</p><p>append：追加字符串 没有的话新建一个</p><p>strlen：获取字符串长度</p><p>incr：自增 第二个参数可以指定步长 incr views 10</p><p>decr：自减 第二个参数可以指定步长</p><p>getrange：getrange name 0 3  如果最后一个参数是-1则获取整个字符串</p><p>setrange: setrange name 0 xx  =&gt; abcde-&gt;xxcde</p><p>setex：为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值。setex name 10 bob</p><p>setnx：如果不存在才创建 setnx name bob </p><p>mget：批量获取值 mget k1 k2</p><p>mset：批量设置值 mset k1 v1 k2 v2</p><p>msetnx：原子性的 要么批量成功要么批量失败</p><p>设置对象：</p><pre><code>1. set user:1 &#123;name:zhangdan,age:3&#125; 获取：get user:12. set user:1 &#123;name:zhangdan,age:3&#125;  获取：get user:1:name</code></pre><p>getset：返回旧值 设置新值 getset name bob</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>lpush(头插法)：从左端放入对应的是rpush(尾插法)</p><p>lrange：获取指定范围 如果最后一个参数是-1则获取全部</p><p>lpop：移除头部元素 对应的是rpop</p><p>lindex：获取下标对应的元素</p><p>llen：返回列表长度</p><p>lrem：移除指定的值 第二个参数是移除的数量 lrm list 1 one 从头部开始移除</p><p>ltrim： ltrim list 0 3 只留下 下标0-3的元素</p><p>rpoplpush：rpoplpush list mylist  把list最右边的元素移除并添加到mylist中</p><p>lset：lset list [index] [new_value] 将指定下标的值替换为另一个</p><p>linsert：linsert list after/before “two” “world” 往two后面/前面插入world</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>set中的值不能重复</p><p>sadd： 添加元素</p><p>srem：移除指定元素</p><p>spop：随机删除元素</p><p>srandmember：随机获取n个元素</p><p>smembers：查看集合中的元素</p><p>sismember：查看集合中是否有某个元素</p><p>scard：获取集合中的元素个数</p><p>smove set1 set2 value1将指定值移动到set2</p><p>sdiff set1 set2查看set1中哪些元素set2中没有</p><p>sinter：两个集合的交集</p><p>sunion：两个集合的并集</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>存放的key是一个map</p><p>hset和hget：设置 获取元素 也有hmset和hmget</p><p>hsetnx</p><p>hgetall：获取所有键值对</p><p>hdel：删除</p><p>hlen：获取键值对数量</p><p>hkeys：只获取所有key</p><p>hvals：只获取所有value</p><p>hincrby ：hincrby hash age 5 </p><h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><p>是set的有序版本</p><p>zset：zset myset 1 bob </p><p>zrange</p><p>zrangebyscore：第二个和第三个参数指定范围 降序是zrevrangebyscore</p><p>​    <img src="/2020/12/01/redis/image-20201202093438696.png" alt="image-20201202093438696"></p><p>zrem ：移除元素</p><p>zcard：获取有序集合中的个数</p><p>zcount：获取指定区间的成员数量</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>不保证原子性：Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p><p>没有隔离级别的概念</p><p>开启事务：multi</p><p>执行事务：exec</p><p>​    <img src="/2020/12/01/redis/image-20201202100249565.png" alt="image-20201202100249565"></p><p>discard：取消事务 事务队列中的命令都不会被执行</p><p>​    <img src="/2020/12/01/redis/image-20201202100555522.png" alt="image-20201202100555522"></p><p>如果事务中出现编译型异常(代码有问题或者命令出错) 所有命令都不会执行 ，如果事务中出现运行时异常(get不存在的值) 其他命令可以正常执行</p><p><strong>redis实现乐观锁</strong></p><p>watch：监视一个元素 如果事务中有其他线程修改这个值 则事务执行失败 失败后可以使用unwatch取消监视 再次watch并开始事务</p><p>unwatch：取消所有的监视    </p><p>通过</p><h1 id="操作redis"><a href="#操作redis" class="headerlink" title="操作redis"></a>操作redis</h1><h2 id="通过jedis操作redis"><a href="#通过jedis操作redis" class="headerlink" title="通过jedis操作redis"></a>通过jedis操作redis</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.52.131&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//执行事务</span></span><br><span class="line">        Transaction multi = jedis.multi();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            multi.set(<span class="string">&quot;value1&quot;</span>,<span class="string">&quot;bob&quot;</span>);</span><br><span class="line">            multi.set(<span class="string">&quot;value2&quot;</span>,<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            multi.get(<span class="string">&quot;value1&quot;</span>);</span><br><span class="line"></span><br><span class="line">            multi.exec();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            multi.discard();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;value2&quot;</span>));</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBoot整合redis"><a href="#SpringBoot整合redis" class="headerlink" title="SpringBoot整合redis"></a>SpringBoot整合redis</h2><p>引入依赖：spring-boot-starter-data-redis</p><p><img src="/2020/12/01/redis/image-20201202104116611.png" alt="image-20201202104116611"></p><p>源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RedisOperations.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RedisProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">      RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">      template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">      <span class="keyword">return</span> template;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">      StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">      template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">      <span class="keyword">return</span> template;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Database index used by the connection factory.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> database = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Connection URL. Overrides host, port, and password. User is ignored. Example:</span></span><br><span class="line"><span class="comment">    * redis://user:password@example.com:6379</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Redis server host.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> String host = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Login password of the redis server.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Redis server port.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> port = <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Whether to enable SSL support.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> ssl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Connection timeout.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> Duration timeout;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Client name to be set on connections with CLIENT SETNAME.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> String clientName;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Sentinel sentinel;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Cluster cluster;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">    connection.flushAll();</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;23&quot;</span>);</span><br><span class="line">    String name = (String)redisTemplate.opsForValue().get(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义RedisTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class="line">        RedisTemplate&lt;String,Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//配置具体的序列化方式</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        <span class="comment">//String的序列化</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h1><p>daemonize yes ：以守护进程的方式运行 默认是no 需要自己开启</p><p>pidfile /var/run/redis_6379.pid：如果以后台方式运行 需要制定pid文件</p><p>save 120 1：表示如果120s内至少有一条数据改动 则进行持久化</p><p>stop-writes-on-bgsave-error yes：持久化失败后 是否继续工作</p><p>rdbcompression yes：是否压缩rdb文件，需要消耗一些cpu资源</p><p>rdbchechsum yes：保存rdb文件的时候 进行错误的校验</p><p>dir ./：文件的保存目录 </p><p>maxclients：设置能连接上redis的最大客户端数</p><p>maxmemory：配置最大的内存容量</p><p>aof配置</p><p>​    appendonly  no ：默认不开启</p><p>​    appendfilename：持久化的文件名</p><p>​    appendfsync everysec：每秒执行 一次 同步 这1s可能会丢失数据</p><h1 id="持久化之RDB操作"><a href="#持久化之RDB操作" class="headerlink" title="持久化之RDB操作"></a>持久化之RDB操作</h1><p>流程：</p><p><img src="/2020/12/01/redis/image-20201202233309973.png" alt="image-20201202233309973"></p><p>在指定时间间隔内将内存中的数据集快照写入磁盘，恢复时将快照文件直接读到内存中</p><p>Redis会单独创建 ( fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p><p>触发机制：默认生成dump.rdb文件</p><ul><li>save的规则 满足的情况下 会自动触发rdb规则</li><li>执行flushdb命令时 会触发</li><li>退出redis 也会触发</li></ul><p>只需要将rdb文件放入到redis启动目录就行 redis启动的时候自动检查dump.rdb并回复其中的数据</p><p>通过命令 config get dir查看启动目录</p><h1 id="持久化之AOF操作"><a href="#持久化之AOF操作" class="headerlink" title="持久化之AOF操作"></a>持久化之AOF操作</h1><p>流程：</p><p><img src="/2020/12/01/redis/image-20201202234131430.png" alt="image-20201202234131430"></p><p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p><p>Aof保存的是appendonely.aof文件 </p><p>默认是不开启的 需要手动开启</p><p>如果aof文件被修改 就会启动失败 可以进行修复redis-check-aof –fix appendonly.aof</p><p>优点</p><ul><li>每一个修改都会同步，文件完整性会更好</li><li>每秒同步一次，可能会丢失一秒的数据</li></ul><p>缺点</p><ul><li>aof数据文件远大于rdb 修复数据较慢</li><li>aof运行速率较慢</li></ul><p>如果aof大小超过了默认配置，会fork一个新的线程来将我们的文件进行重写，这里重写是为了将aof文件变得更小，降低文件占用空间，以便更快的被redis加载</p><p><strong>同时开启两种持久化方式</strong></p><ul><li>·在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li><li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢?作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。</li></ul><p><strong>性能建议</strong></p><ul><li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 9001这条规则。</li><li>如果Enable AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite的最后将 rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</li><li>如果不Enable AOF，仅靠Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave 中的RDB文件，载入较新的那个，微博就是这种架构。</li></ul><h1 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h1><p><strong>流程</strong></p><p><img src="/2020/12/01/redis/image-20201203001310583.png" alt="image-20201203001310583"></p><p><strong>命令</strong></p><p><img src="/2020/12/01/redis/image-20201203001635483.png" alt="image-20201203001635483"></p><p><strong>测试</strong>：创建两个redis连接 一个订阅subscribe diantai 一个推送消息publish diantai hello </p><p><strong>底层实现</strong></p><p><img src="/2020/12/01/redis/image-20201203002602416.png" alt="image-20201203002602416"></p><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>数据的复制是单向的 只能从主机复制到从机 主节点可以有多个从节点 一个从节点只能由一个主节点</p><p>设置主人：slaveof ip port  (建议在配置文件中进行配置)  查看信息：info replication</p><p>从机不能写 只能读 主机中的信息和数据会自动保存到从机中</p><p><strong>复制原理</strong></p><p><img src="/2020/12/01/redis/image-20201203083755766.png" alt="image-20201203083755766"></p><p><strong>哨兵模式</strong></p><p>哨兵是一个独立的进程 ，作为进程 他会独立运行，其原理是哨兵通过发送命令，等待redis服务器响应，从而监控运行的多个redis实例</p><p><img src="/2020/12/01/redis/image-20201203084635501.png" alt="image-20201203084635501"></p><p>当哨兵监控到master宕机 会自动将slave切换成master 然后通过发布订阅通知通知其他从服务器 修改配置文件 让他们切换主机</p><p>一个哨兵可能会出现问题 使用多个哨兵进行监控</p><p><img src="/2020/12/01/redis/image-20201203084841536.png" alt="image-20201203084841536"></p><p>主观下线和客观下线</p><p><img src="/2020/12/01/redis/image-20201203090416317.png" alt="image-20201203090416317"></p><p>配置哨兵配置文件sentinel.conf</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor myredis<span class="built_in"> ip port </span>1 #最后一个参数 是否进行重新投票</span><br></pre></td></tr></table></figure><p>启动哨兵：redis-sentinel /config/sentinel.conf</p><p>当主机宕机的时候 会自动挑选一个从机作为主机 宕机的主机修复后成为从机</p><h1 id="缓存穿透和雪崩"><a href="#缓存穿透和雪崩" class="headerlink" title="缓存穿透和雪崩"></a>缓存穿透和雪崩</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h2><p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀!），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p><p><strong>解决方法</strong></p><p><strong>布隆过滤器</strong>：是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合就舍弃，从而避免了对底层存储系统的查询压力</p><p><strong>缓存空对象</strong>：当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源</p><p><img src="/2020/12/01/redis/image-20201203094734020.png" alt="image-20201203094734020"></p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><strong>缓存击穿</strong></h2><p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><p>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p><p><strong>解决方案</strong></p><p>设置热点数据永不过期</p><p>加互斥锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h2><p>缓存雪崩是指在某一时间段，缓存集中过期失效，redis宕机</p><p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p><p><strong>解决方案</strong></p><p>高可用：搭建集群</p><p>限流降级：缓存失效后，通过加锁或队列来控制数据库写缓存的线程数量</p><p>数据预热：数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>]]></content>
    
    
    <summary type="html">Redis，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库</summary>
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>牛客网练习题笔记</title>
    <link href="http://example.com/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-23T15:16:32.000Z</published>
    <updated>2021-03-12T11:34:33.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="希尔排序是不是一种稳定的排序方法？"><a href="#希尔排序是不是一种稳定的排序方法？" class="headerlink" title="希尔排序是不是一种稳定的排序方法？"></a>希尔排序是不是一种稳定的排序方法？</h2><p>答：由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p><p><a href="https://www.cnblogs.com/chengxiao/p/6104371.html">图解算法之希尔排序</a></p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><a href="https://blog.csdn.net/qq_34840129/article/details/80619761?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control">前中后序遍历</a></p><ul><li><p>前序遍历：根左右</p></li><li><p>中序遍历：左根右</p></li><li><p>后序遍历：左右根</p></li></ul><p><a href="https://blog.csdn.net/adminabcd/article/details/46672759?utm_medium=distribute.pc_relevant_t0.none-task-blog-searchFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-searchFromBaidu-1.control">n个节点的二叉树有多少种形态</a></p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p><a href="https://baijiahao.baidu.com/s?id=1618548971082312617&wfr=spider&for=pc">关于IP地址、网络地址、子网掩码、广播地址的理解</a></p><p><a href="https://blog.csdn.net/u014465934/article/details/81146443">子网掩码、网络地址、广播地址的计算</a></p><p>面试问题</p><ul><li><a href="https://blog.csdn.net/weixin_41910694/article/details/91960815">https://blog.csdn.net/weixin_41910694/article/details/91960815</a></li><li><a href="https://blog.csdn.net/qq_39322743/article/details/79700863">https://blog.csdn.net/qq_39322743/article/details/79700863</a></li></ul><p>RIP基础知识</p><ul><li><a href="https://cshihong.blog.csdn.net/article/details/80503512?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control">https://cshihong.blog.csdn.net/article/details/80503512?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control</a></li><li><a href="https://bingw.blog.csdn.net/article/details/53346473?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control">https://bingw.blog.csdn.net/article/details/53346473?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control</a></li></ul><p>CRC校验原理</p><ul><li><a href="https://blog.csdn.net/qiaobt/article/details/81661345">https://blog.csdn.net/qiaobt/article/details/81661345</a></li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p><a href="https://blog.csdn.net/starlh35/article/details/76445267?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.control">并发操作会带来哪些数据不一致性</a>:<strong>丢失的修改、不可重复读、读脏数据、幻影读</strong>（幻影读在一些资料中往往与不可重复读归为一类）。</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>问：写个的sql查询语句，如有一张表示英语口语练习每个学员的学时的表a，字段有 studentid(学号) name(可重复) grade(年级) hours（学时），找出那些学时高于他们同一年级的平均学时的学生。</p><p>答：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">table</span>  a <span class="keyword">left</span>  <span class="keyword">join</span>  (<span class="keyword">SELECT</span> grade,<span class="keyword">AVG</span>(<span class="keyword">hours</span>) <span class="keyword">as</span> <span class="keyword">hours</span> <span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> grade) <span class="keyword">as</span> b <span class="keyword">on</span> a.grade=b.grade <span class="keyword">where</span>   a.hours&gt;b.hours <span class="keyword">AND</span> a.grade=b.grade</span><br></pre></td></tr></table></figure><p>问：<a href="https://blog.csdn.net/qq_35571554/article/details/82796278">说下你对索引的理解，以及数据库索引的数据结构，为什么会被设计为b树或者B+树</a></p><p>答：索引用于提升数据库的查找速度。 主要从树的高度、降低磁盘io两方面展开</p><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><ol><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseClass</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;I’m BaseClass class&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">static</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;static BaseClass&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> <span class="keyword">extends</span> <span class="title">BaseClass</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;I’m Base class&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">static</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;static Base&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">new</span> Base();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><p>执行顺序为：父类静态代码块 -&gt;子类静态代码块 -&gt;父类非静态代码块 -&gt; 父类构造函数 -&gt; 子类非静态代码块 -&gt; 子类构造函数。</p><ol start="2"><li>对象空间被收集掉之后，会执行该对象的finalize方法(×)：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法， 并且在<strong>下一次</strong>垃圾回收动作发生时，才会<strong>真正的</strong>回收对象占用的内存</li></ol><ol start="3"><li><strong>包的作用</strong></li></ol><ul><li>1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</li><li>2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li><li>3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li></ul><p>Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。</p><ol start="4"><li>java中 %是取余运算最后符号和第1个值一样</li><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201228162626849.png" alt="image-20201228162626849"></li></ol><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201228162636766.png" alt="image-20201228162636766"></p><ol start="6"><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201228163509069.png" alt="image-20201228163509069"></li></ol><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201228163617276.png" alt="image-20201228163617276"></p><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201228163529004.png" alt="image-20201228163529004"></p><ol start="7"><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201228163800403.png" alt="image-20201228163800403"></li></ol><p>我们在执行URL u =new URL(“<a href="http://www.123.com/">http://www.123.com</a>“);这句话的时候确实要抛出异常，但是这个异常属于IOException，不管网址是否存在，最后都会返回该网址的一个连接，打印出来就是该网址。</p><ol start="8"><li><a href="https://blog.csdn.net/liangyihuai/article/details/83106584">CyclicBarrier和CountDownLatch都可以让一组线程等待其他线程。前者是让一组线程相互等待到某一个状态再执行。后者是一个线程等待其他线程结束再执行。</a></li></ol><p><strong>Callable中的call比Runnable中的run厉害就厉害在有返回值和可以抛出异常。同时这个返回值和线程池一起用的时候可以返回一个异步对象Future。</strong></p><ol start="9"><li><p>java8中，忽略内部接口的情况，不能用来修饰interface里的方法的修饰符有:private , protected</p></li><li><p>抽象方法只可以被public 和 protected修饰；</p></li><li><p>重载与方法的返回值类型与访问权限无关</p></li><li><p>线程私有：虚拟机栈，程序计数器，本地方法栈  共享:java堆，方法区</p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201228164700773.png" alt="image-20201228164700773"></p></li></ol><ul><li>声明的时候不能指定大小</li></ul><ol start="14"><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201228164913519.png" alt="image-20201228164913519"></li></ol><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201228164946718.png" alt="image-20201228164946718"></p><ol start="15"><li><p>java运算符优先级：<a href="http://c.biancheng.net/view/794.html">http://c.biancheng.net/view/794.html</a></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105170242902.png" alt="image-20210105170242902"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105170252150.png" alt="image-20210105170252150"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105171431976.png" alt="image-20210105171431976"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105171440894.png" alt="image-20210105171440894"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105171937623.png" alt="image-20210105171937623"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105172313366.png" alt="image-20210105172313366"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105172515143.png" alt="image-20210105172515143"></p><ol><li><pre><code class="java">public static void main(String[] args) &#123;    String str = &quot;12,3&quot;;    String str2 = &quot;123&quot;;    System.out.print(str.split(&quot;,&quot;).length);//2    //String split 这个方法默认返回一个数组，如果没有找到分隔符，会把整个字符串当成一个长度为1的字符串数组返回到结果    System.out.print(str2.split(&quot;,&quot;).length);//2&#125;</code></pre></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105173044278.png" alt="image-20210105173044278"></p><ol><li>注意equal和==的区别</li></ol></li><li><p>接口中的属性默认是private static final</p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105173343910.png" alt="image-20210105173343910"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105173635738.png" alt="image-20210105173635738"></p><ol><li>数组元素在内存中是一个接着一个线性存放的，通过第一个元素就能访问随后的元素，避免了数据覆盖的可能性，和数据类型覆盖并没有关系。</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105173752455.png" alt="image-20210105173752455"></p><ol><li><p>这类多态问题中，无论向上或向下转型，都记住一句话就可以了。</p><p><strong>编译看左边，运行看右边。</strong>意思编译时候，看左边有没有该方法，运行的时候结果看 <strong>new</strong> 的对象是谁，就调用的谁。</p></li></ol></li><li><p>单例模式中，两个基本要点是:构造函数私有,唯一实例</p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105174349947.png" alt="image-20210105174349947"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105174358254.png" alt="image-20210105174358254"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105174542394.png" alt="image-20210105174542394"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105174601119.png" alt="image-20210105174601119"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105174723561.png" alt="image-20210105174723561"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106211441331.png" alt="image-20210106211441331"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106211458214.png" alt="image-20210106211458214"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106211835788.png" alt="image-20210106211835788"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106211852176.png" alt="image-20210106211852176"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106212423016.png" alt="image-20210106212423016"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106212429344.png" alt="image-20210106212429344"></li><li>A B D是并发编程的锁机制相关，Future是一个线程任务的返回结果的‘欠条’。</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106213047691.png" alt="image-20210106213047691"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106213058066.png" alt="image-20210106213058066"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106213443483.png" alt="image-20210106213443483"></p><ol><li>second中v.i = <code>20</code>;已经改变v指向的对象中的值 所以first最后一行打印的应该是20</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106214233706.png" alt="image-20210106214233706"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106214323629.png" alt="image-20210106214323629"></li><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106214330068.png" alt="image-20210106214330068"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106214433699.png" alt="image-20210106214433699"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106214444017.png" alt="image-20210106214444017"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106214547104.png" alt="image-20210106214547104"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106214552994.png" alt="image-20210106214552994"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106214614323.png" alt="image-20210106214614323"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107171020455.png" alt="image-20210107171020455"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107171509591.png" alt="image-20210107171509591"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107171510385.png" alt="image-20210107171510385">z<img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107171513513.png" alt="image-20210107171513513"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107172001632.png" alt="image-20210107172001632"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107172012758.png" alt="image-20210107172012758"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107174912026.png" alt="image-20210107174912026"></p><ol><li>Square没有重写equal方法 判断的还是两个引用是否相等</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107175344971.png" alt="image-20210107175344971"></p><ol><li>接口方法默认是public abstract的，且实现该接口的类中对应的方法的可见性不能小于接口方法的可见性，因此也只能是public的。</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107180458042.png" alt="image-20210107180458042"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107180503469.png" alt="image-20210107180503469"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107180943624.png" alt="image-20210107180943624"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107180950765.png" alt="image-20210107180950765"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107184059579.png" alt="image-20210107184059579"></p><ol><li>（1）是一个普通方法</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107184205583.png" alt="image-20210107184205583"></p><ol><li>Java中静态变量只能在类主体中定义，不能在方法中定义。</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107184306702.png" alt="image-20210107184306702"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107194106028.png" alt="image-20210107194106028"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107194132761.png" alt="image-20210107194132761"></li></ol></li><li><p>正则表达式的学习</p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107202231599.png" alt="image-20210107202231599"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107202501184.png" alt="image-20210107202501184"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109175818399.png" alt="image-20210109175818399"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109175910347.png" alt="image-20210109175910347"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109180045460.png" alt="image-20210109180045460"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109180301821.png" alt="image-20210109180301821"></p><ol><li>子类可以不是abstract</li><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109180518044.png" alt="image-20210109180518044"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109180552071.png" alt="image-20210109180552071"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109180557485.png" alt="image-20210109180557485"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109180719868.png" alt="image-20210109180719868"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109181346678.png" alt="image-20210109181346678"></p><ol><li>读取路径是request做的</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109181704154.png" alt="image-20210109181704154"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109181727290.png" alt="image-20210109181727290"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109182209631.png" alt="image-20210109182209631"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109182215903.png" alt="image-20210109182215903"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109182505921.png" alt="image-20210109182505921"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109182834824.png" alt="image-20210109182834824"></p><ol><li><img src="file://D:/log/source/_posts/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109182834824.png?lastModify=1610188297" alt="image-20210109182834824"><ol><li>实例变量是在类声明的内部但是在类的其他成员方法之外声明的</li><li>类的成员变量包括实例变量和类变量（静态变量）,成员方法包括实例方法和类方法（静态方法）</li></ol></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109183322635.png" alt="image-20210109183322635"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109183337878.png" alt="image-20210109183337878"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210110184406346.png" alt="image-20210110184406346"></p><ol><li>A、abstract修饰的类，不可实例化，所以需要子类去继承，然后重写其中的抽象方法。但是final修饰类是不可继承的。两者属性相冲。</li><li>D、static不可以修饰非static的属性，因为类加载的时候，static属性比非static先初始化，那么一个存在的总不能访问一个没有存在的吧。</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210110185014750.png" alt="image-20210110185014750"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210110185023277.png" alt="image-20210110185023277"></li></ol></li><li><p>重载和重写的区别</p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210110185211470.png" alt="image-20210110185211470"></p><ol><li>服务器就创建了一个application</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210110185442964.png" alt="image-20210110185442964"></p><ol><li>java的赋值运算有返回值 赋什么值就返回什么值</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210110190014730.png" alt="image-20210110190014730"></p><ol><li>子类可以继承父类的全部数据域和方法，但是这里继承代表的是“拥有”，即：只是拥有父类的全部数据域和方法，但不具备对某些私有数据域或私有方法的使用权（调用）。</li></ol></li><li><p>实现多线程的方法：继承Thread类 实现Runnable接口 实现Callable接口</p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210110190522958.png" alt="image-20210110190522958"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210110191027017.png" alt="image-20210110191027017"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210110191154675.png" alt="image-20210110191154675"></p><ol><li><img src="https://uploadfiles.nowcoder.com/images/20180701/3807435_1530425536125_D49BCBCCF82CF58C566E12F1E3130070" alt="img"></li></ol></li><li><p>session中存储属性：session.setAttribute(“key”，”value”)</p></li><li><p>Sting,StringBuilder,StringBuffer</p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115165852224.png" alt="image-20210115165852224"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115170023661.png" alt="image-20210115170023661"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115170037923.png" alt="image-20210115170037923"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115170304923.png" alt="image-20210115170304923"></p><ol><li>因为String是被final修饰的类，所以本身的内容是不会改变的，相当于基本数据类型的值传递，在changge方法中给str赋值了“test”，相当于重新创建了一个string类型的变量</li><li>注意String str = “test”; 和 String str = new String(“test”);的区别</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115171538415.png" alt="image-20210115171538415"></p><ol><li><strong>如果try，finally语句里均有return，忽略try的return，而使用finally的return.</strong></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115172030479.png" alt="image-20210115172030479"></p><ol><li>java object默认的基本方法中没有copy()，含有如下方法：getClass(), hashCode(), equals(), clone(), toString(), notify(), notifyAll(), wait(), finalize()</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115172236655.png" alt="image-20210115172236655"></p><ol><li>导入java.util.*不能读取其子目录的类，因为如果java.util里面有个a类，java.util.regex里面也有个a类，我们若是要调用a类的方法或属性时，应该使用哪个a类呢。所以也应该选C</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115172352568.png" alt="image-20210115172352568"></p><ol><li><p>首先 super.getClass() 是父类的getClass（）方法，其父类是Date，它的getClass（）方法是继承自Object类而且没有重写，</p><p>所以就是调用<strong>object的getClass（）方法。而看一下getclass的方法解释如下图</strong></p><p><img src="https://uploadfiles.nowcoder.com/images/20160722/579609_1469158660593_072774B6B658B3603E1AA7198722775C"></p><p><strong>所以可以知道是返回当前运行时的类。</strong></p></li><li><p>在调用getName()方法而getName()是：包名+类名**</p></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115172522217.png" alt="image-20210115172522217"></p><ol><li>web容器是一种服务程序，在服务器一个端口就有一个提供相应服务的程序，而这个程序就是处理从客户端发出的请求，如JAVA中的Tomcat容器，ASP的IIS或PWS都是这样的容器。一个服务器可以多个容器。</li><li>servlet是运行在服务器端的小应用程序，是接收网络服务的请求和产生响应的一种方式。servlet的功能：接受http请求，产生动态http响应。</li></ol></li><li><p>true flase null不是关键字</p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115172819184.png" alt="image-20210115172819184"></p><ol><li><p>Jsp只会在客户端第一次发请求的时候被编译，之后的请求不会再编译，同时tomcat能自动检测jsp变更与否，变更则再进行编译。</p><p>第一次编译并初始化时调用： init() ；销毁调用： destroy() 。在整个jsp生命周期中均只调用一次。 </p><p>service()方法是接收请求，返回响应的方法。每次请求都执行一次，该方法被HttpServlet封装为doGet和doPost方法</p></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115172950347.png" alt="image-20210115172950347"></p><ol><li>ab相同 cd相同</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115173104765.png" alt="image-20210115173104765"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115173119227.png" alt="image-20210115173119227"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210116162100847.png" alt="image-20210116162100847"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210116162408021.png" alt="image-20210116162408021"></p><ol><li>不能有两个public类 子类不能访问父类的私有变量</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210116162521133.png" alt="image-20210116162521133"></p><ol><li>EOFException：当输入过程中意外到达文件或流的末尾时，抛出此异常。</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210116163034404.png" alt="image-20210116163034404"></p><ol><li>枚举类有三个实例，故调用三次构造方法，打印三次It is a account type</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210116163256251.png" alt="image-20210116163256251"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210116163328489.png" alt="image-20210116163328489"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210117161309975.png" alt="image-20210117161309975"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210117160613840.png" alt="image-20210117160613840"></p><ol><li><p><strong>（1）从速度上看：System.arraycopy &gt; clone &gt; Arrays.copyOf &gt; for</strong><br><strong>（2）for的速度之所以最慢是因为下标表示法每次都从起点开始寻位到指定下标处（现代编译器应该对其有进行优化，改为指针），另外就是它每一次循环都要判断一次是否达到数组最大长度和进行一次额外的记录下标值的加法运算。</strong> </p><p>（3）System.arraycopy:native方法+jvm手写函数 在jvm中预写好速度最快</p><p>（4）clone:native方法但并未手写 需要jni转换 速度其次</p><p><strong>（5）查看Arrays.copyOf的源码可以发现，它其实本质上是调用了System.arraycopy。之所以时间差距比较大，是因为很大一部分开销全花在了Math.min函数上了。</strong></p></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210117161051627.png" alt="image-20210117161051627"></p><ol><li><strong>由于replaceAll方法的第一个参数是一个正则表达式，而”.”在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成”/“。如果想替换的只是”.”，那么久要写成”\.”</strong></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210117161540388.png" alt="image-20210117161540388"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210117161724389.png" alt="image-20210117161724389"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210117162000840.png" alt="image-20210117162000840"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210117162008056.png" alt="image-20210117162008056"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210117162150331.png" alt="image-20210117162150331"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210117162201796.png" alt="image-20210117162201796"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210117162552290.png" alt="image-20210117162552290"></p><ol><li><p>主要考核了这几个知识点：</p><p>1.静态内部类才可以声明静态方法</p><p>2.静态方法不可以使用非静态变量</p><p>3.抽象方法不可以有函数体 </p></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122162446809.png" alt="image-20210122162446809"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122162647241.png" alt="image-20210122162647241"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122162653784.png" alt="image-20210122162653784"></li><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122162702612.png" alt="image-20210122162702612"></li><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122162709782.png" alt="image-20210122162709782"></li><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122162716157.png" alt="image-20210122162716157"></li><li>只有A可以指定字符集、</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122162912805.png" alt="image-20210122162912805"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122162922723.png" alt="image-20210122162922723"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122163014350.png" alt="image-20210122163014350"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122163035993.png" alt="image-20210122163035993"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122163405991.png" alt="image-20210122163405991"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122163427923.png" alt="image-20210122163427923"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122163637223.png" alt="image-20210122163637223"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122163642864.png" alt="image-20210122163642864"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122163758860.png" alt="image-20210122163758860"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122163810456.png" alt="image-20210122163810456"></li></ol></li><li><p>重载与重写：<a href="https://blog.csdn.net/wintershii/article/details/80558739">https://blog.csdn.net/wintershii/article/details/80558739</a></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122164017658.png" alt="image-20210122164017658"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123124816263.png" alt="image-20210123124816263"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123124930710.png" alt="image-20210123124930710"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123125045033.png" alt="image-20210123125045033"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123125057445.png" alt="image-20210123125057445"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123125247316.png" alt="image-20210123125247316"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123125319422.png" alt="image-20210123125319422"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123125346966.png" alt="image-20210123125346966"></p><ol><li>运行异常，可以通过java虚拟机来自行处理。非运行异常，我们应该捕获或者抛出</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123125435657.png" alt="image-20210123125435657"></p><ol><li>length得到的是字符，不是字节。</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123125624618.png" alt="image-20210123125624618"></p><ol><li>request.getAttribute()方法返回request范围内存在的对象，而request.getParameter()方法是获取http提交过来的数据。</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123125952795.png" alt="image-20210123125952795"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123130011892.png" alt="image-20210123130011892"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123130033328.png" alt="image-20210123130033328"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123130135614.png" alt="image-20210123130135614"></li><li>java是自动管理内存的，通常情况下程序运行到稳定状态，内存大小也达到一个 基本稳定的值但是内存泄露导致Gc不能回收泄露的垃圾，内存不断变大.最终超出内存界限，抛出OutOfMemoryExpection</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123130334531.png" alt="image-20210123130334531"></p><ol><li>分母为0 为运行时异常，jvm帮我们捕获，无需代码里面显式捕获</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123130740493.png" alt="image-20210123130740493"></p><ol><li>A：方法抛出异常是throws B：throw用于抛出异常 C也是错的</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123130914569.png" alt="image-20210123130914569"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123131316466.png" alt="image-20210123131316466"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123131326280.png" alt="image-20210123131326280"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123131427089.png" alt="image-20210123131427089"></p><ol><li>字符流和字节流每次读入的字节数是不确定的，可能相同也可能不相同；字符流和字节流都有缓冲流</li><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123131506629.png" alt="image-20210123131506629"></li></ol></li><li><p>IO流关系图</p><ol><li><img src="http://uploadfiles.nowcoder.com/images/20150328/138512_1427527478646_1.png" alt="img"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210128185021408.png" alt="image-20210128185021408"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210128185249478.png" alt="image-20210128185249478"></p><ol><li>​    既然求最小整数，那肯定先想到负数，则最高位（符号位）一定为1，原码中肯定是1所在的位数越高，值越小，而补码是由原码取反加1得到的，则在补码中1所在的位数一定要越低，即补码为1000 0011；由补码求得原码：1111 1101=-(64+32+16+8+4+1)=-125;</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210128185532442.png" alt="image-20210128185532442"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210128185546647.png" alt="image-20210128185546647"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210128185714149.png" alt="image-20210128185714149"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210128185825903.png" alt="image-20210128185825903"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210128185832411.png" alt="image-20210128185832411"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210206110407500.png" alt="image-20210206110407500"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210206110416072.png" alt="image-20210206110416072"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210206110603111.png" alt="image-20210206110603111"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210206110611012.png" alt="image-20210206110611012"></li></ol></li><li><p>数组是对象</p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210206110725104.png" alt="image-20210206110725104"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210206110848262.png" alt="image-20210206110848262"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210206110858596.png" alt="image-20210206110858596"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210206111018140.png" alt="image-20210206111018140"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210206111030006.png" alt="image-20210206111030006"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210206111117394.png" alt="image-20210206111117394"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207114345964.png" alt="image-20210207114345964"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207114354402.png" alt="image-20210207114354402"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207114610909.png" alt="image-20210207114610909"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207114620000.png" alt="image-20210207114620000"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207114652201.png" alt="image-20210207114652201"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207114733921.png" alt="image-20210207114733921"></p></li><li><p>除了jvm不是用java编写 jdk中的开发工具包都是java编写的</p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207114904411.png" alt="image-20210207114904411"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207115000623.png" alt="image-20210207115000623"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207115038891.png" alt="image-20210207115038891"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207115138087.png" alt="image-20210207115138087"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207115148922.png" alt="image-20210207115148922"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207115220995.png" alt="image-20210207115220995"></p><ol><li><p>注意c选项</p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207115301583.png" alt="image-20210207115301583"></p></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217183025112.png" alt="image-20210217183025112"></p><ol><li>构造方法是在对象创建时就被调用，用于初始化。</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217183146132.png" alt="image-20210217183146132"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217183435998.png" alt="image-20210217183435998"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217183442132.png" alt="image-20210217183442132"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217183617554.png" alt="image-20210217183617554"></p><ol><li>D选项反了</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217183642553.png" alt="image-20210217183642553"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217183739684.png" alt="image-20210217183739684"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217183802339.png" alt="image-20210217183802339"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217183855884.png" alt="image-20210217183855884"></p><ol><li>只要是被子类重写的方法，不被super调用都是调用子类方法</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217183922205.png" alt="image-20210217183922205"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217184036777.png" alt="image-20210217184036777"></p><ol><li>join()有资格释放资源其实是通过调用wait()来实现的</li></ol></li><li><p>java数组下标可以是整数或整型表达式</p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210301112032516.png" alt="image-20210301112032516"></p><ol><li>final修饰的变量必须初始化或者在构造函数中赋值</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210301112145677.png" alt="image-20210301112145677"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210301112203863.png" alt="image-20210301112203863"></p><ol><li>构造函数中可以调用其他函数</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210301112506533.png" alt="image-20210301112506533"></p><ol><li><p>包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱</p><p>包装类的equals()方法不处理数据转型</p></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210301112547079.png" alt="image-20210301112547079"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210301112611454.png" alt="image-20210301112611454"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210301112825299.png" alt="image-20210301112825299"></p><ol><li>编译看左边，运行看右边。 父类型引用指向子类型对象，无法调用只在子类型里定义的方法</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210301130408089.png" alt="image-20210301130408089"></p><ol><li>JDK8以后的默认方法和静态方法可以有方法体，题目的方法应该是指普通方法</li><li>接口中不可以包含静态方法</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210301130624405.png" alt="image-20210301130624405"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210312192658784.png" alt="image-20210312192658784"></p></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210312192800067.png" alt="image-20210312192800067"></p><ol><li>子类的权限不能比父类更低</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210312192935022.png" alt="image-20210312192935022"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210312192949637.png" alt="image-20210312192949637"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210312193141112.png" alt="image-20210312193141112"></p><ol><li>只有char变成 int 的时候才会变为对应的assic码</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210312193255547.png" alt="image-20210312193255547"></p><ol><li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210312193301891.png" alt="image-20210312193301891"></li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210312193333272.png" alt="image-20210312193333272"></p><ol><li>使用链地址法</li></ol></li><li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210312193432509.png" alt="image-20210312193432509"></p></li><li></li></ol>]]></content>
    
    
    <summary type="html">记录在牛客刷题过程中的错题和解题过程以及相关知识点整理</summary>
    
    
    
    <category term="错题本" scheme="http://example.com/categories/%E9%94%99%E9%A2%98%E6%9C%AC/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB</title>
    <link href="http://example.com/2020/11/23/MongoDB/"/>
    <id>http://example.com/2020/11/23/MongoDB/</id>
    <published>2020-11-23T10:31:16.000Z</published>
    <updated>2021-02-03T14:49:09.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在linux上安装</p><p>在mongodb/bin目录下执行./mongod  -f  mongodb.conf</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>数据库：存放集合的仓库</p><p>集合：类似于数组 存放文档</p><p>文档：文档是数据库中最小的单位</p><p>数据库和集合不需要手动创建 当创建的文档所在的集合或数据库不存在会自动创建（在第一次往里插入文档的时候创建）</p><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>show dbs：显示当前所有数据库</p><p>use 数据库名：进入到指定数据库中</p><p>db：显示当前所在的数据库</p><p>show collections：显示数据库的所有集合</p><h2 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h2><p>insert：同时插入多条或一条数据（如果插入一条去掉[]）</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.students.insert([</span><br><span class="line">&#123;<span class="attr">name:</span><span class="string">&quot;bob&quot;</span>,<span class="attr">age:</span><span class="number">23</span>,<span class="attr">gender:</span><span class="string">&quot;male&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="attr">name:</span><span class="string">&quot;jack&quot;</span>,<span class="attr">age:</span><span class="number">23</span>,<span class="attr">gender:</span><span class="string">&quot;male&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="attr">name:</span><span class="string">&quot;rose&quot;</span>,<span class="attr">age:</span><span class="number">23</span>,<span class="attr">gender:</span><span class="string">&quot;male&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="attr">name:</span><span class="string">&quot;tom&quot;</span>,<span class="attr">age:</span><span class="number">23</span>,<span class="attr">gender:</span><span class="string">&quot;male&quot;</span>&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><ul><li>自动生成一个字段_id该字段由ObjectId()生成 可以自己指定</li></ul><p>insertOne：插入一条数据</p><p>insertMany：插入多条数据</p><h2 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h2><p>find:查询集合所有文档 可以接收一个文档作为条件参数                  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.find</span>(&#123;<span class="attribute">name</span>:<span class="string">&quot;bob&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>findOne：查询集合中符合条件的第一个文档 返回的是一个文档替换</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.findOne</span>(&#123;<span class="attribute">name</span>:<span class="string">&quot;bob&quot;</span>&#125;)<span class="selector-class">.name</span></span><br></pre></td></tr></table></figure><p>count和length</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.find</span>()<span class="selector-class">.count</span>()</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.find</span>()<span class="selector-class">.length</span>()</span><br></pre></td></tr></table></figure><h2 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h2><p>update:第一个参数为查询条件 第二个参数为新替换  默认情况下会使用新替换替换旧替换 如果想只替换指定的属性 需要使用修改操作符$set</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.update</span>(</span><br><span class="line">&#123;<span class="attribute">name</span>:<span class="string">&quot;bob&quot;</span>&#125;,</span><br><span class="line">&#123;$<span class="attribute">set</span>:&#123;</span><br><span class="line"><span class="attribute">name</span>:<span class="string">&quot;bao&quot;</span>,</span><br><span class="line"><span class="attribute">age</span>:<span class="number">121</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>$unset可以删除指定属性</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.update</span>(</span><br><span class="line">&#123;<span class="attribute">name</span>:<span class="string">&quot;bao&quot;</span>&#125;,</span><br><span class="line">&#123;$<span class="attribute">unset</span>:&#123;</span><br><span class="line"><span class="attribute">age</span>:<span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>updateOne:删除第一个符合条件的文档</p><p>updateMany:删除所有符合条件的文档</p><p>update默认是只修改一个 如果想修改多个 需要增加属性</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.update</span>(</span><br><span class="line">&#123;<span class="attribute">name</span>:<span class="string">&quot;bob&quot;</span>&#125;,</span><br><span class="line">&#123;$<span class="attribute">set</span>:&#123;</span><br><span class="line"><span class="attribute">name</span>:<span class="string">&quot;bao&quot;</span>,</span><br><span class="line"><span class="attribute">age</span>:<span class="number">121</span>&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">multi</span>:true</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><p>很少调用删除方法 一般进行逻辑删除</p><p>remove:默认删除所有符合条件的文档 如果有第二个参数且为true则只删除一个 如果传入空参则删除所有文档</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.remove</span>(&#123;<span class="attribute">age</span>:<span class="number">121</span>&#125;)</span><br></pre></td></tr></table></figure><p>removeOne:删除一个</p><p>removeMany:删除多个</p><p>db.集合名.drop():删除集合</p><p>db.dropDatabase():删除当下的数据库</p><h2 id="sort-投影"><a href="#sort-投影" class="headerlink" title="sort 投影"></a>sort 投影</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>(&#123;<span class="attribute">age</span>:<span class="number">1</span>&#125;) <span class="comment">//升序</span></span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>(&#123;<span class="attribute">age</span>:-<span class="number">1</span>&#125;) <span class="comment">//降序</span></span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>(&#123;<span class="attribute">age</span>:<span class="number">1</span>,<span class="attribute">sal</span>:<span class="number">1</span>&#125;) <span class="comment">//按多个条件进行排序</span></span><br></pre></td></tr></table></figure><p>find可以传入第二个参数设置查询结果的投影(只显示指定的字段)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.find</span>(&#123;&#125;,&#123;<span class="attribute">name</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><h1 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>mongoose是nodeJS提供连接 mongodb的一个库.遵循的是一种, 模板式方法, 能够对你输入的数据进行自动处理</p><p>mongoose提供了几个新的对象</p><ul><li>Schema：定义了约束数据库的文档结构</li><li>Model：表示集合中的所有文档，对应collection</li><li>Document：表示集合中的具体文档</li></ul><p>安装:npm i mongoose –save</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入mongoose</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&quot;mongoose&quot;</span>)</span><br><span class="line"><span class="comment">//链接数据库 如果端口是默认端口可以省略</span></span><br><span class="line">mongoose.connect(<span class="string">&quot;mongodb://192.168.52.131/test&quot;</span> )</span><br><span class="line"><span class="comment">//监视连接状态 mongoose.connection.once(&quot;open&quot;,function()&#123;&#125;) , mongoose.connection.once(&quot;close&quot;,function()&#123;&#125;)</span></span><br><span class="line">mongoose.connection.once(<span class="string">&quot;open&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;数据库 链接成功&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//断开数据库</span></span><br><span class="line">mongoose.disconnect()</span><br><span class="line"></span><br><span class="line">mongoose.connection.once(<span class="string">&quot;close&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;数据库 链接断开&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Schema和Model"><a href="#Schema和Model" class="headerlink" title="Schema和Model"></a>Schema和Model</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入mongoose</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&quot;mongoose&quot;</span>)</span><br><span class="line"><span class="comment">//链接数据库 如果端口是默认端口可以省略</span></span><br><span class="line">mongoose.connect(<span class="string">&quot;mongodb://192.168.52.131/test&quot;</span> )</span><br><span class="line"><span class="comment">//创建schema对象</span></span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema</span><br><span class="line"><span class="keyword">const</span> studentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    age: <span class="built_in">Number</span>,</span><br><span class="line">    gender: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">&quot;male&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//创建model:第一个参数是映射的数据库中的集合名,可以将集合名自动变为复数可以是student</span></span><br><span class="line"><span class="keyword">let</span> studentModel = mongoose.model(<span class="string">&quot;students&quot;</span>,studentSchema)</span><br><span class="line"><span class="comment">//操作文档</span></span><br><span class="line">studentModel.create(&#123;<span class="attr">name</span>:<span class="string">&quot;zhao&quot;</span>,<span class="attr">age</span>:<span class="number">12</span>,<span class="attr">gender</span>:<span class="string">&quot;female&quot;</span>&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;插入成功&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="model的方法"><a href="#model的方法" class="headerlink" title="model的方法"></a>model的方法</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><img src="/2020/11/23/MongoDB/image-20201125235035148.png" alt="image-20201125235035148"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询:docs是查询到的集合 project有两种形式(&quot;name -age&quot;),&#123;name:1,age:0&#125;</span></span><br><span class="line"><span class="comment">//skip是跳过几个文档 limit是显示几个文档</span></span><br><span class="line"><span class="comment">//返回一个docs</span></span><br><span class="line">studentModel.find(&#123;<span class="attr">age</span>:<span class="number">23</span>&#125;,<span class="string">&quot;name age&quot;</span>,&#123;<span class="attr">skip</span>:<span class="number">1</span>,<span class="attr">limit</span>:<span class="number">1</span>&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err,docs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(docs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">studentModel.find(<span class="string">&quot;5fbe5d6c575e000016001b71&quot;</span>,<span class="string">&quot;name age&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(doc)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p><img src="/2020/11/23/MongoDB/image-20201126000554126.png" alt="image-20201126000554126"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">studentModel.updateOne(&#123;<span class="attr">name</span>:<span class="string">&quot;zhao&quot;</span>&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="attr">age</span>:<span class="number">100</span>&#125;&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;更新成功&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><img src="/2020/11/23/MongoDB/image-20201126000636656.png" alt="image-20201126000636656"></p><p>查询文档数量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">studentModel.count(&#123;&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err,count</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(count)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="document的方法"><a href="#document的方法" class="headerlink" title="document的方法"></a>document的方法</h2><p><img src="/2020/11/23/MongoDB/image-20201126001448733.png" alt="image-20201126001448733"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个document</span></span><br><span class="line"><span class="keyword">let</span> student = <span class="keyword">new</span> studentModel(&#123;</span><br><span class="line">    name:<span class="string">&quot;zhao&quot;</span>,</span><br><span class="line">    age:<span class="number">21</span>,</span><br><span class="line">    gender: <span class="string">&quot;female&quot;</span></span><br><span class="line">&#125;)moku</span><br><span class="line">student.save()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">studentModel.findOne(&#123;&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="comment">//修改1</span></span><br><span class="line">        doc.update(&#123;<span class="attr">$set</span>:&#123;<span class="attr">age</span>:<span class="number">28</span>&#125;&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;修改成功&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//修改2</span></span><br><span class="line">        doc.age = <span class="number">12</span></span><br><span class="line">        doc.save()</span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        doc.remove(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;删除成功&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>直接使用doc删除属性是删不掉的 需要用toObject转换成对象 在删除</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">doc</span> = <span class="meta">doc</span>.toObject()</span><br><span class="line">delete <span class="meta">doc</span>.age</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">MongoDB笔记</summary>
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="http://example.com/2020/11/16/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2020/11/16/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-11-16T15:49:37.000Z</published>
    <updated>2021-02-03T13:45:15.172Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_42034205/article/details/90384772">为什么与hashcode &gt;&gt;&gt; 16异或？</a></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> hash(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="built_in">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">key</span> == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = <span class="built_in">key</span>.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/JustBeauty/article/details/81116144">ParameterizedType详解</a></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(<span class="built_in">Object</span> x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x instanceof <span class="built_in">Comparable</span>) &#123;</span><br><span class="line">        Class&lt;?&gt; c; <span class="built_in">Type</span>[] ts, <span class="keyword">as</span>; <span class="built_in">Type</span> t; ParameterizedType p;</span><br><span class="line">        <span class="keyword">if</span> ((c = x.getClass()) == <span class="built_in">String</span>.<span class="keyword">class</span>) <span class="comment">// bypass checks</span></span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((t = ts[i]) instanceof ParameterizedType) &amp;&amp;</span><br><span class="line">                    ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                     <span class="built_in">Comparable</span>.<span class="keyword">class</span>) &amp;&amp;</span><br><span class="line">                    (<span class="keyword">as</span> = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    <span class="keyword">as</span>.length == <span class="number">1</span> &amp;&amp; <span class="keyword">as</span>[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/loading4/p/6239441.html">返回大于输入参数且最近的2的整数次幂的数</a></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static final <span class="built_in">int</span> tableSizeFor(<span class="built_in">int</span> cap) &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">n</span> = cap - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    return (<span class="built_in">n</span> &lt; <span class="number">0</span>) ? <span class="number">1</span> <span class="symbol">:</span> (<span class="built_in">n</span> &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY <span class="symbol">:</span> <span class="built_in">n</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于为什么最后要+1：<a href="https://www.jianshu.com/p/e33d3fa32091">https://www.jianshu.com/p/e33d3fa32091</a></p><p>以cap = 5为例</p><p><img src="/2020/11/16/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image.png"></p><p>参考：</p><p>​    <a href="https://blog.csdn.net/woshimaxiao1/article/details/83661464">https://blog.csdn.net/woshimaxiao1/article/details/83661464</a></p><p>​    <a href="https://blog.csdn.net/qq_40574571/article/details/97612100">https://blog.csdn.net/qq_40574571/article/details/97612100</a></p>]]></content>
    
    
    <summary type="html">HashMap的一些方法详解和源码分析</summary>
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch笔记</title>
    <link href="http://example.com/2020/11/14/elasticSearch%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2020/11/14/elasticSearch%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-14T05:01:05.000Z</published>
    <updated>2021-03-01T12:36:16.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装ik分词器"><a href="#安装ik分词器" class="headerlink" title="安装ik分词器"></a>安装ik分词器</h1><p>首先在docker中部署好es和kibana</p><p>在es中添加ik分词器插件:elasticsearch-plugin install <a href="https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.6.1/e">https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.6.1/e</a></p><p>重启es：docker restart id</p><h1 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT <span class="regexp">/customer/</span>_doc/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET <span class="regexp">/customer/</span>_doc/<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="regexp">/customer/</span>_doc/<span class="number">1</span></span><br></pre></td></tr></table></figure><p>bulk操作</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /customer/_bulk</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:5&#125;&#125;  #action 可以是create update</span><br><span class="line">&#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:22&#125; #data</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:6&#125;&#125;</span><br><span class="line">&#123;&quot;delete&quot;:&#123;&quot;_index&quot;:&quot;customer&quot;,&quot;_id&quot;:1&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:22&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:7&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:29&#125;</span><br></pre></td></tr></table></figure><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p><strong>搜索所有字段并排序</strong></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; </span><br><span class="line">  &quot;match_all&quot;: &#123;&#125; </span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123; &quot;account_number&quot;: &quot;asc&quot; &#125;</span><br><span class="line">  ]</span><br><span class="line">  &quot;_source&quot;: &quot;[account_number]&quot; #指定返回的字段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>limit</strong>：下标从0开始</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123; &quot;account_number&quot;: &quot;asc&quot; &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;from&quot;: 10,</span><br><span class="line">  &quot;size&quot;: 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搜索指定字段： searches the <code>address</code> field to find customers whose addresses contain <code>mill</code> or <code>lane</code></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;mill lane&quot; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>搜索整个字段而不是词条</strong>：Only matches addresses that contain the phrase <code>mill lane</code></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;address&quot;: &quot;mill lane&quot; &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;address.keyword&quot;: &quot;mill lane&quot; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用bool条件查询</strong>：should,must,must not</p><p>For example, the following request searches the <code>bank</code> index for accounts that belong to customers who are 40 years old, but excludes anyone who lives in Idaho (ID)</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;age&quot;: &quot;40&quot; &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;state&quot;: &quot;ID&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>bool查询中也可以使用filter进行筛选</strong></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">          &quot;balance&quot;: &#123;</span><br><span class="line">            &quot;gte&quot;: 20000,</span><br><span class="line">            &quot;lte&quot;: 30000</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>term:和match一样匹配某个属性的值 全文检索字段用match 其他字段匹配用term</p><h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><p>基本使用</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;group_by_state&quot;: &#123; #指定结果名称</span><br><span class="line">      &quot;terms&quot;: &#123; #指定聚合方法</span><br><span class="line">        &quot;field&quot;: &quot;state.keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子聚合</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;group_by_state&quot;: &#123; </span><br><span class="line">      &quot;terms&quot;: &#123; </span><br><span class="line">        &quot;field&quot;: &quot;state.keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;average_balance&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;balance&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在聚合中排序</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;group_by_state&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;state.keyword&quot;,</span><br><span class="line">        &quot;order&quot;: &#123;</span><br><span class="line">          &quot;average_balance&quot;: &quot;desc&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;average_balance&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;balance&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h1><p>创建映射</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT /sutdent</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;properties&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;age&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span>&#125;,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>&#125;,</span><br><span class="line">      <span class="string">&quot;email&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加新的字段映射</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT <span class="string">/student/_mapping</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;properties&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;gender&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">      <span class="string">&quot;index&quot;</span>: <span class="literal">false</span>, <span class="comment">#该字段不支持索引</span></span><br><span class="line">      <span class="string">&quot;doc_value&quot;</span>: <span class="literal">false</span> <span class="comment">#该字段不支持聚合</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能修改索引 只能通过数据迁移的方式创建新的映射</p><p>迁移数据</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;index&quot;</span>:<span class="string">&quot;old&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;index&quot;</span>: <span class="string">&quot;new&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用分词器</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span>,</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;我是中国人&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;我是中国人&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-Data-ElasticSearch"><a href="#Spring-Data-ElasticSearch" class="headerlink" title="Spring Data ElasticSearch"></a>Spring Data ElasticSearch</h1><p>导入jar包并修改版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.6.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>springboot 的版本2.x会报错</p><p>创建配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchClientConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">restHighLevelClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        <span class="keyword">new</span> HttpHost(<span class="string">&quot;192.168.52.131&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="狂神"><a href="#狂神" class="headerlink" title="狂神"></a>狂神</h2><h3 id="关于索引的API操作"><a href="#关于索引的API操作" class="headerlink" title="关于索引的API操作"></a>关于索引的API操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestHighLevelClient restHighLevelClient;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">creatIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//索引的创建</span></span><br><span class="line">    CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    restHighLevelClient.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    GetIndexRequest request = <span class="keyword">new</span> GetIndexRequest(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="keyword">boolean</span> exists = restHighLevelClient.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(exists);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DeleteIndexRequest request = <span class="keyword">new</span> DeleteIndexRequest(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    AcknowledgedResponse delete = restHighLevelClient.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(delete.isAcknowledged());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于文档的API操作"><a href="#关于文档的API操作" class="headerlink" title="关于文档的API操作"></a>关于文档的API操作</h3><p>创建一个pojo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document(indexName = &quot;item&quot;,shards = 1, replicas = 0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Good</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String title; <span class="comment">//标题</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="keyword">private</span> String category;<span class="comment">// 分类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="keyword">private</span> String brand; <span class="comment">// 品牌</span></span><br><span class="line"><span class="comment">//index默认为ture 如果不想索引该值可以设置为false</span></span><br><span class="line">    <span class="meta">@Field(index = false,type = FieldType.Double)</span></span><br><span class="line">    <span class="keyword">private</span> Double price; <span class="comment">// 价格</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="crud"><a href="#crud" class="headerlink" title="crud"></a>crud</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="built_in">public</span> <span class="type">void</span> addDocument() throws IOException &#123;</span><br><span class="line">    Good good = <span class="built_in">new</span> Good(<span class="number">1</span>L,&quot;测试商品&quot;,&quot;手机&quot;,&quot;apple&quot;,<span class="number">1000.0</span>);</span><br><span class="line">    IndexRequest request = <span class="built_in">new</span> IndexRequest(&quot;good&quot;);</span><br><span class="line">    request.id(&quot;1&quot;);</span><br><span class="line">    request.timeout(TimeValue.timeValueSeconds(<span class="number">1</span>));</span><br><span class="line">    request.timeout(&quot;1s&quot;);</span><br><span class="line">    //将我们的数据利用fastjson转换成<span class="type">json</span>并放入请求</span><br><span class="line">    request.source(<span class="type">JSON</span>.toJSONString(good), XContentType.JSON);</span><br><span class="line">    IndexResponse response = restHighLevelClient.<span class="keyword">index</span>(request, RequestOptions.<span class="keyword">DEFAULT</span>);</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(response.toString());</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line"><span class="built_in">public</span> <span class="type">void</span> getDocument() throws IOException &#123;</span><br><span class="line">    GetRequest request = <span class="built_in">new</span> GetRequest(&quot;good&quot;,&quot;1&quot;);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="keyword">exists</span> = restHighLevelClient.<span class="keyword">exists</span>(request, RequestOptions.<span class="keyword">DEFAULT</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">exists</span>)&#123;</span><br><span class="line">        GetResponse response = restHighLevelClient.<span class="keyword">get</span>(request, RequestOptions.<span class="keyword">DEFAULT</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(response.getSourceAsString());</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">exists</span>);</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line"><span class="built_in">public</span> <span class="type">void</span> deleteDocument() throws IOException &#123;</span><br><span class="line">    DeleteRequest request = <span class="built_in">new</span> DeleteRequest(&quot;good&quot;,&quot;1&quot;);</span><br><span class="line">    DeleteResponse response= restHighLevelClient.<span class="keyword">delete</span>(request, RequestOptions.<span class="keyword">DEFAULT</span>);</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(response.status());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="批量处理数据"><a href="#批量处理数据" class="headerlink" title="批量处理数据"></a>批量处理数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bulkRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BulkRequest request = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    request.timeout(<span class="string">&quot;10s&quot;</span>);</span><br><span class="line">    ArrayList&lt;Good&gt; goods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    goods.add(<span class="keyword">new</span> Good(<span class="number">1L</span>,<span class="string">&quot;测试商品&quot;</span>,<span class="string">&quot;手机&quot;</span>,<span class="string">&quot;apple&quot;</span>,<span class="number">1000.0</span>));</span><br><span class="line">    goods.add(<span class="keyword">new</span> Good(<span class="number">2L</span>,<span class="string">&quot;测试商品&quot;</span>,<span class="string">&quot;手机&quot;</span>,<span class="string">&quot;apple&quot;</span>,<span class="number">1000.0</span>));</span><br><span class="line">    goods.add(<span class="keyword">new</span> Good(<span class="number">3L</span>,<span class="string">&quot;测试商品&quot;</span>,<span class="string">&quot;手机&quot;</span>,<span class="string">&quot;apple&quot;</span>,<span class="number">1000.0</span>));</span><br><span class="line">    goods.add(<span class="keyword">new</span> Good(<span class="number">4L</span>,<span class="string">&quot;测试商品&quot;</span>,<span class="string">&quot;手机&quot;</span>,<span class="string">&quot;apple&quot;</span>,<span class="number">1000.0</span>));</span><br><span class="line">    goods.add(<span class="keyword">new</span> Good(<span class="number">5L</span>,<span class="string">&quot;测试商品&quot;</span>,<span class="string">&quot;手机&quot;</span>,<span class="string">&quot;apple&quot;</span>,<span class="number">1000.0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;goods.size();i++)&#123;</span><br><span class="line">        request.add(<span class="keyword">new</span> IndexRequest(<span class="string">&quot;good&quot;</span>).id(<span class="string">&quot;&quot;</span>+(i+<span class="number">1</span>)).source(JSON.toJSONString(goods.get(i)),XContentType.JSON));</span><br><span class="line">    &#125;</span><br><span class="line">    BulkResponse response = restHighLevelClient.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response.hasFailures());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">        <span class="comment">//构建搜索条件</span></span><br><span class="line">        SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;测试商品&quot;</span>);</span><br><span class="line"><span class="comment">//        MatchAllQueryBuilder matchAllQueryBuilder = QueryBuilders.matchAllQuery();</span></span><br><span class="line">        sourceBuilder.query(termQueryBuilder);</span><br><span class="line">        <span class="comment">//构建分页</span></span><br><span class="line">        request.source(sourceBuilder);</span><br><span class="line">        SearchResponse searchResponse = restHighLevelClient.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="keyword">for</span>(SearchHit documentFields:searchResponse.getHits().getHits())&#123;</span><br><span class="line">            System.out.println(documentFields.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="黑马"><a href="#黑马" class="headerlink" title="黑马"></a>黑马</h2><h3 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h3><h4 id="新增和更新"><a href="#新增和更新" class="headerlink" title="新增和更新"></a>新增和更新</h4><p>Spring Data 的强大之处，就在于你不用写任何DAO处理，自动根据方法名或类的信息进行CRUD操作。只要你定义一个接口，然后继承Repository提供的一些子接口，就能具备各种基本的CRUD功能。</p><p>我们只需要定义接口，然后继承它就OK了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GoodRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Good</span>,<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增和批量新增</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Good good = <span class="keyword">new</span> Good(<span class="number">10L</span>, <span class="string">&quot;小米手机7&quot;</span>, <span class="string">&quot; 手机&quot;</span>, <span class="string">&quot;小米&quot;</span>, <span class="number">3499.00</span>);</span><br><span class="line">    goodRepository.save(good);</span><br><span class="line">    List&lt;Good&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(good);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Good&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> Good(<span class="number">2L</span>, <span class="string">&quot;坚果手机R1&quot;</span>, <span class="string">&quot; 手机&quot;</span>, <span class="string">&quot;锤子&quot;</span>, <span class="number">3699.00</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Good(<span class="number">3L</span>, <span class="string">&quot;华为META10&quot;</span>, <span class="string">&quot; 手机&quot;</span>, <span class="string">&quot;华为&quot;</span>, <span class="number">4499.00</span>));</span><br><span class="line">    <span class="comment">// 接收对象集合，实现批量新增</span></span><br><span class="line">    goodRepository.saveAll(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findById</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Optional&lt;Good&gt; optional = goodRepository.findById(<span class="number">1l</span>);</span><br><span class="line">    System.out.println(optional.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 查询全部，并按照价格降序排序</span></span><br><span class="line">    Iterable&lt;Good&gt; items = goodRepository.findAll(Sort.by(Sort.Direction.DESC, <span class="string">&quot;price&quot;</span>));</span><br><span class="line">    items.forEach(good -&gt; System.out.println(good));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h4><p>Spring Data 的另一个强大功能，是根据方法名称自动实现功能。</p><p>比如：你的方法名叫做：findByTitle，那么它就知道你是根据title查询，然后自动帮你完成，无需写实现类。</p><p>当然，方法名称要符合一定的约定：</p><table><thead><tr><th>Keyword</th><th>Sample</th><th>Elasticsearch Query String</th></tr></thead><tbody><tr><td><code>And</code></td><td><code>findByNameAndPrice</code></td><td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : [ &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125;, &#123;&quot;field&quot; : &#123;&quot;price&quot; : &quot;?&quot;&#125;&#125; ]&#125;&#125;</code></td></tr><tr><td><code>Or</code></td><td><code>findByNameOrPrice</code></td><td><code>&#123;&quot;bool&quot; : &#123;&quot;should&quot; : [ &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125;, &#123;&quot;field&quot; : &#123;&quot;price&quot; : &quot;?&quot;&#125;&#125; ]&#125;&#125;</code></td></tr><tr><td><code>Is</code></td><td><code>findByName</code></td><td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125;&#125;&#125;</code></td></tr><tr><td><code>Not</code></td><td><code>findByNameNot</code></td><td><code>&#123;&quot;bool&quot; : &#123;&quot;must_not&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125;&#125;&#125;</code></td></tr><tr><td><code>Between</code></td><td><code>findByPriceBetween</code></td><td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;range&quot; : &#123;&quot;price&quot; : &#123;&quot;from&quot; : ?,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true&#125;&#125;&#125;&#125;&#125;</code></td></tr><tr><td><code>LessThanEqual</code></td><td><code>findByPriceLessThan</code></td><td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;range&quot; : &#123;&quot;price&quot; : &#123;&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true&#125;&#125;&#125;&#125;&#125;</code></td></tr><tr><td><code>GreaterThanEqual</code></td><td><code>findByPriceGreaterThan</code></td><td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;range&quot; : &#123;&quot;price&quot; : &#123;&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true&#125;&#125;&#125;&#125;&#125;</code></td></tr><tr><td><code>Before</code></td><td><code>findByPriceBefore</code></td><td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;range&quot; : &#123;&quot;price&quot; : &#123;&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true&#125;&#125;&#125;&#125;&#125;</code></td></tr><tr><td><code>After</code></td><td><code>findByPriceAfter</code></td><td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;range&quot; : &#123;&quot;price&quot; : &#123;&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true&#125;&#125;&#125;&#125;&#125;</code></td></tr><tr><td><code>Like</code></td><td><code>findByNameLike</code></td><td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &#123;&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true&#125;&#125;&#125;&#125;&#125;</code></td></tr><tr><td><code>StartingWith</code></td><td><code>findByNameStartingWith</code></td><td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &#123;&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true&#125;&#125;&#125;&#125;&#125;</code></td></tr><tr><td><code>EndingWith</code></td><td><code>findByNameEndingWith</code></td><td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &#123;&quot;query&quot; : &quot;*?&quot;,&quot;analyze_wildcard&quot; : true&#125;&#125;&#125;&#125;&#125;</code></td></tr><tr><td><code>Contains/Containing</code></td><td><code>findByNameContaining</code></td><td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &#123;&quot;query&quot; : &quot;**?**&quot;,&quot;analyze_wildcard&quot; : true&#125;&#125;&#125;&#125;&#125;</code></td></tr><tr><td><code>In</code></td><td><code>findByNameIn(Collection&lt;String&gt;names)</code></td><td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;bool&quot; : &#123;&quot;should&quot; : [ &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125;, &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125; ]&#125;&#125;&#125;&#125;</code></td></tr><tr><td><code>NotIn</code></td><td><code>findByNameNotIn(Collection&lt;String&gt;names)</code></td><td><code>&#123;&quot;bool&quot; : &#123;&quot;must_not&quot; : &#123;&quot;bool&quot; : &#123;&quot;should&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125;&#125;&#125;&#125;&#125;</code></td></tr><tr><td><code>Near</code></td><td><code>findByStoreNear</code></td><td><code>Not Supported Yet !</code></td></tr><tr><td><code>True</code></td><td><code>findByAvailableTrue</code></td><td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;available&quot; : true&#125;&#125;&#125;&#125;</code></td></tr><tr><td><code>False</code></td><td><code>findByAvailableFalse</code></td><td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;available&quot; : false&#125;&#125;&#125;&#125;</code></td></tr><tr><td><code>OrderBy</code></td><td><code>findByAvailableTrueOrderByNameDesc</code></td><td><code>&#123;&quot;sort&quot; : [&#123; &quot;name&quot; : &#123;&quot;order&quot; : &quot;desc&quot;&#125; &#125;],&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;available&quot; : true&#125;&#125;&#125;&#125;</code></td></tr></tbody></table><p>例如，我们来按照价格区间查询，定义这样的一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ItemRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Item</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据价格区间查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> price1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> price2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Item&gt; <span class="title">findByPriceBetween</span><span class="params">(<span class="keyword">double</span> price1, <span class="keyword">double</span> price2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后添加一些测试数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">indexList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Item&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> Item(<span class="number">1L</span>, <span class="string">&quot;小米手机7&quot;</span>, <span class="string">&quot;手机&quot;</span>, <span class="string">&quot;小米&quot;</span>, <span class="number">3299.00</span>, <span class="string">&quot;http://image.leyou.com/13123.jpg&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Item(<span class="number">2L</span>, <span class="string">&quot;坚果手机R1&quot;</span>, <span class="string">&quot;手机&quot;</span>, <span class="string">&quot;锤子&quot;</span>, <span class="number">3699.00</span>, <span class="string">&quot;http://image.leyou.com/13123.jpg&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Item(<span class="number">3L</span>, <span class="string">&quot;华为META10&quot;</span>, <span class="string">&quot;手机&quot;</span>, <span class="string">&quot;华为&quot;</span>, <span class="number">4499.00</span>, <span class="string">&quot;http://image.leyou.com/13123.jpg&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Item(<span class="number">4L</span>, <span class="string">&quot;小米Mix2S&quot;</span>, <span class="string">&quot;手机&quot;</span>, <span class="string">&quot;小米&quot;</span>, <span class="number">4299.00</span>, <span class="string">&quot;http://image.leyou.com/13123.jpg&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Item(<span class="number">5L</span>, <span class="string">&quot;荣耀V10&quot;</span>, <span class="string">&quot;手机&quot;</span>, <span class="string">&quot;华为&quot;</span>, <span class="number">2799.00</span>, <span class="string">&quot;http://image.leyou.com/13123.jpg&quot;</span>));</span><br><span class="line">    <span class="comment">// 接收对象集合，实现批量新增</span></span><br><span class="line">    itemRepository.saveAll(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要写实现类，然后我们直接去运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryByPriceBetween</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Item&gt; list = <span class="keyword">this</span>.itemRepository.findByPriceBetween(<span class="number">2000.00</span>, <span class="number">3500.00</span>);</span><br><span class="line">    <span class="keyword">for</span> (Item item : list) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;item = &quot;</span> + item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2020/11/14/elasticSearch%E7%AC%94%E8%AE%B0/log\source_posts\elasticSearch笔记\1531993518230.png" alt="1531993518230"></p><p>虽然基本查询和自定义方法已经很强大了，但是如果是复杂查询（模糊、通配符、词条查询等）就显得力不从心了。此时，我们只能使用原生查询。</p><h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><h4 id="基本查询-1"><a href="#基本查询-1" class="headerlink" title="基本查询"></a>基本查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 词条查询</span></span><br><span class="line">    MatchQueryBuilder queryBuilder = QueryBuilders.matchQuery(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;小米&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行查询</span></span><br><span class="line">    Iterable&lt;Good&gt; items = goodRepository.search(queryBuilder);</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QueryBuilders提供了大量的静态方法，用于生成各种不同类型的查询对象，例如：词条、模糊、通配符等QueryBuilder对象。</p><h4 id="自定义查询"><a href="#自定义查询" class="headerlink" title="自定义查询"></a>自定义查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNativeQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构建查询条件</span></span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">// 添加基本的分词查询</span></span><br><span class="line">    queryBuilder.withQuery(QueryBuilders.matchQuery(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;小米&quot;</span>));</span><br><span class="line">    <span class="comment">// 执行搜索，获取结果</span></span><br><span class="line">    Page&lt;Good&gt; items = goodRepository.search(queryBuilder.build());</span><br><span class="line">    <span class="comment">// 打印总条数</span></span><br><span class="line">    System.out.println(items.getTotalElements());</span><br><span class="line">    <span class="comment">// 打印总页数</span></span><br><span class="line">    System.out.println(items.getTotalPages());</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NativeSearchQueryBuilder：Spring提供的一个查询条件构建器，帮助构建json格式的请求体</p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNativeQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构建查询条件</span></span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">// 添加基本的分词查询</span></span><br><span class="line">    queryBuilder.withQuery(QueryBuilders.termQuery(<span class="string">&quot;category&quot;</span>, <span class="string">&quot;手机&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化分页参数</span></span><br><span class="line">    <span class="keyword">int</span> page = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 设置分页参数</span></span><br><span class="line">    queryBuilder.withPageable(PageRequest.of(page, size));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行搜索，获取结果</span></span><br><span class="line">    Page&lt;Item&gt; items = <span class="keyword">this</span>.itemRepository.search(queryBuilder.build());</span><br><span class="line">    <span class="comment">// 打印总条数</span></span><br><span class="line">    System.out.println(items.getTotalElements());</span><br><span class="line">    <span class="comment">// 打印总页数</span></span><br><span class="line">    System.out.println(items.getTotalPages());</span><br><span class="line">    <span class="comment">// 每页大小</span></span><br><span class="line">    System.out.println(items.getSize());</span><br><span class="line">    <span class="comment">// 当前页</span></span><br><span class="line">    System.out.println(items.getNumber());</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构建查询条件</span></span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">// 添加基本的分词查询</span></span><br><span class="line">    queryBuilder.withQuery(QueryBuilders.termQuery(<span class="string">&quot;category&quot;</span>, <span class="string">&quot;手机&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    queryBuilder.withSort(SortBuilders.fieldSort(<span class="string">&quot;price&quot;</span>).order(SortOrder.DESC));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行搜索，获取结果</span></span><br><span class="line">    Page&lt;Item&gt; items = <span class="keyword">this</span>.itemRepository.search(queryBuilder.build());</span><br><span class="line">    <span class="comment">// 打印总条数</span></span><br><span class="line">    System.out.println(items.getTotalElements());</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="聚合-1"><a href="#聚合-1" class="headerlink" title="聚合"></a>聚合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAgg</span><span class="params">()</span></span>&#123;</span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">// 不查询任何结果</span></span><br><span class="line">    queryBuilder.withSourceFilter(<span class="keyword">new</span> FetchSourceFilter(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;&quot;</span>&#125;, <span class="keyword">null</span>));</span><br><span class="line">    <span class="comment">// 1、添加一个新的聚合，聚合类型为terms，聚合名称为brands，聚合字段为brand</span></span><br><span class="line">    queryBuilder.addAggregation(</span><br><span class="line">        AggregationBuilders.terms(<span class="string">&quot;brands&quot;</span>).field(<span class="string">&quot;brand&quot;</span>));</span><br><span class="line">    <span class="comment">// 2、查询,需要把结果强转为AggregatedPage类型</span></span><br><span class="line">    AggregatedPage&lt;Item&gt; aggPage = (AggregatedPage&lt;Item&gt;) <span class="keyword">this</span>.itemRepository.search(queryBuilder.build());</span><br><span class="line">    <span class="comment">// 3、解析</span></span><br><span class="line">    <span class="comment">// 3.1、从结果中取出名为brands的那个聚合，</span></span><br><span class="line">    <span class="comment">// 因为是利用String类型字段来进行的term聚合，所以结果要强转为StringTerm类型</span></span><br><span class="line">    StringTerms agg = (StringTerms) aggPage.getAggregation(<span class="string">&quot;brands&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.2、获取桶</span></span><br><span class="line">    List&lt;StringTerms.Bucket&gt; buckets = agg.getBuckets();</span><br><span class="line">    <span class="comment">// 3.3、遍历</span></span><br><span class="line">    <span class="keyword">for</span> (StringTerms.Bucket bucket : buckets) &#123;</span><br><span class="line">        <span class="comment">// 3.4、获取桶中的key，即品牌名称</span></span><br><span class="line">        System.out.println(bucket.getKeyAsString());</span><br><span class="line">        <span class="comment">// 3.5、获取桶中的文档数量</span></span><br><span class="line">        System.out.println(bucket.getDocCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套聚合求平均值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSubAgg</span><span class="params">()</span></span>&#123;</span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">// 不查询任何结果</span></span><br><span class="line">    queryBuilder.withSourceFilter(<span class="keyword">new</span> FetchSourceFilter(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;&quot;</span>&#125;, <span class="keyword">null</span>));</span><br><span class="line">    <span class="comment">// 1、添加一个新的聚合，聚合类型为terms，聚合名称为brands，聚合字段为brand</span></span><br><span class="line">    queryBuilder.addAggregation(</span><br><span class="line">        AggregationBuilders.terms(<span class="string">&quot;brands&quot;</span>).field(<span class="string">&quot;brand&quot;</span>)</span><br><span class="line">        .subAggregation(AggregationBuilders.avg(<span class="string">&quot;priceAvg&quot;</span>).field(<span class="string">&quot;price&quot;</span>)) <span class="comment">// 在品牌聚合桶内进行嵌套聚合，求平均值</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 2、查询,需要把结果强转为AggregatedPage类型</span></span><br><span class="line">    AggregatedPage&lt;Item&gt; aggPage = (AggregatedPage&lt;Item&gt;) <span class="keyword">this</span>.itemRepository.search(queryBuilder.build());</span><br><span class="line">    <span class="comment">// 3、解析</span></span><br><span class="line">    <span class="comment">// 3.1、从结果中取出名为brands的那个聚合，</span></span><br><span class="line">    <span class="comment">// 因为是利用String类型字段来进行的term聚合，所以结果要强转为StringTerm类型</span></span><br><span class="line">    StringTerms agg = (StringTerms) aggPage.getAggregation(<span class="string">&quot;brands&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.2、获取桶</span></span><br><span class="line">    List&lt;StringTerms.Bucket&gt; buckets = agg.getBuckets();</span><br><span class="line">    <span class="comment">// 3.3、遍历</span></span><br><span class="line">    <span class="keyword">for</span> (StringTerms.Bucket bucket : buckets) &#123;</span><br><span class="line">        <span class="comment">// 3.4、获取桶中的key，即品牌名称  3.5、获取桶中的文档数量</span></span><br><span class="line">        System.out.println(bucket.getKeyAsString() + <span class="string">&quot;，共&quot;</span> + bucket.getDocCount() + <span class="string">&quot;台&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.6.获取子聚合结果：</span></span><br><span class="line">        InternalAvg avg = (InternalAvg) bucket.getAggregations().asMap().get(<span class="string">&quot;priceAvg&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;平均售价：&quot;</span> + avg.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ES的基本使用以及使用spring data操作ES</summary>
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>RuoYi</title>
    <link href="http://example.com/2020/11/09/RuoYi/"/>
    <id>http://example.com/2020/11/09/RuoYi/</id>
    <published>2020-11-09T08:40:57.000Z</published>
    <updated>2021-02-03T14:50:01.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Common"><a href="#Common" class="headerlink" title="Common"></a>Common</h1><h2 id="BaseController"><a href="#BaseController" class="headerlink" title="BaseController"></a>BaseController</h2><h3 id="initBinder"><a href="#initBinder" class="headerlink" title="initBinder"></a>initBinder</h3><p>@InitBinder:<a href="https://blog.csdn.net/qq_38016931/article/details/82080940">博客1</a>       <a href="https://www.cnblogs.com/lvbinbin2yujie/p/10459303.html">博客2</a></p><h3 id="startPage"><a href="#startPage" class="headerlink" title="startPage"></a>startPage</h3><h2 id="Convert"><a href="#Convert" class="headerlink" title="Convert"></a>Convert</h2><h3 id="toEnum"><a href="#toEnum" class="headerlink" title="toEnum"></a>toEnum</h3><p>isAssignableFrom:<a href="https://blog.csdn.net/qq_36666651/article/details/81215221">博客</a></p><h3 id="toStr"><a href="#toStr" class="headerlink" title="toStr"></a>toStr</h3><p>ChatSet:<a href="https://blog.csdn.net/qq_36691683/article/details/81608244?utm_medium=distribute.pc_relevant.none-task-blog-title-2&spm=1001.2101.3001.4242">博客</a></p><h2 id="ServletUtils"><a href="#ServletUtils" class="headerlink" title="ServletUtils"></a>ServletUtils</h2><h3 id="getRequestAttributes"><a href="#getRequestAttributes" class="headerlink" title="getRequestAttributes"></a>getRequestAttributes</h3><p>RequestContextHolder:<a href="https://blog.csdn.net/asdfsadfasdfsa/article/details/79158459">博客1</a>,<a href="https://www.jianshu.com/p/3a3dc1c9bf4c">博客2</a></p><h3 id="isAjaxRequest"><a href="#isAjaxRequest" class="headerlink" title="isAjaxRequest"></a>isAjaxRequest</h3><p>X-Requested-With:<a href="https://blog.csdn.net/jokeMqc/article/details/78739677">博客</a></p><p>规定uri中有xml和json是异步请求</p><p><img src="/2020/11/09/RuoYi/image-20201110091906045.png" alt="image-20201110091906045"></p><h2 id="StrFormatter"><a href="#StrFormatter" class="headerlink" title="StrFormatter"></a>StrFormatter</h2><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><p>只是大概了解了一下 以后仔细研究这个类的原理</p><h2 id="IpUitls"><a href="#IpUitls" class="headerlink" title="IpUitls"></a>IpUitls</h2><h3 id="getIpAddr"><a href="#getIpAddr" class="headerlink" title="getIpAddr"></a>getIpAddr</h3><p>代理http请求获取客户端IP:<a href="https://blog.csdn.net/fengwind1/article/details/51992528">https://blog.csdn.net/fengwind1/article/details/51992528</a></p><h2 id="ExcelUitls"><a href="#ExcelUitls" class="headerlink" title="ExcelUitls"></a>ExcelUitls</h2><h3 id="getCellValue"><a href="#getCellValue" class="headerlink" title="getCellValue"></a>getCellValue</h3><p>判断是否为小数 </p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ((<span class="name">Double</span>) val % <span class="number">1</span> &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>使用DecimalFormat可以将数字进行格式化 <a href="https://www.cnblogs.com/Small-sunshine/p/11648652.html">参考博客</a></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">DecimalFormat(<span class="string">&quot;0&quot;</span>)</span>.format(<span class="keyword">val</span>);</span><br></pre></td></tr></table></figure><h1 id="Generate"><a href="#Generate" class="headerlink" title="Generate"></a>Generate</h1>]]></content>
    
    
    <summary type="html">学习若依项目过程中的记录和总结</summary>
    
    
    
    <category term="项目" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="心得" scheme="http://example.com/tags/%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>Debug</title>
    <link href="http://example.com/2020/11/08/DeBug/"/>
    <id>http://example.com/2020/11/08/DeBug/</id>
    <published>2020-11-08T00:26:54.000Z</published>
    <updated>2020-11-20T02:31:45.003Z</updated>
    
    <content type="html"><![CDATA[<p>centos 7 docker 启动一个web服务的时候 启动报错</p><p>WARNING: IPv4 forwarding is disabled. Networking will not work.</p><p>在宿主机上修改配置文件 <code>/usr/lib/sysctl.d/00-system.conf</code> 追加  <code>net.ipv4.ip_forward=1</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;net.ipv4.ip_forward=1&quot;</span> &gt;&gt;<span class="regexp">/usr/</span>lib<span class="regexp">/sysctl.d/</span><span class="number">00</span>-system.conf</span><br></pre></td></tr></table></figure><p>重启network和docker服务</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart<span class="built_in"> network </span>&amp;&amp; systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录日常的一些bug</summary>
    
    
    
    <category term="bug" scheme="http://example.com/categories/bug/"/>
    
    
    <category term="bug" scheme="http://example.com/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js</title>
    <link href="http://example.com/2020/10/22/Vue-js/"/>
    <id>http://example.com/2020/10/22/Vue-js/</id>
    <published>2020-10-22T12:46:05.000Z</published>
    <updated>2021-02-03T14:43:31.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VUE基础"><a href="#VUE基础" class="headerlink" title="VUE基础"></a>VUE基础</h1><h2 id="列表展示"><a href="#列表展示" class="headerlink" title="列表展示"></a>列表展示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for&#x3D;&quot;item in names&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue (&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &#39;hello vue&#39;,</span><br><span class="line">                names: [&#39;bob&#39;,&#39;jack&#39;,&#39;rose&#39;],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;h2&gt;当前计数:&#123;&#123;counter&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;button v-on:click&#x3D;&quot;increment&quot;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">&lt;!--        @是v-on的简写 是语法糖--&gt;</span><br><span class="line">        &lt;button @click&#x3D;&quot;counter--&quot;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                counter: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                increment: function ()&#123;</span><br><span class="line">                    this.counter++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><h2 id="Vue的options"><a href="#Vue的options" class="headerlink" title="Vue的options"></a>Vue的options</h2><p>创建vue实例的时候 传入了一个对象options 包含一下选项</p><ul><li>el:决定之后vue实例管理哪个dom 类型:String|HtmlElement</li><li>data: vue实例对应的数据对象 类型：Object|Function 在组件中必须是函数类型</li><li>methods:定义vue的一些方法 可以在其他地方调用  也可以在指令中使用</li></ul><h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p><img src="file://D:/%E7%A5%9E%E7%A7%98%E6%96%87%E4%BB%B6/Java/%E4%B9%90%E4%BC%98/%E7%AC%94%E8%AE%B0/vue%E5%85%A5%E9%97%A8/assets/lifecycle.png?lastModify=1603424928" alt="Vue life cycle"></p><p><strong>钩子函数</strong></p><p>beforeCreated：我们在用Vue时都要进行实例化，因此，该函数就是在Vue实例化时调用，也可以将他理解为初始化函数比较方便一点，在Vue1.0时，这个函数的名字就是init。 </p><p>created：在创建实例之后进行调用。 </p><p>beforeMount：页面加载完成，没有渲染。如：此时页面还是</p><p>mounted：我们可以将他理解为原生js中的window.onload=function({.,.}),或许大家也在用jquery，所以也可以理解为jquery中的$(document).ready(function(){….})，他的功能就是：在dom文档渲染完毕之后将要执行的函数，该函数在Vue1.0版本中名字为compiled。 此时页面中的已被渲染成峰哥</p><p>beforeDestroy：该函数将在销毁实例前进行调用 。</p><p>destroyed：改函数将在销毁实例时进行调用。</p><p>beforeUpdate：组件更新之前。</p><p>updated：组件更新之后。</p><h2 id="插值操作"><a href="#插值操作" class="headerlink" title="插值操作"></a>插值操作</h2><p>mustache语法也就是双大括号 里面不仅可以直接写变量 也可以写简单的表达式 <code>&#123;&#123;namee * 2&#125;&#125;</code> </p><p>不能在属性值中使用&lt;img src=”“&gt;</p><p>v-once：当修改module中的数据时 view中的数据不会改变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">&lt;!--        在console中分别修改两个变量的值 查看是否改变--&gt;</span><br><span class="line">        &lt;h1 v-once&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;age&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                name: &#39;bob&#39;,</span><br><span class="line">                age: 23</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>v-html:将string中的html解析并渲染</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;h2 v-html&#x3D;&quot;url&quot;&gt;&#123;&#123;url&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;url&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                name: &#39;bob&#39;,</span><br><span class="line">                age: 23,</span><br><span class="line">                url: &#39;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度一下&lt;&#x2F;a&gt;&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>v-text:会把标签中的文本内容覆盖掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 v-text&#x3D;&quot;name&quot;&gt;我即将被覆盖&lt;&#x2F;h2&gt;</span><br></pre></td></tr></table></figure><p>v-pre:标签的内容不会编译解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">页面上直接显示&#123;&#123;name&#125;&#125;</span><br><span class="line">&lt;h2 v-pre&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;</span><br></pre></td></tr></table></figure><p>v-cloak:有时候页面可能加载过慢 先显示 再显示bob 为了避免这总情况 使用v-cloak vue解析之后v-cloak被删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        [v-cloak] &#123;</span><br><span class="line">            display: none;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot; v-cloak&gt;</span><br><span class="line">        &lt;h2 v-text&#x3D;&quot;name&quot;&gt;我即将被覆盖&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                name: &#39;bob&#39;,</span><br><span class="line">                age: 23,</span><br><span class="line">                url: &#39;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度一下&lt;&#x2F;a&gt;&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p>动态绑定:为属性绑定model中的数据 可以简写为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot; v-cloak&gt;</span><br><span class="line">        &lt;a v-bind:href&#x3D;&quot;baidu&quot;&gt;跳转到百度&lt;&#x2F;a&gt;</span><br><span class="line">        &lt;a :href&#x3D;&quot;baidu&quot;&gt;跳转百度&lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                baidu: &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>动态绑定class:对象语法</p><p><strong>方法一</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .active &#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .front &#123;</span><br><span class="line">            font-size:10px;</span><br><span class="line">        &#125;</span><br><span class="line">        .location &#123;</span><br><span class="line">            text-align:center;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot; v-cloak&gt;</span><br><span class="line">        &lt;h2 class&#x3D;&#39;location&#39; :class&#x3D;&quot;&#123;active:isActive,front:true&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &#39;一条信息&#39;,</span><br><span class="line">                title: &#39;title&#39;,</span><br><span class="line">                active: &#39;active&#39;,</span><br><span class="line">                isActive: true,</span><br><span class="line">                isFront: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p><strong>方法二</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot; v-cloak&gt;</span><br><span class="line">        &lt;h2 class&#x3D;&#39;location&#39; :class&#x3D;&quot;getClasses()&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &#39;一条信息&#39;,</span><br><span class="line">                title: &#39;title&#39;,</span><br><span class="line">                </span><br><span class="line">                isActive: true,</span><br><span class="line">                isFront: true</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                getClasses: function ()&#123;</span><br><span class="line">                    return &#123;active:this.isActive,front:this.isFront&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>数组语法：无法动态修改 很少使用 也可以封装成一个方法</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 <span class="keyword">class</span>=&#x27;<span class="symbol">location</span>&#x27; :<span class="symbol">class</span>=&quot;[<span class="symbol">active,</span>&#x27;<span class="symbol">front</span>&#x27;]&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>作业：点击哪个 哪个变色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for&#x3D;&quot;(item,index) in movies&quot;</span><br><span class="line">                :class&#x3D;&quot;&#123;&#39;active&#39;:currentIndex&#x3D;&#x3D;index&#125;&quot;</span><br><span class="line">                @click&#x3D;&#39;changeColor(index)&#39;&gt;</span><br><span class="line">                &#123;&#123;item&#125;&#125;</span><br><span class="line">            &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                currentIndex: 0,</span><br><span class="line">                movies: [&quot;三国演义&quot;,&quot;水浒传&quot;,&quot;红楼梦&quot;,&quot;西游记&quot;]</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                changeColor: function(index)&#123;</span><br><span class="line">                    this.currentIndex &#x3D; index;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>v-bind动态绑定style：对象语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;h2 :style&#x3D;&quot;&#123;fontSize: &#39;20px&#39;,color: red&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                currentIndex: 0,</span><br><span class="line">                message: &#39;hello wolrd&#39;,</span><br><span class="line">                movies: [&quot;三国演义&quot;,&quot;水浒传&quot;,&quot;红楼梦&quot;,&quot;西游记&quot;],</span><br><span class="line">                red: &#39;red&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                changeColor: function(index)&#123;</span><br><span class="line">                    this.currentIndex &#x3D; index;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>返回的是一个属性 相比于method 可以缓存数据 调用多次 不用重复计算</p><p>简写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                firstName: &#39;Bob&#39;,</span><br><span class="line">                LastName: &#39;Allen&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            computed: &#123;</span><br><span class="line">                fullName: function ()&#123;</span><br><span class="line">                    return this.firstName + &#39; &#39; + this.LastName;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>属性有两个方法getter和setter 完整写法</p><h2 id="块级作用域var和let"><a href="#块级作用域var和let" class="headerlink" title="块级作用域var和let"></a>块级作用域var和let</h2><p>var的if和for没有块级作用域 函数有作用域 很多时候需要借助function的作用域来解决引用外面变量的问题 </p><p>ES6中加入了let let有if和for的块级作用域</p><h2 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h2><p>const修饰的变量不会被再次赋值 在es6开发中 优先使用const 需要改变某个标识符的时候才使用let</p><p>const修饰的标识符必须赋值  错误示范：const name;</p><p>指向的对象不能修改但是可以改变对象的内部属性</p><h2 id="对象增量写法"><a href="#对象增量写法" class="headerlink" title="对象增量写法"></a>对象增量写法</h2><p>ES6中新增的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;自动解析：把变量和他的值最为对象的属性</span><br><span class="line">      const name &#x3D; &quot;bob&quot;;</span><br><span class="line">      const age &#x3D; 18;</span><br><span class="line">      const obj &#x3D; &#123;</span><br><span class="line">          name,age,</span><br><span class="line">          &#x2F;&#x2F;定义函数:并进行类型验证 传入的参数必须是String</span><br><span class="line">          run(name:String)&#123;</span><br><span class="line">              console.log(&quot;我要跑了&quot;)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p>.stop修饰符 阻止事件冒泡</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">       &lt;div @click&#x3D;&quot;divClick&quot;&gt;</span><br><span class="line">           aaaa</span><br><span class="line">           &lt;button @click.stop&#x3D;&quot;btnClick&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">       &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue (&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &#39;hello vue&#39;,</span><br><span class="line">                names: [&#39;bob&#39;,&#39;jack&#39;,&#39;rose&#39;],</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                divClick()&#123;</span><br><span class="line">                    console.log(&quot;divClick&quot;)</span><br><span class="line">                &#125;,</span><br><span class="line">                btnClick()&#123;</span><br><span class="line">                    console.log(&quot;btnClick&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>.prevent阻止默认事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#执行自己的函数submitClick而不是跳转到baidu</span><br><span class="line">&lt;form action&#x3D;&quot;baidu&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; @click.prevent&#x3D;&quot;submitClick&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure><p>监听键帽的点击</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; @keyup&#x3D;&quot;keyUp&quot;&gt;</span><br><span class="line">#只监听enter</span><br><span class="line">@keyUp.enter</span><br></pre></td></tr></table></figure><p>.once只触发一次回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click.once&#x3D;&quot;btnClick&quot;&gt;只触发一次&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure><h2 id="v-if-v-else-if-v-else"><a href="#v-if-v-else-if-v-else" class="headerlink" title="v-if v-else-if v-else"></a>v-if v-else-if v-else</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;h2 v-if&#x3D;&quot;counter&gt;0&quot;&gt;&#123;&#123;message+&#39;counter&gt;0&#39;&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2 v-else-if&#x3D;&quot;counter&lt;0&quot;&gt;&#123;&#123;message+&#39;counter&lt;0&#39;&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2 v-else&gt;&#123;&#123;message+&#39;counter&#x3D;&#x3D;0&#39;&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                counter: 1,</span><br><span class="line">                message:&quot;hello world&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line"></span><br><span class="line">                increment: function ()&#123;</span><br><span class="line">                    this.counter++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>案例：登录切换 点击切换 输入框显示不同的内容</p><p><img src="/2020/10/22/Vue-js/image-20201026213741391.png" alt="image-20201026213741391"></p><p>小问题：在输入框输入内容后 点击切换 输入框中的内容还在 因为vue在进行dom渲染时 出于性能考虑 会尽可能的复用已经存在的元素 而不是重新创建新的元素  如果不希望重复利用  可以在input里添加key 如果两个input的key不同则不可以复用</p><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>v-show当条件为false的时候 仅将元素的dispaly属性置为none </p><p>v-if条件为false的时候 不会有对应的元素在dom中</p><p>显示与隐藏切换频繁的时候使用v-show</p><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p><strong>遍历数组</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li v-for&#x3D;&quot;(movie,index) in movies&quot;&gt;</span><br><span class="line">            &#123;&#123;index+1&#125;&#125;.&#123;&#123;movie&#125;&#125;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>第二个参数是index 顺序不能交换</p><p><strong>遍历对象</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &#x2F;&#x2F;key是下标</span><br><span class="line">        &lt;li v-for&#x3D;&quot;(value,key) in person&quot;&gt;</span><br><span class="line">            &#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p><img src="/2020/10/22/Vue-js/image-20201028082150266.png" alt="image-20201028082150266"></p><p>vue是响应式的 当数据发生变化的时候 vue会自动检测 数据变化 视图会发生对应的更新 </p><p>vue中包含了一组观察数组编译的方法 使用他们改变数组也会触发视图的更新:push pop shift unshift sort reverse</p><p>shift删除数组最前面的元素 unshift在数组前面添加元素</p><p>使用数组下标修改元素 不能做到响应式</p><h2 id="购物车案例"><a href="#购物车案例" class="headerlink" title="购物车案例"></a>购物车案例</h2><p>过滤器的使用：过滤器会把管道前的元素作为第一个参数传入</p><p><img src="/2020/10/22/Vue-js/image-20201028091630236.png" alt="image-20201028091630236"></p><p>​    <img src="/2020/10/22/Vue-js/image-20201028091636710.png" alt="image-20201028091636710"></p><h2 id="高阶函数的使用"><a href="#高阶函数的使用" class="headerlink" title="高阶函数的使用"></a>高阶函数的使用</h2><p>遍历的两种方式</p><p><img src="/2020/10/22/Vue-js/image-20201030090307298.png" alt="image-20201030090307298"></p><p><strong>filter</strong>：回调函数返回true时 函数内部将这次回调的n加入到新的数据中 返回false 这个n被过滤掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">       &lt;h2 v-for&#x3D;&quot;num in testFilter(nums)&quot;&gt;&#123;&#123;num&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue (&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                nums:[1,2,3,4,5],</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                testFilter(arr)&#123;</span><br><span class="line">                    return arr.filter(function (n)&#123;</span><br><span class="line">                        return n&lt;&#x3D;3;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p><strong>map</strong>:返回的值取代之前的值加入到回调函数的数组中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">       &lt;h2 v-for&#x3D;&quot;num in testMap(nums)&quot;&gt;&#123;&#123;num&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue (&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                nums:[1,2,3,4,5],</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                testMap(arr)&#123; </span><br><span class="line">                    return arr.map(function (n)&#123;</span><br><span class="line">                        return n*2;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>reduce:对数组中的所有内容进行汇总</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;testReduce(nums)&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue (&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                nums:[1,2,3,4,5],</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                testReduce(arr)&#123;</span><br><span class="line">                    &#x2F;&#x2F;n是数组的元素 preValue是每次返回的结果</span><br><span class="line">                    return arr.reduce(function (preValue,n)&#123;</span><br><span class="line">                        return preValue+n;</span><br><span class="line">                    &#125;,0)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>v-model可以实现表单元素和数据的双向绑定</p><p><strong>radio</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        男：&lt;input type&#x3D;&quot;radio&quot; value&#x3D;&quot;男&quot; name&#x3D;&quot;sex&quot; v-model&#x3D;&quot;sex&quot;&gt;&lt;br&gt;</span><br><span class="line">        女：&lt;input type&#x3D;&quot;radio&quot; value&#x3D;&quot;女&quot; name&#x3D;&quot;sex&quot; v-model&#x3D;&quot;sex&quot;&gt;&lt;br&gt;</span><br><span class="line">        选择结果:&#123;&#123;sex&#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                sex: &quot;&quot;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p><strong>checkbox</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;agree&quot; v-model&#x3D;&quot;isAgree&quot;&gt;同意协议</span><br><span class="line"></span><br><span class="line">        &lt;h2&gt;您选择的是&#123;&#123;isAgree&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;button :disabled&#x3D;&quot;!isAgree&quot;&gt;下一步&lt;&#x2F;button&gt;</span><br><span class="line">     &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                isAgree: false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;篮球&quot; v-model&#x3D;&quot;hobbies&quot;&gt;篮球</span><br><span class="line">        &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;足球&quot; v-model&#x3D;&quot;hobbies&quot;&gt;足球</span><br><span class="line">        &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;排球&quot; v-model&#x3D;&quot;hobbies&quot;&gt;排球</span><br><span class="line">        &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;羽毛球&quot; v-model&#x3D;&quot;hobbies&quot;&gt;羽毛球</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        你的爱好是:&#123;&#123;hobbies&#125;&#125;</span><br><span class="line">     &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                hobbies: []</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>值绑定：标签中的属性不要写死 使用动态绑定</p><p><img src="/2020/10/22/Vue-js/image-20201030103422316.png" alt="image-20201030103422316"></p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>延时加载v-model.lazy:当表格失去焦点或者回车的时候 数据才会更新</p><p>如果希望表格中数据是number类型 可以使用v-model.member</p><p>v-model.trim:去除掉首尾的空格</p><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><h3 id="基本使用过程"><a href="#基本使用过程" class="headerlink" title="基本使用过程"></a><strong>基本使用过程</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">&lt;!--        使用组件--&gt;</span><br><span class="line">        &lt;my-cpn&gt;&lt;&#x2F;my-cpn&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;&#x2F;创建组件</span><br><span class="line">        const cpn &#x3D; Vue.extend(&#123;</span><br><span class="line">            template: &#96;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h2&gt;我是标题&lt;&#x2F;h2&gt;</span><br><span class="line">                    &lt;h2&gt;不能引用data里的数据&lt;&#x2F;h2&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &#96;</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F;注册组件</span><br><span class="line">        Vue.component(&#39;my-cpn&#39;,cpn)</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><h3 id="全局组件和局部组件"><a href="#全局组件和局部组件" class="headerlink" title="全局组件和局部组件"></a><strong>全局组件和局部组件</strong></h3><p>全局组件：使用Vue.component()进行注册  可以在多个vue实例中使用</p><p>局部组件:在vue中的conponents中进行组测只能在当前vue实例中使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const app &#x3D; new Vue(&#123;</span><br><span class="line">el: &#39;#app&#39;,</span><br><span class="line">components: &#123;</span><br><span class="line">myCpn:cpn</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="父组件和局部组件"><a href="#父组件和局部组件" class="headerlink" title="父组件和局部组件"></a><strong>父组件和局部组件</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;parent&gt;&lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;&#x2F;创建组件</span><br><span class="line">        const child &#x3D; Vue.extend(&#123;</span><br><span class="line">            template: &#96;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h2&gt;我是子组件&lt;&#x2F;h2&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &#96;</span><br><span class="line">        &#125;)</span><br><span class="line">        const parent &#x3D; Vue.extend(&#123;</span><br><span class="line">            template: &#96;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h2&gt;我是父组件&lt;&#x2F;h2&gt;</span><br><span class="line">                    &lt;child&gt;&lt;&#x2F;child&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &#96;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                child: child</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                parent: parent</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><h3 id="注册组件语法糖"><a href="#注册组件语法糖" class="headerlink" title="注册组件语法糖"></a><strong>注册组件语法糖</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;parent&gt;&lt;&#x2F;parent&gt;</span><br><span class="line">        &lt;cpn&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;&#x2F;直接创建并注册组件</span><br><span class="line">        Vue.component(&#39;child&#39;,&#123;</span><br><span class="line">            template: &#96;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h2&gt;我是子组件&lt;&#x2F;h2&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &#96;</span><br><span class="line">        &#125;)</span><br><span class="line">        Vue.component(&#39;parent&#39;,&#123;</span><br><span class="line">            template: &#96;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h2&gt;我是父组件&lt;&#x2F;h2&gt;</span><br><span class="line">                    &lt;child&gt;&lt;&#x2F;child&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &#96;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                &#39;cpn&#39;: &#123;</span><br><span class="line">                    template: &#96;</span><br><span class="line">                        &lt;div&gt;</span><br><span class="line">                            &lt;h2&gt;我是普通组件&lt;&#x2F;h2&gt;</span><br><span class="line">                        &lt;&#x2F;div&gt;</span><br><span class="line">                    &#96;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><h3 id="组件模块抽离"><a href="#组件模块抽离" class="headerlink" title="组件模块抽离"></a><strong>组件模块抽离</strong></h3><p>template只能有一个根标签</p><p>方法一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;x-template&quot; id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;我是普通组件&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            &#39;cpn&#39;: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是普通组件&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            &#39;cpn&#39;: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="组件data"><a href="#组件data" class="headerlink" title="组件data"></a>组件data</h3><p>组件不能访问实例中的数据 有自己的data 保存在 data函数中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;child&gt;&lt;&#x2F;child&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                &#39;cpn&#39;: &#123;</span><br><span class="line">                    template: &#39;#cpn&#39;,</span><br><span class="line">                    date() &#123;</span><br><span class="line">                        return &#123;</span><br><span class="line">                            message: &#39;hello world&#39;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>为什么data必须是函数？防止相同组件定义多个的时候数据共享 导致错误 通过函数定义data可以保证每个组件都有自己单独的空间</p><h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><p>通过props向子组件传递数据 通过事件向父组件发送消息</p><h4 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a><strong>父传子</strong></h4><p>vue实例相当于一个父组件 template只能有一个根标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;cpn v-bind:cmovies&#x3D;&quot;movies&quot; v-bind:cmessage&#x3D;&quot;message&quot;&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;div&gt;&#123;&#123;cmovies&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div&gt;&#123;&#123;cmessage&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const cpn &#x3D;  &#123;</span><br><span class="line">            template: &#39;#cpn&#39;,</span><br><span class="line">            &#x2F;&#x2F;数组形式</span><br><span class="line">            &#x2F;&#x2F; props: [&quot;cmovies&quot;,&quot;cmessage&quot;]</span><br><span class="line">        &#x2F;&#x2F;    对象形式:可以对传入数据进行类型限制 支持 String Number Boolean Array Object Date Function Symbol</span><br><span class="line">            props: &#123;</span><br><span class="line">                cmovies: Array,</span><br><span class="line">                cmessage: &#123;</span><br><span class="line">                    type: [String,Number],&#x2F;&#x2F;可以定义多个</span><br><span class="line">                    default: &#39;aaa&#39;, &#x2F;&#x2F;如果父组件中message为null或message未定义 或者没绑定父组件的任何值则给他一个默认值 如果类型是数组或者对象 默认值必须是一个函数</span><br><span class="line">                    required: true, &#x2F;&#x2F;这个参数是必须的</span><br><span class="line">                    validate(value)&#123;</span><br><span class="line">                        &#x2F;&#x2F;进行一些判断</span><br><span class="line">                        return value &#x3D;&#x3D; 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &#39;hello world&#39;,</span><br><span class="line">                movies: [&quot;水浒传&quot;,&quot;红楼梦&quot;,&quot;三国演义&quot;],</span><br><span class="line">            &#125;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                cpn</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p><strong>props驼峰标识</strong></p><p><img src="/2020/10/22/Vue-js/image-20201030182132676.png" alt="image-20201030182132676"></p><h4 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a><strong>子传父</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpn @itemclick&#x3D;&quot;cpnClick&quot;&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;button v-for&#x3D;&quot;item in categories&quot; @click&#x3D;&quot;btnClick(item)&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const cpn &#x3D;  &#123;</span><br><span class="line">        template: &#39;#cpn&#39;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                categories: [</span><br><span class="line">                    &#123;id: &#39;1&#39;,name: &#39;热门推荐&#39;&#125;,</span><br><span class="line">                    &#123;id: &#39;2&#39;,name: &#39;电脑办公&#39;&#125;,</span><br><span class="line">                    &#123;id: &#39;3&#39;,name: &#39;家用电器&#39;&#125;,</span><br><span class="line">                    &#123;id: &#39;4&#39;,name: &#39;手机数码&#39;&#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            btnClick(item)&#123;</span><br><span class="line">                &#x2F;&#x2F;发送一个事件并且传递参数</span><br><span class="line">                this.$emit(&#39;itemclick&#39;,item)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;hello world&#39;,</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            cpnClick(item)&#123;</span><br><span class="line">                console.log(&#39;cpnClick&#39;+item.name)</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><ul><li>组件中的btnClick方法会emit一个itemClick 通过itemClick会把参数传入到父组件的cpnClick方法中</li></ul><h4 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a><strong>双向绑定</strong></h4><p>现在通过子组件和父组件都能改变父组件中的data 但是为了避免混淆vue规定只能通过父组件改变data中的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpn&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;childnum1&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;childnum1&quot;&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;childnum2&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;childnum2&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            num1:1,</span><br><span class="line">            num2:2</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;,</span><br><span class="line">                props: &#123;</span><br><span class="line">                    childnum1: Number,</span><br><span class="line">                    childnum2: Number</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>在子组件中添加data 使其绑定一个中间值dnumber 修改的时候修改的是dnumber的值 而不是父组件中data的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpn :childnum1&#x3D;&quot;num1&quot; :childnum2&#x3D;&quot;num2&quot;&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;props:&#123;&#123;childnum1&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2&gt;data:&#123;&#123;dnumber1&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;childnum1&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;dnumber1&quot;&gt;</span><br><span class="line">        &lt;h2&gt;props:&#123;&#123;childnum2&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2&gt;props:&#123;&#123;dnumber2&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;dnumber2&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            numm1:1,</span><br><span class="line">            num2:2</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;,</span><br><span class="line">                props: &#123;</span><br><span class="line">                    childnum1: Number,</span><br><span class="line">                    childnum2: Number</span><br><span class="line">                &#125;,</span><br><span class="line">                data()&#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        dnumber1: this.childnum1,</span><br><span class="line">                        dnumber2: this.childnum2</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>增加新的功能 反向修改父组件中的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpn :childnum1&#x3D;&quot;num1&quot; :childnum2&#x3D;&quot;num2&quot; @num1change&#x3D;&quot;num1change&quot; @num2chage&#x3D;&quot;num2change&quot;&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;props:&#123;&#123;childnum1&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2&gt;data:&#123;&#123;dnumber1&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;!--使这个input绑定childnum并双向绑定方法childnum1input --&gt;</span><br><span class="line">        &lt;!--@input 一般用于监听事件 只要输入的值变化了就会触发input--&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;childnum1&quot; @input&#x3D;&quot;childnum1input&quot;&gt;</span><br><span class="line">        &lt;h2&gt;props:&#123;&#123;childnum2&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2&gt;data:&#123;&#123;dnumber2&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;childnum2&quot; @input&#x3D;&quot;childnum2input&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            num1:1,</span><br><span class="line">            num2:2</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">          num1change(value)&#123;</span><br><span class="line">              this.num1 &#x3D; parseFloat(value)</span><br><span class="line">          &#125;,</span><br><span class="line">          num2change(value)&#123;</span><br><span class="line">              this.num2 &#x3D; parseFloat(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;,</span><br><span class="line">                props: &#123;</span><br><span class="line">                    childnum1: Number,</span><br><span class="line">                    childnum2: Number</span><br><span class="line">                &#125;,</span><br><span class="line">                data()&#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        dnumber1: this.childnum1,</span><br><span class="line">                        dnumber2: this.childnum2</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    childnum1input(event) &#123;   </span><br><span class="line">                        &#x2F;&#x2F;event.target.value的值是childnum1 改变dnumber后把YX,递给父组件</span><br><span class="line">                        this.dnumber1 &#x3D; event.target.value;</span><br><span class="line">                        this.$emit(&#39;num1change&#39;,this.dnumber1)</span><br><span class="line">                        </span><br><span class="line">                    &#125;,</span><br><span class="line">                    childnum2input(event) &#123;</span><br><span class="line">                        this.dnumber2 &#x3D; event.target.value;</span><br><span class="line">                        this.$emit(&#39;num2change&#39;,this.dnumber2)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>增加新的功能 当在第一个input中输入内容的时候 第二个input的内容和数据 为第一个input的100</p><p><img src="/2020/10/22/Vue-js/image-20201031085733023.png" alt="image-20201031085733023"></p><p>watch实现双向绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpn :childnum1&#x3D;&quot;num1&quot; :childnum2&#x3D;&quot;num2&quot; @num1change&#x3D;&quot;num1change&quot; @num2chage&#x3D;&quot;num2change&quot;&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;props:&#123;&#123;childnum1&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2&gt;data:&#123;&#123;dnumber1&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;!--使这个input绑定childnum并双向绑定方法childnum1input --&gt;</span><br><span class="line">        &lt;!--@input 一般用于监听事件 只要输入的值变化了就会触发input--&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;dnumber1&quot;&gt;</span><br><span class="line">        &lt;h2&gt;props:&#123;&#123;childnum2&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2&gt;data:&#123;&#123;dnumber2&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;dnumber2&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            num1:1,</span><br><span class="line">            num2:2</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">          num1change(value)&#123;</span><br><span class="line">              this.num1 &#x3D; parseFloat(value)</span><br><span class="line">          &#125;,</span><br><span class="line">          num2change(value)&#123;</span><br><span class="line">              this.num2 &#x3D; parseFloat(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;,</span><br><span class="line">                props: &#123;</span><br><span class="line">                    childnum1: Number,</span><br><span class="line">                    childnum2: Number</span><br><span class="line">                &#125;,</span><br><span class="line">                data()&#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        dnumber1: this.childnum1,</span><br><span class="line">                        dnumber2: this.childnum2</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                watch:&#123;</span><br><span class="line">                    dnumber1(newvalue)&#123;</span><br><span class="line">                        this.dnumber2 &#x3D; newvalue * 100;</span><br><span class="line">                        this.$emit(&#39;num1change&#39;,newvalue)</span><br><span class="line">                    &#125;,</span><br><span class="line">                    dnumber2(newvalue)&#123;</span><br><span class="line">                        this.dnumber1 &#x3D; newvalue &#x2F; 100;</span><br><span class="line">                        this.$emit(&#39;num2change&#39;,newvalue)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><h3 id="父组件访问子组件"><a href="#父组件访问子组件" class="headerlink" title="父组件访问子组件"></a>父组件访问子组件</h3><p>$children:需要根据自组件的下标获取 不方便 很少使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;cpn&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">        &lt;cpn&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">        &lt;button @click&#x3D;&quot;btnClick&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是子组件&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;hello world&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            btnClick()&#123;</span><br><span class="line">                console.log(this.$children)</span><br><span class="line">                this.$children[0].showMessage()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;,</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    showMessage()&#123;</span><br><span class="line">                        console.log(&#39;showMessage&#39;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>$refs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;cpn ref&#x3D;&quot;aaa&quot;&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">        &lt;cpn ref&#x3D;&quot;bbb&quot;&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">        &lt;cpn ref&#x3D;&quot;ccc&quot;&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">        &lt;button @click&#x3D;&quot;btnClick&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是子组件&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;hello world&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            btnClick()&#123;</span><br><span class="line">                console.log(this.$refs.aaa)</span><br><span class="line">                this.$refs.aaa.showMessage()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;,</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    showMessage()&#123;</span><br><span class="line">                        console.log(&#39;showMessage&#39;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><h3 id="子组件访问父组件"><a href="#子组件访问父组件" class="headerlink" title="子组件访问父组件"></a>子组件访问父组件</h3><p>parent和root</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;cpn&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是子组件&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;button @click&#x3D;&quot;btnclick&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;hello world&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;,</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    btnclick()&#123;</span><br><span class="line">                        &#x2F;&#x2F;访问父组件</span><br><span class="line">                        console.log(this.$parent.message)</span><br><span class="line">                    &#x2F;&#x2F;访问根组件</span><br><span class="line">                        console.log(this.$root.message)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpn&gt;</span><br><span class="line">        &lt;!--这种方式 如果有多个插槽 会替换所有插槽 --&gt;</span><br><span class="line">        &lt;h2&gt;呵呵呵&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2&gt;呵呵呵&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;cpn&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是子组件&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;!--        定义一个插槽 默认值为一个button 会把cpn标签中的所有内容都放在插槽中--&gt;</span><br><span class="line">        &lt;slot&gt;&lt;button&gt;按钮&lt;&#x2F;button&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>给插槽添加一个name属性 可以通过name插入指定的插槽    不指定名字会插入到没有name属性的插槽中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpn&gt;</span><br><span class="line">        &lt;span slot&#x3D;&quot;left&quot;&gt;呵呵呵&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;替换没有名字的插槽&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;cpn&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">&lt;!--        定义一个插槽 默认值为一个button 会把cpn标签中的所有内容都放在插槽中--&gt;</span><br><span class="line">        &lt;slot name&#x3D;&quot;left&quot;&gt;&lt;button&gt;左边&lt;&#x2F;button&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">        &lt;slot name&#x3D;&quot;mid&quot;&gt;&lt;button&gt;中间&lt;&#x2F;button&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">        &lt;slot name&#x3D;&quot;right&quot;&gt;&lt;button&gt;右边&lt;&#x2F;button&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">        &lt;slot&gt;&lt;button&gt;没有名字&lt;&#x2F;button&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h3 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h3><p>模板中的变量使用组件中的 视图中的变量使用vue实例中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">&lt;!--    isshow为true--&gt;</span><br><span class="line">    &lt;cpn v-show&#x3D;&quot;isshow&quot;&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;world&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;!--        isshow为false--&gt;</span><br><span class="line">        &lt;h2 v-show&#x3D;&quot;isshow&quot;&gt;hello&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;hello world&#39;,</span><br><span class="line">            isshow: true</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;,</span><br><span class="line">                data()&#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        isshow:false</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>父组件替换插槽的标签 但是内容由子组件来提供</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpn&gt;</span><br><span class="line">&lt;!--        改变展示方式--&gt;</span><br><span class="line">        &lt;!--    获取子组件中的数据 2.5版本以上可以用div代替template--&gt;</span><br><span class="line">        &lt;template slot-scope&#x3D;&quot;slot&quot;&gt;</span><br><span class="line">            &lt;span v-for&#x3D;&quot;movie in slot.data&quot;&gt;&#123;&#123;movie&#125;&#125;-&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;&#x2F;cpn&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;cpn&gt;</span><br><span class="line">            &lt;slot :data&#x3D;&quot;movies&quot;&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li v-for&#x3D;&quot;movie in movies&quot;&gt;&#123;&#123;movie&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;&#x2F;ul&gt;</span><br><span class="line">            &lt;&#x2F;slot&gt;</span><br><span class="line">        &lt;&#x2F;cpn&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;hello world&#39;,</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;,</span><br><span class="line">                data()&#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        movies: [&#39;三国演义&#39;,&#39;水浒传&#39;,&#39;西游记&#39;,&#39;红楼梦&#39;]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p><strong>commonJS的导入和导出</strong></p><p><img src="/2020/10/22/Vue-js/image-20201101090719158.png" alt="image-20201101090719158"></p><p><strong>ES6的导入和导出</strong></p><p>导出变量</p><p><img src="/2020/10/22/Vue-js/image-20201101091751012.png" alt="image-20201101091751012"></p><p>导出函数和类</p><p><img src="/2020/10/22/Vue-js/image-20201101092123506.png" alt="image-20201101092123506"></p><p>上面的方式导入和导出的变量名必须保持一致</p><p>export default：导出的东西只能有一个</p><p><img src="/2020/10/22/Vue-js/image-20201101092458727.png" alt="image-20201101092458727"></p><p>导入</p><p><img src="/2020/10/22/Vue-js/image-20201101092634309.png" alt="image-20201101092634309"></p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>主要功能是模块化和打包 支持各种模块化规范 可以处理模块之间的依赖 并且打包成一个文件</p><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>创建mathUtils.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1* num2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    add,mul</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建一个main.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;add,mul&#125; = <span class="built_in">require</span>(<span class="string">&#x27;./mathUtils.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;name,age,height&#125; <span class="keyword">from</span> <span class="string">&quot;./info.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br><span class="line"><span class="built_in">console</span>.log(age)</span><br><span class="line"><span class="built_in">console</span>.log(height)</span><br></pre></td></tr></table></figure><p>创建info.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;bob&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">10</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> height = <span class="number">1.79</span></span><br></pre></td></tr></table></figure><p>通过webpack进行打包 ：webpack ./src/main.js  -o ./dist/bundle.js</p><p>创建一个index.html应用bundle.js</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>webpack.config.js配置</strong></p><p>执行webpack的时候自动找到webpack.config.js 读取其中的入口和出口</p><p>出口的path需要绝对路径  当前文件的绝对路径可以通过require(‘path’)获取 前期是安装node相关的包 执行npm init即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname,<span class="string">&#x27;dist&#x27;</span>),   <span class="comment">//要填入绝对路径 动态获取 __dirname是node中的属性 可以获取当前文件所在目录</span></span><br><span class="line">        filename: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>package.json配置</strong></p><p>当执行npm init后 会生成此文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;webpack1&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;webpack.config.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在scripts定义脚本 通过npm run xxx执行 该命令先在本地查找 再进行全局查找</p><p>本地安装不要加 -g :npm install webpack –save-dev (–save-dev是开发时依赖 项目打包后不需要继续使用)</p><p>安装后自动生成一个node_modules文件夹 并在pacckage.json中添加devDependencies</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;^3.6.0&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><p><img src="/2020/10/22/Vue-js/image-20201101190647078.png" alt="image-20201101190647078"></p><h4 id="处理css文件"><a href="#处理css文件" class="headerlink" title="处理css文件"></a>处理css文件</h4><p><strong>安装style-loader和css-loader添加css文件</strong></p><p>npm install css-loader –save-dev  安装css-loader同理</p><p>在webpack.config.js中进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">       rules: [</span><br><span class="line">           &#123;</span><br><span class="line">               test: &#x2F;\.css$&#x2F;,</span><br><span class="line">               &#x2F;&#x2F;多个loader时从右向左架子啊</span><br><span class="line">               use: [</span><br><span class="line">                   &#39;style-loader&#39;,      &#x2F;&#x2F;负责将样式添加到dom中</span><br><span class="line">                   &#39;css-loader&#39;         &#x2F;&#x2F;只负责加载css文件</span><br><span class="line">               ]</span><br><span class="line">           &#125;</span><br><span class="line">       ]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在main.js中引入css</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./css/normal.css&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="图片文件的处理"><a href="#图片文件的处理" class="headerlink" title="图片文件的处理"></a>图片文件的处理</h4><p>安装ur-loader：npm install –save-dev url-loader</p><p>在webpck.config.js中添加配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">//如果图片大于limit需要安装limit 执行webpack后会把图片打包并重新命名（32位hash 防止重复）</span></span><br><span class="line">            <span class="comment">// 小于limit会将图片编译成base64字符串形式</span></span><br><span class="line">            loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">8192</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包后图片被放在dist目录中 但是浏览器访问的时候还是直接查找打包后的图片 这样会404 在webpack.config.js中的output中添加一行配置 <code>publicPath: &#39;dist/&#39;</code> 这样相当于在图片前面加了一个dist/ 就可以访问成功了</p><p><img src="/2020/10/22/Vue-js/image-20201102091142454.png" alt="image-20201102091142454"></p><p>选项</p><ul><li>img：文件要打包到的文件夹 </li><li>name：获取文件原来的名</li><li>hash:8：hash只保留八位</li><li>ext：获取图片原来的扩展名</li></ul><p>把生成的图片放在dist的img目录下 并且格式为name.hash:8.ext</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">    name: <span class="string">&#x27;img/[name].[hash:8].[ext]&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ES6转ES5"><a href="#ES6转ES5" class="headerlink" title="ES6转ES5"></a>ES6转ES5</h4><p>使用babel对应的loader</p><p>安装：npm install <a href="mailto:&#x62;&#97;&#x62;&#x65;&#x6c;&#45;&#108;&#111;&#97;&#x64;&#101;&#114;&#64;&#x38;&#46;&#x30;&#46;&#48;&#45;&#x62;&#101;&#x74;&#97;&#x2e;&#x30;">&#x62;&#97;&#x62;&#x65;&#x6c;&#45;&#108;&#111;&#97;&#x64;&#101;&#114;&#64;&#x38;&#46;&#x30;&#46;&#48;&#45;&#x62;&#101;&#x74;&#97;&#x2e;&#x30;</a> @babel/core @babel/preset-env webpack</p><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [<span class="string">&#x27;es2015&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行npm run build</p><h3 id="使用vue的配置过程"><a href="#使用vue的配置过程" class="headerlink" title="使用vue的配置过程"></a>使用vue的配置过程</h3><p>安装vue：npm install vue –save</p><p>在js中导入vue：<code>import Vue from &#39;vue&#39;</code></p><p>vue运行的时候有两个版本</p><ul><li>runtime-only:代码中 不可以用任何的template</li><li>runtime-complier:代码中可以有template  因为有complier可以编译模块</li></ul><p>在webpack.config.js中进行配置使用runtime-complier</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">       alias: &#123;</span><br><span class="line">           <span class="string">&#x27;vue@&#x27;</span>: <span class="string">&#x27;vue/dist/vue.ems.js&#x27;</span> <span class="comment">//使vue指定具体文件夹</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在html正常使用vue 可以在vue中定义一个template 会替换掉&lt;div id=”app”&gt;中的内容</p><p>如果</p><h1 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h1><h3 id="vue-cli2"><a href="#vue-cli2" class="headerlink" title="vue-cli2"></a>vue-cli2</h3><p>vue-cli可以快速搭建 vue开发环境以及对应的webpack配置</p><p>安装vue-cli:npm uninstall -g @vue/cli </p><p>Vue CLI &gt;= 3 与旧版使用了相同的 <code>vue</code> 命令，所以 Vue CLI 2 (<code>vue-cli</code>) 被覆盖了。如果你仍然需要使用旧版本的 <code>vue init</code> 功能，你可以全局安装一个桥接工具：npm install -g @vue/cli-init</p><p>初始化项目：vue-cli2:vue init webpack xxx</p><p>node xxx.js可以直接执行js文件</p><p>build和config中进行了一些配置 npm run build 用来打包 npm run dev运行项目</p><p>static文件夹下的文件会原封不动的放入到dist中 其中的.gitKeep文件使即使改目录为空 也会上传到git服务器</p><p>vue程序运行过程</p><p><img src="/2020/10/22/Vue-js/image-20201102145346773.png" alt="image-20201102145346773"></p><p>创建项目的时候 vue build可选compiler和runtime 区别只体现在main.js中</p><ul><li><p><img src="/2020/10/22/Vue-js/image-20201102145518641.png" alt="image-20201102145518641"></p></li><li><p>compiler需要解析语法树并编译给render 代码更多 性能较低</p></li><li><p>所以初始化项目的时候一般选runtime-only</p></li><li><p>render的参数h是函数createElement  可以创建.vue文件</p><ul><li>普通用法<img src="/2020/10/22/Vue-js/image-20201102150311038.png" alt="image-20201102150311038"></li><li>还可以传入.vue文件 文件中的template由vue-template-complier解析为render() </li></ul></li></ul><h3 id="vue-cli3"><a href="#vue-cli3" class="headerlink" title="vue-cli3"></a>vue-cli3</h3><p><img src="/2020/10/22/Vue-js/image-20201102152512117.png" alt="image-20201102152512117"></p><p>初始化项目：vue create vue_cli3</p><p>在终端输入vue ui就可以启动vue ui</p><p>导入需要配置的项目</p><p><img src="/2020/10/22/Vue-js/image-20201102155709761.png" alt="image-20201102155709761"></p><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const cli &#x3D; (参数列表)&#x3D;&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只有一行 大括号可以省略 并且自动返回</p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>vue-cli</p><h2 id="url的hash"><a href="#url的hash" class="headerlink" title="url的hash"></a>url的hash</h2><p><img src="/2020/10/22/Vue-js/image-20201102192709374.png" alt="image-20201102192709374"></p><h2 id="history的pushState"><a href="#history的pushState" class="headerlink" title="history的pushState"></a>history的pushState</h2><p><img src="/2020/10/22/Vue-js/image-20201102192846900.png" alt="image-20201102192846900"></p><p>三个参数分别是：data，title，url 相当于把url压入栈中 当执行history.back的时候出栈 总是显示栈顶的url ，history.go(n)可以入栈n个 或者出栈n个url</p><p>相似的指令有replaceStatus 不能back</p><h2 id="router安装和配置方式"><a href="#router安装和配置方式" class="headerlink" title="router安装和配置方式"></a>router安装和配置方式</h2><p>安装：npm install vue-router –save</p><p>在src中创建router/index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置路由信息</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//通过Vue.use(插件)安装插件</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"><span class="comment">//创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> routes = []</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="comment">//配置路径和组件之间的映射关系</span></span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//将router实例传入到Vue实例中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>在main.js中导入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果导入的是router目录 自动查找index.js文件</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/index&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)  <span class="comment">//相当于el: &#x27;#pp&#x27;</span></span><br></pre></td></tr></table></figure><p> 创建路由组件</p><p>About.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是关于&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;div&gt;我是关于内容&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;About&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>Home.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是首页&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;div&gt;我是首页内容&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Home&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>在index.js中进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">        component: Home</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">        component: About</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在App.vue中进行渲染 roter-link会被渲染成&lt;a&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;home&quot; tag&#x3D;&quot;button&quot;&gt;首页&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;about&quot;&gt;关于&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>路由的默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  redirect: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由默认使用的是url的hash</p><p><img src="/2020/10/22/Vue-js/image-20201103104538701.png" alt="image-20201103104538701"></p><p>如果想展示localhost:8080/about可以使用history 默认使用replaceStatus</p><p>在index.js中进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="comment">//配置路径和组件之间的映射关系</span></span><br><span class="line">    routes,</span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span>  <span class="comment">//使用history</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="router-link的属性"><a href="#router-link的属性" class="headerlink" title="router-link的属性"></a>router-link的属性</h2><p>tag属性可以指定router-link渲染成什么组件</p><p><code>    &lt;router-link to=&quot;/home&quot; tag=&quot;button&quot;&gt;首页&lt;/router-link&gt;</code></p><p>使用history的replaceStatus模式使不能点击&lt;- 和-&gt; ：<code>   &lt;router-link to=&quot;/home&quot; tag=&quot;button&quot; replace&gt;首页&lt;/router-link&gt;</code></p><p>当点击router-link的时候 会为其加一个class：router-link-active<img src="/2020/10/22/Vue-js/image-20201103105508310.png" alt="image-20201103105508310"></p><p>可以利用这个class改变样式</p><p><img src="/2020/10/22/Vue-js/image-20201103105543332.png" alt="image-20201103105543332"></p><p>可以使用active-class=” xxx”重命名这个class:<code>    &lt;router-link to=&quot;/home&quot; active-class=&quot;active&quot;&gt;首页&lt;/router-link&gt;</code></p><p>也可以在VueRouter中统一修改</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes,</span><br><span class="line">    <span class="keyword">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">    linkActiveClas<span class="variable">s:</span> <span class="string">&#x27;active&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="通过代码跳转路由"><a href="#通过代码跳转路由" class="headerlink" title="通过代码跳转路由"></a>通过代码跳转路由</h2><p>router会为每个.vue文件添加一个$router属性 这个属性就是VueRouter对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;homeClick&quot;&gt;首页&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;aboutClick&quot;&gt;关于&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    homeClick()&#123;</span><br><span class="line">      &#x2F;&#x2F;相当于history.pushStatus</span><br><span class="line">      this.$router.push(&#39;&#x2F;home&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    aboutClick()&#123;</span><br><span class="line">      &#x2F;&#x2F;相当于history.replaceStatus</span><br><span class="line">      this.$router.replace(&#39;&#x2F;about&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h2 id="动态路由的使用"><a href="#动态路由的使用" class="headerlink" title="动态路由的使用"></a>动态路由的使用</h2><p>创建一个User.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是用户&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;div&gt;用户内容&lt;&#x2F;div&gt;</span><br><span class="line">     &#x2F;&#x2F;$this获得当前处于活跃状态的路由 参数名是在index.js中配置的参数名</span><br><span class="line">    &lt;div&gt;用户信息：&#123;&#123;this.$route.params.id&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>在index.js配置</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义了一个参数id</span></span><br><span class="line">    <span class="attribute">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>,</span><br><span class="line">    <span class="attribute">component</span>: User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在App.vue中进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#39;&#x2F;user&#x2F;&#39;+userId&quot;&gt;用户&lt;&#x2F;router-link&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;配置一个属性userId 动态拼接在路由路径上</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      userId: &#39;bob&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>主要作用是将路由对应的组件打包成一个个的js代码块</p><p><img src="/2020/10/22/Vue-js/image-20201103124819887.png" alt="image-20201103124819887"></p><p>​    打包后一个懒加载对应要给js文件</p><h2 id="路由的嵌套使用"><a href="#路由的嵌套使用" class="headerlink" title="路由的嵌套使用"></a>路由的嵌套使用</h2><p>为Home组件添加两个子路由</p><p> 在index.js中进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">       path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">       component: Home,</span><br><span class="line">       children: [</span><br><span class="line">           &#123;</span><br><span class="line">             path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">             redirect: <span class="string">&#x27;/home/news&#x27;</span></span><br><span class="line">           &#125;,</span><br><span class="line">           &#123;</span><br><span class="line">               path: <span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">               component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/Home_news&#x27;</span>)</span><br><span class="line">           &#125;,</span><br><span class="line">           &#123;</span><br><span class="line">               path: <span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">               component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/Home_message&#x27;</span>)</span><br><span class="line">           &#125;</span><br><span class="line">       ]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在Home.vue中进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是首页&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;div&gt;我是首页内容&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;home&#x2F;news&quot;&gt;新闻&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;home&#x2F;message&quot;&gt;消息&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>创建一个组件Profile</p><p>在index.js中进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;/profile&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/Profile&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在App.vue中为其创建router-link并传入参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123;path: &#39;&#x2F;profile&#39;,query: &#123;name: &#39;bob&#39;,age: 18&#125;&#125;&quot;&gt;档案&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><p>Profile.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;信息&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;this.$route.query.name&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;this.$route.query.age&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>动态传参和参数传递通过button实现跳转</p><p><img src="/2020/10/22/Vue-js/image-20201104073922502.png" alt="image-20201104073922502"></p><h2 id="导航首位"><a href="#导航首位" class="headerlink" title="导航首位"></a>导航首位</h2><p>如果实现跳转到不同页面时 title跟着变化</p><p>在index.js中为路由配置添加meta属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    component: About,</span><br><span class="line">    meta: &#123;</span><br><span class="line">        title: <span class="string">&#x27;关于&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>使用beforeEach(前置钩子：在路由跳转之前执行)实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//from是要离开的路由对象 to是要进入的路由对象 </span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.title = to.meta.title</span><br><span class="line">    <span class="built_in">console</span>.log(to)</span><br><span class="line">    next()  <span class="comment">//调用该方法 才能进入到下一个钩子</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是home中有两个子路由 不知道匹配哪一个 会undefined 使用：document.title = to.matched[0].meta.title 永远匹配第一个</p><p><img src="/2020/10/22/Vue-js/image-20201104082132846.png" alt="image-20201104082132846"></p><p>beforeEach就是一个全局守卫 还有afterEach 只有参数to和from</p><p>路由独享的守卫</p><p><img src="/2020/10/22/Vue-js/image-20201104083026727.png" alt="image-20201104083026727"></p><p>组件内的守卫</p><p><img src="/2020/10/22/Vue-js/image-20201104083222421.png" alt="image-20201104083222421"></p><h2 id="keepAlive"><a href="#keepAlive" class="headerlink" title="keepAlive"></a>keepAlive</h2><p>之前组件的状态没有被保留下来 当通过路由跳转的时候 会创建一个新的组件 希望保留状态可以使用keepAlive</p><p>把home路由下嵌套路由的重定向配置删除</p><p>在Vue.app中把roterLink放在keepAlive中</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;keep-alive&gt;</span></span><br><span class="line">  <span class="section">&lt;router-view&gt;</span><span class="section">&lt;/router-view&gt;</span></span><br><span class="line"><span class="section">&lt;/keep-alive&gt;</span></span><br></pre></td></tr></table></figure><p>在Home.vue中进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Home&quot;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      path: &#39;&#x2F;home&#x2F;news&#39; &#x2F;&#x2F;默认跳转到news</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  activated() &#123;</span><br><span class="line">    this.$router.push(this.path)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave(to,from,next)&#123;</span><br><span class="line">    this.path &#x3D; this.$route.path &#x2F;&#x2F;记录离开时当前路径</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>activated和deactivated只有在有keepAlive的时候才会生效</p><p><strong>属性</strong></p><p><img src="/2020/10/22/Vue-js/image-20201104100841241.png" alt="image-20201104100841241"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">exclude</span>=<span class="string">&quot;Profile&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>promise是异步编程的一种解决方案</p><p>定时器的异步事件</p><p><img src="/2020/10/22/Vue-js/image-20201104110609705.png" alt="image-20201104110609705"></p><p>resolve会执行the里的代码块 reject会执行catch里的代码块</p><p>then中可以传入两个参数then(data=&gt;{},error=&gt;{}) </p><h1 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a><strong>三种状态</strong></h1><p><img src="/2020/10/22/Vue-js/image-20201104153536990.png" alt="image-20201104153536990"></p><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p><img src="/2020/10/22/Vue-js/image-20201104155201850.png" alt="image-20201104155201850"></p><p>如果想让catch处理可以是：return Promise.resolve(res+”xxx”)</p><h2 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h2><p><img src="/2020/10/22/Vue-js/image-20201104205609194.png" alt="image-20201104205609194"></p><p>当两个请求都完成的时候 会执行then中的代码 返回结果存在results中</p><h1 id="VueX"><a href="#VueX" class="headerlink" title="VueX"></a>VueX</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><img src="/2020/10/22/Vue-js/image-20201104210407094.png" alt="image-20201104210407094"></p><p>管理什么状态？</p><p><img src="/2020/10/22/Vue-js/image-20201104211527323.png" alt="image-20201104211527323"></p><p>一般为vuex创建一个单独文件夹store 在其中创建于给index.js文件 并创建状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    counter: <span class="number">100</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>state是全局的 在任何组件中都能取到</p><p>在main.js中进行导入后就可以使用了</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;template&gt;</span></span><br><span class="line">  <span class="variable">&lt;div&gt;</span>&#123;&#123;<span class="variable">$store</span>.<span class="keyword">state</span>.counter&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="状态管理图例"><a href="#状态管理图例" class="headerlink" title="状态管理图例"></a><strong>状态管理图例</strong></h2><p><img src="/2020/10/22/Vue-js/image-20201104231353077.png" alt="image-20201104231353077"></p><p>修改state一定要通过mutation修改 </p><p>actions省略 他是用来处理异步操作的 可以请求后端api    </p><p>devtools可以记录每次修改state的状态</p><p>mutations中定义方法 方法中默认传入一个参数state</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment () &#123;</span><br><span class="line">    <span class="built_in">this</span>.state.counter++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>在其他方法中通过commit使用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123;$store.state.counter&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;button @click&#x3D;&quot;addition&quot;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  components: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addition () &#123;</span><br><span class="line">      this.$store.commit(&#39;increment&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>state单一状态树：在整个项目中只创建一个store </p><h2 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h2><p>getter中也有一个默认参数state</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  powerCounter () &#123;</span><br><span class="line">    return this.<span class="keyword">state</span>.counter * this.<span class="keyword">state</span>.counter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接通过$store.getters.powerCounter获取</p><p>如果需要为getter传入参数 可以使其返回一个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  powerCounter () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.state.counter * <span class="built_in">this</span>.state.counter</span><br><span class="line">  &#125;,</span><br><span class="line">  powerCounterAndAdd () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.getters.powerCounter + x</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过$store.getters.powerCounterAndAdd(x)获取</p><h2 id="数据响应式原理"><a href="#数据响应式原理" class="headerlink" title="数据响应式原理"></a>数据响应式原理</h2><p>state是响应式的 state中数据改变的时候 vue组件会自动更新</p><p>响应式的新增的属性和删除属性(在方法中)</p><p>Vue.set(state.person,’address’,’jiusan’)</p><p>vue.delete(state.person,’addres’)</p><h2 id="mutation的类型常量"><a href="#mutation的类型常量" class="headerlink" title="mutation的类型常量"></a>mutation的类型常量</h2><p>创建一个js文件存储常量</p><p>mutatiaon-types.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> POWERCOUNT = <span class="string">&#x27;powerCounter&#x27;</span></span><br></pre></td></tr></table></figure><p>在index.js中导入并使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; POWERCOUNT &#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/mutations-types&#x27;</span></span><br><span class="line"></span><br><span class="line">mutations: &#123;</span><br><span class="line">    [POWERCOUNT] () &#123;</span><br><span class="line">        <span class="built_in">this</span>.state.counter++</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有导出是defalut的时候 import不用大括号包裹</p><p> 在App.vue中导入并使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; POWERCOUNT &#125; from &#39;@&#x2F;store&#x2F;mutations-types&#39;</span><br><span class="line">additionByAccount (count) &#123;</span><br><span class="line">this.$store.commit(&#39;incrementByAccount&#39;, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>处理异步操作必须用action不能用mutation</p><p>action中的方法有一个默认值 context</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>createStore(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    counter: 100,</span><br><span class="line">    person: &#123;</span><br><span class="line">      age: 10,</span><br><span class="line">      name: <span class="string">&#x27;bob&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    updatePerson () &#123;</span><br><span class="line">      this.state.person.name = <span class="string">&#x27;jason&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    updatePerson (context) &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;updatePerson&#x27;</span>)</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>在App.vue中进行使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;$store.state.person&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;updatePerson&quot;&gt;修改person&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">updatePerson () &#123;</span><br><span class="line">  this.$store.dispatch(&#39;aupdatePerson&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><p>防止store臃肿 可以进行抽离 将store分割成模块</p><p><img src="/2020/10/22/Vue-js/image-20201105104634173.png" alt="image-20201105104634173"></p><p>可以使用state.a进行引用 其中的getters和mutations和之前使用方式相同 如果在store中找不到相应的方法 就去模块中查找</p><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>在项目中安装axios：npm install axios –save</p><p>在main.js中使用    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    url: <span class="string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,</span><br><span class="line">    params: &#123;</span><br><span class="line">        type: <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">        page:<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    method: <span class="string">&#x27;get&#x27;</span> <span class="comment">//默认是get请求</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>请求方式</p><p><img src="/2020/10/22/Vue-js/image-20201105130459781.png" alt="image-20201105130459781"></p><p>发送并发请求:返回结果是一个数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios.all([</span><br><span class="line">   axios(&#123;</span><br><span class="line">    url: <span class="string">&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span></span><br><span class="line">&#125;),axios(&#123;</span><br><span class="line">    url: <span class="string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,</span><br><span class="line">    params: &#123;</span><br><span class="line">        type: <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">        page:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以把返回结果分开处理</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">axios</span><span class="selector-class">.all</span>([</span><br><span class="line">   axios(&#123;</span><br><span class="line">    <span class="attribute">url</span>: <span class="string">&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span></span><br><span class="line">&#125;),axios(&#123;</span><br><span class="line">    <span class="attribute">url</span>: <span class="string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,</span><br><span class="line">    <span class="attribute">params</span>: &#123;</span><br><span class="line">        <span class="attribute">type</span>: <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">        <span class="attribute">page</span>:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)])<span class="selector-class">.then</span>(axios.spread((res1,res2) =&gt; &#123;</span><br><span class="line">    console.log(res1)</span><br><span class="line">    console.log(res2)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p><strong>全局配置</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">axios.defaults.baseURL</span>=<span class="string">&#x27;http://123.207.32.32:8000&#x27;</span></span><br><span class="line"><span class="attr">axios.defaults.timeout</span>= <span class="number">5000</span> //单位是毫秒</span><br></pre></td></tr></table></figure><p><img src="/2020/10/22/Vue-js/image-20201105133058548.png" alt="image-20201105133058548"></p><h2 id="axios实例和模块封装"><a href="#axios实例和模块封装" class="headerlink" title="axios实例和模块封装"></a><strong>axios实例和模块封装</strong></h2><p>如果像访问多个ip 把baseUrl设置为全局的话没有通用性 </p><p>可以创建实例 处理不同ip的请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建实例</span></span><br><span class="line"><span class="keyword">const</span> axiosInstance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout:<span class="number">5000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axiosInstance(&#123;</span><br><span class="line">    url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>模块封装：创建一个文件夹network 在其中创建一个request.js</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios from <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">export function <span class="title">request</span><span class="params">(config)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> axiosInstance = axios.create(&#123;</span><br><span class="line">        baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">        timeout:<span class="number">5000</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> axiosInstance(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main.js中进行使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&quot;@/network/request&quot;</span>;</span><br><span class="line"></span><br><span class="line">createApp(App).use(store).use(router).mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">    url: <span class="string">&#x27;/home/data&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>axios.create会返回一个promise 当需要用其他框架的时候 直接修改request.js文件使其也返回一个promise即可 模块中的代码不用修改</p><h2 id="axios拦截器的使用"><a href="#axios拦截器的使用" class="headerlink" title="axios拦截器的使用"></a>axios拦截器的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export function request(config)&#123;</span><br><span class="line">    const axiosInstance &#x3D; axios.create(&#123;</span><br><span class="line">        baseURL: &#39;http:&#x2F;&#x2F;123.207.32.32:8000&#39;,</span><br><span class="line">        timeout:5000</span><br><span class="line">    &#125;)</span><br><span class="line">    axiosInstance.interceptors.request.use(config &#x3D;&gt;&#123;</span><br><span class="line">        console.log(config)</span><br><span class="line">        return config</span><br><span class="line">    &#125;,error &#x3D;&gt; &#123;</span><br><span class="line">        console.log(error)</span><br><span class="line">    &#125;)</span><br><span class="line">    axiosInstance.interceptors.response.usr(result &#x3D;&gt; &#123;</span><br><span class="line">        console.log(result.data)</span><br><span class="line">        </span><br><span class="line">    &#125;,error &#x3D;&gt; &#123;</span><br><span class="line">        console.log(error)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return axiosInstance(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Vue是一套用于构建用户界面的渐进式框架</summary>
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
