<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>勺子柄の博客</title>
  
  <subtitle>记录生活中的点点滴滴</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-05-16T03:19:48.690Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>鲍炳江</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>grpc</title>
    <link href="http://example.com/2021/05/16/grpc/"/>
    <id>http://example.com/2021/05/16/grpc/</id>
    <published>2021-05-16T02:25:03.000Z</published>
    <updated>2021-05-16T03:19:48.690Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://www.cnblogs.com/oolo/p/11840305.html">https://www.cnblogs.com/oolo/p/11840305.html</a></p><p>代码：grpc</p><p><img src="/2021/05/16/grpc/log\source_posts\grpc\image-20210516104041823.png" alt="image-20210516104041823"></p><p>安装grpc和编译插件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> google.golang.org/grpc</span><br><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span> github.<span class="keyword">com</span>/golang/protobuf/protoc-gen-<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>创建一个protobuf文件</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;./proto&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">StringMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">repeated</span> StringSingle ss = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">StringSingle</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Empty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">MaxSize</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Echo(Empty) <span class="keyword">returns</span> (stream StringMessage) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令进行编译该文件：protoc –go_out=plugins=grpc:. service.proto</p><p>应用：<a href="https://segmentfault.com/a/1190000015135650/">https://segmentfault.com/a/1190000015135650/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/oolo/p/11840305.html&quot;&gt;https://www.cnblogs.com/oolo/p/11840305.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码：grpc&lt;/p&gt;
&lt;p&gt;&lt;img src</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>工作笔记</title>
    <link href="http://example.com/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-10T07:54:42.000Z</published>
    <updated>2021-05-17T06:10:01.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="week1"><a href="#week1" class="headerlink" title="week1"></a>week1</h1><h2 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h2><h3 id="修改代码并上传"><a href="#修改代码并上传" class="headerlink" title="修改代码并上传"></a>修改代码并上传</h3><p>把代码clone到linux /home/bingjiang.bao目录下 进行修改</p><p>修改代码之后 使用git flow 上传</p><p>git flow init</p><p>git flow feature start timeLogFeature</p><p>git flow feature publish timeLogFeature</p><p>提交到远程仓库 提交compare给群里的成员review</p><p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510161845764.png" alt="image-20210510161845764"></p><p>没有问题之后结束feature：git flow feature finish timeLogFeature</p><p>提交到develop：git push origin develop</p><p>在gitlab上提交merge申请</p><p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510162112266.png" alt="image-20210510162112266"></p><h3 id="上传配置"><a href="#上传配置" class="headerlink" title="上传配置"></a>上传配置</h3><p>登录atlantis 进入负责的模块</p><p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510161256085.png" alt="image-20210510161256085"></p><p>在linux上clone配置文件仓库</p><p>在仓库目录下 上传项目中的配置</p><p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510160958148.png" alt="image-20210510160958148"><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510161028144.png" alt="image-20210510161028144"></p><p>并上传到配置仓库</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">git</span> <span class="string">clone http://atlantis.domob-inc.cn/git/module/707.git rta_stats_sync_conf</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">rta_stats_sync_conf</span></span><br><span class="line"><span class="attr">touch</span> <span class="string">README.md</span></span><br><span class="line"><span class="attr">git</span> <span class="string">add README.md</span></span><br><span class="line"><span class="attr">git</span> <span class="string">commit -m &#x27;first commit&#x27;</span></span><br><span class="line"><span class="attr">git</span> <span class="string">push -u origin master</span></span><br></pre></td></tr></table></figure><p>之后在配置管理中打tag并编辑配置</p><p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510161409881.png" alt="image-20210510161409881"></p><p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510161417897.png" alt="image-20210510161417897"></p><h3 id="上线"><a href="#上线" class="headerlink" title="上线"></a>上线</h3><p>merge请求被通过之后 会触发钩子函数 发送请求到jenkins<strong>做一些事情</strong>比如从github上下载文件 执行build.sh等事情</p><p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510172549747.png" alt="image-20210510172549747"></p><p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510172602515.png" alt="image-20210510172602515"></p><p>进行上线</p><p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510172122005.png" alt="image-20210510172122005"></p><p>添加进程：添加一台服务器</p><p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510172148413.png" alt="image-20210510172148413"></p><p>可以对进程进行分组管理</p><p>在上线管理中进行上线</p><p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510172239565.png" alt="image-20210510172239565"></p><p>准备上线 -&gt; 选择要上线的服务</p><p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510172310334.png" alt="image-20210510172310334"></p><p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510172329595.png" alt="image-20210510172329595"></p><p>添加配置标签和版本号 上线前动作没意义 上线重启</p><h2 id="day02"><a href="#day02" class="headerlink" title="day02"></a>day02</h2><p>熟悉rta_stats_sync模块</p><p>在linux搭建运行环境</p><p>编辑.bash_profile 配置运行环境</p><p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210511150758962.png" alt="image-20210511150758962"></p><p>执行source .bash_profile 刷新配置</p><p>拷贝.m2文件 用于maven</p><p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210511150905097.png" alt="image-20210511150905097"></p><p>创建target目录</p><p>执行build.sh skip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PNAME=RTBAdInfo</span><br><span class="line"></span><br><span class="line">VERSION=1.73.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SKIP=$@</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">maven编译生成target及lib目录</span></span><br><span class="line">if [ &quot;$SKIP&quot; = &quot;skip&quot; ]; then</span><br><span class="line">    mvn clean package -Dmaven.test.skip=true</span><br><span class="line">else</span><br><span class="line">    mvn clean package</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cd target</span><br><span class="line">VERSION=1.73.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SKIP=$@</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">maven编译生成target及lib目录</span></span><br><span class="line">if [ &quot;$SKIP&quot; = &quot;skip&quot; ]; then</span><br><span class="line">    mvn clean package -Dmaven.test.skip=true</span><br><span class="line">else</span><br><span class="line">    mvn clean package</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cd target</span><br><span class="line">SCRATCH_DIR=$PNAME-$VERSION</span><br><span class="line"></span><br><span class="line">if [ ! -f &quot;$SCRATCH_DIR&quot;.tar.gz ]; then</span><br><span class="line">   echo &quot;$SCRATCH_DIR&quot;.tar.gz does not exist!</span><br><span class="line">   exit -1</span><br><span class="line">tar -xvf &quot;$SCRATCH_DIR&quot;.tar.gz</span><br><span class="line">rm -rf &quot;$SCRATCH_DIR&quot;/config</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">对发布的文件做一些处理，版本号替换，修改权限等</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PNAME=RTBAdInfo</span><br><span class="line"></span><br><span class="line">VERSION=1.73.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SKIP=$@</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">maven编译生成target及lib目录</span></span><br><span class="line">if [ &quot;$SKIP&quot; = &quot;skip&quot; ]; then</span><br><span class="line">    mvn clean package -Dmaven.test.skip=true</span><br><span class="line">else</span><br><span class="line">    mvn clean package</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cd target</span><br><span class="line">SCRATCH_DIR=$PNAME-$VERSION</span><br><span class="line"></span><br><span class="line">if [ ! -f &quot;$SCRATCH_DIR&quot;.tar.gz ]; then</span><br><span class="line">   echo &quot;$SCRATCH_DIR&quot;.tar.gz does not exist!</span><br><span class="line">   exit -1</span><br><span class="line">tar -xvf &quot;$SCRATCH_DIR&quot;.tar.gz</span><br><span class="line">rm -rf &quot;$SCRATCH_DIR&quot;/config</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">对发布的文件做一些处理，版本号替换，修改权限等</span></span><br><span class="line">sed -i -e &quot;s/__BUILD_VERSION__/$VERSION/&quot; $SCRATCH_DIR/bin/RTBAdInfo</span><br><span class="line">find $SCRATCH_DIR/&#123;bin,lib&#125; -name &#x27;*.sh&#x27; -exec chmod +x &#123;&#125; \;</span><br><span class="line">find $SCRATCH_DIR/&#123;bin,lib&#125; -name &#x27;*.py&#x27; -exec chmod +x &#123;&#125; \;</span><br><span class="line">chmod +x $SCRATCH_DIR/bin/*</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">fpm --epoch `date +%s` -s dir -t rpm -n <span class="variable">$PNAME</span> -v <span class="variable">$VERSION</span> --rpm-defattrfile=0775 --prefix=/usr/<span class="built_in">local</span>/domob/prog.d <span class="variable">$SCRATCH_DIR</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">rm -rf <span class="variable">$SCRATCH_DIR</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成一条软链 ln -s target/RTBAdinfo-1.73.2 current</p><p>从shell可以看到删除了当前文件夹下的配置文件 所以要拷贝linux中tmp下的配置文件到当前目录</p><p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210511153436476.png" alt="image-20210511153436476"></p><p>再拷贝tmp下的RTBAdinfo.sh到当前目录</p><p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210511153521966.png" alt="image-20210511153521966"></p><p>这个shell中通过软链启动项目 执行命令./RTBAdInfo.sh start 真正执行的是RTBAdinfo-1.73.2/bin/RTBAdinfo</p><p><strong>学习rta_Adinfo代码</strong></p><h2 id="day03"><a href="#day03" class="headerlink" title="day03"></a>day03</h2><p>学习rta_collect模块 改成mod模式 并提交</p><p>rta_collect模块上线</p><p>go项目在linux环境下  执行build.sh文件 生成可执行文件 然后执行即可</p><p>上线的时候 不要提交.idea vendors(依赖包目录) target bin 目录</p><h2 id="day04"><a href="#day04" class="headerlink" title="day04"></a>day04</h2><p>可以基于媒体x客户来，自定义的配置出价阈值。如果低于阈值，就触发报警。</p><p>报警的方式：通过飞书的Webhook</p><p>创建Webhook报警<a href="https://help.aliyun.com/document_detail/173081.html">https://help.aliyun.com/document_detail/173081.html</a></p><h1 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h1><h2 id="day01-1"><a href="#day01-1" class="headerlink" title="day01"></a>day01</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;week1&quot;&gt;&lt;a href=&quot;#week1&quot; class=&quot;headerlink&quot; title=&quot;week1&quot;&gt;&lt;/a&gt;week1&lt;/h1&gt;&lt;h2 id=&quot;day01&quot;&gt;&lt;a href=&quot;#day01&quot; class=&quot;headerlink&quot; title=&quot;day</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>golang</title>
    <link href="http://example.com/2021/05/09/golang/"/>
    <id>http://example.com/2021/05/09/golang/</id>
    <published>2021-05-09T01:35:31.000Z</published>
    <updated>2021-05-15T05:07:37.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h2><p>Go语言保证了既能到达静态编译语言的安全和性能，又达到了动态语言开发维护的高效率，使用一个表达式来形容Go语言:Go = C+ Python,说明Go语言既有c静态语言程序的运行速度，又能达到Python动态语言的快速开发。</p><ul><li>从c语言中继承了很多理念，包括表达式语法，控制结构，基础数据类型，调用参数传值，指针等等，也保留了和c语言一样的编译执行方式及弱化的指针。<br>引</li><li>入包的概念，用于组织程序结构，Go语言的一个文件都要归属于一个包，而不能单独存在。</li><li>垃圾回收机制，内存自动回收，不需开发人员管理</li><li>天然并发(重要特点)<ul><li>从语言层面支持并发，实现简单</li><li>goroutine轻量级线程，可实现大并发处理，高效利用多核</li><li>基于CPS并发模型实现</li></ul></li><li>吸收了管道通信机制，形成go语言特有的通道channel。通过管道channel，可以实现不同的goroute之间的相互通信</li><li>函数可以返回多个值</li><li>新的创新：切片 延时执行defer</li></ul><h2 id="编译和执行"><a href="#编译和执行" class="headerlink" title="编译和执行"></a>编译和执行</h2><ul><li>有了go源文件，通过编译器将其编译成机器可以识别的二进制码文件</li><li>在该源文件目录下，通过go build对 hello.go文件进行编译。可以指定生成的可执行文件名，在windows下必须是.exe后缀。<ul><li>go build -o myhello.exe hello.go</li></ul></li><li>如果程序没有任何错误就没有任何提示，会在当前目录下出现一个可执行文件，该文件是二进制文件。如果程序有错误 编译时，会在错误的那行报错</li><li>也可以使用go run指令 直接执行源码。这种方式需要在go环境下执行，可执行文件的执行不需要go环境但是编译器会将程序运行的依赖的库文件包含在可执行文件中，所以，可执行文件变大了很多</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>go编译器是对文件一行一行进行编译的 所以不要把多条语句写在同一行</p><p>go语言定义的变量或者import的包如果没有使用到 不能通过编译</p><p>注释与java一样</p><p>转义符：\t：制表符，\n：换行符，\r：回车</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">   <span class="comment">//如果不赋值 则使用默认值 </span></span><br><span class="line">   i = <span class="number">10</span></span><br><span class="line">   fmt.Println(i)</span><br><span class="line">   <span class="comment">//如果不声明数据类型 则根据值自动判定类型</span></span><br><span class="line">   <span class="keyword">var</span> x = <span class="number">11</span></span><br><span class="line">   fmt.Println(x)</span><br><span class="line">   <span class="comment">//这种方式等同于 var y int = 11</span></span><br><span class="line">   y := <span class="number">11</span></span><br><span class="line">   fmt.Println(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时声明多个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次性声明全局变量</span></span><br><span class="line"><span class="comment">//全局变量作用据在整个包都有效，如果首字母大写 则在整个程序有效</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> Sex = <span class="string">&quot;male&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   y    = <span class="number">100</span></span><br><span class="line">   sex2 = <span class="string">&quot;female&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//一次性声明局部变量</span></span><br><span class="line">   <span class="keyword">var</span> n1, n2, n3 <span class="keyword">int</span></span><br><span class="line">   fmt.Println(n1, n2, n3)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> m1, name, m3 = <span class="number">100</span>, <span class="string">&quot;bob&quot;</span>, <span class="number">23</span></span><br><span class="line">   fmt.Println(m1, name, m3)</span><br><span class="line"></span><br><span class="line">   b1, name, b3 := <span class="number">22</span>, <span class="string">&quot;tom&quot;</span>, <span class="number">23</span></span><br><span class="line">   fmt.Println(b1, name, b3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量在同一作用域数据类型不能变化，值可以变化</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="/2021/05/09/golang/log\source_posts\golang\image-20210512131113419.png" alt="image-20210512131113419"></p><p>int默认是int32</p><p>其他数值型</p><p><img src="/2021/05/09/golang/log\source_posts\golang\image-20210509122839263.png" alt="image-20210509122839263"></p><p>float64比float32精准 默认也是float64</p><p>浮点数常量有两种表示形式</p><ul><li>十进制数形式：5.12    .512</li><li>科学计数法形式：5.1234e2    5.12E-2</li></ul><p><strong>字符</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> c <span class="keyword">byte</span> = <span class="string">&#x27;s&#x27;</span></span><br><span class="line">   <span class="comment">//如果保存的字符对应值大于255 可以考虑使用int 一个汉字3字节</span></span><br><span class="line">   <span class="comment">//在go中 字符的本质是一个整数 输出的是该字符对应的utf8编码的码值</span></span><br><span class="line">   <span class="keyword">var</span> x <span class="keyword">int</span> = <span class="string">&#x27;你&#x27;</span></span><br><span class="line">   <span class="comment">//可以对整数进行格式化输出 输出的是该数字对应的unicode字符</span></span><br><span class="line">   <span class="keyword">var</span> y <span class="keyword">int</span> = <span class="number">20320</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//字符类型可以进行运算</span></span><br><span class="line">   <span class="keyword">var</span> n = c + <span class="number">10</span></span><br><span class="line">   fmt.Println(c, x) <span class="comment">//115 20320</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;y = %c\n&quot;</span>, y) <span class="comment">//y = 你</span></span><br><span class="line">   fmt.Println(n)  <span class="comment">//123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串</strong>:go语言的编码都统一成了utf-8 没有乱码问题</p><p>字符串类型是不可变的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> address = <span class="string">&quot;hello&quot;</span></span><br><span class="line">   address[<span class="number">0</span>] = <span class="string">&#x27;q&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果x想修改字符串可以转换成byte 和rune</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> str = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">   arr := []<span class="keyword">byte</span>(str)</span><br><span class="line">   arr[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span></span><br><span class="line">   str = <span class="keyword">string</span>(arr)</span><br><span class="line">   <span class="comment">//这种方式不能处理中文 会出现乱码 使用rune可以解决 rune按字符处理</span></span><br><span class="line">   arr2 := []<span class="keyword">rune</span>(str)</span><br><span class="line">   arr2[<span class="number">0</span>] = <span class="string">&#x27;就&#x27;</span></span><br><span class="line">   str = <span class="keyword">string</span>(arr2)</span><br><span class="line">   fmt.Println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bool类型占一个字节 只允许取值false和true</p><p>字符串的两种表现形式</p><ul><li>双引号 会识别转义字符 </li><li>反引号：以字符串的原生形式输出 包括换行和特殊字符 可以实现防止攻击 输出源代码等效果</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   str2 := <span class="string">&quot;abc\nabc&quot;</span></span><br><span class="line">   fmt.Println(str2)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//使用的反引号 ``</span></span><br><span class="line">   str3 := <span class="string">` </span></span><br><span class="line"><span class="string">   package main</span></span><br><span class="line"><span class="string">   import (</span></span><br><span class="line"><span class="string">      &quot;fmt&quot;</span></span><br><span class="line"><span class="string">      &quot;unsafe&quot;</span></span><br><span class="line"><span class="string">   )</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">   //演示golang中bool类型使用</span></span><br><span class="line"><span class="string">   func main() &#123;</span></span><br><span class="line"><span class="string">      var b = false</span></span><br><span class="line"><span class="string">      fmt.Println(&quot;b=&quot;, b)</span></span><br><span class="line"><span class="string">      //注意事项</span></span><br><span class="line"><span class="string">      //1. bool类型占用存储空间是1个字节</span></span><br><span class="line"><span class="string">      fmt.Println(&quot;b 的占用空间 =&quot;, unsafe.Sizeof(b) )</span></span><br><span class="line"><span class="string">      //2. bool类型只能取true或者false</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">   &#125;`</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(str3)</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>当一个字符串太长 可以分行写 但是注意 +号要留在上一行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//当一个拼接的操作很长时，怎么办，可以分行写,但是注意，需要将+保留在上一行.</span></span><br><span class="line">str4 := <span class="string">&quot;hello &quot;</span> + <span class="string">&quot;world&quot;</span> + <span class="string">&quot;hello &quot;</span> + <span class="string">&quot;world&quot;</span> + <span class="string">&quot;hello &quot;</span> + </span><br><span class="line"><span class="string">&quot;world&quot;</span> + <span class="string">&quot;hello &quot;</span> + <span class="string">&quot;world&quot;</span> + <span class="string">&quot;hello &quot;</span> + <span class="string">&quot;world&quot;</span> + </span><br><span class="line"><span class="string">&quot;hello &quot;</span> + <span class="string">&quot;world&quot;</span></span><br><span class="line">fmt.Println(str4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基本数据类型的默认值</strong>:整形和浮点型为0 字符串为”” 布尔类型为false</p><p><strong>基本数据类型的相互转换</strong></p><p>go在不同类型的变量之间赋值时需要显示转换 不能自动转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">23</span></span><br><span class="line">   <span class="keyword">var</span> j <span class="keyword">float64</span> = <span class="keyword">float64</span>(i)</span><br><span class="line">   fmt.Println(j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据类型转换可以从大到小 也可以从小到大 但是从大到小转换的时候会做溢出处理 </p><p>被转换的是变量存储的数据 变量本身的数据类型没有变化</p><p>基本类型转string类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">23</span></span><br><span class="line">    <span class="keyword">var</span> num2 <span class="keyword">float64</span> = <span class="number">32.3</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> myChar <span class="keyword">byte</span> = <span class="string">&#x27;s&#x27;</span></span><br><span class="line">    <span class="comment">//方法一：使用fmt.Sprintf函数</span></span><br><span class="line">    str = fmt.Sprintf(<span class="string">&quot;%d&quot;</span>,num)</span><br><span class="line">    str = fmt.Sprintf(<span class="string">&quot;%f&quot;</span>,num2)</span><br><span class="line">    str = fmt.Sprintf(<span class="string">&quot;%t&quot;</span>,b)</span><br><span class="line">    str = fmt.Sprintf(<span class="string">&quot;%c&quot;</span>,myChar)</span><br><span class="line">    <span class="comment">//方法二：使用strconv中的函数</span></span><br><span class="line">    str = strconv.FormatInt(<span class="keyword">int64</span>(num),<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    str = strconv.FormatFloat(num2,<span class="string">&#x27;f&#x27;</span>,<span class="number">10</span>,<span class="number">64</span>) <span class="comment">//10表示保留小数点10为 64表示float64</span></span><br><span class="line">    </span><br><span class="line">    str = strconv.FormatBool(b)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//int64转换为int</span></span><br><span class="line">    <span class="keyword">var</span> num5 <span class="keyword">int64</span> = <span class="number">4567</span></span><br><span class="line">str = strconv.Itoa(<span class="keyword">int</span>(num5))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>string转基本类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">&quot;101&quot;</span></span><br><span class="line">   <span class="keyword">var</span> x <span class="keyword">int64</span></span><br><span class="line">   <span class="comment">//第二个参数是机制 第三个参数是默认值 如果转换不成数字返回结果为默认值</span></span><br><span class="line">   x,_ = strconv.ParseInt(str,<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line">   fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&amp;：获取变量的地址</span></span><br><span class="line"><span class="comment">//*int表示指针类型</span></span><br><span class="line"><span class="keyword">var</span> ptr *<span class="keyword">int</span> = &amp;i</span><br><span class="line"></span><br><span class="line">fmt.Println(&amp;i) <span class="comment">//0xc0000ac058</span></span><br><span class="line"><span class="comment">//ptr指向的地址</span></span><br><span class="line">fmt.Println(ptr) <span class="comment">//0xc0000ac058</span></span><br><span class="line"><span class="comment">//ptr的地址</span></span><br><span class="line">fmt.Println(&amp;ptr) <span class="comment">//0xc0000d8018</span></span><br><span class="line"><span class="comment">//ptr指向的地址上面值 使用*获取指针类型所指向的值</span></span><br><span class="line">fmt.Println(*ptr) <span class="comment">//23</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改之后i的值会变化</span></span><br><span class="line">*ptr = <span class="number">10</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值类型和引用类型</p><p><img src="/2021/05/09/golang/log\source_posts\golang\image-20210509132923543.png" alt="image-20210509132923543"></p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>运算符与java差不多但是不支持三元运算符</p><p>golang的自增和自减只能当作一个独立语言使用 并且只能写在变量后面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//在golang中，++ 和 -- 只能独立使用.</span></span><br><span class="line">   <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">8</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line">   a = i++ <span class="comment">//错误，i++只能独立使用</span></span><br><span class="line">   a = i-- <span class="comment">//错误, i--只能独立使用</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> i++ &gt; <span class="number">0</span> &#123; <span class="comment">//错误</span></span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">   i++</span><br><span class="line">   ++i <span class="comment">// 错误，在golang没有 前++</span></span><br><span class="line">   i--</span><br><span class="line">   --i <span class="comment">// 错误，在golang没有 前--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h2><p>fmt.scanln和fmt.scanf</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;请输入姓名：&quot;</span>)</span><br><span class="line">   fmt.Scanln(&amp;name)</span><br><span class="line">    </span><br><span class="line">   fmt.Println(<span class="string">&quot;请输入姓名：&quot;</span>)</span><br><span class="line">   fmt.Scnaf(<span class="string">&quot;%s&quot;</span>,&amp;name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//二进制</span></span><br><span class="line">   <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;%b\n&quot;</span>,i)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//八进制</span></span><br><span class="line">   <span class="keyword">var</span> j <span class="keyword">int</span> = <span class="number">011</span></span><br><span class="line">   fmt.Println(j)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//十六进制</span></span><br><span class="line">   <span class="keyword">var</span> k <span class="keyword">int</span> = <span class="number">0x11</span></span><br><span class="line">   fmt.Println(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="程序流程控制"><a href="#程序流程控制" class="headerlink" title="程序流程控制"></a>程序流程控制</h1><p><strong>if</strong>：if中可以定义变量 但是作用域只在if块内有效</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> age := <span class="number">20</span>; age &gt; <span class="number">18</span> &#123;</span><br><span class="line">      fmt.Print(<span class="string">&quot;已成年&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>switch</strong></p><ul><li>case后的表达式可以有多个，使用逗号间隔</li><li>case语句不需要写break 默认会有</li><li>case后面表达式的类型必须与switch后表达式的类型相同</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> n1 <span class="keyword">int</span> = <span class="number">23</span></span><br><span class="line">   <span class="keyword">var</span> n2 <span class="keyword">int</span> = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> n1 &#123;</span><br><span class="line">      <span class="keyword">case</span> n2, <span class="number">5</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;没有匹配到&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch后面也可以不带表达式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">23</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> age &gt; <span class="number">18</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;已成年&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> age &lt; <span class="number">3</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;小孩&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;未成年&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch穿透：如果在case语句块后增加fallthrough 则会继续执行下一个case</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">23</span></span><br><span class="line"><span class="comment">//会打印出已成年和小孩</span></span><br><span class="line">   <span class="keyword">switch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> age &gt; <span class="number">18</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;已成年&quot;</span>)</span><br><span class="line">         <span class="keyword">fallthrough</span></span><br><span class="line">      <span class="keyword">case</span> age &lt; <span class="number">3</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;小孩&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;未成年&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>for</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//第一种写法</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>;i &lt;= <span class="number">10</span>;i++ &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//第二种写法</span></span><br><span class="line">   j := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> j &lt;= <span class="number">10</span> &#123;</span><br><span class="line"></span><br><span class="line">      j++</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//第三种写法</span></span><br><span class="line">   k := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> k &lt; <span class="number">10</span> &#123;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      k++</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   str := <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(str);i++ &#123;</span><br><span class="line">      fmt.Println(str[i])</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用上面这种方式遍历字符串时 如果字符串中有中文会出现乱码 因为是按字节遍历</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//按字符遍历</span></span><br><span class="line">   str2 := <span class="string">&quot;您好&quot;</span></span><br><span class="line">   <span class="keyword">for</span> index,value := <span class="keyword">range</span> str2 &#123;</span><br><span class="line">      fmt.Println(index,value)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go中没有while 和 do while</p><p>break跳出循环 continue结束本轮循环</p><p>goto：可以跳转到任意一行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="number">30</span></span><br><span class="line">   <span class="keyword">if</span> n &gt; <span class="number">20</span> &#123;</span><br><span class="line">      <span class="keyword">goto</span> label</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="number">2</span>)</span><br><span class="line">   label:</span><br><span class="line">      fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return：用在main中表示中止程序</p><h1 id="函数，包和错误处理"><a href="#函数，包和错误处理" class="headerlink" title="函数，包和错误处理"></a>函数，包和错误处理</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>如果函数返回多个值，在接收时希望忽略某个返回值使用_符号</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndSub</span><span class="params">(a <span class="keyword">int</span>,b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + b,a -b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line">   _,a = SumAndSub(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">   fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的基本类型和数组都是值传递:如果希望传入函数内的变量能修改函数外的变量可以传入变量的地址&amp;,函数内以指针的方式操作变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   *a = *a + <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">12</span></span><br><span class="line">   test(&amp;a)</span><br><span class="line">   fmt.Println(a) <span class="comment">//22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go函数不支持重载</p><p>函数也是一种数据类型 可以作为赋值给其他变量也可以作为参数传入其他函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   z := test.Cal</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%T&quot;</span>, z) <span class="comment">//func(int, int) int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>type自定义类型:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//go认为myint和int是两个类型</span></span><br><span class="line">   <span class="keyword">type</span> myint <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">var</span> num1 <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">   <span class="keyword">var</span> num2 myint = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">   num2 = myint(num1)</span><br><span class="line">   fmt.Println(num2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持对返回值命名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a <span class="keyword">int</span> ,b <span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>,sub <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   sum = a + b</span><br><span class="line">   sub = a - b</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持可变参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//args是slice切片 如果一个函数有多个参数 可变参数要放在最后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(args... <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(args);i++ &#123;</span><br><span class="line">      sum += i</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>init函数</strong></p><p>每一个源文件都可以包含一个init函数，该函数会在main函数执行前，被Go运行框架调用，也就是说init会在main函数前被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个文件同时包含全局变量定义，init函数和main函数 则执行流程是全局变量定义-&gt; init -&gt; main</p><p>面试题：如果main目录下的main.go和utils目录下的utils.go都含有变量定义 init函数 那么执行流程是？</p><p><img src="/2021/05/09/golang/log\source_posts\golang\image-20210512145932411.png" alt="image-20210512145932411"></p><p><strong>匿名函数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> x = <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span> ,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b</span><br><span class="line">   &#125;(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将匿名函数赋给一个变量然后通过这个变量调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   x := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span> ,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b</span><br><span class="line">   &#125;</span><br><span class="line">   z := x(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局匿名函数：将匿名函数赋值给一个全局变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun1 = <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="keyword">int</span> ,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> n1 * n2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   x := fun1(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">   fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>闭包</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUpper</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="comment">//这个匿名函数引用到函数外的n 因此这个匿名函数就和n形成一个整体，构成闭包</span></span><br><span class="line">   <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      n += x</span><br><span class="line">      <span class="keyword">return</span> n</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   f := AddUpper()</span><br><span class="line">   fmt.Println(f(<span class="number">1</span>))</span><br><span class="line">   fmt.Println(f(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以理解为 闭包是类 函数时操作 变量是字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果名字没有指定的后缀就加上 然后返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSuffix</span><span class="params">(suffix <span class="keyword">string</span>)</span> <span class="title">func</span> <span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="comment">//参数suffix和返回的匿名函数构成闭包</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> !strings.HasSuffix(name,suffix)&#123;</span><br><span class="line">         <span class="keyword">return</span> name + suffix</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> name</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   f := makeSuffix(<span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">   fmt.Println(f(<span class="string">&quot;picture1&quot;</span>))</span><br><span class="line">   fmt.Println(f(<span class="string">&quot;picture1.jpg&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的defer:一种延时机制 为了在函数执行完毕后 及时的释放资源</p><p><img src="/2021/05/09/golang/log\source_posts\golang\image-20210509154701654.png" alt="image-20210509154701654"></p><p>defer语句放入栈时 相关的值拷贝也同时入栈</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="keyword">int</span> ,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="comment">//将defer后面的语句压入到独立的栈 当函数执行完毕后 再从defer栈按照先入后出的方式出栈，执行</span></span><br><span class="line">   <span class="comment">//相关的值拷贝也入栈</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(n1)</span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(n2)</span><br><span class="line">   n1++</span><br><span class="line">   <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   sum(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串常用系统函数"><a href="#字符串常用系统函数" class="headerlink" title="字符串常用系统函数"></a><strong>字符串常用系统函数</strong></h3><p>具体参考stirngs包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//查找子串是否在指定的字符串中: strings.Contains(&quot;seafood&quot;, &quot;foo&quot;) //true</span></span><br><span class="line">   b := strings.Contains(<span class="string">&quot;seafood&quot;</span>, <span class="string">&quot;mary&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//统计一个字符串有几个指定的子串 ： strings.Count(&quot;ceheese&quot;, &quot;e&quot;) //4</span></span><br><span class="line">   num := strings.Count(<span class="string">&quot;ceheese&quot;</span>, <span class="string">&quot;e&quot;</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;num=%v\n&quot;</span>, num)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//10)不区分大小写的字符串比较(==是区分字母大小写的): fmt.Println(strings.EqualFold(&quot;abc&quot;, &quot;Abc&quot;)) // true</span></span><br><span class="line">   b = strings.EqualFold(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;Abc&quot;</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;b=%v\n&quot;</span>, b) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//11)返回子串在字符串第一次出现的index值，如果没有返回-1 : </span></span><br><span class="line">   <span class="comment">//strings.Index(&quot;NLT_abc&quot;, &quot;abc&quot;) // 4</span></span><br><span class="line">   index := strings.Index(<span class="string">&quot;NLT_abcabcabc&quot;</span>, <span class="string">&quot;abc&quot;</span>) <span class="comment">// 4</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;index=%v\n&quot;</span>,index)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//12)返回子串在字符串最后一次出现的index，</span></span><br><span class="line">   <span class="comment">//如没有返回-1 : strings.LastIndex(&quot;go golang&quot;, &quot;go&quot;)</span></span><br><span class="line">   index = strings.LastIndex(<span class="string">&quot;go golang&quot;</span>, <span class="string">&quot;go&quot;</span>) <span class="comment">//3</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;index=%v\n&quot;</span>,index)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将指定的子串替换成 另外一个子串: strings.Replace(&quot;go go hello&quot;, &quot;go&quot;, &quot;go语言&quot;, n) </span></span><br><span class="line">   <span class="comment">//n可以指定你希望替换几个，如果n=-1表示全部替换</span></span><br><span class="line"></span><br><span class="line">   str2 := <span class="string">&quot;go go hello&quot;</span></span><br><span class="line">   str := strings.Replace(str2, <span class="string">&quot;go&quot;</span>, <span class="string">&quot;北京&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str=%v str2=%v\n&quot;</span>, str, str2)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//按照指定的某个字符，为分割标识，将一个字符串拆分成字符串数组： </span></span><br><span class="line">   <span class="comment">//strings.Split(&quot;hello,wrold,ok&quot;, &quot;,&quot;)</span></span><br><span class="line">   strArr := strings.Split(<span class="string">&quot;hello,wrold,ok&quot;</span>, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(strArr); i++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;str[%v]=%v\n&quot;</span>, i, strArr[i])</span><br><span class="line">   &#125; </span><br><span class="line">   fmt.Printf(<span class="string">&quot;strArr=%v\n&quot;</span>, strArr)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//15)将字符串的字母进行大小写的转换: </span></span><br><span class="line">   <span class="comment">//strings.ToLower(&quot;Go&quot;) // go strings.ToUpper(&quot;Go&quot;) // GO</span></span><br><span class="line"></span><br><span class="line">   str = <span class="string">&quot;goLang Hello&quot;</span></span><br><span class="line">   str = strings.ToLower(str) </span><br><span class="line">   str = strings.ToUpper(str) </span><br><span class="line">   fmt.Printf(<span class="string">&quot;str=%v\n&quot;</span>, str) <span class="comment">//golang hello</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//将字符串左右两边的空格去掉： strings.TrimSpace(&quot; tn a lone gopher ntrn   &quot;)</span></span><br><span class="line">   str = strings.TrimSpace(<span class="string">&quot; tn a lone gopher ntrn   &quot;</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str=%q\n&quot;</span>, str)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//17)将字符串左右两边指定的字符去掉 ： </span></span><br><span class="line">   <span class="comment">//strings.Trim(&quot;! hello! &quot;, &quot; !&quot;)  // [&quot;hello&quot;] //将左右两边 ! 和 &quot; &quot;去掉</span></span><br><span class="line">   str = strings.Trim(<span class="string">&quot;! he!llo! &quot;</span>, <span class="string">&quot; !&quot;</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str=%q\n&quot;</span>, str)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//20)判断字符串是否以指定的字符串开头: </span></span><br><span class="line">   <span class="comment">//strings.HasPrefix(&quot;ftp://192.168.10.1&quot;, &quot;ftp&quot;) // true</span></span><br><span class="line"></span><br><span class="line">   b = strings.HasPrefix(<span class="string">&quot;ftp://192.168.10.1&quot;</span>, <span class="string">&quot;hsp&quot;</span>) <span class="comment">//true</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;b=%v\n&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间日期常用函数"><a href="#时间日期常用函数" class="headerlink" title="时间日期常用函数"></a>时间日期常用函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//看看日期和时间相关函数和方法使用</span></span><br><span class="line">   <span class="comment">//1. 获取当前时间</span></span><br><span class="line">   now := time.Now()</span><br><span class="line">   fmt.Printf(<span class="string">&quot;now=%v now type=%T\n&quot;</span>, now, now)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.通过now可以获取到年月日，时分秒</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;年=%v\n&quot;</span>, now.Year())</span><br><span class="line">   fmt.Printf(<span class="string">&quot;月=%v\n&quot;</span>, now.Month())</span><br><span class="line">   fmt.Printf(<span class="string">&quot;月=%v\n&quot;</span>, <span class="keyword">int</span>(now.Month()))</span><br><span class="line">   fmt.Printf(<span class="string">&quot;日=%v\n&quot;</span>, now.Day())</span><br><span class="line">   fmt.Printf(<span class="string">&quot;时=%v\n&quot;</span>, now.Hour())</span><br><span class="line">   fmt.Printf(<span class="string">&quot;分=%v\n&quot;</span>, now.Minute())</span><br><span class="line">   fmt.Printf(<span class="string">&quot;秒=%v\n&quot;</span>, now.Second())</span><br><span class="line"></span><br><span class="line">   <span class="comment">//格式化日期时间</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;当前年月日 %d-%d-%d %d:%d:%d \n&quot;</span>, now.Year(), </span><br><span class="line">   now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second())</span><br><span class="line"></span><br><span class="line">   dateStr := fmt.Sprintf(<span class="string">&quot;当前年月日 %d-%d-%d %d:%d:%d \n&quot;</span>, now.Year(), </span><br><span class="line">   now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second())</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;dateStr=%v\n&quot;</span>, dateStr)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//格式化日期时间的第二种方式</span></span><br><span class="line">   fmt.Printf(now.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">   fmt.Println()</span><br><span class="line">   fmt.Printf(now.Format(<span class="string">&quot;2006-01-02&quot;</span>))</span><br><span class="line">   fmt.Println()</span><br><span class="line">   fmt.Printf(now.Format(<span class="string">&quot;15:04:05&quot;</span>))</span><br><span class="line">   fmt.Println()</span><br><span class="line"></span><br><span class="line">   fmt.Printf(now.Format(<span class="string">&quot;2006&quot;</span>))</span><br><span class="line">   fmt.Println()</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//Unix和UnixNano的使用</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;unix时间戳=%v unixnano时间戳=%v\n&quot;</span>, now.Unix(), now.UnixNano())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间的常量</p><p><img src="/2021/05/09/golang/log\source_posts\golang\image-20210509161046950.png" alt="image-20210509161046950"></p><p>常量的作用：在程序中可用于获取指定时间单位的时间，比如想获得100毫秒 100 * time.Millisecond</p><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a><strong>内置函数</strong></h3><p>这些函数不用导包可以直接使用</p><ul><li>len：用来求长度</li><li>new：用来分配内存，返回的是指针</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   num1 := <span class="number">100</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;num1的类型%T , num1的值=%v , num1的地址%v\n&quot;</span>, num1, num1, &amp;num1)</span><br><span class="line"></span><br><span class="line">   num2 := <span class="built_in">new</span>(<span class="keyword">int</span>) <span class="comment">// *int</span></span><br><span class="line">   <span class="comment">//num2的类型%T =&gt; *int</span></span><br><span class="line">   <span class="comment">//num2的值 = 地址 0xc04204c098 （这个地址是系统分配）</span></span><br><span class="line">   <span class="comment">//num2的地址%v = 地址 0xc04206a020  (这个地址是系统分配)</span></span><br><span class="line">   <span class="comment">//num2指向的值 = 100</span></span><br><span class="line">   *num2  = <span class="number">100</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;num2的类型%T , num2的值=%v , num2的地址%v\n num2这个指针，指向的值=%v&quot;</span>, </span><br><span class="line">      num2, num2, &amp;num2, *num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h2><p>GO中处理异常的方式：defer，panic，recover</p><p>go中可以抛出一个panic的异常 然后在defer中通过recover不会这个异常 然后正常处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      err := <span class="built_in">recover</span>() <span class="comment">//捕获异常</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;err&quot;</span>,err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   num1 := <span class="number">10</span></span><br><span class="line">   num2 := <span class="number">0</span></span><br><span class="line">   res := num1 / num2</span><br><span class="line">   fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go中也支持自定义错误 ，使用errors.New(返回一个error类型的值，表示一个错误)和panic内置函数(接受一个interface{}类型的值作为参数，可以接收error类型的变量，输出错误信息，并退出程序)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数去读取以配置文件init.conf的信息</span></span><br><span class="line"><span class="comment">//如果文件名传入不正确，我们就返回一个自定义的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readConf</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> name == <span class="string">&quot;config.ini&quot;</span> &#123;</span><br><span class="line">      <span class="comment">//读取...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//返回一个自定义错误</span></span><br><span class="line">      <span class="keyword">return</span> errors.New(<span class="string">&quot;读取文件错误..&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   err := readConf(<span class="string">&quot;config2.ini&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">//如果读取文件发送错误，就输出这个错误，并终止程序</span></span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;test02()继续执行....&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>在import时，路径从$GOPATH的src下开始 不用带src</p><p>如果报名较长，可以取别名，取别名后原来的包名就不能用了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">    util <span class="string">&quot;go_code/utils&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>同一个包下不能有相同的函数名</p><p>为了让其他包的文件 可以访问到本包下的函数 该函数的首字母要大写</p><p>如果要编译一个可执行程序文件，就需要将包声明为 main</p><h1 id="数组与切片"><a href="#数组与切片" class="headerlink" title="数组与切片"></a>数组与切片</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>go中 数组是值类型</p><p>如果想在其他函数中修改原阿里的数组可以使用引用传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(arr *[3]<span class="keyword">int</span>)</span></span> &#123; <span class="comment">//3可以省略</span></span><br><span class="line">   (*arr)[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">   test(&amp;arr)</span><br><span class="line">   fmt.Println(arr[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组的定义：var 数组名 [数组大小]数据类型</p><p>数组创建后如果没赋值 有默认值</p><p>数组的第一个元素的地址就是数组的地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">      arr[i] = i</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println</span>(&amp;arr)</span><br><span class="line">   <span class="built_in">println</span>(&amp;arr[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组初始化的四种方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> arr1 [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">   <span class="keyword">var</span> arr2 = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">   <span class="keyword">var</span> arr3 = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">   <span class="keyword">var</span> arr4 = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">200</span>,<span class="number">0</span>:<span class="number">100</span>,<span class="number">3</span>:<span class="number">300</span>&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for-range循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> arr2 = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> index,val := <span class="keyword">range</span> arr2 &#123;</span><br><span class="line">      fmt.Println(index,val)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>长度是数组类型的一部分 传参的时候如果长度不一致会编译错误</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片是数组的一个引用，因此切片是引用类型，在进行传递时，遵守引用传递的机制。切片的使用和数组类似，遍历切片、访问切片的元素和求切片长度len(slice)都一样。切片的长度是可以变化的，因此切片是一个可以动态变化数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">//定义一个切片 起始下标为1 结束下标为3但不包括3</span></span><br><span class="line">slice := arr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">slice[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(arr)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice))</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slice是一个引用类型 底层是一个结构体 对切片的修改 会改变数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">   ptr *[<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">   <span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">   <span class="built_in">cap</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过make创建切片：var 切片名 []type  = make([]type,len,[cap])</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//第二个参数是len 第三个参数是cap</span></span><br><span class="line">   <span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int64</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">   slice[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义切片的时候指定具体数组 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> slice = []<span class="keyword">string</span>&#123;<span class="string">&quot;12&quot;</span>,<span class="string">&quot;to,&quot;</span>&#125;</span><br><span class="line">   fmt.Println(<span class="built_in">cap</span>(slice))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片的遍历与数组的遍历相似 切片可以继续切片</p><p>使用append函数可以对切片进行动态追加</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> slice = []<span class="keyword">string</span>&#123;<span class="string">&quot;12&quot;</span>,<span class="string">&quot;to,&quot;</span>&#125;</span><br><span class="line">   slice1 := <span class="built_in">append</span>(slice,<span class="string">&quot;sfs&quot;</span>,<span class="string">&quot;as&quot;</span>)</span><br><span class="line">    <span class="comment">//追加切片</span></span><br><span class="line">   slice = <span class="built_in">append</span>(slice,slice1...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片的拷贝操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> slice = []<span class="keyword">string</span>&#123;<span class="string">&quot;12&quot;</span>,<span class="string">&quot;to,&quot;</span>&#125;</span><br><span class="line">   <span class="keyword">var</span> slice2 = <span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="number">10</span>)</span><br><span class="line">   <span class="comment">//slice与slice2空间是独立的 互补影响</span></span><br><span class="line">   <span class="built_in">copy</span>(slice2,slice)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>string底层是一个数据 也可以进行切片 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   str := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">   slice := str[<span class="number">2</span>:]</span><br><span class="line">   <span class="built_in">println</span>(<span class="built_in">len</span>(slice))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维数组 : var arr [2][2]int </p><p>二维数组的声明和一维数组的几种方法相同</p><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>key不可以是slice，map，function因为这几个没法用==判断</p><p>value的类型和key差不多</p><p>声明map后 需要用make初始化 分配内存后才能赋值和使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">map</span> [<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">   a = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">   a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">   a[<span class="number">1</span>] =<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    person := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;person1&quot;</span> : <span class="string">&quot;bob&quot;</span></span><br><span class="line">        <span class="string">&quot;person2&quot;</span> : <span class="string">&quot;tom&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    person[<span class="string">&quot;person1&quot;</span>] = <span class="string">&quot;jack&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map的删除：没有办法一次删除全部key  可以make一个新的map 让之前那个成为垃圾 被回收</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">map</span> [<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">   a = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">   a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">   a[<span class="number">1</span>] =<span class="number">1</span></span><br><span class="line">   <span class="comment">//当指定的key不存在 删除不会操作也不会报错</span></span><br><span class="line">   <span class="built_in">delete</span>(a,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map的查找</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">map</span> [<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">   a = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">   a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">   a[<span class="number">1</span>] =<span class="number">1</span></span><br><span class="line"></span><br><span class="line">   val,ok := a[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      </span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(val)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map的遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">map</span> [<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">   a = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">   a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">   a[<span class="number">1</span>] =<span class="number">1</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> key,val := <span class="keyword">range</span> a &#123;</span><br><span class="line">      fmt.Println(key,val)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果切片类型是map，map个数可以动态变化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> monster = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">2</span>)</span><br><span class="line">   <span class="keyword">if</span> monster[<span class="number">0</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">      monster[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">3</span>)</span><br><span class="line">      monster[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;bob&quot;</span></span><br><span class="line">      monster[<span class="number">0</span>][<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;23&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> monster[<span class="number">1</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">      monster[<span class="number">1</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">3</span>)</span><br><span class="line">      monster[<span class="number">1</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;bob&quot;</span></span><br><span class="line">      monster[<span class="number">1</span>][<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;24&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/05/09/golang/log\source_posts\golang\image-20210509183134360.png" alt="image-20210509183134360"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> monster = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">2</span>)</span><br><span class="line">   <span class="keyword">if</span> monster[<span class="number">0</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">      monster[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">3</span>)</span><br><span class="line">      monster[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;bob&quot;</span></span><br><span class="line">      monster[<span class="number">0</span>][<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;23&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> monster[<span class="number">1</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">      monster[<span class="number">1</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">3</span>)</span><br><span class="line">      monster[<span class="number">1</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;bob&quot;</span></span><br><span class="line">      monster[<span class="number">1</span>][<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;24&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   newMonster := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span> : <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">      <span class="string">&quot;age&quot;</span> : <span class="string">&quot;23&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   monster = <span class="built_in">append</span>(monster,newMonster)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map排序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//按照key的顺序输出val</span></span><br><span class="line">   map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">   map1[<span class="number">10</span>] = <span class="number">100</span></span><br><span class="line">   map1[<span class="number">1</span>] = <span class="number">13</span></span><br><span class="line">   map1[<span class="number">4</span>] = <span class="number">56</span></span><br><span class="line">   map1[<span class="number">8</span>] = <span class="number">90</span></span><br><span class="line"></span><br><span class="line">   fmt.Println(map1)</span><br><span class="line">   <span class="comment">//先把key放在切片中 然后对切片就行排序 最后遍历切片</span></span><br><span class="line">   <span class="keyword">var</span> keys []<span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> k, _ := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">      keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">   &#125;</span><br><span class="line">   sort.Ints(keys)</span><br><span class="line">   fmt.Println(keys)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, val := <span class="keyword">range</span> keys &#123;</span><br><span class="line">      fmt.Println(val, map1[val])</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>map达到一定容量的时候 会自动扩容</p><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>struct和java中的类有同等的地位</p><p>结构体：字段如果没有赋值则是默认值 如果是引用类型 比如slice，map则为null</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">xiaoming := Cat&#123;<span class="string">&quot;xiaoming&quot;</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> cat2 Cat</span><br><span class="line">cat2.name = <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">cat2.age = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(cat2.name)</span><br><span class="line"><span class="built_in">println</span>(xiaoming.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   cat1 := Cat&#123;<span class="string">&quot;xiaoming&quot;</span>,<span class="number">23</span>&#125;</span><br><span class="line">   cat2 := cat1</span><br><span class="line">   <span class="comment">//不同结构体变量的字段是独立的 互不影响</span></span><br><span class="line">   cat2.age = <span class="number">12</span></span><br><span class="line">   fmt.Println(cat1.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他声明方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> cat1 *Cat = <span class="built_in">new</span>(Cat)</span><br><span class="line">   (*cat1).name = <span class="string">&quot;bob&quot;</span></span><br><span class="line">   <span class="comment">//也可以这样写 go底层对进行了处理</span></span><br><span class="line">   cat1.name = <span class="string">&quot;tom&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> cat2 *Cat = &amp;Cat&#123;<span class="string">&quot;blb&quot;</span>,<span class="number">23</span>&#125;</span><br><span class="line">   (*cat2).name = <span class="string">&quot;bob&quot;</span></span><br><span class="line">   <span class="comment">//也可以这样写 go底层对进行了处理</span></span><br><span class="line">   cat2.name = <span class="string">&quot;tom&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体中所有字段在内存中是连续的 但是引用类型指向的地址不一定是连续的</p><p>结构体之间的转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a Cat</span><br><span class="line">   <span class="keyword">var</span> b Animal</span><br><span class="line"></span><br><span class="line">   a = Cat(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义方法:方法作用在指定的数据类型上，自定义类型都可以有方法 不限于struct</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span>  <span class="title">getName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体是值类型所以要传递指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span> <span class="title">setName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">c.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := Cat&#123;<span class="string">&quot;tom&quot;</span>,<span class="number">23</span>&#125;</span><br><span class="line">c.setName(<span class="string">&quot;bob&quot;</span>)</span><br><span class="line">name := c.getName()</span><br><span class="line">fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法和函数的区别:调用和传参机制基本相同，不一样的地方是方法调用时，会将调用方法的变量当作实参也传递给方法</p><p>方法的注意事项和细节：首字母小写只能在本包访问</p><p>自定义类型也可以定义方法</p><p>如果一个类型实现了String方法 fmt.Println默认会调用该方法</p><p>创建struct时指定值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="keyword">string</span></span><br><span class="line">   age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   c1 := Cat&#123;<span class="string">&quot;bob&quot;</span>,<span class="number">23</span>&#125;</span><br><span class="line"></span><br><span class="line">   c2 := Cat&#123;</span><br><span class="line">      age : <span class="number">21</span>,</span><br><span class="line">      name : <span class="string">&quot;bob&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   c3 := &amp;Cat&#123;<span class="string">&quot;bob&quot;</span>,<span class="number">23</span>&#125;</span><br><span class="line">   c4 := &amp;Cat&#123;</span><br><span class="line">      age : <span class="number">21</span>,</span><br><span class="line">      name : <span class="string">&quot;bob&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(c1,c2,*c3,*c4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>model/student.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment">//首字母小写 只能在model下使用</span></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name <span class="keyword">string</span></span><br><span class="line">   Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过工厂模式 让其他包可以使用student</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">student</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;student&#123;name,age&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main/main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;hello/model&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用工厂模式方式创建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   person := model.NewPerson(<span class="string">&quot;bob&quot;</span>, <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>将结构体字段的首字母小写 其他包不能使用 (类似private)</p><p>给结构体所在包提供一个工厂模式的函数(类似构造函数)</p><p>提供Get Set方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="keyword">string</span></span><br><span class="line">   age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">student</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;student&#123;name,age&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span> <span class="title">SetName</span><span class="params">(name <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">   s.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>结构体可以使用嵌套匿名结构体所有的字段和方法 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="keyword">string</span></span><br><span class="line">   age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">   A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> b B</span><br><span class="line">   b.A.age = <span class="number">23</span></span><br><span class="line">   b.A.name = <span class="string">&quot;bob&quot;</span></span><br><span class="line">    <span class="comment">//可以简化 :编译器先看B有没有age 如果没有再看A 再没有就报错</span></span><br><span class="line">    <span class="comment">//当结构体和匿名结构体有相同的字段就就近访问 如果希望访问匿名结构体中的字段可以b.A.age</span></span><br><span class="line">   age := b.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体如果嵌入多个匿名结构体 且两个匿名结构体有相同的字段和方法 且结构体本身没有 在访问时必须指定匿名结构体名字否则编译报错</p><p>如果一个struct嵌入了一个又名结构体 这种模式是组合 那么在范根组合的结构体的字段或方法时 必须带上结构体的名字</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="keyword">string</span></span><br><span class="line">   age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//组合</span></span><br><span class="line">    a A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> b B</span><br><span class="line">   b.a.age = <span class="number">23</span></span><br><span class="line">   b.a.name = <span class="string">&quot;bob&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套匿名结构体后，可以在创建结构体变量时，直接指定各个匿名结构体字段的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="keyword">string</span></span><br><span class="line">   age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//组合</span></span><br><span class="line">    A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//组合</span></span><br><span class="line">   *A</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   b := B&#123;A&#123;<span class="string">&quot;bob&quot;</span>,<span class="number">23</span>&#125;&#125;</span><br><span class="line">   c := B&#123;A&#123;<span class="string">&quot;bob&quot;</span>,<span class="number">23</span>&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>只要是自定义类型就可以实现接口 不限于结构体，可以实现多个接口</p><p>接口中不能有变量</p><p>要实现了接口的所有方法</p><p>只有实现了接口才能把自定义数据类型的实例赋值给接口类型</p><p>可以把任何变量赋值给空接口</p><p>接口类型默认是指针</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是通过接口实现的 可以按照统一的接口来调用不同的实现 这是接口变量就呈现不同的形态</p><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="keyword">string</span></span><br><span class="line">   age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> inter <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">var</span> cat Cat = Cat&#123;<span class="string">&quot;bob&quot;</span>,<span class="number">23</span>&#125;</span><br><span class="line">   inter = cat</span><br><span class="line">   <span class="keyword">var</span> b Cat</span><br><span class="line">   <span class="comment">//使用类型断言 判断inter的类型 在进行赋值</span></span><br><span class="line">   b = inter.(Cat)</span><br><span class="line">   fmt.Println(b)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//带检测到类型断言</span></span><br><span class="line">   <span class="keyword">if</span> y,ok := inter.(Cat); ok &#123;</span><br><span class="line">      fmt.Println(y)</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;转换失败&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>参考：<a href="https://www.cnblogs.com/louis181214/p/10309601.html">https://www.cnblogs.com/louis181214/p/10309601.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//得到文件对象</span></span><br><span class="line">   file, err := os.Open(<span class="string">&quot;D:/test.txt&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">   &#125;</span><br><span class="line">   file.Close()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//读取到的内容显示到终端</span></span><br><span class="line">   data, err := ioutil.ReadFile(<span class="string">&quot;D:/test.txt&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(fmt.Println(<span class="keyword">string</span>(bytes)))</span><br><span class="line"></span><br><span class="line">   <span class="comment">//写文件 第二个参数是文件打开模式 可以组合 第三个参数是权限控制 (linux)</span></span><br><span class="line">   openFile, err := os.OpenFile(<span class="string">&quot;D:/test.txt&quot;</span>, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> openFile.Close()</span><br><span class="line">   str := <span class="string">&quot;i am bob&quot;</span></span><br><span class="line">   <span class="comment">//使用带缓存的write</span></span><br><span class="line">   writer := bufio.NewWriter(openFile)</span><br><span class="line">   writer.WriteString(str)</span><br><span class="line">   writer.Flush()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//把一个文件的内容写入到另一个文件</span></span><br><span class="line">   file1Path := <span class="string">&quot;D:/test.txt&quot;</span></span><br><span class="line">   file2Path := <span class="string">&quot;D:/b.txt&quot;</span></span><br><span class="line">   data, err := ioutil.ReadFile(file1Path)</span><br><span class="line">   ioutil.WriteFile(file2Path,data,<span class="number">0666</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//判断文件或文件夹是否存在</span></span><br><span class="line">   _, err = os.Stat(file2Path)</span><br><span class="line">   <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">//文件存在</span></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">if</span>(os.isNotExist(err))&#123;</span><br><span class="line">        <span class="comment">//文件不存在</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h1><p>序列化 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//想要序列化的值必须首字母大写</span></span><br><span class="line">   <span class="comment">//json可以指定序列化后的key</span></span><br><span class="line">   Name <span class="keyword">string</span> <span class="string">`json:&quot;cat_name&quot;`</span></span><br><span class="line">   Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//struct序列化</span></span><br><span class="line">   cat := Cat&#123;</span><br><span class="line">      Name : <span class="string">&quot;bob&quot;</span>,</span><br><span class="line">      Age : <span class="number">12</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   bytes, _ := json.Marshal(&amp;cat)</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="keyword">string</span>(bytes))</span><br><span class="line"></span><br><span class="line">   <span class="comment">//map序列化</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   a =<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">   a[<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;北京&quot;</span></span><br><span class="line">   a[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;bob&quot;</span></span><br><span class="line">   a[<span class="string">&quot;age&quot;</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">   data, _ := json.Marshal(&amp;a)</span><br><span class="line">   fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//对slice进行序列化</span></span><br><span class="line">   <span class="keyword">var</span> slice []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   <span class="comment">//使用map前，需要先make</span></span><br><span class="line">   m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">   m1[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;jack&quot;</span></span><br><span class="line">   m1[<span class="string">&quot;age&quot;</span>] = <span class="number">7</span></span><br><span class="line">   m1[<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;北京&quot;</span></span><br><span class="line">   slice = <span class="built_in">append</span>(slice, m1)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> m2 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   <span class="comment">//使用map前，需要先make</span></span><br><span class="line">   m2 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">   m2[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;tom&quot;</span></span><br><span class="line">   m2[<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;20&quot;</span></span><br><span class="line">   m2[<span class="string">&quot;address&quot;</span>] = [<span class="number">2</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;墨西哥&quot;</span>,<span class="string">&quot;夏威夷&quot;</span>&#125;</span><br><span class="line">   slice = <span class="built_in">append</span>(slice, m2)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将切片进行序列化操作</span></span><br><span class="line">   data, err := json.Marshal(slice)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;序列化错误 err=%v\n&quot;</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//输出序列化后的结果</span></span><br><span class="line">   fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//想要序列化的值必须首字母大写</span></span><br><span class="line">   <span class="comment">//json可以指定序列化后的key</span></span><br><span class="line">   Name <span class="keyword">string</span> <span class="string">`json:&quot;cat_name&quot;`</span></span><br><span class="line">   Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//注意name这个字段</span></span><br><span class="line">   str := <span class="string">&quot;&#123;\&quot;cat_name\&quot;:\&quot;bob\&quot;,\&quot;Age\&quot;:12&#125;&quot;</span></span><br><span class="line">   <span class="keyword">var</span> cat Cat</span><br><span class="line">   err := json.Unmarshal([]<span class="keyword">byte</span>(str),&amp;cat)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//反序列化map</span></span><br><span class="line">   str1 := <span class="string">&quot;&#123;\&quot;address\&quot;:\&quot;北京\&quot;,\&quot;age\&quot;:2,\&quot;name\&quot;:\&quot;bob\&quot;&#125;&quot;</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   _ = json.Unmarshal([]<span class="keyword">byte</span>(str1), &amp;a)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//反序列化slice</span></span><br><span class="line">   str2 := <span class="string">&quot;[&#123;\&quot;address\&quot;:\&quot;北京\&quot;,\&quot;age\&quot;:7,\&quot;name\&quot;:\&quot;jack\&quot;&#125;,&#123;\&quot;address\&quot;:[\&quot;墨西哥\&quot;,\&quot;夏威夷\&quot;],\&quot;age\&quot;:\&quot;20\&quot;,\&quot;name\&quot;:\&quot;tom\&quot;&#125;]&quot;</span></span><br><span class="line">   <span class="keyword">var</span> slice []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   _ = json.Unmarshal([]<span class="keyword">byte</span>(str2), &amp;slice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>sum.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(a <span class="keyword">int</span> ,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sum_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSum</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   res := Sum(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">   <span class="keyword">if</span> res != <span class="number">3</span> &#123;</span><br><span class="line">      t.Fatalf(<span class="string">&quot;Sum(1,2) 执行错误，期望值=%v 实际值=%v\n&quot;</span>, <span class="number">3</span>, res)</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      t.Logf(<span class="string">&quot;执行正确&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试文件必须以_test.go结尾 </p><p>测试用例函数必须以Test开头 测试函数形参类型必须是*testing.T</p><p>一个测试文件中可以有多个测试用例函数</p><p>执行：在命令行输入命令 go test 错误会输出日志 正确不会 如果带上参数-v无论对错都输出日志</p><p>当出现错误可以使用t.FatalF格式化 输出错误信息 并退出程序</p><p>t.logF可以输出相应的日志</p><p>可以只测试目录下的单个文件 go test -v sum_test.go</p><h1 id="goroutine和channel"><a href="#goroutine和channel" class="headerlink" title="goroutine和channel"></a>goroutine和channel</h1><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>一个go线程上可以起多个协程，写成是轻量级的线程</p><p>go协程的特点</p><ul><li>有独立的栈空间</li><li>共享程序堆空间</li><li>调度由用户控制</li><li>协程是轻量级的线程</li></ul><p>设置cpu</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   cpuNum := runtime.NumCPU()</span><br><span class="line">   fmt.Println(<span class="string">&quot;cpuNum=&quot;</span>, cpuNum)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//可以自己设置使用多个cpu</span></span><br><span class="line">   runtime.GOMAXPROCS(cpuNum - <span class="number">1</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="number">10</span>;i++ &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;test&quot;</span>,i)</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//开启一个协程</span></span><br><span class="line">   <span class="keyword">go</span> test()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="number">10</span>;i++ &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;main&quot;</span>,i)</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;![image<span class="number">-20210510140138756</span>](D:\log\source\_posts\golang\image<span class="number">-20210510140138756.</span>png)</span><br></pre></td></tr></table></figure><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>channle本质是一个队列 是线程安全的多个goroutine访问时不需要加锁</p><p>channel是有类型的 一个类型的channel只能存放该类型的数据</p><p>channel是引用类型 且必须make之后才能使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> intChannel <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">   intChannel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//想channel写入数据</span></span><br><span class="line">   intChannel &lt;- <span class="number">10</span></span><br><span class="line">   num := <span class="number">21</span></span><br><span class="line">   intChannel &lt;- num</span><br><span class="line"></span><br><span class="line">   <span class="comment">//从管道取出数据</span></span><br><span class="line">   num2 := &lt;- intChannel</span><br><span class="line">   fmt.Println(num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//创建一个可以存放任意类型的channel</span></span><br><span class="line">   <span class="keyword">var</span> intChannel <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   intChannel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">   cat := Cat&#123;<span class="string">&quot;bob&quot;</span>,<span class="number">23</span>&#125;</span><br><span class="line">   intChannel &lt;- cat</span><br><span class="line">   intChannel &lt;- <span class="number">10</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">var</span> cat3 Cat</span><br><span class="line">   <span class="comment">//取出的时候要断言</span></span><br><span class="line">   cat3 = (&lt;-intChannel).(Cat)</span><br><span class="line">   fmt.Println(cat3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>channel的关闭:使用内置函数close管理channel 关闭后不能像channel中写入数据 但是仍然可以从channel中读取数据</p><p>channel的遍历：遍历时如果没有关闭channel会报错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//创建一个可以存放任意类型的channel</span></span><br><span class="line">   <span class="keyword">var</span> intChannel <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   intChannel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">   cat := Cat&#123;<span class="string">&quot;bob&quot;</span>,<span class="number">23</span>&#125;</span><br><span class="line">   intChannel &lt;- cat</span><br><span class="line">   intChannel &lt;- <span class="number">10</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">close</span>(intChannel)</span><br><span class="line">   <span class="keyword">for</span> v := <span class="keyword">range</span> intChannel &#123;</span><br><span class="line">      fmt.Println(v)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明管道为只读或只写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//声明只读管道</span></span><br><span class="line">   <span class="keyword">var</span> readOnlyChannel <span class="keyword">chan</span>&lt;- <span class="keyword">int</span></span><br><span class="line">   <span class="comment">//声明只写管道</span></span><br><span class="line">   <span class="keyword">var</span> writeOnlyChannel  &lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select解决从管道读取数据阻塞的问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//创建一个可以存放任意类型的channel</span></span><br><span class="line">   <span class="keyword">var</span> intChannel <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">   intChannel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">   intChannel &lt;- <span class="number">20</span></span><br><span class="line">   intChannel &lt;- <span class="number">10</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> stringChannel <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">   stringChannel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">   stringChannel &lt;- <span class="string">&quot;bob&quot;</span></span><br><span class="line">   stringChannel &lt;- <span class="string">&quot;tom&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> v:= &lt;-intChannel:</span><br><span class="line">            fmt.Println(<span class="string">&quot;从intChannel中读取数据&quot;</span>,v)</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">         <span class="keyword">case</span> v:= &lt;-stringChannel:</span><br><span class="line">            fmt.Println(<span class="string">&quot;从stringChannel中读取数据&quot;</span>,v)</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;结束&quot;</span>)</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在goroutine中使用recover解决写成中出现panic导致程序崩溃的问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFor</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="number">10</span>;i++ &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;test&quot;</span>,i)</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> err:=<span class="built_in">recover</span>();err != <span class="literal">nil</span> &#123;&#125;</span><br><span class="line">      fmt.Println(<span class="string">&quot;发生错误&quot;</span>)</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   a := <span class="number">2</span></span><br><span class="line">   b := <span class="number">0</span></span><br><span class="line">   c := a / b</span><br><span class="line">   fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">go</span> myFor()</span><br><span class="line">   <span class="keyword">go</span> test()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">10</span> ;i++ &#123;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>reflect.TyepOf()：获取变量的类型 返回reflect.Type类型</p><p>reflect.ValueOf()：获取变量的值 ，返回reflect.Value类型 (是一个结构体 可以获取到关于该变量的很多信息)</p><p>变量，interface{}，reflect.Value可以相互转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//想要序列化的值必须首字母大写</span></span><br><span class="line">   <span class="comment">//json可以指定序列化后的key</span></span><br><span class="line">   Name <span class="keyword">string</span> <span class="string">`json:&quot;cat_name&quot;`</span></span><br><span class="line">   Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="comment">//interface转换成reflect.Value</span></span><br><span class="line">   rVal := reflect.ValueOf(b)</span><br><span class="line">   <span class="comment">//reflect.Value转换为interface</span></span><br><span class="line">   inter := rVal.Interface()</span><br><span class="line">   <span class="comment">//interface转换为变量</span></span><br><span class="line">   value := inter.(Cat)</span><br><span class="line">   fmt.Println(value)</span><br><span class="line">   fmt.Println(reflect.TypeOf(b).Name())</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   cat := Cat&#123;<span class="string">&quot;bob&quot;</span>,<span class="number">23</span>&#125;</span><br><span class="line">   test(cat)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>反射的注意事项和细节</p><ul><li>reflect.Value.Kind：获取变量的类型 返回一个常量</li><li>Type和Kind的区别：Type是类型，Kind是类型 两者又是相同 比如int类型，有时不同 比如type Cat struct 。kind返回struct，Type返回Cat</li></ul><p>通过反射来修改变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   val := reflect.ValueOf(b)</span><br><span class="line">   val.Elem().SetInt(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line">   test(&amp;a)</span><br><span class="line">   fmt.Println(a)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>reflect.Value.Elem()：Elem returns the value that the interface v contains or that the pointer v points to.</p><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p> server.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//从conn中读取 如果客户端没有write则阻塞</span></span><br><span class="line">n,err := conn.Read(buf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;发生错误1&quot;</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(buf[:n]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8888&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;发生错误2&quot;</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> listen.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">conn, err := listen.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;发生错误3&quot;</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> process(conn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8888&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="comment">//从终端读取一行用户输入 发送给服务器</span></span><br><span class="line">line,err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">line = strings.Trim(line,<span class="string">&quot; \r\n&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> line == <span class="string">&quot;exit&quot;</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;客户端退出&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送line给服务器</span></span><br><span class="line">_, err = conn.Write([]<span class="keyword">byte</span>(line)) <span class="comment">//第一个返回参数是字节数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Go连接到redis"><a href="#Go连接到redis" class="headerlink" title="Go连接到redis"></a>Go连接到redis</h1><p>安装redis包</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/<span class="keyword">go</span>-redis/redis</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//创建redis线程池</span></span><br><span class="line">   client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">      Addr:     <span class="string">&quot;192.168.52.131:6379&quot;</span>,</span><br><span class="line">      Password: <span class="string">&quot;&quot;</span>, <span class="comment">// no password set</span></span><br><span class="line">      DB:       <span class="number">0</span>,  <span class="comment">// use default DB</span></span><br><span class="line">      PoolSize: <span class="number">500</span>,  <span class="comment">// Redis连接池大小</span></span><br><span class="line">      MaxRetries: <span class="number">500</span>,           <span class="comment">// 最大重试次数</span></span><br><span class="line">      IdleTimeout: <span class="number">600</span> * time.Second,          <span class="comment">// 空闲链接超时时间</span></span><br><span class="line">   &#125;)</span><br><span class="line">   client.Set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;bob&quot;</span>, <span class="number">0</span>)</span><br><span class="line">   result, _ := client.Get(<span class="string">&quot;name&quot;</span>).Result()</span><br><span class="line"></span><br><span class="line">   fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Go连接到mysql"><a href="#Go连接到mysql" class="headerlink" title="Go连接到mysql"></a>Go连接到mysql</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/<span class="keyword">go</span>-sql-driver/mysql</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;database/sql&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//import 下划线（如：import _ github/demo）的作用：当导入一个包时，该包下的文件里所有init()函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行init()函数而已。这个时候就可以使用 import _ 引用该包。</span></span><br><span class="line">_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">db,_:=sql.Open(<span class="string">&quot;mysql&quot;</span>,<span class="string">&quot;root:Bbj0611..@tcp(192.168.52.131:3306)/exercise&quot;</span>)</span><br><span class="line"></span><br><span class="line">err := db.Ping()</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;数据库链接失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line"> <span class="comment">//多行查询</span></span><br><span class="line">rows,_:=db.Query(<span class="string">&quot;select * from grade&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> id,level <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> rows.Next()&#123;</span><br><span class="line">rows.Scan(&amp;id,&amp;level)</span><br><span class="line"> fmt.Println(id,level)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;语言特点&quot;&gt;&lt;a href=&quot;#语言特点&quot; class=&quot;headerlink&quot; title=&quot;语言特点&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>thrift</title>
    <link href="http://example.com/2021/05/08/thrift/"/>
    <id>http://example.com/2021/05/08/thrift/</id>
    <published>2021-05-08T03:19:01.000Z</published>
    <updated>2021-05-16T02:24:48.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><p>代码：ThriftDemo</p><p>创建一个maven项目</p><p>导入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>libthrift<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建thrift文件</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span>  <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> sayHello(<span class="number">1</span>:<span class="built_in">string</span> username)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thrift-0.9.0.exe 是官网提供的windows下编译工具，运用这个工具生成相关代码</p><p>在cmd中切换目录到thrift文件的根目录 进行编译：thrift-0.9.0.exe -r -gen java DemoHello.thrift</p><h1 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h1><p>代码：ThriftDemo</p><p>参考：<a href="https://segmentfault.com/a/1190000019752111">https://segmentfault.com/a/1190000019752111</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;java&lt;/h1&gt;&lt;p&gt;代码：ThriftDemo&lt;/p&gt;
&lt;p&gt;创建一个maven项目&lt;/p&gt;
&lt;p&gt;导入jar包&lt;/p&gt;
&lt;figure cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>尚硅谷面试题</title>
    <link href="http://example.com/2021/04/08/%E5%B0%9A%E7%A1%85%E8%B0%B7%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2021/04/08/%E5%B0%9A%E7%A1%85%E8%B0%B7%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-04-08T10:41:20.000Z</published>
    <updated>2021-04-08T15:03:39.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一季"><a href="#第一季" class="headerlink" title="第一季"></a>第一季</h1><h2 id="解决spring-mvc乱码问题"><a href="#解决spring-mvc乱码问题" class="headerlink" title="解决spring mvc乱码问题"></a>解决spring mvc乱码问题</h2><p>post请求乱码:在web.xml中配置过滤器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>get请求乱码：修改tomcat的conf目录下的server.xml文件，把第一个Connection标签的URIEncoding的值改为UTF-8</p><h2 id="Mybatis中实体类的属性名和表中的字段名不一样怎么办"><a href="#Mybatis中实体类的属性名和表中的字段名不一样怎么办" class="headerlink" title="Mybatis中实体类的属性名和表中的字段名不一样怎么办"></a>Mybatis中实体类的属性名和表中的字段名不一样怎么办</h2><ol><li><p>写sql语句的时候起别名 别名为实体类中的属性名</p></li><li><p>在mybatis的全局配置文件中开启驼峰命名规则</p><ol><li><pre><code class="xml">&lt;configuration&gt;    &lt;settings&gt;        &lt;!-- 数据库中的last_name会被映射成lastName--&gt;        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;&gt;&lt;/setting&gt;    &lt;/settings&gt;&lt;/configuration&gt;</code></pre></li></ol></li><li><p>在mapper映射文件中使用resultMap来自定映射规则</p><ol><li><img src="/2021/04/08/%E5%B0%9A%E7%A1%85%E8%B0%B7%E9%9D%A2%E8%AF%95%E9%A2%98/log\source_posts\尚硅谷面试题\image-20210408225345722.png" alt="image-20210408225345722"></li></ol></li></ol><h2 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h2><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其它表关联的字段，外键关系建立索引</li><li>单键/组合索引的选择问题，组合索引性价比更高</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或者分组字段</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一季&quot;&gt;&lt;a href=&quot;#第一季&quot; class=&quot;headerlink&quot; title=&quot;第一季&quot;&gt;&lt;/a&gt;第一季&lt;/h1&gt;&lt;h2 id=&quot;解决spring-mvc乱码问题&quot;&gt;&lt;a href=&quot;#解决spring-mvc乱码问题&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面经总结</title>
    <link href="http://example.com/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</id>
    <published>2021-04-06T05:48:48.000Z</published>
    <updated>2021-05-16T06:55:34.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mybatis一级、二级缓存"><a href="#Mybatis一级、二级缓存" class="headerlink" title="Mybatis一级、二级缓存"></a>Mybatis一级、二级缓存</h2><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>　Mybatis对缓存提供支持，但是在没有配置的默认情况下，它只开启一级缓存，一级缓存只是相对于同一个SqlSession而言。所以在参数和SQL完全一样的情况下，我们使用同一个SqlSession对象调用一个Mapper方法，往往只执行一次SQL，因为使用SelSession第一次查询后，MyBatis会将其放在缓存中，以后再查询的时候，如果没有声明需要刷新，并且缓存没有超时的情况下，SqlSession都会取出当前缓存的数据，而不会再次发送SQL到数据库。</p><p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/log\source_posts\面经总结\image-20210406141934323.png" alt="image-20210406141934323"></p><p>一级缓存的生命周期：当SqlSession调用close方法和clearCache方法或者执行更新操作 会使缓存失效</p><p>如何判断完全相同的两次查询</p><ul><li>传入的statementId</li><li>查询时要求的结果集中的结果范围<ul><li>sql语句和参数</li></ul></li></ul><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>　MyBatis的二级缓存是Application级别的缓存，它可以提高对数据库查询的效率，以提高应用的性能</p><p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/log\source_posts\面经总结\image-20210406142221333.png" alt="image-20210406142221333"></p><p>SqlSessionFactory层面上的二级缓存默认是不开启的，二级缓存的开启需要进行配置，实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的。 也就是要求实现Serializable接口，配置方法很简单，只需要在映射XML文件配置就可以开启缓存了<cache>，如果我们配置了二级缓存就意味着：</cache></p><ul><li>映射语句文件中的所有select语句将会被缓存。</li><li>映射语句文件中的所有insert、update和delete语句会刷新缓存。</li><li>缓存会使用默认的Least Recently Used（LRU，最近最少使用的）算法来收回。</li><li>缓存会存储列表集合或对象(无论查询方法返回什么)的1024个引用</li><li>缓存会被视为是read/write(可读/可写)的缓存，意味着对象检索不是共享的，而且可以安全的被调用者修改，不干扰其他调用者或线程所做的潜在修改。</li></ul><p>除了在映射配置文件中设置开启缓存 还要在全局配置中开启</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个配置使全局的映射器(二级缓存)启用或禁用缓存--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        .....</span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    ....</span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Ping过程及其原理"><a href="#Ping过程及其原理" class="headerlink" title="Ping过程及其原理"></a>Ping过程及其原理</h2><p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/log\source_posts\面经总结\image-20210406144955826.png" alt="image-20210406144955826"></p><p>同一网段ping：如果主机A，要去 ping主机B，那么主机A，就要封装二层报文，他会先查自己的arp缓存表，如果没有B的MAC地址，就会向外发送一个ARP广播包</p><p>跨网段ping：如果主机A要ping主机C,那么主机A发现主机C的IP和自己不是同一网段,他就去找 <strong>网关</strong> 转发,但是他也不知道网关的MAC情况下呢?他就会向之前那个步骤一样 <strong>先发送一个ARP广播,学到网关的MAC,再发封装ICMP报文给网关路由器.**当路由器收到主机A发过来的ICMP报文,发现自己的目的地址是其本身MAC地址,根据目的的IP2.1.1.1,查路由表,发现2.1.1.1/24的路由表项,得到一个出口指针,去掉原来的MAC头部.加上自己的MAC地址向主机C转发( **如果网关也没有主机C的MAC地址,还是要向前面一个步骤一样,ARP广播一下即可相互学到….路由器2端口能学到主机D的MAC,主机D也能学到路由器2端口的MAC.</strong> .) </p><h2 id="ping命令使用的协议"><a href="#ping命令使用的协议" class="headerlink" title="ping命令使用的协议"></a>ping命令使用的协议</h2><p>使用的是<a href="http://www.so.com/s?q=ICMP&ie=utf-8&src=internal_wenda_recommend_text">ICMP</a>协议，是“Internet Control Message Protocol”（Internet控制消息协议）的缩写，是<a href="http://www.so.com/s?q=TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F&ie=utf-8&src=internal_wenda_recommend_text">TCP/IP协议族</a>的一个子协议，用于在IP主机、<a href="http://www.so.com/s?q=%E8%B7%AF%E7%94%B1%E5%99%A8&ie=utf-8&src=internal_wenda_recommend_text">路由器</a>之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。<br>它是用来检查网络是否通畅或者网络连接速度的命令。它所利用的原理是这样的：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少。</p><p>ICMP是网络层协议</p><h2 id="dns域名解析过程"><a href="#dns域名解析过程" class="headerlink" title="dns域名解析过程"></a><a href="https://blog.csdn.net/baidu_37964071/article/details/80500825?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&dist_request_id=1331974.5978.16185553650719277&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">dns域名解析过程</a></h2><h2 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h2><p>为什么要做主从复制？</p><p>1、在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p><p>2、做数据的热备</p><p>3、架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</p><p><strong>原理</strong></p><p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/log\source_posts\面经总结\image-20210406145829715.png" alt="image-20210406145829715"></p><ul><li>步骤一：主库db的更新事件(update、insert、delete)被写到binlog</li><li>步骤二：从库发起连接，连接到主库</li><li>步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库</li><li>步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log</li><li>步骤五：还会创建一个SQL线程，从relay log里面读取内容，从<strong>Exec_Master_Log_Pos</strong>位置开始执行读取到的更新事件，将更新内容写入到slave的db</li></ul><p>注：上面的解释是解释每一步做了什么，整个mysql主从复制是异步的，不是按照上面的步骤执行的。</p><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>序列化和反序列化的定义：</p><p>(1)Java序列化就是指把Java对象转换为字节序列的过程</p><p>​    Java反序列化就是指把字节序列恢复为Java对象的过程。</p><p>(2)序列化最重要的作用：在传递和保存对象时.保证对象的完整性和可传递性。对象转换为有序字节流,以便在网络上传输或者保存在本地文件中。</p><p>​    反序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。  </p><p>(3)序列化和反序列化的注意点：</p><p>​    ①序列化时，只对对象的状态进行保存，而不管对象的方法；</p><p>​    ②当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</p><p>​    ③当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；这是能用序列化解决深拷贝的重要原因；</p><p>​    ④并非所有的对象都可以序列化，至于为什么不可以，有很多原因了，比如：</p><p>​        安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列    化进行传输的过程中，这个对象的private等域是不受保护的；</p><p>​        资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现；</p><p>​    ⑤声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。</p><p>​    ⑥序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。为它赋予明确的值。显式地定义serialVersionUID有两种用途：在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</p><p>​    ⑦Java有很多基础类已经实现了serializable接口，比如String,Vector等。但是也有一些没有实现serializable接口的；</p><h2 id="JDBC原理"><a href="#JDBC原理" class="headerlink" title="JDBC原理"></a><a href="https://www.cnblogs.com/qlqwjy/p/8227665.html"><strong>JDBC原理</strong></a></h2><h2 id="java三大特性"><a href="#java三大特性" class="headerlink" title="java三大特性"></a>java三大特性</h2><p><strong>封装</strong></p><p>封装也称信息隐藏，是指利用抽象数据类型把数据和基于数据的操作封装起来，使其成为一个不可分割的整体，数据隐藏在抽象数据内部，尽可能的隐藏数据细节，只保留一些接口使其与外界发生联系。也就是说用户无需知道内部的数据和方法的具体实现细节，只需根据留在外部的接口进行操作就行。</p><p>为了保证属性的安全性可以把属性的访问修饰符改为private 通过setter和getter 方法访问和复制</p><p><strong>继承</strong></p><p>多个类具有共同的属性（成员变量）与行为（成员方法）的时候，将这些共同的部分抽取出来定义到一个公共的类中，其他及各类可以与这个公共的类形成继承关系，从而在多个类中不需要重 复定义公共部分。这个公共的类就是父类，其他的类就是子类。子类可以直接访问父类的非私有化成员变量，访问父类的私有化成员变量可以使用super.get()方法。</p><p>继承的特点：</p><p>（1）子类比父类强大<br>（2）java是单继承，不能进行多继承。但是可以继承多层子类（<strong>不建议继承超过3层</strong>）<br>（3）子类继承父类，但是对父类的成员变量是无法直接操作，只能通过父类继承过来的setter和getter方法.</p><p><strong>多态</strong></p><p>java程序中定义的引用变量所指向的具体类型和通过该引用类型发出的方法在调用时不确定，该引用变量发出的方法到底调用哪个类的实现的方法，必须在程序运行期间才能决定</p><p>多态有两种：引用多态和方法多态</p><h2 id="Object类中的方法"><a href="#Object类中的方法" class="headerlink" title="Object类中的方法"></a><a href="https://blog.csdn.net/qq_42570601/article/details/104049532">Object类中的方法</a></h2><h2 id="HashMap为什么使用拉链法解决地址冲突"><a href="#HashMap为什么使用拉链法解决地址冲突" class="headerlink" title="HashMap为什么使用拉链法解决地址冲突"></a>HashMap为什么使用拉链法解决地址冲突</h2><p>不用的key，可能会有相同的hashcode</p><h2 id="TCP和UDP的应用"><a href="#TCP和UDP的应用" class="headerlink" title="TCP和UDP的应用"></a>TCP和UDP的应用</h2><p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/log\source_posts\面经总结\image-20210407215856506.png" alt="image-20210407215856506"></p><h2 id="数据先写Redis还是DB？redis缓存一致性问题？"><a href="#数据先写Redis还是DB？redis缓存一致性问题？" class="headerlink" title="数据先写Redis还是DB？redis缓存一致性问题？"></a><a href="https://blog.csdn.net/qq_20597727/article/details/88652045?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujs&dist_request_id=1330144.34982.16182132035436085&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujs">数据先写Redis还是DB？redis缓存一致性问题？</a></h2><h2 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a><a href="https://www.jianshu.com/p/47fd7f86c848">redis分布式锁</a></h2><h2 id="操作系统缓存一致性问题"><a href="#操作系统缓存一致性问题" class="headerlink" title="操作系统缓存一致性问题"></a><a href="https://www.cnblogs.com/HuiH/p/12690598.html">操作系统缓存一致性问题</a></h2><h2 id="有没有了解其他的缓存中间件？"><a href="#有没有了解其他的缓存中间件？" class="headerlink" title="有没有了解其他的缓存中间件？"></a>有没有了解其他的缓存中间件？</h2><p>1、MemCached介绍<br>MemCached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。它便于快速开发，减轻开发难度，解决了大数据量缓存的很多问题，本质上，它是一个简洁的key-value存储系统</p><p>2、MemCached工作原理<br>主要通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度。</p><p>Redis与MemCached的区别<br>（1）Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等；<br>（2）Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；<br>（3）虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘；<br>（4）分布式集群部署：<br>a、memcache集群节点间的数据是独立的，不能相互通讯，但可以利用magent开源软件解决 ;<br>b、Redis高可用的，可以做一主多从，主从之间进行数据同步。 当Master宕机后，通过选举算法(Paxos、Raft)从slave中选举出新Master继续对外提供服务，主机恢复后以slave的身份重新加入<br>（5）存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）；<br>（6）灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；</p><h2 id="分布式-session"><a href="#分布式-session" class="headerlink" title="分布式 session"></a><a href="https://blog.csdn.net/qq_35620501/article/details/95047642?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control">分布式 session</a></h2><h2 id="Spring-bean的循环依赖以及解决方式"><a href="#Spring-bean的循环依赖以及解决方式" class="headerlink" title="Spring-bean的循环依赖以及解决方式"></a><a href="https://louyuting.blog.csdn.net/article/details/77940767?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs&dist_request_id=1330147.35086.16182171424877071&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs">Spring-bean的循环依赖以及解决方式</a></h2><h2 id="为什么需要三层缓存？两层或者一层行不行"><a href="#为什么需要三层缓存？两层或者一层行不行" class="headerlink" title="为什么需要三层缓存？两层或者一层行不行"></a><a href="https://blog.csdn.net/zhangmingan123/article/details/111178263">为什么需要三层缓存？两层或者一层行不行</a></h2><h2 id="Java进程CPU占用率高的排查和常见解决方案"><a href="#Java进程CPU占用率高的排查和常见解决方案" class="headerlink" title="Java进程CPU占用率高的排查和常见解决方案"></a><a href="https://wangcw.blog.csdn.net/article/details/86242263?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-8.baidujs&dist_request_id=1330147.36178.16182310883074655&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-8.baidujs">Java进程CPU占用率高的排查和常见解决方案</a></h2><h2 id="给定-a、b-两个文件，各存放-50-亿个-URL，每个-URL-各占-64B，内存限制是-4G。请找出-a、b-两个文件共同的-URL"><a href="#给定-a、b-两个文件，各存放-50-亿个-URL，每个-URL-各占-64B，内存限制是-4G。请找出-a、b-两个文件共同的-URL" class="headerlink" title="给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL"></a><a href="https://www.cnblogs.com/aspirant/p/7154551.html">给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL</a></h2><h2 id="https的加密过程"><a href="#https的加密过程" class="headerlink" title="https的加密过程"></a><a href="https://blog.csdn.net/qq_32998153/article/details/80022489">https的加密过程</a></h2><h2 id="HTTPS的数字证书验证原理"><a href="#HTTPS的数字证书验证原理" class="headerlink" title="HTTPS的数字证书验证原理"></a><a href="https://blog.csdn.net/liuxingrong666/article/details/83869161?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">HTTPS的数字证书验证原理</a></h2><p>数字证书中有ijge</p><h2 id="InnoDB怎么解决幻读问题"><a href="#InnoDB怎么解决幻读问题" class="headerlink" title="InnoDB怎么解决幻读问题"></a><a href="https://blog.csdn.net/qq_33330687/article/details/89004462?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">InnoDB怎么解决幻读问题</a></h2><p>根据这篇文章回答这两个问题:客户端拿到服务端的证书后是怎么验证证书的合法性？证书有什么内容？</p><h2 id="Http，TCP，Socker之间的区别和联系"><a href="#Http，TCP，Socker之间的区别和联系" class="headerlink" title="Http，TCP，Socker之间的区别和联系"></a><a href="https://www.cnblogs.com/jing99/p/6181488.html">Http，TCP，Socker之间的区别和联系</a></h2><h2 id="list和set的区别"><a href="#list和set的区别" class="headerlink" title="list和set的区别"></a><a href="https://www.cnblogs.com/q2546/p/11394723.html">list和set的区别</a></h2><h2 id="hashmap查询复杂度"><a href="#hashmap查询复杂度" class="headerlink" title="hashmap查询复杂度"></a>hashmap查询复杂度</h2><p><a href="https://blog.csdn.net/donggua3694857/article/details/64127131?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control&amp;dist_request_id=1331647.1257.16183250244152227&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control">https://blog.csdn.net/donggua3694857/article/details/64127131?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control&amp;dist_request_id=1331647.1257.16183250244152227&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control</a></p><p><a href="https://blog.csdn.net/john1337/article/details/104727895">https://blog.csdn.net/john1337/article/details/104727895</a></p><h2 id="数组实现扩容栈"><a href="#数组实现扩容栈" class="headerlink" title="数组实现扩容栈"></a>数组实现扩容栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个数组容器 用于存储栈元素 data.length是最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [] data;</span><br><span class="line">    <span class="comment">//栈顶标记 用于标记栈顶元素的位置 当栈为空时,top=-1,栈中有效元素的个数是top+1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//默认最大容量为10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     创建一个默认容量为10的栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data=<span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     创建一个指定容量为capacity的栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(capacity&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            capacity=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.data=<span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将元素e入栈,如果当前的栈已经满了,则扩容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 用户指定入栈的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top+<span class="number">1</span>==data.length)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] newData = Arrays.copyOf(data,top * <span class="number">2</span>);</span><br><span class="line">            data = newData;</span><br><span class="line">        &#125;</span><br><span class="line">        data[++top]=e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     从栈中弹出一个元素,如果栈已经是空,则返回-1即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回当前栈顶的元素,如果栈为空则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top==-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈为空，无法弹栈元素&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[top--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     获取当前栈顶元素，如果栈为空，则返回-1即可</span></span><br><span class="line"><span class="comment">     <span class="doctag">@return</span> 返回当前栈顶元素，如果栈为空,如果栈为空,则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top==-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈为空，无法弹栈元素&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[top];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     判断当前栈是否为空</span></span><br><span class="line"><span class="comment">     <span class="doctag">@return</span> true表示栈空,否则栈不为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     清空当前的栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        top=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     获取栈中有效元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hashmap不安全的原因"><a href="#hashmap不安全的原因" class="headerlink" title="hashmap不安全的原因"></a><a href="https://blog.csdn.net/swpu_ocean/article/details/88917958?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">hashmap不安全的原因</a></h2><h2 id="PriorityQueue原理"><a href="#PriorityQueue原理" class="headerlink" title="PriorityQueue原理"></a><a href="https://blog.csdn.net/u010623927/article/details/87179364">PriorityQueue原理</a></h2><h2 id="进程有哪些状态？是如何进行切换的"><a href="#进程有哪些状态？是如何进行切换的" class="headerlink" title="进程有哪些状态？是如何进行切换的"></a>进程有哪些状态？是如何进行切换的</h2><p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/log\source_posts\面经总结\image-20210415132137774.png" alt="image-20210415132137774"></p><h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h2><p>  存放进程的管理和控制信息的数据结构称为进程控制块。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。</p><p>在不同的操作系统中对进程的控制和管理机制不同，PCB中的信息多少也不一样，通常PCB应包含如下一些信息。</p><p>1、进程标识符 name：每个进程都必须有一个唯一的标识符，可以是字符串，也可以是一个数字。UNIX系统中就是一个整型数。在进程创建时由系统赋予。</p><p>2、进程当前状态 status：说明进程当前所处的状态。为了管理的方便，系统设计时会将相同的状态的进程组成一个队列，如就绪进程队列，等待进程则要根据等待的事件组成多个等待队列，如等待打印机队列、等待磁盘I/O完成队列等等。</p><p>3、进程相应的程序和数据地址，以便把PCB与其程序和数据联系起来。</p><p>4、进程资源清单。列出所拥有的除CPU外的资源记录，如拥有的I/O设备，打开的文件列表等。</p><p>5、进程优先级 priority：进程的优先级反映进程的紧迫程序，通常由用户指定和系统设置。UNIX系统采用用户设置和系统计算相结合的方式确定进程的优先级 。 </p><p>6、CPU现场保护区 cpustatus：当进程因某种原因不能继续占用CPU时（等待打印机），释放CPU，这时就要将CPU的各种状态信息保护起来，为将来再次得到处理机恢复CPU的各种状态，继续运行。</p><p>7、进程同步与通信机制 用于实现进程间互斥、同步和通信所需的信号量等。</p><p>8、进程所在队列PCB的链接字   根据进程所处的现行状态，进程相应的PCB参加到不同队列中。PCB链接字指出该进程所在队列中下一个进程PCB的首地址。</p><p>9、与进程有关的其他信息。 如进程记账信息，进程占用CPU的时间等。</p><h2 id="为什么要划分内核态和用户态"><a href="#为什么要划分内核态和用户态" class="headerlink" title="为什么要划分内核态和用户态"></a><a href="https://blog.csdn.net/qq_29996285/article/details/88078906?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs&dist_request_id=1331647.20720.16184648700343463&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs">为什么要划分内核态和用户态</a></h2><h2 id="操作系统用户态和内核态之间的切换过程"><a href="#操作系统用户态和内核态之间的切换过程" class="headerlink" title="操作系统用户态和内核态之间的切换过程"></a><a href="https://blog.csdn.net/ddna/article/details/4941373?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs">操作系统用户态和内核态之间的切换过程</a></h2><h2 id="内核线程的作用"><a href="#内核线程的作用" class="headerlink" title="内核线程的作用"></a>内核线程的作用</h2><ol><li>周期性的将dirty内存页同步到磁盘设备上。 比如 bpflush线程周期性的把dirty数据写回磁盘</li><li>内存页很少的情况下，把内存page 交换到磁盘空间。 比如kswapd，系统会为每一个NUMA创建一个kswapd进程，但是在非NUMA系统上，则仅有一个kswapd</li><li>管理延时动作</li><li>实现文件系统的事物日志</li></ol><h2 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a><a href="https://blog.csdn.net/xifeijian/article/details/8209783?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs">进程上下文切换</a></h2><h2 id="线程上下文切换和进程上下文切换的区别"><a href="#线程上下文切换和进程上下文切换的区别" class="headerlink" title="线程上下文切换和进程上下文切换的区别"></a><a href="https://www.msdn.hk/jshtml/jswz/752.html">线程上下文切换和进程上下文切换的区别</a></h2><h2 id="进程上下文切换频繁的后果"><a href="#进程上下文切换频繁的后果" class="headerlink" title="进程上下文切换频繁的后果"></a>进程上下文切换频繁的后果</h2><p>context switch过高会导致CPU频繁在寄存器和运行队列之间奔波 ，更多的时间花在了进程切换，而不是真正工作的进程上。直接的消耗包括CPU寄存器需要保存和加载，系统调度器的代码需要执行。间接消耗在于多核cache之间的共享数据。</p><h2 id="大量close-wait对系统影响"><a href="#大量close-wait对系统影响" class="headerlink" title="大量close_wait对系统影响"></a>大量close_wait对系统影响</h2><p>在服务器与客户端通信过程中，因服务器发生了socket未关导致的closed_wait发生</p><ol><li>导致服务器资源消耗过大</li><li>如果连接数满了，服务端进程将无法新建socket来响应新的请求。</li><li>假设你的程序会去连接另一个服务，而未正常关闭，那么可能导致你的程序超过最大连接数的时候报异常，引起连锁反应甚至导致程序崩溃</li></ol><h2 id="三次握手第三次报文丢失怎么办"><a href="#三次握手第三次报文丢失怎么办" class="headerlink" title="三次握手第三次报文丢失怎么办"></a>三次握手第三次报文丢失怎么办</h2><p><strong>Server端</strong></p><p>第三次的ACK在网络中丢失，那么Server 端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。 而Server重发SYN+ACK包的次数，可以通过设置</p><p>/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5. 如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。</p><p><strong>Client 端</strong></p><p>在linux c 中，client 一般是通过 connect() 函数来连接服务器的，而connect()是在 TCP的三次握手的第二次握手完成后就成功返回值。也就是说 client 在接收到 SYN+ACK包，它的TCP连接状态就为 established （已连接），表示该连接已经建立。那么如果 第三次握手中的ACK包丢失的情况下，Client 向 server端发送数据，Server端将以 RST包响应，方能感知到Server的错误。</p><p>关于rst包：<a href="https://blog.csdn.net/hik_zxw/article/details/50167703">https://blog.csdn.net/hik_zxw/article/details/50167703</a></p><h2 id="三次握手第二次报文丢失怎么办"><a href="#三次握手第二次报文丢失怎么办" class="headerlink" title="三次握手第二次报文丢失怎么办"></a>三次握手第二次报文丢失怎么办</h2><p>在发送完ACK+SYN报文后会启动一个定时器，超时没有收到ACK确认，会再次发送，会进行多次重试。超时时间依旧每次翻倍，重试次数可设置</p><h2 id="tcp的push标志位"><a href="#tcp的push标志位" class="headerlink" title="tcp的push标志位"></a><a href="https://blog.csdn.net/javajiawei/article/details/81987949">tcp的push标志位</a></h2><p>数据包先存放在tcp接受缓冲区中 收到带有push的报文后 在发送给应用层</p><h2 id="TCP的发送缓冲区和接收缓冲区"><a href="#TCP的发送缓冲区和接收缓冲区" class="headerlink" title="TCP的发送缓冲区和接收缓冲区"></a><a href="https://blog.csdn.net/kesenzhang/article/details/104881397">TCP的发送缓冲区和接收缓冲区</a></h2><h2 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a><a href="https://blog.csdn.net/baidu_17611285/article/details/80171239">TCP头部</a></h2><h2 id="UDP头部"><a href="#UDP头部" class="headerlink" title="UDP头部"></a><a href="https://blog.csdn.net/ASJBFJSB/article/details/80357111">UDP头部</a></h2><h2 id="如果程序有bug怎么排查"><a href="#如果程序有bug怎么排查" class="headerlink" title="如果程序有bug怎么排查"></a><a href="https://blog.csdn.net/weixin_38546942/article/details/103757949">如果程序有bug怎么排查</a></h2><h2 id="偏向锁升级到轻量级锁"><a href="#偏向锁升级到轻量级锁" class="headerlink" title="偏向锁升级到轻量级锁"></a>偏向锁升级到轻量级锁</h2><p>\1. 首先获取锁 对象的 Markword，判断是否处于可偏向状 态。（biased_lock=1、且 ThreadId 为空）</p><p> \2. 如果是可偏向状态，则通过 CAS 操作，把当前线程的 ID 写入到 MarkWord a) 如果 cas 成功，那么 markword 就会变成这样。 表示已经获得了锁对象的偏向锁，接着执行同步代码 块 b) 如果 cas 失败，说明有其他线程已经获得了偏向锁， 这种情况说明当前锁存在竞争，需要撤销已获得偏向 锁的线程，并且把它持有的锁升级为轻量级锁（这个 操作需要等到全局安全点，也就是没有线程在执行字 节码）才能执行</p><p>\3. 如果是已偏向状态，需要检查 markword 中存储的 ThreadID 是否等于当前线程的 ThreadID a) 如果相等，不需要再次获得锁，可直接执行同步代码 块 b) 如果不相等，说明当前锁偏向于其他线程，需要撤销 偏向锁并升级到轻量级锁</p><h2 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a><a href="https://blog.csdn.net/tjiyu/article/details/52959418?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">五种IO模型</a></h2><h2 id="redis实现分布式锁"><a href="#redis实现分布式锁" class="headerlink" title="redis实现分布式锁"></a><a href="https://www.jianshu.com/p/47fd7f86c848">redis实现分布式锁</a></h2><h2 id="Redis主从同步"><a href="#Redis主从同步" class="headerlink" title="Redis主从同步"></a><a href="https://www.cnblogs.com/daofaziran/p/10978628.html">Redis主从同步</a></h2><h2 id="谈谈你对-Springboot-的理解？为什么要用-Springboot？"><a href="#谈谈你对-Springboot-的理解？为什么要用-Springboot？" class="headerlink" title="谈谈你对 Springboot 的理解？为什么要用 Springboot？"></a>谈谈你对 Springboot 的理解？为什么要用 Springboot？</h2><p>我对spring boot的理解:<br>spring boot 是微服务框架的起点，他简化了配置过程、部署过程、监控过程。<br>它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，4spring boot整合了很多的框架，同时 将其他技术同spring结合起来。<br>为什么使用springboot：<br>其实就是简单、快速、方便！平时如果我们需要搭建一个spring web项目的时候需要怎么做呢？</p><p>1）配置web.xml，加载spring和spring mvc<br>2）配置数据库连接、配置spring事务<br>3）配置加载配置文件的读取，开启注解<br>4）配置日志文件<br>…<br>配置完成之后部署tomcat 调试<br>…<br>但是如果使用spring boot呢？</p><p>很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套web项目或者是构建一个微服务！</p><h2 id="springboot的配置方式有哪些"><a href="#springboot的配置方式有哪些" class="headerlink" title="springboot的配置方式有哪些"></a><a href="https://blog.csdn.net/weixin_43809795/article/details/109206340">springboot的配置方式有哪些</a></h2><h2 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h2><p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/log\source_posts\面经总结\image-20210416164524307.png" alt="image-20210416164524307"></p><h2 id="java垃圾回收机制"><a href="#java垃圾回收机制" class="headerlink" title="java垃圾回收机制"></a>java垃圾回收机制</h2><p>程序员不需要去关心内存动态分配和垃圾回收的问题，这一切都交给了JVM来处理.回收机制使用可达性分析算法判断哪些是垃圾对象，并把堆分为年轻代和老年代，分别用不同的垃圾回收算法进行垃圾回收</p><h2 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a><a href="https://blog.csdn.net/weixin_42228338/article/details/97684517?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&dist_request_id=1331978.491.16185720218088971&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">B树和B+树</a></h2><h2 id="redo日志的刷盘策略"><a href="#redo日志的刷盘策略" class="headerlink" title="redo日志的刷盘策略"></a><a href="https://blog.csdn.net/weixin_38629422/article/details/105813338">redo日志的刷盘策略</a></h2><h2 id="hashmap为何引入红黑树"><a href="#hashmap为何引入红黑树" class="headerlink" title="hashmap为何引入红黑树"></a><a href="https://blog.csdn.net/weixin_43258908/article/details/89174471">hashmap为何引入红黑树</a></h2><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a><a href="https://www.cnblogs.com/heyouxin/p/13037146.html">公平锁和非公平锁</a></h2><p>ReentrantLock怎么实现公平锁和非公平锁，底层？</p><h2 id="生产者消费者模式为什么使用notifyAll而不是notify-考虑了什么"><a href="#生产者消费者模式为什么使用notifyAll而不是notify-考虑了什么" class="headerlink" title="生产者消费者模式为什么使用notifyAll而不是notify 考虑了什么"></a><a href="https://blog.csdn.net/chenchaofuck1/article/details/51660119?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.baidujs">生产者消费者模式为什么使用notifyAll而不是notify 考虑了什么</a></h2><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a><a href="https://blog.csdn.net/yzpbright/article/details/112675352?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-1&spm=1001.2101.3001.4242">阻塞队列</a></h2><h2 id="spring事务"><a href="#spring事务" class="headerlink" title="spring事务"></a><a href="https://www.cnblogs.com/mseddl/p/11577846.html">spring事务</a></h2><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a><a href="https://www.jianshu.com/p/6dde7f92951e">协程</a></h2><h2 id="可重复读隔离级别的实现原理"><a href="#可重复读隔离级别的实现原理" class="headerlink" title="可重复读隔离级别的实现原理"></a><a href="https://www.cnblogs.com/lmj612/p/10598971.html">可重复读隔离级别的实现原理</a></h2><h2 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a><a href="https://blog.csdn.net/jisuanji12306/article/details/86363390">线程间的通信</a></h2><h2 id="mmap为什么效率高"><a href="#mmap为什么效率高" class="headerlink" title="mmap为什么效率高"></a><a href="https://blog.csdn.net/mg0832058/article/details/5890688?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.baidujs">mmap为什么效率高</a></h2><h2 id="虚拟内存？细说"><a href="#虚拟内存？细说" class="headerlink" title="虚拟内存？细说"></a><a href="https://www.cnblogs.com/yaoxiaowen/p/7805964.html">虚拟内存？细说</a></h2><h2 id="java负数的二进制表示"><a href="#java负数的二进制表示" class="headerlink" title="java负数的二进制表示"></a><a href="https://blog.csdn.net/zgrjkflmkyc/article/details/12185143">java负数的二进制表示</a></h2><h2 id="数据库四种锁"><a href="#数据库四种锁" class="headerlink" title="数据库四种锁"></a>数据库四种锁</h2><p>（1）共享锁(S锁, 读锁)<br>共享锁锁定的资源可以被其它用户读取，但其它用户不能修改它。在SELECT 命令执行时，SQL Server 通常会对对象进行共享锁锁定。通常加共享锁的数据页被读取完毕后，共享锁就会立即被释放。</p><p>（2）排他锁(X锁，写锁)<br>排他锁锁定的资源只允许进行锁定操作的程序使用，其它任何对该资源的操作均不会被接受。执行数据更新命令，即INSERT、UPDATE 或DELETE 命令时，SQL Server 会自动使用排他锁。但当对象上有其它锁存在时，无法对其加排他锁。排他锁一直到事务结束才能被释放。共享锁可以一层套一层的上锁，但排他锁只能加一个。</p><p>（3）乐观锁<br>总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现。</p><p>version方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p><p>（4）悲观锁<br>总是假设最坏的情况，每次取数据时都认为其他线程会修改该数据，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。根据范围，锁还可以划分成行级锁和表锁。</p><h2 id="隔离级别实现原理"><a href="#隔离级别实现原理" class="headerlink" title="隔离级别实现原理"></a><a href="https://www.cnblogs.com/wajika/p/6680200.html">隔离级别实现原理</a></h2><h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a><a href="https://www.jianshu.com/p/7a5b0043b035">什么是面向对象</a></h2><h2 id="如何实现负载均衡？"><a href="#如何实现负载均衡？" class="headerlink" title="如何实现负载均衡？"></a><a href="https://blog.csdn.net/wenjianfeng/article/details/92033268">如何实现负载均衡？</a></h2><p>负载均衡算法：<a href="https://www.cnblogs.com/xuwc/p/14053765.html">https://www.cnblogs.com/xuwc/p/14053765.html</a></p><h2 id="同步队列和等待队列"><a href="#同步队列和等待队列" class="headerlink" title="同步队列和等待队列"></a><a href="https://blog.csdn.net/makecontral/article/details/78135531">同步队列和等待队列</a></h2><h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a><a href="https://segmentfault.com/a/1190000013075736">中间人攻击</a></h2><h2 id="实现BST"><a href="#实现BST" class="headerlink" title="实现BST"></a>实现BST</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BstTree</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getMin</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">while</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getMax</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">while</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">insertIntoBST</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        root = insertIntoBST(root, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">            root.right=  insertIntoBST(root.right,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        root = deleteNode(root, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete 考虑不同分支情况， 删除操作也需要自顶向下遍历查找到待删除节点位置</span></span><br><span class="line">    <span class="comment">// 0. 待删除节点为根节点</span></span><br><span class="line">    <span class="comment">// 1. 待删除节点无左孩子，用右孩子替代删除节点</span></span><br><span class="line">    <span class="comment">// 2. 待删除节点无右孩子，用左孩子替代删除节点</span></span><br><span class="line">    <span class="comment">// 3. 待删除节点既有右孩子又有左孩子，找到右子树的最小值替换待删除节点，然后删除右子树最小值</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">            root.right= deleteNode(root.right,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">            root.left = deleteNode(root.left,val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.right ==<span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode minNode = getMin(root);</span><br><span class="line">                root.val = minNode.val;</span><br><span class="line">                root.right = deleteNode(root.right,val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchBST</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        TreeNode target = searchBST(root, val);</span><br><span class="line">        <span class="keyword">return</span> target == <span class="keyword">null</span> ? -<span class="number">1</span> : target.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &gt; root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考博客：<a href="https://blog.csdn.net/huangdingsheng/article/details/99843453">https://blog.csdn.net/huangdingsheng/article/details/99843453</a></p><p>​                   <a href="https://blog.csdn.net/sheepmu/article/details/38407221?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">https://blog.csdn.net/sheepmu/article/details/38407221?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.baidujs</a></p><h2 id="float和double的区别"><a href="#float和double的区别" class="headerlink" title="float和double的区别"></a><a href="https://www.cnblogs.com/liutianci/p/8443372.html">float和double的区别</a></h2><h2 id="GCRoot有哪些"><a href="#GCRoot有哪些" class="headerlink" title="GCRoot有哪些"></a>GCRoot有哪些</h2><p> JVM垃圾回收的根对象的范围有以下几种：</p><p>（1）虚拟机（JVM）栈中引用对象<br>（2）方法区中的类静态属性引用对象</p><p>（3）方法区中常量引用的对象（final 的常量值）</p><p>（4）本地方法栈JNI的引用对象</p><h2 id="对多线程的理解"><a href="#对多线程的理解" class="headerlink" title="对多线程的理解"></a>对多线程的理解</h2><p><strong>多线程指的是在单个程序中可以同时运行多个不同的线程，执行不同的任务</strong></p><p>多线程并发编程是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。</p><p>并发编程三要素：原子性，可见性，有序性 。从这三个要素说一下如何保证多线程运行安全</p><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。</p><p>索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。索引提供指向存储在表的指定列中的数据值的指针，然后根据您指定的排序顺序对这些指针排序。</p><h2 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a><a href="https://blog.csdn.net/MoreeVan/article/details/11977115?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs">AOP原理</a></h2><h2 id="三种垃圾收集算法的优劣"><a href="#三种垃圾收集算法的优劣" class="headerlink" title="三种垃圾收集算法的优劣"></a>三种垃圾收集算法的优劣</h2><p><strong>标记清除算法</strong></p><p>​    优点：标记-清除算法实现起来比较容易</p><p>​    缺点：但是有一个比较严重的问题就是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。</p><p><strong>复制算法</strong></p><pre><code> 优点：这种算法虽然实现简单，运行高效且不容易产生内存碎片。 缺点：但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。</code></pre><p><strong>标记整理算法</strong></p><p>​    优点：碎片少 内存利用率高</p><p>​    缺点：算法复杂度大，执行步骤较多</p><h2 id="TCP和HTTP的区别"><a href="#TCP和HTTP的区别" class="headerlink" title="TCP和HTTP的区别"></a>TCP和HTTP的区别</h2><p> http是要基于TCP连接基础上的，简单的说，TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http是用来收发数据，即实际应用上来的。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理的代理类是实现了一个InvocationHandler的接口，我们通过reflect.Proxy的类的newProxyInstance方法就可以得到这个接口的实例，然后再来作为参数传递进去，这里每一个在代理类上处理的东西也会被重定向到调用处理器上。</p><p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/log\source_posts\面经总结\image-20210423105943552.png" alt="image-20210423105943552"></p><p>如果一个对象的a方法调用b方法不会触发动态代理 因为没有调用对象的代理类 </p><h2 id="JVM频繁Full-GC的解决经验"><a href="#JVM频繁Full-GC的解决经验" class="headerlink" title="JVM频繁Full GC的解决经验"></a><a href="https://blog.csdn.net/zhangfengaiwuyan/article/details/89380008">JVM频繁Full GC的解决经验</a></h2><h2 id="为什么会有STW"><a href="#为什么会有STW" class="headerlink" title="为什么会有STW"></a>为什么会有STW</h2><p>在进行标记的时候，如果工作线程不停止的话，那么肯定会有新对象生成。这些对象是没有被标记的，里面可能有存活的对象，也可能有已经没有被引用的垃圾对象。那么在标记完后，进行回收时。要如何回收？</p><h2 id="为什么在-JDK8-中要将-HashMap-的链表转为红黑树"><a href="#为什么在-JDK8-中要将-HashMap-的链表转为红黑树" class="headerlink" title="为什么在 JDK8 中要将 HashMap 的链表转为红黑树"></a>为什么在 JDK8 中要将 HashMap 的链表转为红黑树</h2><p>因为通常情况下，链表长度很难达到8，但是特殊情况下链表长度为8，哈希表容量又很大，造成链表性能很差的时候，只能采用红黑树提高性能，这是一种应对策略。</p><h2 id="HashMap时间复杂度"><a href="#HashMap时间复杂度" class="headerlink" title="HashMap时间复杂度"></a><a href="https://blog.csdn.net/LoveMyTail/article/details/107286727">HashMap时间复杂度</a></h2><h2 id="用-token-来验证信息和用密码登录的区别"><a href="#用-token-来验证信息和用密码登录的区别" class="headerlink" title="用 token 来验证信息和用密码登录的区别"></a><a href="https://blog.csdn.net/ly_twt/article/details/102217361">用 token 来验证信息和用密码登录的区别</a></h2><h2 id="oss和Oauth2-0"><a href="#oss和Oauth2-0" class="headerlink" title="oss和Oauth2.0"></a>oss和Oauth2.0</h2><p>OAuth2.0</p><ul><li><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></li><li><a href="https://www.cnblogs.com/flashsun/p/7424071.html">https://www.cnblogs.com/flashsun/p/7424071.html</a></li><li>代码实现：<a href="https://www.zifangsky.cn/1313.html">https://www.zifangsky.cn/1313.html</a></li></ul><p>OSS</p><ul><li><a href="https://www.zifangsky.cn/1313.html">https://www.zifangsky.cn/1313.html</a></li><li>代码：<a href="https://gitee.com/zifangsky/OAuth2.0Demo/tree/master#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D">https://gitee.com/zifangsky/OAuth2.0Demo/tree/master#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D</a></li></ul><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ol><li><p>介绍一下项目</p></li><li><p>项目对JVM内存方面的考虑？</p></li><li><p>Redis存了啥？为什么要这么存？</p></li><li><p>项目有没有安全性考虑</p></li><li><p><strong>你的优势和劣势？</strong></p><ol><li>自学能力强、抗压能力强、能理解他人 懂得换位思考、责任心强、善于决策,独立思考</li><li>不注重细节、喜欢争论、过于理想化、不愿意承认失败、太追求细节导致拖延、不善于决策、不愿意寻求帮助、</li></ol></li><li><p>业余爱好</p></li><li><p>这几年的职业规划</p><ol><li>我今年刚毕业，对于工作方面的事情还没有一个很清楚的概念，不过我会在工作中不断的学习，切实的去了解工作当中所需要的技能。<br>更了解这个行业之后，我也会有针对性的改变自己的学习计划，使自己更加适应这个行业，朝着行业的大方向去发展。</li></ol></li></ol><ol start="8"><li></li></ol>]]></content>
    
    
    <summary type="html">面经总结</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>秒杀项目</title>
    <link href="http://example.com/2021/03/26/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/"/>
    <id>http://example.com/2021/03/26/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-03-26T07:31:25.000Z</published>
    <updated>2021-03-26T11:12:41.861Z</updated>
    
    <content type="html"><![CDATA[<p>使用Mybatis-generator生成数据库文件的映射</p><p>密码单独存放一张表</p><p><img src="/2021/03/26/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/log\source_posts\秒杀项目\image-20210326161412600.png" alt="image-20210326161412600"></p><p>创建一个model 用于封装用户信息和密码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;性别不能不填写&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Byte gender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;年龄不能不填写&quot;)</span></span><br><span class="line">    <span class="meta">@Min(value = 0, message = &quot;年龄必须大于0岁&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 150, message = &quot;年龄必须小于150岁&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;手机号不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String telphone;</span><br><span class="line">    <span class="keyword">private</span> String regisitMode;</span><br><span class="line">    <span class="keyword">private</span> Integer thirdPartyId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String encrptPassword;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>展示用户信息的时候不应该把密码展示出来 所以创建一个viewObject</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Byte gender;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String telphone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用Mybatis-generator生成数据库文件的映射&lt;/p&gt;
&lt;p&gt;密码单独存放一张表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/03/26/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/log\source_posts\秒杀项目\im</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="项目" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>linux笔记</title>
    <link href="http://example.com/2021/03/23/linux%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/03/23/linux%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-23T08:05:07.000Z</published>
    <updated>2021-03-26T12:19:40.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在线求助"><a href="#在线求助" class="headerlink" title="在线求助"></a>在线求助</h1><ul><li>man command</li><li>command –help</li><li>info command</li></ul><h1 id="正确关机的方法"><a href="#正确关机的方法" class="headerlink" title="正确关机的方法"></a>正确关机的方法</h1><p>sync：数据同步写入磁盘</p><p>shutdown</p><p><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210323161537168.png" alt="image-20210323161537168"></p><p>reboot：重启</p><p>halt：系统停止</p><p>poweoff：系统关机</p><h1 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h1><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210323163238399.png" alt="image-20210323163238399"></p><p>第一个字符如果是-则是文件d则是目录 l为link file</p><p>chgrp：</p><p><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210323163837943.png" alt="image-20210323163837943"></p><p>chown：</p><p><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210323163858673.png" alt="image-20210323163858673"></p><p>chmod：</p><ul><li>r:4 w:2 x:1</li><li><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210323164137541.png" alt="image-20210323164137541"></li><li>chmod u=rwx,go=rx test</li><li>chmod a-x test</li></ul><h3 id="目录权限"><a href="#目录权限" class="headerlink" title="目录权限"></a>目录权限</h3><p><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210323164503845.png" alt="image-20210323164503845"></p><p><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210323164618407.png" alt="image-20210323164618407"></p><p>x代表的是用户能否进入该目录成为工作目录</p><h2 id="目录和文件操作"><a href="#目录和文件操作" class="headerlink" title="目录和文件操作"></a>目录和文件操作</h2><p>cd：切换目录</p><p>pwd：显示当前目录</p><p>mkdir：创建新目录</p><p>rmdir：删除空目录</p><p>ls</p><ul><li>-a : 列出全部的文件 包括隐藏档(开头为.的文件)</li><li>-d：仅列出目录本身 </li><li>-l：列出文件的属性和权限等数据</li></ul><p>cp：复制</p><p>rm：删除</p><p>mv：移动</p><p>获得文件名和目录名</p><p><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210323165540449.png" alt="image-20210323165540449"></p><h2 id="文件查阅"><a href="#文件查阅" class="headerlink" title="文件查阅"></a>文件查阅</h2><p>cat</p><ul><li>-n：打印出行号 </li><li>-b：列出行号 但是空白行跳过</li></ul><p>head -n number fileName ：取出前几行</p><p>tail -n number fileName：取出后几行</p><p>more和less可以一行一行翻阅</p><p>touch：创建文件</p><p>file fileName：查看文件类型</p><h2 id="指令与文件搜寻"><a href="#指令与文件搜寻" class="headerlink" title="指令与文件搜寻"></a>指令与文件搜寻</h2><p>which：搜寻指令的文件名</p><p>whereis：在特定目录中查找文件名</p><p><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210326194047411.png" alt="image-20210326194047411"></p><p>locate：根据/var/lib/mlocate内的数据库的记载，找出用户输入的关键词(keyword)文件名。默认一天更新一次数据库</p><ul><li><p><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210326194533561.png" alt="image-20210326194533561"></p></li><li><p>updated：手动更新，根据/etc/updatedb.conf的设定去搜寻系统硬盘内的文件名，并更新mlocate内的数据库文件。</p></li></ul><p>find</p><p>​    </p>]]></content>
    
    
    <summary type="html">学习linux操作系统和命令使用</summary>
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://example.com/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-22T06:35:27.000Z</published>
    <updated>2021-03-27T06:09:36.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="七大设计原则"><a href="#七大设计原则" class="headerlink" title="七大设计原则"></a>七大设计原则</h1><p>设计模式的目的：代码重用性高 可读性强 可扩展 可靠性高 使程序高内聚 低耦合</p><p>设计原则是各种设计模式的基础</p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>对类来说 一个类应该只负责一项职责 </p><p>例如：类A负责两个不同职责a，b当a需求变更而改变A时 可能造成b执行错误 所以将类A的粒度分解成A1，A2</p><p>注意事项</p><ul><li>降低类的复杂度 一个类只负责一项职责</li><li>提高类的可选性，可维护性</li><li>降低变更而引起的影响</li></ul><p>方案一：在方式1的run方法中，违反了单一职责原则.解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility1</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">      vehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">      vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">      vehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交通工具类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">      System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案二：遵守单一职责原则但是这样做的改动很大，即将类分解，同时修改客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      RoadVehicle roadVehicle = <span class="keyword">new</span> RoadVehicle();</span><br><span class="line">      roadVehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line"></span><br><span class="line">      AirVehicle airVehicle = <span class="keyword">new</span> AirVehicle();</span><br><span class="line">      airVehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      WaterVehicle waterVehicle = <span class="keyword">new</span> WaterVehicle();</span><br><span class="line">      waterVehicle.run(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadVehicle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">      System.out.println(vehicle + <span class="string">&quot;公路运行&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirVehicle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">      System.out.println(vehicle + <span class="string">&quot;天空运行&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterVehicle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">      System.out.println(vehicle + <span class="string">&quot;水中运行&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案三：这种修改方法没有对原来的类做大的修改，只是增加方法，这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      Vehicle2 vehicle2  = <span class="keyword">new</span> Vehicle2();</span><br><span class="line">      vehicle2.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">      vehicle2.runWater(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">      vehicle2.runAir(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">      System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAir</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">      System.out.println(vehicle + <span class="string">&quot; 在天空上运行....&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runWater</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">      System.out.println(vehicle + <span class="string">&quot; 在水中行....&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>客户端不应该依赖其他不需要的接口 即一个类对另一个类的依赖应该建立在最小的接口上</p><p> <img src="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/log\source_posts\设计模式\image-20210322144710531.png" alt="image-20210322144710531"></p><p>Interface1对于AC不是最小接口并且BD必须去实现他们不需要的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;B 实现了 operation4&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;B 实现了 operation5&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;D 实现了 operation1&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;D 实现了 operation2&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;D 实现了 operation3&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;D 实现了 operation4&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;D 实现了 operation5&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A 类通过接口Interface1 依赖(使用) B类，但是只会用到1,2,3方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">      i.operation1();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">      i.operation2();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">      i.operation3();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C 类通过接口Interface1 依赖(使用) D类，但是只会用到1,4,5方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">      i.operation1();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">      i.operation4();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">      i.operation5();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法：将接口Interface1拆分为独立的几个接口，类A和类c分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则<br><img src="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/log\source_posts\设计模式\image-20210322144907809.png" alt="image-20210322144907809"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface3</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface3</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;D 实现了 operation1&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;D 实现了 operation4&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;D 实现了 operation5&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">      i.operation1();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface2 i)</span> </span>&#123;</span><br><span class="line">      i.operation2();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface2 i)</span> </span>&#123;</span><br><span class="line">      i.operation3();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><ol><li><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象</p></li><li><p>依赖倒转的中心思想是面向接口编程</p></li><li><p>依赖倒转原则是基于这样的设计理念:相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类,细节就是具体的实现类</p></li><li><p>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</p></li></ol><p><img src="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/log\source_posts\设计模式\image-20210322150008224.png" alt="image-20210322150008224"></p><p>注意事项</p><ul><li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.</li><li>变量的声明类型尽量是抽象类或接口,这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化</li><li>继承时遵循里氏替换原则</li></ul><p>方法一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完成Person接收消息的功能</span></span><br><span class="line"><span class="comment">//1. 简单，比较容易想到</span></span><br><span class="line"><span class="comment">//2. 如果我们获取的对象是 微信，短信等等，则需要新增类，同时Perons也要增加相应的接收方法</span></span><br><span class="line"><span class="comment">//3. 解决思路：引入一个抽象的接口IReceiver, 表示接收者, 这样Person类与接口IReceiver发生依赖</span></span><br><span class="line"><span class="comment">//   因为Email, WeeiiXiin 等等属于接收的范围，他们各自实现IReceiver 接口就ok, 这样我们就符号依赖倒转原则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Email email )</span> </span>&#123;</span><br><span class="line">      System.out.println(email.getInfo());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//客户端无需改变</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.receive(<span class="keyword">new</span> Email());</span><br><span class="line"></span><br><span class="line">person.receive(<span class="keyword">new</span> WeiXin());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加微信</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiXin</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;微信信息: hello,ok&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里我们是对接口的依赖</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceiver receiver )</span> </span>&#123;</span><br><span class="line">System.out.println(receiver.getInfo());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><ol><li>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</li><li>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法</li><li>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合,依赖来解决问题。</li></ol><p>方案一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Liskov</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      A a = <span class="keyword">new</span> A();</span><br><span class="line">      System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">      B b = <span class="keyword">new</span> B();</span><br><span class="line">      System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11-3</span></span><br><span class="line">      System.out.println(<span class="string">&quot;1-8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1-8</span></span><br><span class="line">      System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 返回两个数的差</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 - num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这里，重写了A类的方法, 可能是无意的</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Liskov</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      A a = <span class="keyword">new</span> A();</span><br><span class="line">      System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">      B b = <span class="keyword">new</span> B();</span><br><span class="line">      <span class="comment">//因为B类不再继承A类，因此调用者，不会再func1是求减法</span></span><br><span class="line">      <span class="comment">//调用完成的功能就会很明确</span></span><br><span class="line">      System.out.println(<span class="string">&quot;11+3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11+3</span></span><br><span class="line">      System.out.println(<span class="string">&quot;1+8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1+8</span></span><br><span class="line">      System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//使用组合仍然可以使用到A类相关方法</span></span><br><span class="line">      System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func3(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">// 这里本意是求出11-3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个更加基础的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">   <span class="comment">//把更加基础的方法和成员写到Base类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 返回两个数的差</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 - num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">   <span class="comment">//如果B需要使用A类的方法,使用组合关系</span></span><br><span class="line">   <span class="keyword">private</span> A a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//我们仍然想使用A的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.a.func1(a, b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节。</p><p>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p><p> 方法一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//使用看看存在的问题</span></span><br><span class="line">      GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">   <span class="comment">//接收Shape对象，然后根据type，来绘制不同的图形</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (s.m_type == <span class="number">1</span>)</span><br><span class="line">         drawRectangle(s);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>)</span><br><span class="line">         drawCircle(s);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">3</span>)</span><br><span class="line">         drawTriangle(s);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//绘制矩形</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//绘制圆形</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//绘制三角形</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTriangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   Rectangle() &#123;</span><br><span class="line">      <span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   Circle() &#123;</span><br><span class="line">      <span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   Triangle() &#123;</span><br><span class="line">      <span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//使用看看存在的问题</span></span><br><span class="line">      GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> OtherGraphic());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">   <span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">      s.draw();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"><span class="comment">// int m_type;</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"><span class="comment">// Rectangle() &#123;</span></span><br><span class="line"><span class="comment">//    super.m_type = 1;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"><span class="comment">// Circle() &#123;</span></span><br><span class="line"><span class="comment">//    super.m_type = 2;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"><span class="comment">// Triangle() &#123;</span></span><br><span class="line"><span class="comment">//    super.m_type = 3;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增一个图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherGraphic</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"><span class="comment">// OtherGraphic() &#123;</span></span><br><span class="line"><span class="comment">//    super.m_type = 4;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制其它图形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><ol><li>一个对象应该对其他对象保持最少的了解类与类关系越密切，耦合度越大</li><li>迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息</li><li>迪米特法则还有个更简单的定义:只与直接的朋友通信</li><li>直接的朋友:每个对象都会与其他对象耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</li></ol><p>方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">      SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">      <span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">      schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">   <span class="comment">//返回学院的所有员工</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">         CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">         emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">         list.add(emp);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">   <span class="comment">//返回学校总部的员工</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">         Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">         emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">         list.add(emp);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//分析问题</span></span><br><span class="line">      <span class="comment">//1. 这里的 CollegeEmployee 不是  SchoolManager的直接朋友</span></span><br><span class="line">      <span class="comment">//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager</span></span><br><span class="line">      <span class="comment">//3. 违反了 迪米特法则</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取到学院员工</span></span><br><span class="line">      List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();</span><br><span class="line">      System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">         System.out.println(e.getId());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//获取到学校总部员工</span></span><br><span class="line">      List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">      System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">         System.out.println(e.getId());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;~~~使用迪米特法则的改进~~~&quot;</span>);</span><br><span class="line">      <span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">      SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">      <span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">      schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">   <span class="comment">//返回学院的所有员工</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">         CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">         emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">         list.add(emp);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//输出学院员工的信息</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//获取到学院员工</span></span><br><span class="line">      List&lt;CollegeEmployee&gt; list1 = getAllEmployee();</span><br><span class="line">      System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">         System.out.println(e.getId());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">   <span class="comment">//返回学校总部的员工</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">         Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">         emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">         list.add(emp);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//分析问题</span></span><br><span class="line">      <span class="comment">//1. 将输出学院的员工方法，封装到CollegeManager</span></span><br><span class="line">      sub.printEmployee();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取到学校总部员工</span></span><br><span class="line">      List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">      System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">         System.out.println(e.getId());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>尽量使用合成/聚合的方式 而不是使用继承</p><p>博客：<a href="https://blog.csdn.net/u012361379/article/details/88605867">https://blog.csdn.net/u012361379/article/details/88605867</a></p><h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><p><a href="https://blog.csdn.net/tianhai110/article/details/6339565">继承、实现、依赖、关联、聚合、组合的联系与区别 </a></p><p>依赖关系：只要在类中用到了对方 他们之间就存在依赖关系 可以是成员属性 方法的返回类型 方法的参数</p><p>泛化关系：实际上就是继承关系 是依赖关系的特列</p><p>实现关系：A类实现B类 是依赖关系的特列</p><p>关联关系：他是依赖关系的特列 是一种拥有的关系,它使一个类知道另一个类的属性和方法。关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</p><p>  <img src="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/log\source_posts\设计模式\image-20210323141002509.png" alt="image-20210323141002509"></p><p>聚合关系：表现的是整体与部分的关系 是关联关系的特例 有导航性和多重性 如果整体与部分可以分开就是聚合 不能分开就是组合</p><p>组合关系：整体与部分的关系  但是整体与部分不可分开</p><p>组合和聚合的区别: <a href="https://blog.csdn.net/willlu10/article/details/79346948">https://blog.csdn.net/willlu10/article/details/79346948</a></p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>模式是解决某类问题的通用解决方法</p><p>设计模式分为三种类型 共23种（实际开发中 不止23种 可能会有其他变种 要灵活运用）</p><ul><li>创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。</li><li>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</li><li>行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式(Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)。</li></ul><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>概念：采取一定的方法保证在整个的软件系统中 对某个类只能存在一个对象实例 并且改类只提供一个取得其对象实例的方法</p><p>单列模式有以下八种方式</p><h3 id="饿汉式-静态常量"><a href="#饿汉式-静态常量" class="headerlink" title="饿汉式 静态常量"></a>饿汉式 静态常量</h3><p>这种方式在类加载的时候就完成实例化 避免了线程同步问题 如果从始至终从未使用过这个类 则会造成内存浪费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1. 构造器私有化, 外部能new</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉式-静态代码块"><a href="#饿汉式-静态代码块" class="headerlink" title="饿汉式 静态代码块"></a>饿汉式 静态代码块</h3><p>这种方式和上一种优缺点相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式(静态变量)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1. 构造器私有化, 外部能new</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">   <span class="keyword">private</span>  <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123; <span class="comment">// 在静态代码块中，创建单例对象</span></span><br><span class="line">      instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式 线程不安全"></a>懒汉式 线程不安全</h3><p>只能在单线程下使用 如果多线程下 一个线程进入判断语句 还未来得及往下执行 另一个线程也通过了这个判断语句 就会产生多个实例 所以在多线程环境下不可使用这种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建 instance</span></span><br><span class="line">   <span class="comment">//即懒汉式</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式-线程安全-同步方法"><a href="#懒汉式-线程安全-同步方法" class="headerlink" title="懒汉式 线程安全 同步方法"></a>懒汉式 线程安全 同步方法</h3><p>虽然解决线程不安全问题 但是效率太低 每次获得类的实例都要进行同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">   <span class="comment">//即懒汉式</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式-线程安全-同步代码块"><a href="#懒汉式-线程安全-同步代码块" class="headerlink" title="懒汉式 线程安全 同步代码块"></a>懒汉式 线程安全 同步代码块</h3><p> 这种方法不能起到线程同步的作用 假如一个线程进入了if判断 还没来得及向下执行 其他线程也通过了这个if会创建多个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h3><p>实例化代码块只执行一次 后面再次访问时直接返回实例化对象 也避免了反复进行同步 线程安全 延迟加载 效率较高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span></span><br><span class="line">   <span class="comment">//同时保证了效率, 推荐使用</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">               instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>线程安全 延迟加载 效率较高 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态内部类完成， 推荐使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//构造器私有化</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//写一个静态内部类,该类中有一个静态属性 Singleton</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用枚举，可以实现单例, 推荐</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   INSTANCE; <span class="comment">//属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能<br>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new </p><p>单例模式使用的场景:需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即:重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session工厂等)</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="简单工厂模式-静态工厂方法"><a href="#简单工厂模式-静态工厂方法" class="headerlink" title="简单工厂模式/ 静态工厂方法"></a>简单工厂模式/ 静态工厂方法</h3><p>定义了一个创建对象的类 由这个类来封装实例化对象的行为</p><p>违反了开闭原则</p><p><a href="https://www.jianshu.com/p/5cb52d84bd6d">博客(静态工厂)</a></p><p><a href="https://www.runoob.com/design-pattern/factory-pattern.html">菜鸟教程（非静态）</a></p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p><strong>工厂父类负责定义创建产品对象的公共接口</strong>，而工厂子类则负责生成具体的产品对象，这样做的目的是<strong>将产品类的实例化操作延迟到工厂子类中完成</strong>，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><p><a href="https://www.jianshu.com/p/c33e0848341e">博客</a></p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂是创建型设计模式，它强调了一系列相关产品对象（属于同一个产品族）的创建过程，它和工厂方法模式]的侧重点不同，工厂方法模式更加侧重于同一产品等级，而抽象工厂模式侧重的是同一产品族</p><p><a href="https://blog.csdn.net/start_mao/article/details/85946950?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase">博客 </a>     </p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式(Prototype模式)是指:用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象<br>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象,无需知道如何创建的细节<br>工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone()</p><p>关于深拷贝：<a href="https://www.cnblogs.com/xinruyi/p/11537963.html">https://www.cnblogs.com/xinruyi/p/11537963.html</a></p><p>博客：<a href="https://www.runoob.com/design-pattern/prototype-pattern.html">https://www.runoob.com/design-pattern/prototype-pattern.html</a></p><p>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">private</span> String color;</span><br><span class="line">   <span class="keyword">private</span> String address = <span class="string">&quot;蒙古羊&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> Sheep friend; <span class="comment">//是对象, 克隆是会如何处理</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name, <span class="keyword">int</span> age, String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">      <span class="keyword">this</span>.color = color;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> color;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.color = color;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Sheep [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, color=&quot;</span> + color + <span class="string">&quot;, address=&quot;</span> + address + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">      Sheep sheep = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         sheep = (Sheep)<span class="keyword">super</span>.clone();</span><br><span class="line">         sheep.friend = (Sheep)friend.clone();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">         System.out.println(e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      <span class="keyword">return</span> sheep;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;原型模式完成对象的创建&quot;</span>);</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">&quot;tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line"></span><br><span class="line">      sheep.friend = <span class="keyword">new</span> Sheep(<span class="string">&quot;jack&quot;</span>, <span class="number">2</span>, <span class="string">&quot;黑色&quot;</span>);</span><br><span class="line"></span><br><span class="line">      Sheep sheep2 = (Sheep)sheep.clone();</span><br><span class="line">      Sheep sheep3 = (Sheep)sheep.clone();</span><br><span class="line">      Sheep sheep4 = (Sheep)sheep.clone();</span><br><span class="line">      Sheep sheep5 = (Sheep)sheep.clone();</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;sheep2 =&quot;</span> + sheep2 + <span class="string">&quot;sheep2.friend=&quot;</span> + sheep2.friend.hashCode());</span><br><span class="line">      System.out.println(<span class="string">&quot;sheep3 =&quot;</span> + sheep3 + <span class="string">&quot;sheep3.friend=&quot;</span> + sheep3.friend.hashCode());</span><br><span class="line">      System.out.println(<span class="string">&quot;sheep4 =&quot;</span> + sheep4 + <span class="string">&quot;sheep4.friend=&quot;</span> + sheep4.friend.hashCode());</span><br><span class="line">      System.out.println(<span class="string">&quot;sheep5 =&quot;</span> + sheep5 + <span class="string">&quot;sheep5.friend=&quot;</span> + sheep5.friend.hashCode());</span><br><span class="line">      System.out.println(sheep3.friend == sheep4.friend);</span><br><span class="line">      System.out.println(sheep3 == sheep4);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦,使得相同的创建过程可以创建不同的产品对象<br>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象<br>可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程<br>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”</p><p>四个角色：</p><ul><li>Product：一个具体的产品对象</li><li>Builder：创建一个Product对象的各个部件指定的接口/抽象类</li><li>ConcreteBuidler：实现接口 ，构建和装配各个部件</li><li>Director：构建一个使用Builder接口的对象，它主要用于创建一个复杂的对象，有两个主要作用</li><li>隔离了客户与对象的生产过程<ul><li>负责控制产品对象的生产过程</li></ul></li></ul><p><img src="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/log\source_posts\设计模式\image-20210324095013395.png" alt="image-20210324095013395"></p><p>博客：<a href="https://www.jianshu.com/p/3d1c9ffb0a28">https://www.jianshu.com/p/3d1c9ffb0a28</a></p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p> 基本介绍</p><ul><li>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)</li><li>主要分为三类：类适配器模式，对象适配器模式，接口适配器模式</li></ul><p>原理</p><ul><li>将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容</li><li>从用户的角度看不到被适配者，是解耦的</li><li>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</li><li>用户收到反馈结果，感觉只是和目标接口交互，如图</li></ul><p><img src="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/log\source_posts\设计模式\image-20210324095934939.png" alt="image-20210324095934939"></p><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><p> Adapter类通过继承src类并实现dst接口 完成src-&gt;dst的适配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">   <span class="comment">//输出220V的电压</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;电压=&quot;</span> + src + <span class="string">&quot;伏&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> src;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dst</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      <span class="comment">//获取到220V电压</span></span><br><span class="line">      <span class="keyword">int</span> srcV = output220V();</span><br><span class="line">      <span class="keyword">int</span> dstV = srcV / <span class="number">44</span> ; <span class="comment">//转成 5v</span></span><br><span class="line">      <span class="keyword">return</span> dstV;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//充电</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charging</span><span class="params">(IVoltage5V iVoltage5V)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(iVoltage5V.output5V() == <span class="number">5</span>) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;电压为5V, 可以充电~~&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iVoltage5V.output5V() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;电压大于5V, 不能充电~~&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot; === 类适配器模式 ====&quot;</span>);</span><br><span class="line">      Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">      phone.charging(<span class="keyword">new</span> VoltageAdapter());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点</p><ul><li>Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点，因为这要求dst必须是接口，有一定局限性;</li><li>src类的方法在Adapter中都会暴露出来，也增加了使用的成本。</li><li>由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。</li></ul><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p>基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题。即:持有src类，实现 dst类接口，完成src-&gt;dst的适配。根据合成复用原则，使用组合替代继承，所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口。使用成本更低，更灵活</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">   <span class="comment">//输出220V的电压，不变</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;电压=&quot;</span> + src + <span class="string">&quot;伏&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> src;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dst</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span>  <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Voltage220V voltage220V; <span class="comment">// 关联关系-聚合</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//通过构造器，传入一个 Voltage220V 实例</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter</span><span class="params">(Voltage220V voltage220v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.voltage220V = voltage220v;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> dst = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">null</span> != voltage220V) &#123;</span><br><span class="line">         <span class="keyword">int</span> src = voltage220V.output220V();<span class="comment">//获取220V 电压</span></span><br><span class="line">         System.out.println(<span class="string">&quot;使用对象适配器，进行适配~~&quot;</span>);</span><br><span class="line">         dst = src / <span class="number">44</span>;</span><br><span class="line">         System.out.println(<span class="string">&quot;适配完成，输出的电压为=&quot;</span> + dst);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> dst;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//充电</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charging</span><span class="params">(IVoltage5V iVoltage5V)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(iVoltage5V.output5V() == <span class="number">5</span>) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;电压为5V, 可以充电~~&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iVoltage5V.output5V() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;电压大于5V, 不能充电~~&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot; === 对象适配器模式 ====&quot;</span>);</span><br><span class="line">      Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">      phone.charging(<span class="keyword">new</span> VoltageAdapter(<span class="keyword">new</span> Voltage220V()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口适配器"><a href="#接口适配器" class="headerlink" title="接口适配器"></a>接口适配器</h3><p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法)，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求<br>适用于一个接口不想使用其所有的方法的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface4</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在AbsAdapter 我们将 Interface4 的方法进行默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsAdapter</span> <span class="keyword">implements</span> <span class="title">Interface4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//默认实现</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      AbsAdapter absAdapter = <span class="keyword">new</span> AbsAdapter() &#123;</span><br><span class="line">         <span class="comment">//只需要去覆盖我们 需要使用 接口方法</span></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">            System.out.println(<span class="string">&quot;使用了m1的方法&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      absAdapter.m1();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接模式(Bridge模式)是指:将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。<br>Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展</p><p>菜鸟教程：<a href="https://www.runoob.com/w3cnote/bridge-pattern2.html">https://www.runoob.com/w3cnote/bridge-pattern2.html</a></p><p> 角色：</p><ul><li><strong>Abstraction</strong>：抽象类。</li><li><strong>RefinedAbstraction</strong>：扩充抽象类。</li><li><strong>Implementor</strong>：实现类接口。</li><li><strong>ConcreteImplementor</strong>：具体实现类 。 </li></ul><p><img src="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/log\source_posts\设计模式\image-20210324101521361.png" alt="image-20210324101521361"></p><p><img src="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/log\source_posts\设计模式\image-20210324101528021.png" alt="image-20210324101528021"></p><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p><a href="https://www.runoob.com/design-pattern/decorator-pattern.html">https://www.runoob.com/design-pattern/decorator-pattern.html</a></p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</p><p><a href="https://www.runoob.com/design-pattern/composite-pattern.html">菜鸟教程</a></p><p>简化客户端操作:客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。<br>具有较强的扩展性:当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动.<br>方便创建出复杂的层次结构:客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构<br>需要遍历组织机构，或者处理的对象具有树形结构时，非常适合使用组合模式.要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p> 外观模式( Facade)，也叫“过程模式:外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用<br>外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节</p><p><a href="https://www.runoob.com/design-pattern/facade-pattern.html">菜鸟教程</a></p><p>外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性<br>外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展通过合理的使用外观模式，可以帮我们更好的划分访问的层次<br>当系统需要进行分层设计时，可以考虑使用Facade模式<br>在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性<br>不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的。</p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p> 享元模式（Flyweight Pattern)也叫蝇量模式:运用共享技术有效地支持大量细粒度的对象<br>常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象,可以从缓冲池里拿。这样可以降低系统内存，同时提高效率<br>享元模式经典的应用场景就是池技术了，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式</p><p> <a href="https://www.runoob.com/design-pattern/flyweight-pattern.html">菜鸟教程</a></p><p>享元模式提出了两个要求:细粒度和共享对象。这里就涉及到内部状态和外部状态了，即将对象的信息分为两个部分:内部状态和外部状态<br>内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。</p><p>比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点，所以棋子颜色就是棋子的内部状态﹔而各个棋子之间的差别就是位置的不同，当我们落子后，落子颜色是定的，但位置是变化的，所以棋子坐标就是棋子的外部状态</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>模板方法模式（Template Method Pattern），又叫模板模式(Template Pattern),在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。<br>简单说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤</p><p>钩子方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类，表示豆浆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SoyaMilk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//模板方法, make , 模板方法可以做成final , 不让子类去覆盖.</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      select();</span><br><span class="line">      <span class="keyword">if</span>(customerWantCondiments()) &#123;</span><br><span class="line">         addCondiments();</span><br><span class="line">      &#125;</span><br><span class="line">      soak();</span><br><span class="line">      beat();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//选材料</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;第一步：选择好的新鲜黄豆  &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//添加不同的配料， 抽象方法, 子类具体实现</span></span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//浸泡</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">soak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;第三步， 黄豆和配料开始浸泡， 需要3小时 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">beat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;第四步：黄豆和配料放到豆浆机去打碎  &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//钩子方法，决定是否需要添加配料</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">customerWantCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeanutSoyaMilk</span> <span class="keyword">extends</span> <span class="title">SoyaMilk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot; 加入上好的花生 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBeanSoyaMilk</span> <span class="keyword">extends</span> <span class="title">SoyaMilk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot; 加入上好的红豆 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PureSoyaMilk</span> <span class="keyword">extends</span> <span class="title">SoyaMilk</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      <span class="comment">//空实现</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">customerWantCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      <span class="comment">//制作红豆豆浆</span></span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;----制作红豆豆浆----&quot;</span>);</span><br><span class="line">      SoyaMilk redBeanSoyaMilk = <span class="keyword">new</span> RedBeanSoyaMilk();</span><br><span class="line">      redBeanSoyaMilk.make();</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;----制作花生豆浆----&quot;</span>);</span><br><span class="line">      SoyaMilk peanutSoyaMilk = <span class="keyword">new</span> PeanutSoyaMilk();</span><br><span class="line">      peanutSoyaMilk.make();</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;----制作纯豆浆----&quot;</span>);</span><br><span class="line">      SoyaMilk pureSoyaMilk = <span class="keyword">new</span> PureSoyaMilk();</span><br><span class="line">      pureSoyaMilk.make();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式(Command Pattern):在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，<br>我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计<br>命名模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。<br>在命名模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求(即命名)，同时命令模式也支持可撤销的操作。</p><p><a href="https://www.runoob.com/design-pattern/command-pattern.html">菜鸟教程</a></p><p>查看项目_1DesignPattern中命令模式的代码</p><p><img src="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/log\source_posts\设计模式\image-20210325094557402.png" alt="image-20210325094557402"></p><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>访问者模式(Visitor Pattern)，封装一些作用于某种数据结构的各元素的操作,它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。<br>主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题</p><p> <a href="https://www.runoob.com/design-pattern/visitor-pattern.html">菜鸟教程</a></p><p>具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的，这样造成了具体元素变更比较困难<br>违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素<br>因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的.</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>如果我们的集合元素是用不同的方式实现的，有数组，还有java的集合类,或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。<br>迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即:不暴露其内部的结构。</p><p> <a href="https://www.runoob.com/design-pattern/iterator-pattern.html">菜鸟教程</a></p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p> <a href="https://www.runoob.com/design-pattern/observer-pattern.html">菜鸟教程</a></p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式(Mediator Pattern)，用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</p><p>博客：<a href="http://c.biancheng.net/view/1393.html">http://c.biancheng.net/view/1393.html</a></p><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>菜鸟：<a href="https://www.runoob.com/design-pattern/memento-pattern.html">https://www.runoob.com/design-pattern/memento-pattern.html</a></p><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>菜鸟</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>菜鸟</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>菜鸟</p><p>状态模式和策略模式的区别：<a href="https://www.runoob.com/w3cnote/state-vs-strategy.html">https://www.runoob.com/w3cnote/state-vs-strategy.html</a></p><h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><p> 菜鸟</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;七大设计原则&quot;&gt;&lt;a href=&quot;#七大设计原则&quot; class=&quot;headerlink&quot; title=&quot;七大设计原则&quot;&gt;&lt;/a&gt;七大设计原则&lt;/h1&gt;&lt;p&gt;设计模式的目的：代码重用性高 可读性强 可扩展 可靠性高 使程序高内聚 低耦合&lt;/p&gt;
&lt;p&gt;设计原则是各种</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="http://example.com/2021/03/19/docker/"/>
    <id>http://example.com/2021/03/19/docker/</id>
    <published>2021-03-19T07:36:54.000Z</published>
    <updated>2021-03-26T07:03:06.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="名词概念"><a href="#名词概念" class="headerlink" title="名词概念"></a>名词概念</h1><p>镜像(image):好比一个模板 可以通过这个模板来创建容器服务 tomcat镜像 ===&gt;run ==&gt;tomcat01容器 ,通过这个镜像可以创建多个容器</p><p>容器:docker利用容器技术 独立运行一个或者一组应用 通过镜像来创建</p><p>仓库:存放镜像 分为公有仓库和私有仓库</p><h1 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h1><p>在linux上安装docker：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p><p>docker info 可以查看docker的信息 docker version可以查看docker版本</p><p>安装要使用国内的镜像地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure><p>如果运行的镜像没有 会从中央仓库下载 指令 <code>docker images </code> 查看镜像</p><p>启动docker:<code>systemctl start docker</code></p><p>查看版本:<code>docker -v</code></p><p>配置镜像加速</p><ul><li>mkdir -p /etc/docker</li><li>vim /etc/docker/daemon.json.rpmsave<ul><li><img src="/2021/03/19/docker/image-20201106103334369.png" alt="image-20201106103334369"></li></ul></li><li>systemctl daemon-reload</li><li>systemctl restart docker</li></ul><h1 id="docker原理"><a href="#docker原理" class="headerlink" title="docker原理"></a>docker原理</h1><p><img src="/2021/03/19/docker/log\source_posts\docker\image-20210326144801192.png" alt="image-20210326144801192"></p><p>docker为什么比vm快</p><ul><li>Docker有着比虚拟机更少的抽象层</li><li>docker利用的是宿主机的内核，vm需要Guest OS（虚拟机中的系统）</li></ul><p><img src="/2021/03/19/docker/log\source_posts\docker\image-20210326144957674.png" alt="image-20210326144957674"></p><h1 id="镜像的基本命令"><a href="#镜像的基本命令" class="headerlink" title="镜像的基本命令"></a>镜像的基本命令</h1><p>参考文档：<a href="https://docs.docker.com/engine/reference/commandline/docker/">https://docs.docker.com/engine/reference/commandline/docker/</a></p><p>docker images 显示镜像信息 </p><ul><li>-q只显示镜像的id </li><li>-a显示全部镜像</li><li>–digests:显示镜像的摘要信息</li><li>–no-trunc:显示完整的镜像信息</li></ul><p>docker search 搜索镜像</p><ul><li>-s n 收藏数不小于n的镜像</li><li>–no-trunc:显示完整的镜像信息</li><li>–automated:只列出automated build类型的镜像</li></ul><p>docker pull 拉取镜像 默认拉取最新版本</p><p>docker rmi 删除镜像 默认删除最新版本 需要先把容器停止 或者使用-f强制删除</p><ul><li>删除全部 docker -rmi -f $(docker images -qa)</li></ul><h1 id="容器的基本命令"><a href="#容器的基本命令" class="headerlink" title="容器的基本命令"></a>容器的基本命令</h1><p>新建容器并启动：docker run [可选参数] image</p><ul><li>–name = ‘’容器名字’’  为容器起一个名字如果不指定 随机分配一个名字</li><li>-d 后台方式运行</li><li>-i 使用交互方式运行 </li><li>-t 为容器重新分配一个伪输入端口 通常与i同时使用</li><li>-p:指定容器的端口</li><li>-P:随机端口映射</li><li>-p 主机端口:docker容器端口</li></ul><p>退出容器</p><ul><li>exit:容器停止并退出</li><li>crtl+p+q:容器不停止退出</li></ul><p>查看正在运行的容器：docker ps</p><ul><li>-a:列出当前所有正在运行的容器+历史上运行过的</li><li>-l:显示最近创建的容器</li><li>-n:显示最近n个创建的容器</li><li>-q:静默模式，只显示容器编号</li><li>–no-trunc:不截断输出</li></ul><p>启动容器docker start</p><p>重启容器docker restart</p><p>停止容器docker stop</p><p>强制停止容器docker kill</p><p>删除已停止的容器docker rm 容器id 加上参数-f可以强制删除</p><ul><li>一次性删除多个容器<ul><li>docker rm -f ${docker ps -a -q}</li><li>docker ps -a -q|xargs docker rm</li></ul></li></ul><p>查看容器日志docker logs -f -t –tail n 容器id </p><ul><li>-f可以不停的追加 实时显示日志信息</li></ul><p>查看容器内运行的进程 docke top 容器id</p><p>查看容器内部细节：docker inspect id</p><p>进入正在运行的容器并以命令行方式交互</p><ul><li><p>命令一：<code>docker exec -it 容器id /bin/bash</code>   进去容器后开启一个新的终端 可以在里面进行一些操作</p></li><li><p>命令二：<code>docker attach 容器id</code>      进入容器正在执行的终端 不会启动新的进程</p></li></ul><h1 id="从容器内拷贝文件到主机"><a href="#从容器内拷贝文件到主机" class="headerlink" title="从容器内拷贝文件到主机"></a>从容器内拷贝文件到主机</h1><p><img src="/2021/03/19/docker/log\source_posts\docker\image-20210326144737928.png" alt="image-20210326144737928"></p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="部署mongodb"><a href="#部署mongodb" class="headerlink" title="部署mongodb"></a>部署mongodb</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">pull</span> <span class="selector-tag">mongo</span><span class="selector-pseudo">:latest</span></span><br><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">run</span> <span class="selector-tag">-itd</span> <span class="selector-tag">--name</span> <span class="selector-tag">mongo</span> <span class="selector-tag">-p</span> 27017<span class="selector-pseudo">:27017</span> <span class="selector-tag">mongo</span> <span class="selector-tag">--auth</span> <span class="selector-id">#--auth</span>表示需要密码才能访问容器服务</span><br><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">exec</span> <span class="selector-tag">-it</span> <span class="selector-tag">mongo</span> <span class="selector-tag">mongo</span> <span class="selector-tag">admin</span></span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.createUser</span>(&#123; <span class="attribute">user</span>:<span class="string">&#x27;admin&#x27;</span>,pwd:<span class="string">&#x27;admin&#x27;</span>,roles:[ &#123; role:<span class="string">&#x27;userAdminAnyDatabase&#x27;</span>, db: <span class="string">&#x27;admin&#x27;</span>&#125;,&quot;<span class="selector-tag">readWriteAnyDatabase</span>&quot;]&#125;);</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.admin</span>(&quot;<span class="selector-tag">admin</span>&quot;,&quot;<span class="selector-tag">admin</span>&quot;)</span><br></pre></td></tr></table></figure><p>部署rabbitmq</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> run -dit --name rabbitmq -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p <span class="number">15672</span>:<span class="number">15672</span> -p <span class="number">5672</span>:<span class="number">5672</span> <span class="number">867</span>da<span class="number">7</span>fcdf<span class="number">92</span></span><br></pre></td></tr></table></figure><h2 id="部署zookeeper"><a href="#部署zookeeper" class="headerlink" title="部署zookeeper"></a>部署zookeeper</h2><p>docker run -d –name zookeeper -p 2181:2181 -t wurstmeister/zookeeper</p><h2 id="部署kafka"><a href="#部署kafka" class="headerlink" title="部署kafka"></a>部署kafka</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span>  -d --name kafka -p 9092:9092 -e <span class="attribute">KAFKA_BROKER_ID</span>=0 -e <span class="attribute">KAFKA_ZOOKEEPER_CONNECT</span>=192.168.52.131:2181  -e <span class="attribute">KAFKA_ADVERTISED_LISTENERS</span>=PLAINTEXT://192.168.52.131:9092 -e <span class="attribute">KAFKA_LISTENERS</span>=PLAINTEXT://0.0.0.0:9092 -t wurstmeister/kafka </span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/lblblblblzdx/article/details/80548294?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs">参考文章</a></p><p>进入容器执行命令：<a href="https://www.hangge.com/blog/cache/detail_2791.html">https://www.hangge.com/blog/cache/detail_2791.html</a></p><h2 id="部署nginx"><a href="#部署nginx" class="headerlink" title="部署nginx"></a>部署nginx</h2><p>拉取镜像 docker pull nginx</p><p>启动容器 docker run -d –name nginx01 -p 80:80 nginx 在容器外访问3304可以访问到容器内的80端口</p><p>访问：crul localhost:3304 </p><h2 id="部署tomcat"><a href="#部署tomcat" class="headerlink" title="部署tomcat"></a>部署tomcat</h2><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200926194534367.png" alt="image-20200926194534367"></p><p>启动：docker run -d -p 3355:8080 –name tomcat01 tomcat</p><p>这个tomcat是极简版的 要把webapps.dist的文件拷贝到webapps</p><p>进入容器并复制：cp -r webapps.dist/* webapps</p><h2 id="部署es-kibana"><a href="#部署es-kibana" class="headerlink" title="部署es+kibana"></a>部署es+kibana</h2><p>启动es：<code>docker run -d --name elasticsearch -p9200:9200 -p9300:9300 -e &quot;discovery.type=single-node&quot;  elasticsearch:7.6.1</code></p><p>启动kibana：<code>docker run -d -p 5601:5601 --name kibana --link elasticsearch:elasticsearch docker.io/kibana:7.6.1</code></p><p>修改kibana容器中kibana.yml  把hosts改为自己的ip</p><p><img src="/2021/03/19/docker/kuangshen-notes\docker\image-20201107203220774.png" alt="image-20201107203220774"></p><p>es镜像的缺点：暴漏十分多的接口  十分耗内存 es的数据一般要放置在安全目录 </p><p>查看容器资源利用率:docker stats</p><p>关闭容器 修改配置文件 增加内存的限制 -e 环境配置修改</p><p>​    <code>docker run -d --name elasticsearch     -p9200:9200 -p9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.1</code></p><p><strong>安装ik分词器</strong></p><p>首先在docker中部署好es和kibana</p><p>在es中添加ik分词器插件:elasticsearch-plugin install <a href="https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.6.1/e">https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.6.1/e</a></p><p>重启es：docker restart id</p><h2 id="部署redis"><a href="#部署redis" class="headerlink" title="部署redis"></a>部署redis</h2><p>启动：docker run -p 6379:6379 -v /home/redis/data:/data -v /home/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis redis-server /usr/local/etc/redis/redis.conf –appendonly yes</p><p>执行客户端：docker exec -it id redis-cli</p><h2 id="部署RocketMQ"><a href="#部署RocketMQ" class="headerlink" title="部署RocketMQ"></a>部署RocketMQ</h2><p><strong>启动NameServer：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9876:9876 --name rmqserver  foxiswho/rocketmq:server-4.5.1</span><br></pre></td></tr></table></figure><p>启动broker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 10911:10911 -p 10909:10909\</span><br><span class="line"> --name rmqbroker --link rmqserver:namesrv\</span><br><span class="line"> -e <span class="string">&quot;NAMESRV_ADDR=namesrv:9876&quot;</span> -e <span class="string">&quot;JAVA_OPTS=-Duser.home=/opt&quot;</span>\</span><br><span class="line"> -e <span class="string">&quot;JAVA_OPT_EXT=-server -Xms128m -Xmx128m&quot;</span>\</span><br><span class="line"> foxiswho/rocketmq:broker-4.5.1</span><br></pre></td></tr></table></figure><p>启动rocketmq console</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name rmqconsole -p 8180:8080 --link rmqserver:namesrv\</span><br><span class="line"> -e <span class="string">&quot;JAVA_OPTS=-Drocketmq.namesrv.addr=namesrv:9876\</span></span><br><span class="line"><span class="string"> -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot;</span>\</span><br><span class="line"> -t styletang/rocketmq-console-ng</span><br></pre></td></tr></table></figure><p>查询启动情况：docker ps|grep rocketmq</p><h2 id="Portainer可视化面板安装"><a href="#Portainer可视化面板安装" class="headerlink" title="Portainer可视化面板安装"></a>Portainer可视化面板安装</h2><p>安装：<code>docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</code></p><p>访问192.168.52.128:8088 选择本地连接</p><h1 id="镜像原理"><a href="#镜像原理" class="headerlink" title="镜像原理"></a>镜像原理</h1><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p><p>UnionFS (联合文件系统） :Union文件系统( UnionFS )是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtualfilesystem)。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p>特性︰一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><h2 id="镜像加载原理"><a href="#镜像加载原理" class="headerlink" title="镜像加载原理"></a>镜像加载原理</h2><h3 id="联合文件系统"><a href="#联合文件系统" class="headerlink" title="联合文件系统"></a>联合文件系统</h3><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927094142961.png" alt="image-20200927094142961"></p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927094216063.png" alt="image-20200927094216063"></p><h3 id="分层理解"><a href="#分层理解" class="headerlink" title="分层理解"></a>分层理解</h3><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927094617723.png" alt="image-20200927094617723"></p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927094704724.png" alt="image-20200927094704724"></p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927094741483.png" alt="image-20200927094741483"></p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927094849878.png" alt="image-20200927094849878"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927095058156.png" alt="image-20200927095058156"></p><h1 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h1><p>docker commit 提交容器成为一个新的副本</p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927114921514.png" alt="image-20200927114921514"></p><h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><h2 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h2><p>​    <img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927115914744.png" alt="image-20200927115914744"></p><p>作用：容器的持久化和同步操作，容器间数据共享</p><h2 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h2><p>使用命令挂载 -v : docker run -it -v  主机目录：容器内目录 <code>docker run -it -v /home/test:/home centos /bin/bash</code></p><p>容器的/home和主机上的home/test双向同步 无论修改哪个目录 会被同步到另一个目录</p><h2 id="实战：mysql同步数据"><a href="#实战：mysql同步数据" class="headerlink" title="实战：mysql同步数据"></a>实战：mysql同步数据</h2><p>启动mysql <code>docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=Bbj0611.. --name mysql01 mysql:5.7</code></p><h2 id="具名挂载和匿名挂载"><a href="#具名挂载和匿名挂载" class="headerlink" title="具名挂载和匿名挂载"></a>具名挂载和匿名挂载</h2><p>匿名挂载：-v 容器内目录 自动在主机生成一个目录    </p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927124330680.png" alt="image-20200927124330680"></p><p>具名挂载：-v 卷名：容器内路径</p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927124407311.png" alt="image-20200927124407311"></p><p>查看卷</p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927124449253.png" alt="image-20200927124449253"></p><p>拓展</p><p>​    <img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927124639590.png" alt="image-20200927124639590"></p><p>默认是rw</p><h2 id="使用dockerFile添加数据卷"><a href="#使用dockerFile添加数据卷" class="headerlink" title="使用dockerFile添加数据卷"></a>使用dockerFile添加数据卷</h2><p>创建/mydocker并进入 创建dockerfile</p><p><img src="/2021/03/19/docker/log\source_posts\docker\image-20210326150236879.png" alt="image-20210326150236879"></p><p>因为不同主机 目录不同 为了移植性更高 使用volueme只指定容器中的卷</p><p>使用build在当前目录下创建新的镜像：docker build -f /mydocker/dockerfile -t baobingjiang/centos .</p><h2 id="容器间传递共享"><a href="#容器间传递共享" class="headerlink" title="容器间传递共享"></a>容器间传递共享</h2><p>先启动一个父容器centos1:docker run -d -it –name centos1 62bb58c893b3 </p><p>再启动一个子容器centos2:docker run -d -it –volumes-from centos1 –name centos2 62bb58c893b3 </p><p>再创建一个子容器centos3</p><p>父子容器之间可以共享 父容器删除后子容器之间也可以共享</p><p>结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止</p><h1 id="DockFile"><a href="#DockFile" class="headerlink" title="DockFile"></a>DockFile</h1><p>dockerfile中的每条指令都会创建一个新的镜像层 并对镜像进行提交</p><p>保留字指令</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span>    基础镜像，当前新镜像是基于哪个镜像的。</span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span>    镜像维护者名字和邮箱地址</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">    容器构建时需要运行的命令 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span>     当期容器对外暴露的端口</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash">    指定在创建容器后，终端默认登陆进来工作的目录，一个落脚点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span>     用来在构建的过程中设置环境变量，这个环境变量可以在后续的任何 <span class="keyword">RUN</span><span class="bash"> 指令中使用，这就如同在命令前面指定了环境变量前缀一样；也可以直接在其他指令中使用这些变量.</span></span><br><span class="line">        比如:  前面写有 EVN  MY_PATH /home            使用： <span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$MY_PATH</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash">     将宿主机目录下的文件拷贝进镜像，且ADD命令会自动处理URL和解压tar压缩包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash">    类似ADD命令，拷贝文件和目录到镜像中，将构建上下文目录中&lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt; 位置</span></span><br><span class="line">　　　　 使用方式 <span class="number">1</span>. <span class="keyword">COPY</span><span class="bash"> 源路径  目标路径    2. COPY[<span class="string">&quot;源路径&quot;</span>,<span class="string">&quot;目标路径&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash">  容器数据卷，用于数据保存和持久化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash">    指定一个容器启动时需要运行的命令，Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run 后面的参数替换</span></span><br><span class="line"></span><br><span class="line">ENTPYPOINT 指定一个容器启动时需要运行的命令，ENTPYPOINT和<span class="keyword">CMD</span><span class="bash">一样都是在指定容器启动程序及参数。区别在于CMD只有最后一个生效， ENTPYPOINT 在docker run 后面追加参数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ONBUILD</span>   当构建一个被集成的Dockerfile时运行，父镜像在被子镜像集成后，父镜像的<span class="keyword">ONBUILD</span>会被触发</span><br></pre></td></tr></table></figure><p>onbuild:子镜像构建的时候 父镜像会打出这句话</p><p><img src="/2021/03/19/docker/kuangshen-notes\docker\image-20201107140036356.png" alt="image-20201107140036356"></p><h2 id="CMD和ENTRYPOINT的区别"><a href="#CMD和ENTRYPOINT的区别" class="headerlink" title="CMD和ENTRYPOINT的区别"></a>CMD和ENTRYPOINT的区别</h2><p>cmd</p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927161923734.png" alt="image-20200927161923734"></p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927161936716.png" alt="image-20200927161936716"></p><p>entrypoint</p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927161959296.png" alt="image-20200927161959296"></p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927162020831.png" alt="image-20200927162020831"></p><p>​    追加命令相当于执行了 ls -al</p><h1 id="构建自己的centos"><a href="#构建自己的centos" class="headerlink" title="构建自己的centos"></a>构建自己的centos</h1><p>创建dockfile</p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927160225714.png" alt="image-20200927160225714"></p><p>创建容器</p><p>​    <img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927160327806.png" alt="image-20200927160327806"></p><p>​    关于最后面的. ：<a href="https://blog.csdn.net/weixin_43002202/article/details/108735549">https://blog.csdn.net/weixin_43002202/article/details/108735549</a></p><p>启动容器 发现自动进入 /usr/local</p><p>通过docker history 查看镜像的构建过程</p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927161313804.png" alt="image-20200927161313804"></p><h1 id="构建自己的tomcat"><a href="#构建自己的tomcat" class="headerlink" title="构建自己的tomcat"></a>构建自己的tomcat</h1><p>dockerfile文件命名为Dockerfiles build会自动寻找这个文件 就不需要-f指定了</p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927175737851.png" alt="image-20200927175737851"></p><p>jdk和tomcat包都在当前目录下</p><p>启动</p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927180241076.png" alt="image-20200927180241076"></p><h1 id="发布镜像到docker-hub"><a href="#发布镜像到docker-hub" class="headerlink" title="发布镜像到docker hub"></a>发布镜像到docker hub</h1><p>登录docker hub账户 <code>docker login -u baobingjiang</code></p><p>给image设置一个tag：<code>docker tag 9b072cf047b2 baobingjiang/mycentos</code></p><p>push:<code> docker push baobingjiang/mycentos</code> </p><h1 id="发布镜像到阿里云容器服务"><a href="#发布镜像到阿里云容器服务" class="headerlink" title="发布镜像到阿里云容器服务"></a>发布镜像到阿里云容器服务</h1><p>创建命名空间</p><p>创建镜像仓库：本地的</p><p>将镜像推送到registry</p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927184738709.png" alt="image-20200927184738709"></p><h1 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h1><p>每启动一个docker容器     docker就会给docker容器分配一个ip 只要安装了docker 就会分配一个桥接模式网卡docker0 使用的技术是evth-pair</p><p>evth-pair:是一对的虚拟设备接口 他们都是成对出现的 一端连着协议 一端彼此相连 它可以充当一个桥梁 连接各种虚拟网络设备</p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927190719361.png" alt="image-20200927190719361"></p><p>原理图</p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927191252374.png" alt="image-20200927191252374"></p><p>所有的容器在不指定网络的情况下 都是docker0路由的 docker会给我们的容器分配一个默认的可用ip</p><h1 id="容器互联–link"><a href="#容器互联–link" class="headerlink" title="容器互联–link"></a>容器互联–link</h1><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927192711585.png" alt="image-20200927192711585"></p><p>docker network ls 列出网卡</p><p>docker network inspect id查看网卡信息</p><p>通过docker inspect 容器id 可以看到再tomcat03中配置了tomcat02</p><p><img src="/2021/03/19/docker/kuangshen-notes\docker\image-20201107152325685.png" alt="image-20201107152325685"></p><p>通过docker exec -it tomcat03 cat /etc/hosts可以看到–link在hosts中增加了一个映射 </p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927193234115.png" alt="image-20200927193234115"></p><p>不建议使用–link  现在推荐使用自定义网络 因为docker0 不支持容器名连接访问</p><h1 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h1><p>网络模式</p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927194632317.png" alt="image-20200927194632317"></p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927194641080.png" alt="image-20200927194641080"></p><p>创建自定义网络：<code>docker network create --driver bridge  --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet </code></p><p>查看mynet信息：<code>docker network inspect mynet</code></p><p>通过自定义网路创建容器:<code>docker run -d -P --name tomcat01 --net mynet tomcat</code></p><p>自定义网络中 不同容器之间不仅可以通过ip地址ping通 还可以通过容器名ping通</p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927195532016.png" alt="image-20200927195532016"></p><h1 id="网络联通"><a href="#网络联通" class="headerlink" title="网络联通"></a>网络联通</h1><p>创建三个tomcat-net-01和tomcat-net-02在mynet下,tomcat01在docker0下 想让tomcat01和其他两个tomcat通信可以使用connect指令</p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927200250001.png" alt="image-20200927200250001"></p><p>相当于一个容器有两个ip地址</p><h1 id="部署redis集群"><a href="#部署redis集群" class="headerlink" title="部署redis集群"></a>部署redis集群</h1><p>创建一个网络 <code>docker network create redisnet --subnet 172.38.0.0/16</code></p><p>通过脚本创建6个redis服务在/mydata下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for port in $(seq 1 6); \</span><br><span class="line">do \</span><br><span class="line">mkdir -p /mydata/redis/node-$&#123;port&#125;/conf</span><br><span class="line">touch /mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">cat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">port 6379 </span><br><span class="line">bind 0.0.0.0</span><br><span class="line">cluster-enabled yes </span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">cluster-announce-ip 172.38.0.1$&#123;port&#125;</span><br><span class="line">cluster-announce-port 6379</span><br><span class="line">cluster-announce-bus-port 16379</span><br><span class="line">appendonly yes</span><br><span class="line">EOF</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6371:6379 -p 16371:16379 --name redis-1 \</span><br><span class="line">  -v /mydata/redis/node-1/data:/data \</span><br><span class="line">  -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">  -d --net redisnet --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><p>进入redis 使用的是sh：<code>docker exec -it redis-1 /bin/sh</code></p><p>建立集群 <code>redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379  172.38.0.13:6379  172.38.0.14:6379  172.38.0.15:6379  172.38.0.16:6379 -- cluster-replicas 1 </code></p><h1 id="SpringBoot微服务打包docker镜像"><a href="#SpringBoot微服务打包docker镜像" class="headerlink" title="SpringBoot微服务打包docker镜像"></a>SpringBoot微服务打包docker镜像</h1><p>创建一个project 并打包</p><p>创建一个Dockerfile文件</p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200928074944874.png" alt="image-20200928074944874"></p><p>将project的jar包和Dockerfile文件上传到linux的目录中</p><p>创建images</p><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200928075241846.png" alt="image-20200928075241846"></p><p>​    </p><p>​    </p><p>​    </p><p>​    </p><p>​    </p><p>​    </p>]]></content>
    
    
    <summary type="html">Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</summary>
    
    
    
    <category term="docker" scheme="http://example.com/categories/docker/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>tomcat</title>
    <link href="http://example.com/2021/03/18/tomcat/"/>
    <id>http://example.com/2021/03/18/tomcat/</id>
    <published>2021-03-18T06:36:01.000Z</published>
    <updated>2021-03-21T07:11:19.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tomcat基础"><a href="#Tomcat基础" class="headerlink" title="Tomcat基础"></a>Tomcat基础</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><strong>http服务器请求处理</strong></p><p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210318143747952.png" alt="image-20210318143747952"></p><p>HTTP服务器不直接调用业务类，而是把请求交给容器来处理，容器通过 Servlet接口调用业务类。</p><p>因此Servlet接口和Servlet容器的出现，达到了HTTP服务器与 业务类解耦的目的。而Servlet接口和Servlet容器这一整套规范叫作Servlet规范。 Tomcat按照Servlet规范的要求实现了Servlet容器，同时它们也具有HTTP服务器的功能。作为Java程序员，如果我们要实现新的业务功能，只需要实现一个Servlet，并把它 注册到Tomcat（Servlet容器）中，剩下的事情就由Tomcat帮我们处理了。</p><p><strong>Tomcat整体架构</strong></p><p>tomcat实现两个核心功能： </p><ul><li><p>处理Socket连接，负责网络字节流与Request和Response对象的转化。</p></li><li><p>加载和管理Servlet，以及具体处理Request请求。</p></li></ul><p>因此Tomcat设计了两个核心组件连接器（Connector）和容器（Container）来分别做这 两件事情。连接器负责对外交流，容器负责内部处理。</p><p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210318144050969.png" alt="image-20210318144050969"></p><h2 id="IO模型与协议"><a href="#IO模型与协议" class="headerlink" title="IO模型与协议"></a>IO模型与协议</h2><p>在Coyote中 ， Tomcat支持的多种I/O模型和应用层协议，具体包含哪些IO模型和应用层 协议，请看下表：</p><p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210318150203575.png" alt="image-20210318150203575"></p><p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210318150221296.png" alt="image-20210318150221296"></p><h2 id="连接器Coyote"><a href="#连接器Coyote" class="headerlink" title="连接器Coyote"></a>连接器Coyote</h2><p>Coyote 是Tomcat的连接器框架的名称 , 是Tomcat服务器提供的供客户端访问的外部接口。客户端通过Coyote与服务器建立连接、发送请求并接受响应 。</p><p>Coyote 封装了底层的网络通信（Socket 请求及响应处理），为Catalina 容器提供了统一的接口，使Catalina 容器与具体的请求协议及IO操作方式完全解耦。Coyote 将Socket 输入转换封装为 Request 对象，交由Catalina 容器进行处理，处理请求完成后, Catalina通过Coyote 提供的Response 对象将结果写入输出流 。</p><p>Coyote 作为独立的模块，只负责具体协议和IO的相关操作， 与Servlet 规范实现没有直 接关系，因此即便是 Request 和 Response 对象也并未实现Servlet规范对应的接口， 而是在Catalina 中将他们进一步封装为ServletRequest 和 ServletResponse 。</p><p>Tomcat为了实现支持多种I/O模型和应用层协议，一个容器可能对接多个连接器，就好比 一个房间有多个门。但是单独的连接器或者容器都不能对外提供服务，需要把它们组装 起来才能工作，组装后这个整体叫作Service组件。这里请你注意，Service本身没有做什么重要的事情，只是在连接器和容器外面多包了一层，把它们组装在一起。Tomcat内可能有多个Service，这样的设计也是出于灵活性的考虑。通过在Tomcat中配置多个 Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。</p><p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210318144407639.png" alt="image-20210318144407639"></p><h3 id="连接器组件"><a href="#连接器组件" class="headerlink" title="连接器组件"></a>连接器组件</h3><p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210318144839639.png" alt="image-20210318144839639"></p><p><strong>EndPoint</strong>:Coyote 通信端点，即通信监听的接口，是具体Socket接收和发送处理器，是对传输层的抽象，因此EndPoint用来实现TCP/IP协议的。Tomcat 并没有EndPoint 接口，而是提供了一个抽象类AbstractEndpoint ， 里面定义了两个内部类：Acceptor和SocketProcessor。Acceptor用于监听Socket连接请求。 SocketProcessor用于处理接收到的Socket请求，它实现Runnable接口，在Run方法里调用协议处理组件Processor进行处理。为了提高处理能力，SocketProcessor被提交到线程池来执行。而这个线程池叫作执行器（Executor)</p><p><strong>Processor</strong>:Coyote 协议处理接口 ，如果说EndPoint是用来实现TCP/IP协议的，那么 Processor用来实现HTTP协议，Processor接收来自EndPoint的Socket，读取字节流解 析成Tomcat Request和Response对象，并通过Adapter将其提交到容器处理， Processor是对应用层协议的抽象</p><p><strong>ProtocolHandler</strong>:Coyote 协议接口， 通过Endpoint 和 Processor ，实现针对具体协议的处理能力。Tomcat 按照协议和I/O 提供了6个实现类 ： AjpNioProtocol ， AjpAprProtocol， AjpNio2Protocol ， Http11NioProtocol ，Http11Nio2Protocol,Http11AprProtocol。我们在配置tomcat/conf/server.xml 时 ， 至少要指定具体的 ProtocolHandler , 当然也可以指定协议名称 ， 如 ： HTTP/1.1</p><p><strong>Adapter</strong>:由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat定义了自己的Request类 来“存放”这些请求信息。ProtocolHandler接口负责解析请求并生成Tomcat Request类。 但是这个Request对象不是标准的ServletRequest，也就意味着，不能用Tomcat Request作为参数来调用容器。Tomcat设计者的解决方案是引入CoyoteAdapter，这是 适配器模式的经典运用，连接器调用CoyoteAdapter的Sevice方法，传入的是Tomcat Request对象，CoyoteAdapter负责将Tomcat Request转成ServletRequest，再调用容 器的Service方法。</p><h2 id="容器Catalina"><a href="#容器Catalina" class="headerlink" title="容器Catalina"></a>容器Catalina</h2><p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210319145215568.png" alt="image-20210319145215568"></p><p>Tomcat 本质上就是一款 Servlet 容器， 因此Catalina 才是 Tomcat 的核心 ， 其他模块 都是为Catalina 提供支撑的。 比如 ： 通过Coyote 模块提供链接通信，Jasper 模块提供 JSP引擎，Naming 提供JNDI 服务，Juli 提供日志服务。</p><h3 id="Catalina-的主要组件"><a href="#Catalina-的主要组件" class="headerlink" title="Catalina 的主要组件"></a>Catalina 的主要组件</h3><p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210319145258094.png" alt="image-20210319145258094"></p><p>如上图所示，Catalina负责管理Server（tomcat服务器），而Server表示着整个服务器。Server下面有多个 服务Service，每个服务都包含着多个连接器组件Connector（Coyote 实现）和<strong>一个</strong>容器 组件Container。在Tomcat 启动的时候， 会初始化一个Catalina的实例。</p><p>Catalina 各个组件的职责：</p><table><thead><tr><th>组件</th><th>职责</th></tr></thead><tbody><tr><td>Catalina</td><td>负责解析Tomcat的配置文件 , 以此来创建服务器Server组件，并根据 命令来对其进行管理</td></tr><tr><td>Server</td><td>服务器表示整个Catalina Servlet容器以及其它组件，负责组装并启动 Servlet引擎,Tomcat连接器。Server通过实现Lifecycle接口，提供了 一种优雅的启动和关闭整个系统的方式</td></tr><tr><td>Service</td><td>服务是Server内部的组件，一个Server包含多个Service。它将若干个 Connector组件绑定到一个Container（Engine）上</td></tr><tr><td>Connector</td><td>连接器，处理与客户端的通信，它负责接收客户请求，然后转给相关 的容器处理，最后向客户返回响应结果</td></tr><tr><td>Container</td><td>容器，负责处理用户的servlet请求，并返回对象给web用户的模块</td></tr></tbody></table><p>Tomcat设计了4种容器，分别是Engine、Host、Context和Wrapper。这4种容器不是平行关系，而是父子关系。Tomcat通过一种分层的架构，使得Servlet容器具有很好的灵活性。</p><p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210319213053382.png" alt="image-20210319213053382"></p><table><thead><tr><th>容器</th><th>描述</th></tr></thead><tbody><tr><td>Engine</td><td>表示整个Catalina的Servlet引擎，用来管理多个虚拟站点，一个Service 最多只能有一个Engine，但是一个引擎可包含多个Host</td></tr><tr><td>Host</td><td>表示一个虚拟主机，或者说一个站点，可以给Tomcat配置多个虚拟主机地址，而一个虚拟主机下可包含多个Context</td></tr><tr><td>Context</td><td>表示一个Web应用程序， 一个Web应用可包含多个Wrapper</td></tr><tr><td>Wrapper</td><td>表示一个Servlet，Wrapper 作为容器中的最底层，不能包含子容器</td></tr></tbody></table><p>那么，Tomcat是怎么管理这些容器的呢？你会发现这些容器具有父子关系，形成一个树形结构，你可能马上就想到了设计模式中的组合模式。没错，Tomcat就是用组合模式来管理这些容器的。具体实现方法是，所有容器组件都实现了Container接口，因此组合模式可以使得用户对单容器对象和组合容器对象的使用具有一致性。这里单容器对象指的是最底层的Wrapper，组合容器对象指的是上面的Context、Host或者Engine</p><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210319221358739.png" alt="image-20210319221358739"></p><p>ProtocalHandler再继续初始化EndPoint  endpoint绑定并监听相应的端口号</p><p>ProtocalHandler继续调用Endpoint的start方法 ：开启线程，接受客户端请求</p><p>加载Tomcat的配置文件，初始化容器组件 ，监听对应的端口号， 准备接受客户端请求</p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="LifeCycle"><a href="#LifeCycle" class="headerlink" title="LifeCycle"></a>LifeCycle</h4><p>由于所有的组件均存在初始化、启动、停止等生命周期方法，拥有生命周期管理的特 性， 所以Tomcat在设计的时候， 基于生命周期管理抽象成了一个接口 Lifecycle ，而组件Server、Service、Container、Executor、Connector 组件 ， 都实现了一个生命周期 的接口，从而具有了以下生命周期中的核心方法：</p><ul><li>init：初始化组件</li><li>start：启动组件</li><li>stop：停止组件</li><li>destory：销毁组件</li></ul><p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210320154226705.png" alt="image-20210320154226705"></p><h4 id="各组件的默认实现"><a href="#各组件的默认实现" class="headerlink" title="各组件的默认实现"></a>各组件的默认实现</h4><p>上面我们提到的Server、Service、Engine、Host、Context都是接口， 下图中罗列了这 些接口的默认实现类。当前对于 Endpoint组件来说，在Tomcat中没有对应的Endpoint 接口， 但是有一个抽象类 AbstractEndpoint ，其下有三个实现类： NioEndpoint、 Nio2Endpoint、AprEndpoint ， 这三个实现类，分别对应于前面讲解链接器 Coyote 时， 提到的链接器支持的三种IO模型：NIO，NIO2，APR ， Tomcat8.5版本中，默认采 用的是 NioEndpoint</p><p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210320154207762.png" alt="image-20210320154207762"></p><p>ProtocolHandler ： Coyote协议接口，通过封装Endpoint和Processor ， 实现针对具体 协议的处理功能。Tomcat按照协议和IO提供了6个实现类</p><p>AJP协议：</p><ul><li><p>AjpNioProtocol ：采用NIO的IO模型。 </p></li><li><p>AjpNio2Protocol：采用NIO2的IO模型</p></li><li><p>AjpAprProtocol ：采用APR的IO模型，需要依赖于APR库。</p><p>HTTP协议：</p></li><li><p>Http11NioProtocol ：采用NIO的IO模型，默认使用的协议（如果服务器没有安装 APR）。</p></li><li><p>Http11Nio2Protocol：采用NIO2的IO模型。</p></li><li><p>Http11AprProtocol ：采用APR的IO模型，需要依赖于APR库。</p></li></ul><p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210320155257146.png" alt="image-20210320155257146"></p><h2 id="请求处理流程"><a href="#请求处理流程" class="headerlink" title="请求处理流程"></a>请求处理流程</h2><h3 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h3><p>设计了这么多层次的容器，Tomcat是怎么确定每一个请求应该由哪个Wrapper容器里的 Servlet来处理的呢？答案是，Tomcat是用Mapper组件来完成这个任务的。</p><p>Mapper组件的功能就是将用户请求的URL定位到一个Servlet，它的工作原理是： Mapper组件里保存了Web应用的配置信息，其实就是容器组件与访问路径的映射关系， 比如Host容器里配置的域名、Context容器里的Web应用路径，以及Wrapper容器里 Servlet映射的路径，你可以想象这些配置信息就是一个多层次的Map。</p><p>当一个请求到来时，Mapper组件通过解析请求URL里的域名和路径，再到自己保存的 Map里去查找，就能定位到一个Servlet。一个请求URL最后只会定位到一个 Wrapper容器，也就是一个Servlet。</p><p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210320181856246.png" alt="image-20210320181856246"></p><p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210320183445781.png" alt="image-20210320183445781"></p><p>步骤如下: </p><ul><li>Connector组件Endpoint中的Acceptor监听客户端套接字连接并接收Socket。</li><li>将连接交给线程池Executor处理，开始执行请求响应任务。</li><li>Processor组件读取消息报文，解析请求行、请求体、请求头，封装成Request对象。</li><li>Mapper组件根据请求行的URL值和请求头的Host值匹配由哪个Host容器、Context容器、Wrapper容器处理请求。</li><li>CoyoteAdaptor组件负责将Connector组件和Engine容器关联起来，把生成的 Request对象和响应对象Response传递到Engine容器中，调用 Pipeline。</li><li>Engine容器的管道开始处理，管道中包含若干个Valve、每个Valve负责部分处理逻辑。执行完Valve后会执行基础的 Valve–StandardEngineValve，负责调用Host容器的 Pipeline。</li><li>Host容器的管道开始处理，流程类似，最后执行 Context容器的Pipeline。</li><li>Context容器的管道开始处理，流程类似，最后执行 Wrapper容器的Pipeline。</li><li>Wrapper容器的管道开始处理，流程类似，最后执行 Wrapper容器对应的Servlet对象的处理方法。</li></ul><p>在Tomcat中定义了Pipeline 和 Valve 两个接口，Pipeline 用于构建责任链， 后者代表责 任链上的每个处理器。Pipeline 中维护了一个基础的Valve，它始终位于Pipeline的末端 （最后执行），封装了具体的请求处理和输出响应的过程。当然，我们也可以调用 addValve()方法， 为Pipeline 添加其他的Valve， 后添加的Valve 位于基础的Valve之 前，并按照添加顺序执行。Pipiline通过获得首个Valve来启动整合链条的执行 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Tomcat基础&quot;&gt;&lt;a href=&quot;#Tomcat基础&quot; class=&quot;headerlink&quot; title=&quot;Tomcat基础&quot;&gt;&lt;/a&gt;Tomcat基础&lt;/h1&gt;&lt;h2 id=&quot;整体架构&quot;&gt;&lt;a href=&quot;#整体架构&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="web" scheme="http://example.com/categories/web/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Servlet</title>
    <link href="http://example.com/2021/03/17/Servlet/"/>
    <id>http://example.com/2021/03/17/Servlet/</id>
    <published>2021-03-17T06:54:29.000Z</published>
    <updated>2021-04-10T08:28:07.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口实现类开发步骤"><a href="#接口实现类开发步骤" class="headerlink" title="接口实现类开发步骤"></a>接口实现类开发步骤</h1><p><img src="/2021/03/17/Servlet/image-20210317215123604.png" alt="image-20210317215123604"></p><p><strong>首先实现servlet类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i am get&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i am post&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tomcat调用Servlet接口实现类的规则：</p><ul><li>tomcat有权创建Servlet接口实现类实例对象 Servlet servlet = new OneServlet();</li><li>tomcat根据实例对象调用service方法处理当前请求 servlet.service();</li></ul><p>HttpServlet类中对service方法进行了实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String method = req.getMethod();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// servlet doesn&#x27;t support if-modified-since, no reason</span></span><br><span class="line">            <span class="comment">// to go through further expensive logic</span></span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                maybeSetLastModified(resp, lastModified);</span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Note that this means NO servlet supports whatever</span></span><br><span class="line">        <span class="comment">// method was requested, anywhere on this server.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        String errMsg = lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">        errArgs[<span class="number">0</span>] = method;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        </span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质是调用doGet doPost方法 所以要在自定义的Servlet类中要实现doGet和doPost方法</p><p><strong>对servlet实现类进行配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    将servlet接口实现类路径地址交给tomcat tomcat中的存储格式为String one = &quot;com.baobingjiang.controller.OneServlet&quot;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>one<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.baobingjiang.controller.OneServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    为了降低用户访问Servlet接口实现类难度 需要设置简短请求别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>one<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/one<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置好tomcat并启动 访问 <a href="http://localhost:8080/myWeb/one%E5%8D%B3%E5%8F%AF%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9C%8B%E5%88%B0%E6%89%93%E5%8D%B0%E7%9A%84%E6%B6%88%E6%81%AF">http://localhost:8080/myWeb/one即可在控制台看到打印的消息</a></p><h1 id="Servlet对象生命周期"><a href="#Servlet对象生命周期" class="headerlink" title="Servlet对象生命周期"></a>Servlet对象生命周期</h1><p>1.网站中所有的servlet接口实现类的实例对象，只能由Http服务器负责创建。开发人员不能手动创建servlet接口实现类的实例对象</p><p>2.在默认的情况下，http服务器接收到对于当前servlet接口实现类第一次请求时自动创建这个servlet接口实现类的实例对象</p><p>可以通过手动配置 要求http服务器在启动时自动创建某个Servlet接口实现类的实例对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>one<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.baobingjiang.controller.OneServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--填写一个大于0的整数即可--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在http服务器运行期间 ，一个servlet接口实现类只能被创建出一个实例对象</p><p>http服务器关闭的时候 会将网站中所有servlet对象全部销毁</p><h1 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h1><p>主要功能：</p><ul><li>将执行结果以二进制形式写入到【响应体】</li><li>设置响应头中[content-type]属性值，从而控制浏览器使用对应编译器将响应体二进制数据编译为【文字，图片，视频，命令】</li><li>设置响应头中【location】属性，将一个请求地址赋值给location.从而控制浏览器向指定服务器发送请求</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String message = <span class="string">&quot;hello &lt;br/&gt; world&quot;</span>;</span><br><span class="line">        <span class="comment">//通过tomcat的输出流 将执行结果以二进制的形式写入到响应体</span></span><br><span class="line">        <span class="comment">//ContentType指定文本格式和字符集</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        resp.getWriter().print(message);</span><br><span class="line">        <span class="comment">//doGet执行完毕后，tomcat将相应包推送给浏览器</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String url = <span class="string">&quot;http://www.baidu.com?username=bob&quot;</span>;</span><br><span class="line">    resp.sendRedirect(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h1><ul><li><p>可以读取Http请求协议包中【请求行】信息</p></li><li><p>可以读取保存在Http请求协议包中【请求头】或则【请求体】中请求参数信息</p></li><li><p>可以代替浏览器向Http服务器申请资源文件调用</p></li></ul><p>浏览器以get方式发送请求 参数在请求头中 当http请求协议包到达http服务器之后 由tomcat对二进制内容进行解码 tomcat默认字符集为utf-8所以不会乱码</p><p>浏览器以post方式发送请求 参数在请求体中 当http请求协议包到达http服务器之后 由当前请求对象(request)对二进制内容进行解码 默认使用的是ISO-8859-1字符集 如果是中文会出现乱码 解决方法：在读取请求体内容之前 应该通知请求对象使用utf-8字符集对请求体内容进行一次重新解码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="comment">//读取请求行中的信息</span></span><br><span class="line">    req.getRequestURL();</span><br><span class="line">    req.getMethod();</span><br><span class="line">    <span class="comment">//读取参数</span></span><br><span class="line">    String username = req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    System.out.println(username);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="请求对象与响应对象的生命周期"><a href="#请求对象与响应对象的生命周期" class="headerlink" title="请求对象与响应对象的生命周期"></a>请求对象与响应对象的生命周期</h1><p>1.在Http服务器接收到浏览器发送的【Http请求协议包】之后，自动为当前的【Http请求协议包】生成一个【请求对象】和一个【响应对象】</p><p> 2.在Http服务器调用doGet/doPost方法时，负责将【请求对象】和【响应对象】作为实参传递到方法，确保doGet/doPost正确执行</p><p> 3.在Http服务器准备推送Http响应协议包之前，负责将本次请求关联的【请求对象】和【响应对象】销毁</p><p><img src="/2021/03/17/Servlet/image-20210318125647204.png" alt="image-20210318125647204"></p><h1 id="欢迎资源文件"><a href="#欢迎资源文件" class="headerlink" title="欢迎资源文件"></a>欢迎资源文件</h1><p>用户发送了一个针对某个网站的【默认请求】时，此时由Http服务器自动从当前网站返回的资源文件</p><ul><li>正常请求： <a href="http://localhost:8080/myWeb/index.html">http://localhost:8080/myWeb/index.html</a></li><li>默认请求： <a href="http://localhost:8080/myWeb/">http://localhost:8080/myWeb/</a>        </li></ul><p>默认配置：自上向下进行查找 如果没有找到就返回一个404状态码</p><welcome-file-list>    <welcome-file>index.html</welcome-file>    <welcome-file>index.htm</welcome-file>    <welcome-file>index.jsp</welcome-file></welcome-file-list><p>自定义配置：在web.xml中进行配置 默认配置将失效</p><welcome-file-list>    <welcome-file>login.html</welcome-file></welcome-file-list><h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><p>Http服务器在推送响应包之前，根据本次请求处理情况将Http状态码写入到响应包中【状态行】上</p><ul><li><p>1XX :最有特征 100; 通知浏览器本次返回的资源文件并不是一个独立的资源文件，需要浏览器在接收 响应包之后，继续向Http服务器所要依赖的其他资源文件</p></li><li><p>2XX:最有特征200，通知浏览器本次返回的资源文件是一个 完整独立资源文件，浏览器在接收到之后不需要所要  其他关联文件* </p></li><li><p>3XX:最有特征302，通知浏览器本次返回的不是一个资源文件内容 而是一个资源文件地址，需要浏览器根据这个地址自动发起 请求来索要这个资源文件</p></li><li><p>4XX:</p><ul><li>404: 通知浏览器，由于在服务端没有定位到被访问的资源文件因此无法提供帮助</li><li>405：通知浏览器，在服务端已经定位到被访问的资源文件（Servlet）但是这个Servlet对于浏览器采用的请求方式不能处理</li></ul></li><li><p>5XX:通知浏览器，在服务端已经定位到被访问的资源文件（Servlet） 这个Servlet可以接收浏览器采用请求方式，但是Servlet在处理 请求期间，由于Java异常导致处理失败</p></li></ul><h1 id="多个Servlet之间调用"><a href="#多个Servlet之间调用" class="headerlink" title="多个Servlet之间调用"></a>多个Servlet之间调用</h1><p>某些来自于浏览器发送请求，往往需要服务端中多个Servlet协同处理。 但是浏览器一次只能访问一个Servlet，导致用户需要手动通过浏览器 发起多次请求才能得到服务。 这样增加用户获得服务难度，导致用户放弃访问当前网站</p><p>解决：无论本次请求涉及到多少个Servlet,用户只需要【手动】通知浏览器发起一次请求即可</p><p>多个Servlet之间调用规则</p><ul><li>重定向 </li><li>请求转发</li></ul><h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>用户第一次通过【手动方式】通知浏览器访问OneServlet。 OneServlet工作完毕后，将TwoServlet地址写入到响应头 location属性中，导致Tomcat将302状态码写入到状态行。 在浏览器接收到响应包之后，会读取到302状态。此时浏览器 自动根据响应头中location属性地址发起第二次请求，访问 TwoServlet去完成请求中剩余任务</p><p>实现命令：response.sendRedirect(“请求地址”) 既可以把当前网站内部的资源文件地址发送给浏览器也可以把其他网站资源文件地址发送给浏览器</p><p>请求方式：重定向解决方案中，通过地址栏通知浏览器发起下一次请求，因此通过重定向解决方案调用的资源文件接收的请求方式一定是【GET】</p><h1 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h1><p>用户第一次通过手动方式要求浏览器访问OneServlet。 OneServlet工作完毕后，通过当前的请求对象代替浏览器 向Tomcat发送请求，申请调用TwoServlet。 Tomcat在接收到这个请求之后，自动调用TwoServlet来 完成剩余任务</p><p>实现命令： request.getRequestDispathcer(“/资源文件名”) 只能向Tomcat服务器申请调用当前网站下资源文件地址，不要写网站名</p><p>请求方式：在请求转发过程中，浏览器只发送一个了个Http请求协议包。 参与本次请求的所有Servlet共享同一个请求协议包，因此这些Servlet接收的请求方式应与浏览器发送的请求方式保持一致</p><h1 id="多个Servlet之间数据共享"><a href="#多个Servlet之间数据共享" class="headerlink" title="多个Servlet之间数据共享"></a>多个Servlet之间数据共享</h1><p>四种数据共享方案</p><ul><li>ServletContext接口</li><li>Cookie类</li><li>HttpSession接口</li><li>HttpServletRequest接口</li></ul><h2 id="ServletContext-全局作用域对象"><a href="#ServletContext-全局作用域对象" class="headerlink" title="ServletContext(全局作用域对象)"></a>ServletContext(全局作用域对象)</h2><p>如果两个Servlet来自于同一个网站。彼此之间可以通过网站的ServletContext实例对象实现数据共享</p><p>工作原理：每一个网站都存在一个全局作用域对象。 这个全局作用域对象相当于一个Map. 在这个网站中OneServlet可以将一个数据 存入到全局作用域对象，当前网站中其他 Servlet此时都可以从全局作用域对象得到 这个数据进行使用</p><p>ServletContext生命周期：在Http服务器启动过程中，自动为当前网站在内存中创建 一个全局作用域对象，在Http服务器运行期间时，一个网站只有一个全局作用域对象。在Http服务器准备关闭时，负责将当前网站中全局作用域对象 进行销毁处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext application=req.getServletContext();</span><br><span class="line">        application.setAttribute(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext application=req.getServletContext();</span><br><span class="line">        <span class="comment">//2.从全局作用域对象得到指定关键字对应数据</span></span><br><span class="line">        Object vale = application.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，此时借助于Cookie对象进行数据共享</p><p>Cookie存放当前用户的私人数据，在共享数据过程中提高服务质量</p><p><img src="/2021/03/17/Servlet/image-20210319133749797.png" alt="image-20210319133749797"></p><p>用户通过浏览器第一次向MyWeb网站发送请求申请OneServlet。OneServlet在运行期间创建一个Cookie存储与当前用户相关数据OneServlet工作完毕后，【将Cookie写入到响应头】交还给当前浏览器。浏览器收到响应响应包之后，将cookie存储在浏览器的缓存<br>一段时间之后，用户通过【同一个浏览器】再次向【myWeb网站】发送请求申请TwoServlet时。【浏览器需要无条件的将myWeb网站之前推送过来的Cookie，写入到请求头】发送过去 此时TwoServlet在运行时，就可以通过读取请求头中cookie中信息，得到OneServlet提供的共享数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        Cookie card=<span class="keyword">new</span> Cookie(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        Cookie card1=<span class="keyword">new</span> Cookie(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;efg&quot;</span>);</span><br><span class="line">        <span class="comment">//2.【发卡】将cookie写入到响应头，交给浏览器</span></span><br><span class="line">        resp.addCookie(card);</span><br><span class="line">        resp.addCookie(card1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//2.循环遍历数据得到每一个cookie的key与value</span></span><br><span class="line">        Cookie cookieArray[]=req.getCookies();</span><br><span class="line">        <span class="keyword">for</span>(Cookie card:cookieArray)&#123;</span><br><span class="line">            String key=card.getName();</span><br><span class="line">            String value=card.getValue();</span><br><span class="line">            System.out.println(key + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在默认情况下，Cookie对象存放在浏览器的缓存中 因此只要浏览器关闭，Cookie对象就被销毁掉</p><p>在手动设置情况下，可以要求浏览器将接收的Cookie 存放在客户端计算机上硬盘上，同时需要指定Cookie 在硬盘上存活时间。在存活时间范围内，关闭浏览器 关闭客户端计算机，关闭服务器，都不会导致Cookie 被销毁。在存活时间到达时，Cookie自动从硬盘上被 删除</p><p>cookie.setMaxAge(60) 单位是s</p><h2 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h2><p>如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，此时 借助于HttpSession对象进行数据共享</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        HttpSession session=req.getSession();</span><br><span class="line">        <span class="comment">//cookie只可以存放字符串类型 session可以存储任意类型</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;key1&quot;</span>,<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        HttpSession session=req.getSession();</span><br><span class="line">        Object res =session.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>getSession():如果当前用户在服务端已经拥有了自己的私人储物柜. 要求tomcat将这个私人储物柜进行返回 如果当前用户在服务端尚未拥有自己的私人储物柜 要求tocmat为当前用户创建一个全新的私人储物柜</p></li><li><p>getSession(false):如果当前用户在服务端已经拥有了自己的私人储物柜. 要求tomcat将这个私人储物柜进行返回 如果当前用户在服务端尚未拥有自己的私人储物柜 此时Tomcat将返回null</p></li></ul><p>http服务器使用cookie将用户与HttpSession关联起来 在浏览器关闭时，意味着用户与他的HttpSession关系被切断 由于Tomcat无法检测浏览器何时关闭，因此在浏览器关闭时并不会导致Tomcat将浏览器关联的HttpSession进行销毁 为了解决这个问题，Tomcat为每一个HttpSession对象设置【空闲时间】 这个空闲时间默认30分钟，如果当前HttpSession对象空闲时间达到30分钟 此时Tomcat认为用户已经放弃了自己的HttpSession，此时Tomcat就会销毁 掉这个HttpSession</p><p>可以在web.xml中进行手动设置</p><session-config>            <session-timeout>5</session-timeout><!--当前网站中每一个session最大空闲时间5分钟--></session-config><h2 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h2><p>在同一个网站中，如果两个Servlet之间通过【请求转发】方式进行调用， 彼此之间共享同一个请求协议包。而一个请求协议包只对应一个请求对象 因此servlet之间共享同一个请求对象，此时可以利用这个请求对象在两个Servlet之间实现数据共享</p><h1 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h1><p>监听器接口用于监控【作用域对象生命周期变化时刻】以及【作用域对象共享数据变化时刻】</p><p>在Servlet规范中，认为在服务端内存中可以在某些条件下为两个Servlet之间提供数据共享方案的对象，被称为【作用域对象】</p><p>Servlet规范下作用域对象:</p><ul><li>ServletContext：全局作用域对象</li><li>HttpSession:会话作用域对象</li><li>HttpServletRequest:请求作用域对象</li></ul><p>监听器接口实现类开发规范：</p><ul><li><p>根据监听的实际情况，选择对应监听器接口进行实现</p></li><li><p>重写监听器接口声明【监听事件处理方法】</p></li><li><p>在web.xml文件将监听器接口实现类注册到Http服务器</p></li></ul><p>ServletContextListener接口：通过这个接口合法的检测全局作用域对象被初始化时刻以及被销毁时刻</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在全局作用域对象被Http服务器初始化被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在全局作用域对象被Http服务器销毁时候触发调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.ServletContextAttributeListener接口:通过这个接口合法的检测全局作用域对象共享数据变化时刻</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ServletContextAttributeListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在全局作用域对象添加共享数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletContextAttributeEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在全局作用域对象更新共享数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletContextAttributeEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在全局作用域对象删除共享数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletContextAttributeEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在web.xml中进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.baobingjiang.listener.MyListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><p>Filter接口在Http服务器调用资源文件之前，对Http服务器进行拦截</p><p>Filter接口实现类开发步骤：三步</p><ul><li>创建一个Java类实现Filter接口</li><li>重写Filter接口中doFilter方法</li><li>web.xml将过滤器接口实现类注册到Http服务器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在web.xml中进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.baobingjiang.filter.MyFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        当tomcat调用img下的任意文件的时候调用myFilter进行拦截--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/img/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java Servlet 是运行在 Web 服务器或应用服务器上的程序,它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层</summary>
    
    
    
    <category term="web" scheme="http://example.com/categories/web/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>kafka</title>
    <link href="http://example.com/2021/03/14/kafka/"/>
    <id>http://example.com/2021/03/14/kafka/</id>
    <published>2021-03-14T07:38:26.000Z</published>
    <updated>2021-03-17T01:00:42.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p><img src="/2021/03/14/kafka/image-20210314153956902.png" alt="image-20210314153956902"></p><p>3）Consumer Group （CG）：消费者组，由多个 consumer 组成。消费者组内每个消费者负 责消费不同分区的数据，<strong>一个分区只能由一个组内消费者消费</strong>；消费者组之间互不影响。</p><p>4）Broker ：一台 kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic。</p><p> 5）Topic ：可以理解为一个队列，生产者和消费者面向的都是一个 topic；</p><p> 6）Partition：为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上， 一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列；</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>Kafka 中消息是以 topic 进行分类的，生产者生产消息，消费者消费消息，都是面向 topic 的。</p><p>topic 是逻辑上的概念，而 partition 是物理上的概念，每个 partition 对应于一个 log文件，该log 文件中存储的就是 producer 生产的数据。</p><p>Producer 生产的数据会被不断追加到该 log 文件末端，且每条数据都有自己的 offset。消费者组中的每个消费者，都会实时记录自消费到了哪个 offset，以便出错恢复时，从上次的位置继续消费。</p><h2 id="文件存储机制"><a href="#文件存储机制" class="headerlink" title="文件存储机制"></a>文件存储机制</h2><p><img src="/2021/03/14/kafka/image-20210315111943178.png" alt="image-20210315111943178"></p><p>由于生产者生产的消息会不断追加到 log 文件末尾，为防止 log 文件过大导致数据定位 效率低下，Kafka 采取了分片和索引机制，将每个 partition 分为多个 segment。每个 segment 对应两个文件——“.index”文件和“.log”文件。这些文件位于一个文件夹下，该文件夹的命名 规则为：topic 名称+分区序号。例如，first 这个 topic 有三个分区，则其对应的文件夹为 first0,first-1,first-2</p><p>index 和 log 文件以当前 segment 的第一条消息的 offset 命名。下图为 index 文件和 log 文件的结构示意图。</p><p><img src="/2021/03/14/kafka/image-20210315112241317.png" alt="image-20210315112241317"></p><p>“.index”文件存储大量的索引信息，“.log”文件存储大量的数据，索引文件中的元 数据指向对应数据文件中 message 的物理偏移地址。</p><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><h3 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h3><p>分区原因:负载均衡,提高并发</p><p>分区原则:    </p><p>（1）指明 partition 的情况下，直接将指明的值直接作为 partiton 值； </p><p>（2）没有指明 partition 值但有 key 的情况下，将 key 的 hash 值与 topic 的 partition 数进行取余得到 partition 值； </p><p>（3）既没有 partition 值又没有 key 值的情况下，第一次调用时随机生成一个整数（后 面每次调用在这个整数上自增），将这个值与 topic 可用的 partition 总数取余得到 partition 值，也就是常说的 round-robin 算法。</p><h3 id="数据可靠性保证"><a href="#数据可靠性保证" class="headerlink" title="数据可靠性保证"></a>数据可靠性保证</h3><p>为保证 producer 发送的数据，能可靠的发送到指定的 topic，topic 的每个 partition 收到 producer 发送的数据后，都需要向 producer 发送 ack（acknowledgement 确认收到），如果 producer 收到 ack，就会进行下一轮的发送，否则重新发送数据。</p><p><img src="/2021/03/14/kafka/image-20210315112849500.png"></p><h4 id="副本数据同步策略"><a href="#副本数据同步策略" class="headerlink" title="副本数据同步策略"></a>副本数据同步策略</h4><p><img src="/2021/03/14/kafka/image-20210315113323908.png" alt="image-20210315113323908"></p><p>Kafka 选择了第二种方案，原因如下：</p><ol><li>同样为了容忍 n 台节点的故障，第一种方案需要 2n+1 个副本，而第二种方案只需要 n+1 个副本，而 Kafka 的每个分区都有大量的数据，第一种方案会造成大量数据的冗余。</li><li>2.虽然第二种方案的网络延迟会比较高，但网络延迟对 Kafka 的影响较小。</li></ol><h4 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h4><p>采用第二种方案之后，设想以下情景：leader 收到数据，所有 follower 都开始同步数据， 但有一个 follower，因为某种故障，迟迟不能与 leader 进行同步，那 leader 就要一直等下去， 直到它完成同步，才能发送 ack。这个问题怎么解决呢？ </p><p>Leader 维护了一个动态的 in-sync replica set (ISR)，意为和 leader 保持同步的 follower 集 合。当 ISR 中的 follower 完成数据的同步之后，leader 就会给 follower 发送 ack。如果 follower 长时间未向leader 同 步 数 据 ， 则 该 follower 将 被 踢 出 ISR</p><h4 id="ack应答机制"><a href="#ack应答机制" class="headerlink" title="ack应答机制"></a>ack应答机制</h4><p>对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失， 所以没必要等 ISR 中的 follower 全部接收成功。 所以 Kafka 为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡， 选择以下的配置。</p><p>acks 参数配置：</p><ul><li><p>0：producer 不等待 broker 的 ack，这一操作提供了一个最低的延迟，broker 一接收到还没有写入磁盘就已经返回，当 broker 故障时有可能丢失数据；</p></li><li><p>1：producer 等待 broker 的 ack，partition 的 leader 落盘成功后返回 ack，如果在 follower 同步成功之前 leader 故障，那么将会丢失数据；</p></li><li><p>-1（all）：producer 等待 broker 的 ack，partition 的 leader 和 follower 全部落盘成功后才 返回 ack。但是如果在 follower 同步完成后，broker 发送 ack 之前，leader 发生故障，那么会 造成数据重复。</p></li></ul><h4 id="故障处理细节"><a href="#故障处理细节" class="headerlink" title="故障处理细节"></a>故障处理细节</h4><p><img src="/2021/03/14/kafka/image-20210315133821379.png" alt="image-20210315133821379"></p><p>（1）follower 故障 follower 发生故障后会被临时踢出 ISR，待该 follower 恢复后，follower 会读取本地磁盘 记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步。 等该 follower 的 LEO 大于等于该 Partition 的 HW，即 follower 追上 leader 之后，就可以重 新加入 ISR 了。</p><p>（2）leader 故障 leader 发生故障之后，会从 ISR 中选出一个新的 leader，之后，为保证多个副本之间的数据一致性，其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader 同步数据。</p><h4 id="Exactly-Once-语义"><a href="#Exactly-Once-语义" class="headerlink" title="Exactly Once 语义"></a>Exactly Once 语义</h4><p>将服务器的 ACK 级别设置为-1，可以保证 Producer 到 Server 之间不会丢失数据，即 At Least Once 语义。相对的，将服务器 ACK 级别设置为 0，可以保证生产者每条消息只会被 发送一次，即 At Most Once 语义。但是，对于一些非常重要的信息，比如说交易数据，下游数据消费者要求数据既不重复也不丢失，即 Exactly Once 语义</p><p>0.11 版本的 Kafka，引入了一项重大特性：幂等性。所谓的幂等性就是指 Producer 不论 向 Server 发送多少次重复数据，Server 端都只会持久化一条。幂等性结合 At Least Once 语 义，就构成了 Kafka 的 Exactly Once 语义。即： At Least Once + 幂等性 = Exactly Once</p><p>开启幂等性的 Producer 在 初始化的时候会被分配一个 PID，发往同一 Partition 的消息会附带 Sequence Number。而 Broker 端会对做缓存，当具有相同主键的消息提交时，Broker 只 会持久化一条。</p><p>但是 PID 重启就会变化，同时不同的 Partition 也具有不同主键，所以幂等性无法保证跨 分区跨会话的 Exactly Once。</p><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><h3 id="消费方式"><a href="#消费方式" class="headerlink" title="消费方式"></a>消费方式</h3><p>consumer 采用 pull（拉）模式从 broker 中读取数据。 push（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的.pull 模式不足之处是，如果 kafka 没有数据，消费者可能会陷入循环中，一直返回空数据.针对这一点，Kafka 的消费者在消费数据时会传入一个时长参数 timeout，如果当前没有 数据可供消费，consumer 会等待一段时间之后再返回，这段时长即为 timeout。</p><h3 id="分区分配策略"><a href="#分区分配策略" class="headerlink" title="分区分配策略"></a>分区分配策略</h3><p>一个 consumer group 中有多个 consumer，一个 topic 有多个 partition，所以必然会涉及 到 partition 的分配问题，即确定那个 partition 由哪个consumer 来消费。Kafka 有两种分配策略RoundRobin和Range。</p><p>RoundRobin</p><p><img src="/2021/03/14/kafka/image-20210315135548013.png" alt="image-20210315135548013"></p><p>Range:如下图，三个消费者均订阅了同一主题，则每个消费者消费到不同的分区；但是<strong>当topic的分区数较大时</strong>，同一个topic的分区，可能在消费者之间<strong>分布得不均衡</strong>。</p><p><img src="/2021/03/14/kafka/image-20210315135813065.png" alt="image-20210315135813065"></p><h3 id="offset-的维护"><a href="#offset-的维护" class="headerlink" title="offset 的维护"></a>offset 的维护</h3><p>由于 consumer 在消费过程中可能会出现断电宕机等故障，consumer 恢复后，需要从故 障前的位置的继续消费，所以 consumer 需要实时记录自己消费到了哪个 offset，以便故障恢 复后继续消费。</p><p>Kafka 0.9 版本之前，consumer 默认将 offset 保存在 Zookeeper 中，从 0.9 版本开始， consumer 默认将 offset 保存在 Kafka 一个内置的 topic 中，该 topic 为__consumer_offsets。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="Producer-事务"><a href="#Producer-事务" class="headerlink" title="Producer 事务"></a>Producer 事务</h3><p>为了实现跨分区跨会话的事务，需要引入一个全局唯一的 Transaction ID，并将 Producer 获得的PID 和Transaction ID 绑定。这样当Producer 重启后就可以通过正在进行的 Transaction ID 获得原来的 PID。</p><p>为了管理 Transaction，Kafka 引入了一个新的组件 Transaction Coordinator。Producer 就 是通过和 Transaction Coordinator 交互获得 Transaction ID 对应的任务状态。Transaction Coordinator 还负责将事务所有写入 Kafka 的一个内部 Topic，这样即使整个服务重启，由于 事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。</p><h3 id="Consumer事务"><a href="#Consumer事务" class="headerlink" title="Consumer事务"></a>Consumer事务</h3><p>上述事务机制主要是从 Producer 方面考虑，对于 Consumer 而言，事务的保证就会相对 较弱，尤其时无法保证 Commit 的信息被精确消费。这是由于 Consumer 可以通过 offset 访 问任意信息，而且不同的 Segment File 生命周期不同，同一事务的消息可能会出现重启后被 删除的情况。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Producer-API"><a href="#Producer-API" class="headerlink" title="Producer API"></a>Producer API</h3><h4 id="消息发送流程"><a href="#消息发送流程" class="headerlink" title="消息发送流程"></a>消息发送流程</h4><p>Kafka 的 Producer 发送消息采用的是异步发送的方式。在消息发送的过程中，涉及到了 两个线程——main 线程和 Sender 线程，以及一个线程共享变量——RecordAccumulator。 main 线程将消息发送给 RecordAccumulator，Sender 线程不断从 RecordAccumulator 中拉取 消息发送到 Kafka broker。</p><p><img src="/2021/03/14/kafka/image-20210315143831877.png" alt="image-20210315143831877"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//kafka 集群，broker-list</span></span><br><span class="line">        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.52.131:9092&quot;</span>);</span><br><span class="line">        <span class="comment">//ack应答级别</span></span><br><span class="line">        props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">        <span class="comment">//重试次数</span></span><br><span class="line">        props.put(<span class="string">&quot;retries&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">//批次大小:一次发送数据的大小</span></span><br><span class="line">        props.put(<span class="string">&quot;batch.size&quot;</span>, <span class="number">16384</span>);</span><br><span class="line">        <span class="comment">//等待时间</span></span><br><span class="line">        props.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//RecordAccumulator 缓冲区大小</span></span><br><span class="line">        props.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">33554432</span>);</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Producer&lt;String, String&gt; myProducer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            myProducer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">&quot;first&quot;</span>,Integer.toString(i), Integer.toString(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不close的话 如果执行时间不到设置的等待时间 或者数据大小不够设置的批次大小 数据会停留在缓存区中不被发送</span></span><br><span class="line">        myProducer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallBackProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;192.168.52.131:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;retries&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        props.put(<span class="string">&quot;batch.size&quot;</span>, <span class="number">16384</span>);</span><br><span class="line">        props.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        props.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">33554432</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span></span><br><span class="line">                KafkaProducer&lt;&gt;(props);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">&quot;first&quot;</span>,</span><br><span class="line">                    Integer.toString(i), Integer.toString(i)), <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">                <span class="comment">//回调函数，该方法会在 Producer 收到 ack 时调用，为异步调用</span></span><br><span class="line">                <span class="comment">//消息发送失败会自动重试</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Exception exception)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (exception == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;success-&gt;&quot;</span> +</span><br><span class="line">                                metadata.offset());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        exception.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h4><p>同步发送的意思就是，一条消息发送之后，会阻塞当前线程，直至返回 ack。 由于 send 方法返回的是一个 Future 对象，根据 Futrue 对象的特点，我们也可以实现同 步发送的效果，只需在调用 Future 对象的 get 方发即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop102:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;retries&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        props.put(<span class="string">&quot;batch.size&quot;</span>, <span class="number">16384</span>);</span><br><span class="line">        props.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        props.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">33554432</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">&quot;first&quot;</span>,</span><br><span class="line">                    Integer.toString(i), Integer.toString(i))).get();</span><br><span class="line">        &#125;</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Consuemr-API"><a href="#Consuemr-API" class="headerlink" title="Consuemr API"></a>Consuemr API</h3><p><strong>自动提交</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;192.168.52.131:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//开启自动提交</span></span><br><span class="line">        props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="comment">//自动提交间隔时间</span></span><br><span class="line">        props.put(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(<span class="string">&quot;first&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;offset = %d, key = %s, value= %s%n&quot;</span>, record.offset(), record.key(), record.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>手动提交</strong></p><p>手动提交 offset 的方法有两种：分别是 commitSync（同步提交）和 commitAsync（异步 提交）。两者的相同点是，都会将本次 poll 的一批数据最高的偏移量提交；不同点是， commitSync 阻塞当前线程，一直到提交成功，并且会自动失败重试（由不可控因素导致， 也会出现提交失败）；而 commitAsync 则没有失败重试机制，故有可能提交失败。</p><p>同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;192.168.52.131:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//开启自动提交</span></span><br><span class="line">        props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        <span class="comment">//自动提交间隔时间</span></span><br><span class="line">        props.put(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(<span class="string">&quot;first&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">                    consumer.poll(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s%n&quot;</span>, record.offset(), record.key(), record.value());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//同步提交，当前线程会阻塞直到 offset 提交成功</span></span><br><span class="line">            consumer.commitSync();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;192.168.52.131:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//开启自动提交</span></span><br><span class="line">        props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        <span class="comment">//自动提交间隔时间</span></span><br><span class="line">        props.put(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(<span class="string">&quot;first&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s%n&quot;</span>, record.offset(), record.key(), record.value());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//异步提交</span></span><br><span class="line">            consumer.commitAsync(<span class="keyword">new</span> OffsetCommitCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        System.err.println(<span class="string">&quot;Commit failed for&quot;</span> +</span><br><span class="line">                                offsets);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义-Interceptors"><a href="#自定义-Interceptors" class="headerlink" title="自定义 Interceptors"></a>自定义 Interceptors</h2><p>Producer 拦截器(interceptor)是在 Kafka 0.10 版本被引入的，主要用于实现 clients 端的定 制化控制逻辑。 对于 producer 而言，interceptor 使得用户在消息发送前以及 producer 回调逻辑前有机会 对消息做一些定制化需求，比如修改消息等。同时，producer 允许用户指定多个 interceptor 按序作用于同一条消息从而形成一个拦截链(interceptor chain)。Intercetpor 的实现接口是 org.apache.kafka.clients.producer.ProducerInterceptor，其定义的方法包括：</p><ol><li>configure(configs):获取配置信息和初始化数据时调用。</li><li>onSend(ProducerRecord):该方法封装进 KafkaProducer.send 方法中，即它运行在用户主线程中。Producer 确保在消息被序列化以及计算分区前调用该方法。用户可以在该方法中对消息做任何操作，但最好 保证不要修改消息所属的 topic 和分区，否则会影响目标分区的计算。</li><li>onAcknowledgement(RecordMetadata, Exception):该方法会在消息从 RecordAccumulator 成功发送到 Kafka Broker 之后，或者在发送过程 中失败时调用。并且通常都是在 producer 回调逻辑触发之前。onAcknowledgement 运行在 producer 的 IO 线程中，因此不要在该方法中放入很重的逻辑，否则会拖慢 producer 的消息 发送效率。</li><li>close:关闭 interceptor，主要用于执行一些资源清理工作</li></ol><p>实现:实现一个简单的双 interceptor 组成的拦截链。第一个 interceptor 会在消息发送前将时间 戳信息加到消息 value 的最前部；第二个 interceptor 会在消息发送后更新成功发送消息数或 失败发送消息数。</p><p>​    </p>]]></content>
    
    
    <summary type="html">Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者在网站中的所有动作流数据</summary>
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ</title>
    <link href="http://example.com/2021/03/14/RocketMQ/"/>
    <id>http://example.com/2021/03/14/RocketMQ/</id>
    <published>2021-03-14T01:08:02.000Z</published>
    <updated>2021-03-15T02:31:48.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul><li><p>Producer：消息的发送者；举例：发信者</p></li><li><p>Consumer：消息接收者；举例：收信者</p></li><li><p>Broker：暂存和传输消息；举例：邮局</p></li><li><p>NameServer：管理Broker；举例：各个邮局的管理机构</p></li><li><p>Topic：区分消息的种类；一个发送者可以发送消息给一个或者多个Topic；一个消息的接收者可以订阅一个或者多个Topic消息；一个topic中可以有多个queue</p></li><li><p>Message Queue：相当于是Topic的分区；用于并行发送和接收消息；<strong>一个消费者集群多台机器共同消费一个 <code>topic</code> 的多个队列，</strong>一个队列只会被一个消费者消费****</p><p><img src="/2021/03/14/RocketMQ/log\source_posts\RocketMQ\image-20210315102610960.png" alt="image-20210315102610960"></p></li></ul><p><img src="/2021/03/14/RocketMQ/log\source_posts\RocketMQ\image-20210315103101346.png" alt="image-20210315103101346"></p><h2 id="集群特点"><a href="#集群特点" class="headerlink" title="集群特点"></a>集群特点</h2><ul><li><p>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</p></li><li><p>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。</p></li><li><p>Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</p></li><li><p>Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。</p></li></ul><h2 id="Broker集群模式"><a href="#Broker集群模式" class="headerlink" title="Broker集群模式"></a>Broker集群模式</h2><h4 id="1）单Master模式"><a href="#1）单Master模式" class="headerlink" title="1）单Master模式"></a>1）单Master模式</h4><p>这种方式风险较大，一旦Broker重启或者宕机时，会导致整个服务不可用。不建议线上环境使用,可以用于本地测试。</p><h4 id="2）多Master模式"><a href="#2）多Master模式" class="headerlink" title="2）多Master模式"></a>2）多Master模式</h4><p>一个集群无Slave，全是Master，例如2个Master或者3个Master，这种模式的优缺点如下：</p><ul><li>优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；</li><li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。</li></ul><h4 id="3）多Master多Slave模式（异步）"><a href="#3）多Master多Slave模式（异步）" class="headerlink" title="3）多Master多Slave模式（异步）"></a>3）多Master多Slave模式（异步）</h4><p>每个Master配置一个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：</p><ul><li>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样；</li><li>缺点：Master宕机，磁盘损坏情况下会丢失少量消息。</li></ul><h4 id="4）多Master多Slave模式（同步）"><a href="#4）多Master多Slave模式（同步）" class="headerlink" title="4）多Master多Slave模式（同步）"></a>4）多Master多Slave模式（同步）</h4><p>每个Master配置一个Slave，有多对Master-Slave，HA采用同步双写方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：</p><ul><li>优点：数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；</li><li>缺点：性能比异步复制模式略低（大约低10%左右），发送单个消息的RT会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</li></ul><h2 id="集群工作流程"><a href="#集群工作流程" class="headerlink" title="集群工作流程"></a>集群工作流程</h2><ol><li>启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。</li><li>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。</li><li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</li><li>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。</li><li>Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。</li></ol><h1 id="消息发送案例"><a href="#消息发送案例" class="headerlink" title="消息发送案例"></a>消息发送案例</h1><h2 id="基本样例"><a href="#基本样例" class="headerlink" title="基本样例"></a>基本样例</h2><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><h4 id="1）发送同步消息"><a href="#1）发送同步消息" class="headerlink" title="1）发送同步消息"></a>1）发送同步消息</h4><p>这种可靠性同步地发送方式使用的比较广泛，比如：重要的消息通知，短信通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建消息生产者producer，并制定生产者组名</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//2.指定Nameserver地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.52.131:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//3.启动producer</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//4.创建消息对象，指定主题Topic、Tag和消息体</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数一：消息主题Topic</span></span><br><span class="line"><span class="comment">             * 参数二：消息Tag</span></span><br><span class="line"><span class="comment">             * 参数三：消息内容</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;springboot-mq&quot;</span>, <span class="string">&quot;Tag1&quot;</span>, (<span class="string">&quot;Hello World&quot;</span> + i).getBytes());</span><br><span class="line">            <span class="comment">//5.发送消息</span></span><br><span class="line">            SendResult result = producer.send(msg);</span><br><span class="line">            <span class="comment">//发送状态</span></span><br><span class="line">            SendStatus status = result.getSendStatus();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;发送结果:&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//线程睡1秒</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭生产者producer</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）发送异步消息"><a href="#2）发送异步消息" class="headerlink" title="2）发送异步消息"></a>2）发送异步消息</h4><p>异步消息通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待Broker的响应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    <span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;TagA&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;OrderID188&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Hello world&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                <span class="comment">// SendCallback接收异步返回结果的回调</span></span><br><span class="line">                producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;%-10d OK %s %n&quot;</span>, index,</span><br><span class="line">                            sendResult.getMsgId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%-10d Exception %s %n&quot;</span>, index, e);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）单向发送消息"><a href="#3）单向发送消息" class="headerlink" title="3）单向发送消息"></a>3）单向发送消息</h4><p>这种方式主要用在不特别关心发送结果的场景，例如日志发送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnewayProducer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    <span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">        Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span> ,</span><br><span class="line">                <span class="string">&quot;TagA&quot;</span> ,</span><br><span class="line">                (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET)</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 发送单向消息，没有任何返回结果</span></span><br><span class="line">        producer.sendOneway(msg);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><p>默认是负载均衡模式</p><p>1）负载均衡模式</p><p>消费者采用负载均衡方式消费消息，多个消费者共同消费队列消息，每个消费者处理的消息不同</p><p>2）广播模式</p><p>消费者采用广播的方式消费消息，每个消费者消费的消息都是相同的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消息生产者,指定组名</span></span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">    <span class="comment">// 指定Namesrv地址信息.</span></span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    <span class="comment">// 订阅Topic:第一个参数是topic第二个参数是tag</span></span><br><span class="line">    consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="comment">//负载均衡模式消费</span></span><br><span class="line">    consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line">    <span class="comment">//广播模式消费</span></span><br><span class="line">    <span class="comment">//consumer.setMessageModel(MessageModel.BROADCASTING);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册回调函数，处理消息</span></span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, </span><br><span class="line">                              Thread.currentThread().getName(), msgs);</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//启动消息者</span></span><br><span class="line">    consumer.start();</span><br><span class="line">    System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><p>消息有序指的是可以按照消息的发送顺序来消费(FIFO)。RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。</p><p>顺序消费的原理解析，在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue(分区队列)；而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。但是如果控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取，则就保证了顺序。当发送和消费参与的queue只有一个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。</p><p>下面用订单进行分区有序的示例。一个订单的顺序流程是：创建、付款、推送、完成。订单号相同的消息会被先后发送到同一个队列中，消费时，同一个OrderId获取到的肯定是同一个队列。</p><h3 id="顺序消息生产"><a href="#顺序消息生产" class="headerlink" title="顺序消息生产"></a>顺序消息生产</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单构建者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderStep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> orderId;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getOrderId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderId</span><span class="params">(<span class="keyword">long</span> orderId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OrderStep&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;orderId=&quot;</span> + orderId +</span><br><span class="line">                <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;OrderStep&gt; <span class="title">buildOrders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  1039L   : 创建    付款 推送 完成</span></span><br><span class="line">        <span class="comment">//  1065L   ： 创建   付款</span></span><br><span class="line">        <span class="comment">//  7235L   ：创建    付款</span></span><br><span class="line">        List&lt;OrderStep&gt; orderList = <span class="keyword">new</span> ArrayList&lt;OrderStep&gt;();</span><br><span class="line"></span><br><span class="line">        OrderStep orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1039L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;创建&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1065L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;创建&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1039L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;付款&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">7235L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;创建&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1065L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;付款&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">7235L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;付款&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1065L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1039L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;推送&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">7235L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1039L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> orderList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建消息生产者producer，并制定生产者组名</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//2.指定Nameserver地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.25.135:9876;192.168.25.138:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//3.启动producer</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="comment">//构建消息集合</span></span><br><span class="line">        List&lt;OrderStep&gt; orderSteps = OrderStep.buildOrders();</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; orderSteps.size(); i++) &#123;</span><br><span class="line">            String body = orderSteps.get(i) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            Message message = <span class="keyword">new</span> Message(<span class="string">&quot;OrderTopic&quot;</span>, <span class="string">&quot;Order&quot;</span>, <span class="string">&quot;i&quot;</span> + i, body.getBytes());</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数一：消息对象</span></span><br><span class="line"><span class="comment">             * 参数二：消息队列的选择器</span></span><br><span class="line"><span class="comment">             * 参数三：选择队列的业务标识（订单ID）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            SendResult sendResult = producer.send(message, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@param</span> mqs：队列集合</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@param</span> msg：消息对象</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@param</span> arg：业务标识的参数 send的第三个参数</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//选择队列</span></span><br><span class="line">                    <span class="keyword">long</span> index = (<span class="keyword">long</span>) arg % mqs.size();</span><br><span class="line">                    <span class="keyword">return</span> mqs.get((<span class="keyword">int</span>) index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, orderSteps.get(i).getOrderId());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;发送结果：&quot;</span> + sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-顺序消费消息"><a href="#4-2-2-顺序消费消息" class="headerlink" title="4.2.2 顺序消费消息"></a>4.2.2 顺序消费消息</h3><p>一个线程处理一个队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 顺序消息消费，带事务方式（应用可控制Offset什么时候提交）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerInOrder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       DefaultMQPushConsumer consumer = <span class="keyword">new</span> </span><br><span class="line">           DefaultMQPushConsumer(<span class="string">&quot;please_rename_unique_group_name_3&quot;</span>);</span><br><span class="line">       consumer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费&lt;br&gt;</span></span><br><span class="line"><span class="comment">        * 如果非第一次启动，那么按照上次消费的位置继续消费</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">       consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;TagA || TagC || TagD&quot;</span>);</span><br><span class="line"></span><br><span class="line">       consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line"></span><br><span class="line">           Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">               context.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">               <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                   <span class="comment">// 可以看到每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序</span></span><br><span class="line">                   System.out.println(<span class="string">&quot;consumeThread=&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;queueId=&quot;</span> + msg.getQueueId() + <span class="string">&quot;, content:&quot;</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//模拟业务逻辑处理中...</span></span><br><span class="line">                   TimeUnit.SECONDS.sleep(random.nextInt(<span class="number">10</span>));</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       consumer.start();</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;Consumer Started.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h2><p>比如电商里，提交了一个订单就可以发送一个延时消息，1h后去检查这个订单的状态，如果还是未付款就取消订单释放库存。</p><h3 id="启动消息消费者"><a href="#启动消息消费者" class="headerlink" title="启动消息消费者"></a>启动消息消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledMessageConsumer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 实例化消费者</span></span><br><span class="line">      DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;ExampleConsumer&quot;</span>);</span><br><span class="line">      <span class="comment">// 订阅Topics</span></span><br><span class="line">      consumer.subscribe(<span class="string">&quot;TestTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">      <span class="comment">// 注册消息监听者</span></span><br><span class="line">      consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; messages, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">for</span> (MessageExt message : messages) &#123;</span><br><span class="line">                  <span class="comment">// Print approximate delay time period</span></span><br><span class="line">                  System.out.println(<span class="string">&quot;Receive message[msgId=&quot;</span> + message.getMsgId() + <span class="string">&quot;] &quot;</span> + (System.currentTimeMillis() - message.getStoreTimestamp()) + <span class="string">&quot;ms later&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 启动消费者</span></span><br><span class="line">      consumer.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送延时消息"><a href="#发送延时消息" class="headerlink" title="发送延时消息"></a>发送延时消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledMessageProducer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 实例化一个生产者来产生延时消息</span></span><br><span class="line">      DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;ExampleProducerGroup&quot;</span>);</span><br><span class="line">      <span class="comment">// 启动生产者</span></span><br><span class="line">      producer.start();</span><br><span class="line">      <span class="keyword">int</span> totalMessagesToSend = <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">          Message message = <span class="keyword">new</span> Message(<span class="string">&quot;TestTopic&quot;</span>, (<span class="string">&quot;Hello scheduled message &quot;</span> + i).getBytes());</span><br><span class="line">          <span class="comment">// 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)</span></span><br><span class="line">          message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">          <span class="comment">// 发送消息</span></span><br><span class="line">          producer.send(message);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 关闭生产者</span></span><br><span class="line">      producer.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>您将会看到消息的消费比存储时间晚10秒</p><h3 id="4-3-4-使用限制"><a href="#4-3-4-使用限制" class="headerlink" title="4.3.4 使用限制"></a>4.3.4 使用限制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org/apache/rocketmq/store/config/MessageStoreConfig.java</span></span><br><span class="line"><span class="keyword">private</span> String messageDelayLevel = <span class="string">&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;</span>;</span><br></pre></td></tr></table></figure><p>现在RocketMq并不支持任意时间的延时，需要设置几个固定的延时等级，从1s到2h分别对应着等级1到18</p><h2 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h2><p>批量发送消息能显著提高传递小消息的性能。限制是这些批量消息应该有相同的topic，相同的waitStoreMsgOK，而且不能是延时消息。此外，这一批消息的总大小不应超过4MB。</p><h3 id="发送批量消息"><a href="#发送批量消息" class="headerlink" title="发送批量消息"></a>发送批量消息</h3><p>如果您每次只发送不超过4MB的消息，则很容易使用批处理，样例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String topic = <span class="string">&quot;BatchTest&quot;</span>;</span><br><span class="line">List&lt;Message&gt; messages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;OrderID001&quot;</span>, <span class="string">&quot;Hello world 0&quot;</span>.getBytes()));</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;OrderID002&quot;</span>, <span class="string">&quot;Hello world 1&quot;</span>.getBytes()));</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;OrderID003&quot;</span>, <span class="string">&quot;Hello world 2&quot;</span>.getBytes()));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   producer.send(messages);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">   <span class="comment">//处理error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果消息的总长度可能大于4MB时，这时候最好把消息进行分割</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListSplitter</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">List</span>&lt;<span class="title">Message</span>&gt;&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE_LIMIT = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Message&gt; messages;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> currIndex;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ListSplitter</span><span class="params">(List&lt;Message&gt; messages)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.messages = messages;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> currIndex &lt; messages.size();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Message&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> nextIndex = currIndex;</span><br><span class="line">       <span class="keyword">int</span> totalSize = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class="line">           Message message = messages.get(nextIndex);</span><br><span class="line">           <span class="keyword">int</span> tmpSize = message.getTopic().length() + message.getBody().length;</span><br><span class="line">           Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">               tmpSize += entry.getKey().length() + entry.getValue().length();</span><br><span class="line">           &#125;</span><br><span class="line">           tmpSize = tmpSize + <span class="number">20</span>; <span class="comment">// 增加日志的开销20字节</span></span><br><span class="line">           <span class="keyword">if</span> (tmpSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">               <span class="comment">//单个消息超过了最大的限制</span></span><br><span class="line">               <span class="comment">//忽略,否则会阻塞分裂的进程</span></span><br><span class="line">               <span class="keyword">if</span> (nextIndex - currIndex == <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">//假如下一个子列表没有元素,则添加这个子列表然后退出循环,否则只是退出循环</span></span><br><span class="line">                  nextIndex++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               totalSize += tmpSize;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;Message&gt; subList = messages.subList(currIndex, nextIndex);</span><br><span class="line">       currIndex = nextIndex;</span><br><span class="line">       <span class="keyword">return</span> subList;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把大的消息分裂成若干个小的消息</span></span><br><span class="line">ListSplitter splitter = <span class="keyword">new</span> ListSplitter(messages);</span><br><span class="line"><span class="keyword">while</span> (splitter.hasNext()) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      List&lt;Message&gt;  listItem = splitter.next();</span><br><span class="line">      producer.send(listItem);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="comment">//处理error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="过滤消息"><a href="#过滤消息" class="headerlink" title="过滤消息"></a>过滤消息</h2><p>在大多数情况下，TAG是一个简单而有用的设计，其可以来选择您想要的消息。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;CID_EXAMPLE&quot;</span>);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;TOPIC&quot;</span>, <span class="string">&quot;TAGA || TAGB || TAGC&quot;</span>);</span><br></pre></td></tr></table></figure><p>消费者将接收包含TAGA或TAGB或TAGC的消息。但是限制是一个消息只能有一个标签，这对于复杂的场景可能不起作用。在这种情况下，可以使用SQL表达式筛选消息。SQL特性可以通过发送消息时的属性来进行计算。在RocketMQ定义的语法下，可以实现一些简单的逻辑。下面是一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">------------</span><br><span class="line">| message  |</span><br><span class="line">|----------|  a &gt; 5 AND b &#x3D; &#39;abc&#39;</span><br><span class="line">| a &#x3D; 10   |  --------------------&gt; Gotten</span><br><span class="line">| b &#x3D; &#39;abc&#39;|</span><br><span class="line">| c &#x3D; true |</span><br><span class="line">------------</span><br><span class="line">------------</span><br><span class="line">| message  |</span><br><span class="line">|----------|   a &gt; 5 AND b &#x3D; &#39;abc&#39;</span><br><span class="line">| a &#x3D; 1    |  --------------------&gt; Missed</span><br><span class="line">| b &#x3D; &#39;abc&#39;|</span><br><span class="line">| c &#x3D; true |</span><br><span class="line">------------</span><br></pre></td></tr></table></figure><h3 id="SQL基本语法"><a href="#SQL基本语法" class="headerlink" title="SQL基本语法"></a>SQL基本语法</h3><p>RocketMQ只定义了一些基本语法来支持这个特性。你也可以很容易地扩展它。</p><ul><li>数值比较，比如：**&gt;，&gt;=，&lt;，&lt;=，BETWEEN，=；**</li><li>字符比较，比如：**=，&lt;&gt;，IN；**</li><li><strong>IS NULL</strong> 或者 <strong>IS NOT NULL；</strong></li><li>逻辑符号 <strong>AND，OR，NOT；</strong></li></ul><p>常量支持类型为：</p><ul><li>数值，比如：<strong>123，3.1415；</strong></li><li>字符，比如：**’abc’，必须用单引号包裹起来；**</li><li><strong>NULL</strong>，特殊的常量</li><li>布尔值，<strong>TRUE</strong> 或 <strong>FALSE</strong></li></ul><p>只有使用push模式的消费者才能用使用SQL92标准的sql语句，接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(finalString topic, <span class="keyword">final</span> MessageSelector messageSelector)</span></span></span><br></pre></td></tr></table></figure><h3 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h3><p>发送消息时，你能通过<code>putUserProperty</code>来设置消息的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建消息生产者producer，并制定生产者组名</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//2.指定Nameserver地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.25.135:9876;192.168.25.138:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//3.启动producer</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//4.创建消息对象，指定主题Topic、Tag和消息体</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数一：消息主题Topic</span></span><br><span class="line"><span class="comment">             * 参数二：消息Tag</span></span><br><span class="line"><span class="comment">             * 参数三：消息内容</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;FilterSQLTopic&quot;</span>, <span class="string">&quot;Tag1&quot;</span>, (<span class="string">&quot;Hello World&quot;</span> + i).getBytes());</span><br><span class="line"><span class="comment">//设置属性</span></span><br><span class="line">            msg.putUserProperty(<span class="string">&quot;i&quot;</span>, String.valueOf(i));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.发送消息</span></span><br><span class="line">            SendResult result = producer.send(msg);</span><br><span class="line">            <span class="comment">//发送状态</span></span><br><span class="line">            SendStatus status = result.getSendStatus();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;发送结果:&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//线程睡1秒</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭生产者producer</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h3><p>用MessageSelector.bySql来使用sql筛选消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建消费者Consumer，制定消费者组名</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//2.指定Nameserver地址</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.25.135:9876;192.168.25.138:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//3.订阅主题Topic和Tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;FilterSQLTopic&quot;</span>, MessageSelector.bySql(<span class="string">&quot;i&gt;5&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.设置回调函数，处理消息</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接受消息内容</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;consumeThread=&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;,&quot;</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//5.启动消费者consumer</span></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p><img src="/2021/03/14/RocketMQ/log\source_posts\RocketMQ\事务消息.png"></p><p>上图说明了事务消息的大致方案，其中分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。</p><h4 id="1）事务消息发送及提交"><a href="#1）事务消息发送及提交" class="headerlink" title="1）事务消息发送及提交"></a><strong>1）事务消息发送及提交</strong></h4><p>(1) 发送消息（half消息）。</p><p>(2) 服务端响应消息写入结果。</p><p>(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p><p>(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p><h4 id="2）事务补偿"><a href="#2）事务补偿" class="headerlink" title="2）事务补偿"></a>2）<strong>事务补偿</strong></h4><p>(1) 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</p><p>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态</p><p>(3) 根据本地事务状态，重新Commit或者Rollback</p><p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p><h4 id="3）事务消息状态"><a href="#3）事务消息状态" class="headerlink" title="3）事务消息状态"></a>3）事务消息状态</h4><p>事务消息共有三种状态，提交状态、回滚状态、中间状态：</p><ul><li>TransactionStatus.CommitTransaction: 提交事务，它允许消费者消费此消息。</li><li>TransactionStatus.RollbackTransaction: 回滚事务，它代表该消息将被删除，不允许被消费。</li><li>TransactionStatus.Unknown: 中间状态，它代表需要检查消息队列来确定状态。</li></ul><h3 id="发送事务消息"><a href="#发送事务消息" class="headerlink" title="发送事务消息"></a>发送事务消息</h3><h4 id="1-创建事务性生产者"><a href="#1-创建事务性生产者" class="headerlink" title="1) 创建事务性生产者"></a>1) 创建事务性生产者</h4><p>使用 <code>TransactionMQProducer</code>类创建生产者，并指定唯一的 <code>ProducerGroup</code>，就可以设置自定义线程池来处理这些检查请求。执行本地事务后、需要根据执行结果对消息队列进行回复。回传的事务状态在请参考前一节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建消息生产者producer，并制定生产者组名</span></span><br><span class="line">        TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">&quot;group5&quot;</span>);</span><br><span class="line">        <span class="comment">//2.指定Nameserver地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.25.135:9876;192.168.25.138:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加事务监听器</span></span><br><span class="line">        producer.setTransactionListener(<span class="keyword">new</span> TransactionListener() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 在该方法中执行本地事务</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> arg</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGA&quot;</span>, msg.getTags())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGB&quot;</span>, msg.getTags())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGC&quot;</span>, msg.getTags())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 该方法时MQ进行消息事务状态回查</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息的Tag:&quot;</span> + msg.getTags());</span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.启动producer</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        String[] tags = &#123;<span class="string">&quot;TAGA&quot;</span>, <span class="string">&quot;TAGB&quot;</span>, <span class="string">&quot;TAGC&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//4.创建消息对象，指定主题Topic、Tag和消息体</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数一：消息主题Topic</span></span><br><span class="line"><span class="comment">             * 参数二：消息Tag</span></span><br><span class="line"><span class="comment">             * 参数三：消息内容</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TransactionTopic&quot;</span>, tags[i], (<span class="string">&quot;Hello World&quot;</span> + i).getBytes());</span><br><span class="line">            <span class="comment">//5.发送消息</span></span><br><span class="line">            SendResult result = producer.sendMessageInTransaction(msg, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//发送状态</span></span><br><span class="line">            SendStatus status = result.getSendStatus();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;发送结果:&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//线程睡1秒</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭生产者producer</span></span><br><span class="line">        <span class="comment">//producer.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2）实现事务的监听接口"><a href="#2）实现事务的监听接口" class="headerlink" title="2）实现事务的监听接口"></a>2）实现事务的监听接口</h4><p>当发送半消息成功时，我们使用 <code>executeLocalTransaction</code> 方法来执行本地事务。它返回前一节中提到的三个事务状态之一。<code>checkLocalTranscation</code> 方法用于检查本地事务状态，并回应消息队列的检查请求。它也是返回前一节中提到的三个事务状态之一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建消费者Consumer，制定消费者组名</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//2.指定Nameserver地址</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.25.135:9876;192.168.25.138:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//3.订阅主题Topic和Tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TransactionTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.设置回调函数，处理消息</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接受消息内容</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;consumeThread=&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;,&quot;</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//5.启动消费者consumer</span></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;生产者启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><ol><li>事务消息不支持延时消息和批量消息。</li><li>为了避免单个消息被检查太多次而导致半队列消息累积，我们默认将单个消息的检查次数限制为 15 次，但是用户可以通过 Broker 配置文件的 <code>transactionCheckMax</code>参数来修改此限制。如果已经检查某条消息超过 N 次的话（ N = <code>transactionCheckMax</code> ） 则 Broker 将丢弃此消息，并在默认情况下同时打印错误日志。用户可以通过重写 <code>AbstractTransactionCheckListener</code> 类来修改这个行为。</li><li>事务消息将在 Broker 配置文件中的参数 transactionMsgTimeout 这样的特定时间长度之后被检查。当发送事务消息时，用户还可以通过设置用户属性 CHECK_IMMUNITY_TIME_IN_SECONDS 来改变这个限制，该参数优先于 <code>transactionMsgTimeout</code> 参数。</li><li>事务性消息可能不止一次被检查或消费。</li><li>提交给用户的目标主题消息可能会失败，目前这依日志的记录而定。它的高可用性通过 RocketMQ 本身的高可用性机制来保证，如果希望确保事务消息不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制。</li><li>事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享。与其他类型的消息不同，事务消息允许反向查询、MQ服务器能通过它们的生产者 ID 查询到消费者。</li></ol>]]></content>
    
    
    <summary type="html">RocketMQ是一款分布式消息中心</summary>
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq</title>
    <link href="http://example.com/2021/03/13/rabbitmq/"/>
    <id>http://example.com/2021/03/13/rabbitmq/</id>
    <published>2021-03-13T02:20:39.000Z</published>
    <updated>2021-03-27T15:30:06.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五种消息模型"><a href="#五种消息模型" class="headerlink" title="五种消息模型"></a>五种消息模型</h1><p>RabbitMQ提供了6种消息模型，但是第6种其实是RPC，并不是MQ，因此不予学习。那么也就剩下5种。</p><p>但是其实3、4、5这三种都属于订阅模型，只不过进行路由的方式不同。</p><p><img src="/2021/03/13/rabbitmq/1527068544487.png" alt="1527068544487"></p><p>我们通过一个demo工程来了解下RabbitMQ的工作方式：</p><p>导入工程：itcast-rabbitmq</p><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们抽取一个建立RabbitMQ连接的工具类，方便其他程序获取连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立与RabbitMQ的连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//定义连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置服务地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.56.101&quot;</span>);</span><br><span class="line">        <span class="comment">//端口</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//设置账号信息，用户名、密码、vhost</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/leyou&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;leyou&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;leyou&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过工程获取连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本消息模型"><a href="#基本消息模型" class="headerlink" title="基本消息模型"></a>基本消息模型</h2><p>RabbitMQ是一个消息代理：它接受和转发消息。 你可以把它想象成一个邮局：当你把邮件放在邮箱里时，你可以确定邮差先生最终会把邮件发送给你的收件人。 在这个比喻中，RabbitMQ是邮政信箱，邮局和邮递员。</p><p>RabbitMQ与邮局的主要区别是它不处理纸张，而是接受，存储和转发数据消息的二进制数据块。</p><p> <img src="/2021/03/13/rabbitmq/1532762975546.png" alt="1532762975546"></p><p>P（producer/ publisher）：生产者，一个发送消息的用户应用程序。</p><p>C（consumer）：消费者，消费和接收有类似的意思，消费者是一个主要用来等待接收消息的用户应用程序</p><p>队列（红色区域）：rabbitmq内部类似于邮箱的一个概念。虽然消息流经rabbitmq和你的应用程序，但是它们只能存储在队列中。队列只受主机的内存和磁盘限制，实质上是一个大的消息缓冲区。许多生产者可以发送消息到一个队列，许多消费者可以尝试从一个队列接收数据。</p><p>总之：</p><p>生产者将消息发送到队列，消费者从队列中获取消息，队列是存储消息的缓冲区。</p><p>我们将用Java编写两个程序;发送单个消息的生产者，以及接收消息并将其打印出来的消费者。我们将详细介绍Java API中的一些细节，这是一个消息传递的“Hello World”。</p><p>我们将调用我们的消息发布者（发送者）Send和我们的消息消费者（接收者）Recv。发布者将连接到RabbitMQ，发送一条消息，然后退出。</p><h3 id="生产者发送消息"><a href="#生产者发送消息" class="headerlink" title="生产者发送消息"></a>生产者发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;simple_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接以及mq通道</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 从连接中创建通道，这是完成大部分API的地方。</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明（创建）队列，必须声明队列才能够发送消息，我们可以把消息发送到队列中。</span></span><br><span class="line">        <span class="comment">// 声明一个队列是幂等的 - 只有当它不存在时才会被创建</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管理工具中查看消息"><a href="#管理工具中查看消息" class="headerlink" title="管理工具中查看消息"></a>管理工具中查看消息</h3><p>进入队列页面，可以看到新建了一个队列：simple_queue</p><p><img src="/2021/03/13/rabbitmq/1532763817830.png" alt="1532763817830"></p><p>点击队列名称，进入详情页，可以查看消息：</p><p><img src="/2021/03/13/rabbitmq/1532763489858.png" alt="1532763489858"></p><p>在控制台查看消息并不会将消息消费，所以消息还在。</p><h3 id="消费者获取消息"><a href="#消费者获取消息" class="headerlink" title="消费者获取消息"></a>消费者获取消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;simple_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [x] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，第二个参数：是否自动进行消息确认。</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，消费者已经获取了消息，但是程序没有停止，一直在监听队列中是否有新的消息。一旦有新的消息进入队列，就会立即打印.</p><h3 id="消息确认机制（ACK）"><a href="#消息确认机制（ACK）" class="headerlink" title="消息确认机制（ACK）"></a>消息确认机制（ACK）</h3><p>通过刚才的案例可以看出，消息一旦被消费者接收，队列中的消息就会被删除。</p><p>那么问题来了：RabbitMQ怎么知道消息被接收了呢？</p><p>如果消费者领取消息后，还没执行操作就挂掉了呢？或者抛出了异常？消息消费失败，但是RabbitMQ无从得知，这样消息就丢失了！</p><p>因此，RabbitMQ有一个ACK机制。当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。不过这种回执ACK分两种情况：</p><ul><li>自动ACK：消息一旦被接收，消费者自动发送ACK</li><li>手动ACK：消息接收后，不会发送ACK，需要手动调用</li></ul><p>大家觉得哪种更好呢？</p><p>这需要看消息的重要性：</p><ul><li>如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便</li><li>如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。如果此时消费者宕机，那么消息就丢失了。</li></ul><p>我们之前的测试都是自动ACK的，如果要手动ACK，需要改动我们的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;simple_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [x] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">                <span class="comment">// 手动进行ACK</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，第二个参数false，手动进行ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到最后一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br></pre></td></tr></table></figure><p>如果第二个参数为true，则会自动进行ACK；如果为false，则需要手动ACK。方法的声明：</p><p><img src="/2021/03/13/rabbitmq/1532764253019.png" alt="1532764253019"></p><h4 id="自动ACK存在的问题"><a href="#自动ACK存在的问题" class="headerlink" title="自动ACK存在的问题"></a>自动ACK存在的问题</h4><p>修改消费者，添加异常，如下：</p><p><img src="/2021/03/13/rabbitmq/1532764600849.png" alt="1532764600849"></p><p>生产者不做任何修改，直接运行，消息发送成功：</p><p><img src="/2021/03/13/rabbitmq/1532764694290.png" alt="1532764694290"></p><p>运行消费者，程序抛出异常。但是消息依然被消费：</p><p><img src="/2021/03/13/rabbitmq/1532764717995.png" alt="1532764717995"></p><p>管理界面：</p><p><img src="/2021/03/13/rabbitmq/1532764734232.png" alt="1532764734232"></p><h4 id="演示手动ACK"><a href="#演示手动ACK" class="headerlink" title="演示手动ACK"></a>演示手动ACK</h4><p>修改消费者，把自动改成手动（去掉之前制造的异常）</p><p><img src="/2021/03/13/rabbitmq/1532764831241.png" alt="1532764831241"></p><p>生产者不变，再次运行：</p><p><img src="/2021/03/13/rabbitmq/1532764895239.png" alt="1532764895239"></p><p>运行消费者</p><p><img src="/2021/03/13/rabbitmq/1532764957092.png" alt="1532764957092"></p><p>但是，查看管理界面，发现：</p><p><img src="/2021/03/13/rabbitmq/1532765013834.png" alt="1532765013834"></p><p>停掉消费者的程序，发现：</p><p><img src="/2021/03/13/rabbitmq/1532765038088.png" alt="1532765038088"></p><p>这是因为虽然我们设置了手动ACK，但是代码中并没有进行消息确认！所以消息并未被真正消费掉。</p><p>当我们关掉这个消费者，消息的状态再次称为Ready</p><p>修改代码手动ACK：</p><p><img src="/2021/03/13/rabbitmq/1532765123282.png" alt="1532765123282"></p><p>执行：</p><p><img src="/2021/03/13/rabbitmq/1532765151039.png" alt="1532765151039"></p><p>消息消费成功！</p><h2 id="work消息模型"><a href="#work消息模型" class="headerlink" title="work消息模型"></a>work消息模型</h2><p>工作队列或者竞争消费者模式</p><p> <img src="/2021/03/13/rabbitmq/1532765197277.png" alt="1532765197277"></p><p>在第一篇教程中，我们编写了一个程序，从一个命名队列中发送并接受消息。在这里，我们将创建一个工作队列，在多个工作者之间分配耗时任务。</p><p>工作队列，又称任务队列。主要思想就是避免执行资源密集型任务时，必须等待它执行完成。相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列。 在后台运行的工作进程将获取任务并最终执行作业。当你运行许多消费者时，任务将在他们之间共享，但是<strong>一个消息只能被一个消费者获取</strong>。</p><p>这个概念在Web应用程序中特别有用，因为在短的HTTP请求窗口中无法处理复杂的任务。</p><p>接下来我们来模拟这个流程：</p><pre><code>P：生产者：任务的发布者C1：消费者，领取任务并且完成任务，假设完成速度较快C2：消费者2：领取任务并完成任务，假设完成速度慢</code></pre><p>面试题：避免消息堆积？</p><p>1）采用workqueue，多个消费者监听同一队列。</p><p>2）接收到消息以后，而是通过线程池，异步消费。 </p><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>生产者与案例1中的几乎一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;test_work_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 循环发布任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 消息内容</span></span><br><span class="line">            String message = <span class="string">&quot;task .. &quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这里我们是循环发送50条消息。</p><h3 id="消费者1"><a href="#消费者1" class="headerlink" title="消费者1"></a>消费者1</h3><p><img src="/2021/03/13/rabbitmq/1527085386747.png" alt="1527085386747"></p><h3 id="消费者2"><a href="#消费者2" class="headerlink" title="消费者2"></a>消费者2</h3><p><img src="/2021/03/13/rabbitmq/1527085448377.png" alt="1527085448377"></p><p>与消费者1基本类似，就是没有设置消费耗时时间。</p><p>这里是模拟有些消费者快，有些比较慢。</p><p>接下来，两个消费者一同启动，然后发送50条消息：</p><p><img src="/2021/03/13/rabbitmq/1527085826462.png" alt="1527085826462"></p><p>可以发现，两个消费者各自消费了25条消息，而且各不相同，这就实现了任务的分发。</p><h3 id="能者多劳"><a href="#能者多劳" class="headerlink" title="能者多劳"></a>能者多劳</h3><p>刚才的实现有问题吗？</p><ul><li>消费者1比消费者2的效率要低，一次任务的耗时较长</li><li>然而两人最终消费的消息数量是一样的</li><li>消费者2大量时间处于空闲状态，消费者1一直忙碌</li></ul><p>现在的状态属于是把任务平均分配，正确的做法应该是消费越快的人，消费的越多。</p><p>怎么实现呢？</p><p>我们可以使用basicQos方法和prefetchCount = 1设置。 这告诉RabbitMQ一次不要向工作人员发送多于一条消息。 或者换句话说，不要向工作人员发送新消息，直到它处理并确认了前一个消息。 相反，它会将其分派给不是仍然忙碌的下一个工作人员。</p><p><img src="/2021/03/13/rabbitmq/1532765689904.png" alt="1532765689904"></p><p>再次测试：</p><p><img src="/2021/03/13/rabbitmq/1527086159534.png" alt="1527086159534"></p><h2 id="订阅模型分类"><a href="#订阅模型分类" class="headerlink" title="订阅模型分类"></a>订阅模型分类</h2><p>在之前的模式中，我们创建了一个工作队列。 工作队列背后的假设是：每个任务只被传递给一个工作人员。 在这一部分，我们将做一些完全不同的事情 - 我们将会传递一个信息给多个消费者。 这种模式被称为“发布/订阅”。 </p><p>订阅模型示意图：</p><p> <img src="/2021/03/13/rabbitmq/1527086284940.png" alt="1527086284940"></p><p>解读：</p><p>1、1个生产者，多个消费者</p><p>2、每一个消费者都有自己的一个队列</p><p>3、生产者没有将消息直接发送到队列，而是发送到了交换机</p><p>4、每个队列都要绑定到交换机</p><p>5、生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者获取的目的</p><p>X（Exchanges）：交换机一方面：接收生产者发送的消息。另一方面：知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</p><p>Exchange类型有以下几种：</p><pre><code>Fanout：广播，将消息交给所有绑定到交换机的队列Direct：定向，把消息交给符合指定routing key 的队列 Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</code></pre><p>我们这里先学习</p><pre><code>Fanout：即广播模式</code></pre><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><h2 id="订阅模型-Fanout"><a href="#订阅模型-Fanout" class="headerlink" title="订阅模型-Fanout"></a>订阅模型-Fanout</h2><p>Fanout，也称为广播。</p><p>流程图：</p><p> <img src="/2021/03/13/rabbitmq/1527086564505.png" alt="1527086564505"></p><p>在广播模式下，消息发送流程是这样的：</p><ul><li>1）  可以有多个消费者</li><li>2）  每个<strong>消费者有自己的queue</strong>（队列）</li><li>3）  每个<strong>队列都要绑定到Exchange</strong>（交换机）</li><li>4）  <strong>生产者发送的消息，只能发送到交换机</strong>，交换机来决定要发给哪个队列，生产者无法决定。</li><li>5）  交换机把消息发送给绑定过的所有队列</li><li>6）  队列的消费者都能拿到消息。实现一条消息被多个消费者消费</li></ul><h3 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h3><p>两个变化：</p><ul><li>1）  声明Exchange，不再声明Queue</li><li>2）  发送消息到Exchange，不再发送到Queue</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;fanout_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为fanout</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">&quot;Hello everyone&quot;</span>;</span><br><span class="line">        <span class="comment">// 发布消息到Exchange</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [生产者] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者1-1"><a href="#消费者1-1" class="headerlink" title="消费者1"></a>消费者1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;fanout_exchange_queue_1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;fanout_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者1] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动返回完成</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意代码中：<strong>队列需要和交换机绑定</strong></p><h3 id="消费者2-1"><a href="#消费者2-1" class="headerlink" title="消费者2"></a>消费者2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;fanout_exchange_queue_2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;fanout_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者2] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，手动返回完成</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们运行两个消费者，然后发送1条消息：</p><p><img src="/2021/03/13/rabbitmq/1532766264386.png" alt="1532766264386"></p><p><img src="/2021/03/13/rabbitmq/1532766291204.png" alt="1532766291204"></p><h2 id="订阅模型-Direct"><a href="#订阅模型-Direct" class="headerlink" title="订阅模型-Direct"></a>订阅模型-Direct</h2><p>有选择性的接收消息</p><p>在订阅模式中，生产者发布消息，所有消费者都可以获取所有消息。</p><p>在路由模式中，我们将添加一个功能 - 我们将只能订阅一部分消息。 例如，我们只能将重要的错误消息引导到日志文件（以节省磁盘空间），同时仍然能够在控制台上打印所有日志消息。</p><p>但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p>在Direct模型下，队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）</p><p>消息的发送方在向Exchange发送消息时，也必须指定消息的routing key。</p><p> <img src="/2021/03/13/rabbitmq/1532766437787.png" alt="1532766437787"></p><p>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</p><p>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</p><p>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</p><p>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</p><h3 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h3><p>此处我们模拟商品的增删改，发送消息的RoutingKey分别是：insert、update、delete</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;direct_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为direct</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">&quot;商品新增了， id = 1001&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息，并且指定routing key 为：insert ,代表新增商品</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;insert&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [商品服务：] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者1-2"><a href="#消费者1-2" class="headerlink" title="消费者1"></a>消费者1</h3><p>我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;direct_exchange_queue_1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;direct_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。假设此处需要update和delete消息</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;update&quot;</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;delete&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者1] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者2-2"><a href="#消费者2-2" class="headerlink" title="消费者2"></a>消费者2</h3><p>我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;direct_exchange_queue_2&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;direct_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;insert&quot;</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;update&quot;</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;delete&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者2] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>我们分别发送增、删、改的RoutingKey，发现结果：</p><p> <img src="/2021/03/13/rabbitmq/1527088296131.png" alt="1527088296131"></p><h2 id="订阅模型-Topic"><a href="#订阅模型-Topic" class="headerlink" title="订阅模型-Topic"></a>订阅模型-Topic</h2><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p><p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><p> 通配符规则：</p><pre><code>`#`：匹配一个或多个词`*`：匹配不多不少恰好1个词</code></pre><p>举例：</p><pre><code>`audit.#`：能够匹配`audit.irs.corporate` 或者 `audit.irs``audit.*`：只能匹配`audit.irs`</code></pre><p> <img src="/2021/03/13/rabbitmq/1532766712166.png" alt="1532766712166"></p><p>在这个例子中，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：“<speed>.<color>.<species>”。</species></color></speed></p><p>我们创建了三个绑定：Q1绑定了绑定键“* .orange.<em>”，Q2绑定了“</em>.*.rabbit”和“lazy.＃”。</p><p>Q1匹配所有的橙色动物。</p><p>Q2匹配关于兔子以及懒惰动物的消息。</p><p>练习，生产者发送如下消息，会进入那个队列：</p><p>quick.orange.rabbit     Q1 Q2</p><p>lazy.orange.elephant     </p><p>quick.orange.fox      </p><p>lazy.pink.rabbit      </p><p>quick.brown.fox     </p><p>quick.orange.male.rabbit </p><p>orange </p><h3 id="生产者-3"><a href="#生产者-3" class="headerlink" title="生产者"></a>生产者</h3><p>使用topic类型的Exchange，发送消息的routing key有3种： <code>item.isnert</code>、<code>item.update</code>、<code>item.delete</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;topic_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为topic</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">&quot;新增商品 : id = 1001&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息，并且指定routing key 为：insert ,代表新增商品</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;item.insert&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [商品服务：] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者1-3"><a href="#消费者1-3" class="headerlink" title="消费者1"></a>消费者1</h3><p>我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;topic_exchange_queue_1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;topic_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。需要 update、delete</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;item.update&quot;</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;item.delete&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者1] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者2-3"><a href="#消费者2-3" class="headerlink" title="消费者2"></a>消费者2</h3><p>我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;topic_exchange_queue_2&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;topic_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;item.*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者2] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>如何避免消息丢失？</p><p>1）  消费者的ACK机制。可以防止消费者丢失消息。</p><p>2）  但是，如果在消费者消费之前，MQ就宕机了，消息就没了。</p><p>是可以将消息进行持久化呢？</p><p>要将消息持久化，前提是：队列、Exchange都持久化</p><h3 id="交换机持久化"><a href="#交换机持久化" class="headerlink" title="交换机持久化"></a>交换机持久化</h3><p><img src="/2021/03/13/rabbitmq/1532766951432.png" alt="1532766951432"></p><h3 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h3><p><img src="/2021/03/13/rabbitmq/1532766981230.png" alt="1532766981230"></p><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p><img src="/2021/03/13/rabbitmq/1532767057491.png" alt="1532767057491"></p><h1 id="Spring-AMQP"><a href="#Spring-AMQP" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring-amqp是对AMQP协议的抽象实现，而spring-rabbit 是对协议的具体实现，也是目前的唯一实现。底层使用的就是RabbitMQ。</p><h2 id="依赖和配置"><a href="#依赖和配置" class="headerlink" title="依赖和配置"></a>依赖和配置</h2><p>添加AMQP的启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>application.yml</code>中添加RabbitMQ地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.101</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">leyou</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">leyou</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/leyou</span></span><br></pre></td></tr></table></figure><h2 id="监听者"><a href="#监听者" class="headerlink" title="监听者"></a>监听者</h2><p>在SpringAmqp中，对消息的消费者进行了封装和抽象，一个普通的JavaBean中的普通方法，只要通过简单的注解，就可以成为一个消费者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(value = &quot;spring.test.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(</span></span><br><span class="line"><span class="meta">                    value = &quot;spring.test.exchange&quot;,</span></span><br><span class="line"><span class="meta">                    ignoreDeclarationExceptions = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">                    type = ExchangeTypes.TOPIC</span></span><br><span class="line"><span class="meta">            ),</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;#.#&quot;&#125;))</span></span><br><span class="line">    <span class="comment">//Message:原生消息详细信息：消息头+消息体</span></span><br><span class="line">    <span class="comment">//OrderReturnReasonEntity:消息内容</span></span><br><span class="line">    <span class="comment">//Channel:当前传输数据的通道</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(Message message,OrderReturnReasonEntity content,Channel channel)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@RabbitListener</code>：方法上的注解，声明这个方法是一个消费者方法，需要指定下面的属性：<ul><li><code>bindings</code>：指定绑定关系，可以有多个。值是<code>@QueueBinding</code>的数组。<code>@QueueBinding</code>包含下面属性：<ul><li><code>value</code>：这个消费者关联的队列。值是<code>@Queue</code>，代表一个队列</li><li><code>exchange</code>：队列所绑定的交换机，值是<code>@Exchange</code>类型</li><li><code>key</code>：队列和交换机绑定的<code>RoutingKey</code></li></ul></li></ul></li></ul><p>类似listen这样的方法在一个类中可以写多个，就代表多个消费者。</p><h2 id="AmqpTemplate"><a href="#AmqpTemplate" class="headerlink" title="AmqpTemplate"></a>AmqpTemplate</h2><p>Spring最擅长的事情就是封装，把他人的框架进行封装和整合。</p><p>Spring为AMQP提供了统一的消息处理模板：AmqpTemplate，非常方便的发送消息，其发送方法：</p><p><img src="/2021/03/13/rabbitmq/1527090258083.png" alt="1527090258083"></p><p>红框圈起来的是比较常用的3个方法，分别是：</p><ul><li>指定交换机、RoutingKey和消息体</li><li>指定消息</li><li>指定RoutingKey和消息，会向默认的交换机发送消息</li></ul><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = Application.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSend</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String msg = <span class="string">&quot;hello, Spring boot amqp&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate.convertAndSend(<span class="string">&quot;spring.test.exchange&quot;</span>,<span class="string">&quot;a.b&quot;</span>, msg);</span><br><span class="line">        <span class="comment">// 等待10秒后再结束</span></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后查看日志：</p><p><img src="/2021/03/13/rabbitmq/1532767726274.png" alt="1532767726274"></p>]]></content>
    
    
    <summary type="html">RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件</summary>
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>org.springframework.core.io.buffer.NettyDataBufferFactory</title>
    <link href="http://example.com/2021/02/22/org-springframework-core-io-buffer-NettyDataBufferFactory/"/>
    <id>http://example.com/2021/02/22/org-springframework-core-io-buffer-NettyDataBufferFactory/</id>
    <published>2021-02-22T11:59:57.000Z</published>
    <updated>2021-02-22T12:02:58.544Z</updated>
    
    <content type="html"><![CDATA[<p>在做商城项目的时候启动网关后路由到登录页面出现了下面的错误</p><p><img src="/2021/02/22/org-springframework-core-io-buffer-NettyDataBufferFactory/log\source_posts\org-springframework-core-io-buffer-NettyDataBufferFactory\image-20210222200203003.png" alt="image-20210222200203003"></p><p>解决方法： 由于springcloud的gateway使用的是webflux,默认使用netty,所以从依赖中排除 tomcat相关的依赖 ，就可以了</p><p>安装Maven Helper插件</p><p><img src="/2021/02/22/org-springframework-core-io-buffer-NettyDataBufferFactory/log\source_posts\org-springframework-core-io-buffer-NettyDataBufferFactory\image-20210222200252334.png" alt="image-20210222200252334"></p><p>排除该依赖</p>]]></content>
    
    
    <summary type="html">org.springframework.core.io.buffer.DefaultDataBufferFactory cannot be cast to org.springframework.core.io.buffer.NettyDataBufferFactory</summary>
    
    
    
    <category term="bug" scheme="http://example.com/categories/bug/"/>
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>谷粒商城</title>
    <link href="http://example.com/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/"/>
    <id>http://example.com/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/</id>
    <published>2021-02-15T09:21:39.000Z</published>
    <updated>2021-04-28T00:53:58.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="商品服务"><a href="#商品服务" class="headerlink" title="商品服务"></a>商品服务</h1><h1 id="Oss对象存储"><a href="#Oss对象存储" class="headerlink" title="Oss对象存储"></a>Oss对象存储</h1><p>文件存储</p><p><strong><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210408200004406.png" alt="image-20210408200004406"></strong></p><p>上传方式：采用JavaScript客户端直接签名（参见JavaScript客户端签名直传)时，AccessKey lD和AcessKey Secret会暴露在前端页面,因此存在严重的安全隐患。因此，OSS提供了服务端签名后直传的方案。</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210408201741526.png" alt="image-20210408201741526"></p><p>创建一个新的module(mall-thirdparty)用于存放第三方应用</p><p>导入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alicloud-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在配置文件中进行配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">alicloud:</span></span><br><span class="line">          <span class="attr">access-key:</span> <span class="string">LTAI4G5zyHGVo57wWXZSsBv6</span></span><br><span class="line">          <span class="attr">secret-key:</span> <span class="string">hNTww8jjeAHGe92BuxkEeVHDia4dAx</span></span><br><span class="line">          <span class="attr">oss:</span></span><br><span class="line">            <span class="attr">endpoint:</span> <span class="string">oss-cn-beijing.aliyuncs.com</span></span><br></pre></td></tr></table></figure><p>创建一个controller用于向oss上传文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OssController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OSS ossClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.cloud.alicloud.oss.endpoint&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.cloud.alicloud.oss.bucket&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String bucket;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.cloud.alicloud.access-key&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/oss/policy&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">policy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String bucket = <span class="string">&quot;mall-pict&quot;</span>; <span class="comment">// 请填写您的 bucketname 。</span></span><br><span class="line">        String host = <span class="string">&quot;https://&quot;</span> + bucket + <span class="string">&quot;.&quot;</span> + endpoint; <span class="comment">// host的格式为 bucketname.endpoint</span></span><br><span class="line">        <span class="comment">// callbackUrl为 上传回调服务器的URL，请将下面的IP和Port配置为您自己的真实信息。</span></span><br><span class="line">        String callbackUrl = <span class="string">&quot;http://88.88.88.88:8888&quot;</span>;</span><br><span class="line">        String format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">        String dir = format + <span class="string">&quot;/&quot;</span>; <span class="comment">// 用户上传文件时指定的前缀。上传图片的日期</span></span><br><span class="line">        Map&lt;String, String&gt; respMap = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> expireTime = <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">long</span> expireEndTime = System.currentTimeMillis() + expireTime * <span class="number">1000</span>;</span><br><span class="line">            Date expiration = <span class="keyword">new</span> Date(expireEndTime);</span><br><span class="line">            <span class="comment">// PostObject请求最大可支持的文件大小为5 GB，即CONTENT_LENGTH_RANGE为5*1024*1024*1024。</span></span><br><span class="line">            PolicyConditions policyConds = <span class="keyword">new</span> PolicyConditions();</span><br><span class="line">            policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, <span class="number">0</span>, <span class="number">1048576000</span>);</span><br><span class="line">            policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);</span><br><span class="line"></span><br><span class="line">            String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);</span><br><span class="line">            <span class="keyword">byte</span>[] binaryData = postPolicy.getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            String encodedPolicy = BinaryUtil.toBase64String(binaryData);</span><br><span class="line">            String postSignature = ossClient.calculatePostSignature(postPolicy);</span><br><span class="line"></span><br><span class="line">            respMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">            respMap.put(<span class="string">&quot;accessid&quot;</span>, accessId);</span><br><span class="line">            respMap.put(<span class="string">&quot;policy&quot;</span>, encodedPolicy);</span><br><span class="line">            respMap.put(<span class="string">&quot;signature&quot;</span>, postSignature);</span><br><span class="line">            respMap.put(<span class="string">&quot;dir&quot;</span>, dir);</span><br><span class="line">            respMap.put(<span class="string">&quot;host&quot;</span>, host);</span><br><span class="line">            respMap.put(<span class="string">&quot;expire&quot;</span>, String.valueOf(expireEndTime / <span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// Assert.fail(e.getMessage());</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ossClient.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R.ok().put(<span class="string">&quot;data&quot;</span>,respMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端有一个文件上传组件 前端从后端拿到policy和签名 然后连同文件一起发送给oss服务器完成文件的上传</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210422153538601.png" alt="image-20210422153538601"></p><p>配置跨域</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210223210510929.png" alt="image-20210223210510929"></p><p><strong>JSR303表单校验</strong></p><p>为需要校验的字段加上注解</p><p>@Valid开启校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">save</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> BrandEntity brand, BindingResult bindingResult)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//BindingResult可以获取到校验的结果</span></span><br><span class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line">        bindingResult.getFieldErrors().forEach(item -&gt; &#123;</span><br><span class="line">            String message = item.getDefaultMessage();</span><br><span class="line">            <span class="comment">//错误的属性名</span></span><br><span class="line">            String field = item.getField();</span><br><span class="line">            map.put(field,message);</span><br><span class="line">        &#125;);</span><br><span class="line">        R.error(<span class="number">400</span>,<span class="string">&quot;提交的数据不可发&quot;</span>).put(<span class="string">&quot;data&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">    brandService.save(brand);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次都这么获取叫校验结果太麻烦 创建一个类进行统一异常处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice(&quot;com.baobingjiang.mall.product.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionControllerAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">handlerValidException</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;数据校验出现问题&#123;&#125;,异常类型&#123;&#125;&quot;</span>,e.getMessage(),e.getClass());</span><br><span class="line">        <span class="keyword">return</span> R.error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分组校验：新增和修改使用两种校验方法</p><ul><li><p>字段校验注解指定分组</p></li><li><p>在controller中使用@Validated注解</p></li><li><p>没有指定分组的注解在没有指定@Validated时才会生效</p></li></ul><p>自定义校验</p><ul><li><p>编写一个自定义的校验注解</p><ul><li><pre><code class="java">@Documented//指定校验器@Constraint(validatedBy = &#123;ListValueConstraintValidator.class&#125;)@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ListValue &#123;    //要有这三个基本属性    //错误信息去哪取    String message() default &quot;&#123;javax.validation.constraints.NotBlank.message&#125;&quot;;    //支持分组    Class&lt;?&gt;[] groups() default &#123;&#125;;    //支持负载信息    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;    int[] vals() default &#123;&#125;;&#125;<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 编写一个自定义的校验器</span><br><span class="line"></span><br><span class="line">  * ```java</span><br><span class="line">    <span class="built_in">public</span> <span class="keyword">class</span> ListValueConstraintValidator implements ConstraintValidator&lt;ListValue,<span class="type">Integer</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">Set</span>&lt;<span class="type">Integer</span>&gt; <span class="keyword">set</span> = <span class="built_in">new</span> HashSet&lt;&gt;();</span><br><span class="line">        @Override</span><br><span class="line">        <span class="built_in">public</span> <span class="type">void</span> initialize(ListValue constraintAnnotation) &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="type">int</span>[] vals = constraintAnnotation.vals(); // <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> val:vals)&#123;</span><br><span class="line">                <span class="keyword">set</span>.<span class="keyword">add</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        <span class="built_in">public</span> <span class="type">boolean</span> isValid(<span class="type">Integer</span> <span class="type">integer</span>, ConstraintValidatorContext constraintValidatorContext)    &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">set</span>.contains(<span class="type">integer</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>关联校验器和校验注解</p></li></ul><p>自定义更新两种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBrand</span><span class="params">(Long brandId, String name)</span> </span>&#123;</span><br><span class="line">    CategoryBrandRelationEntity categoryBrandRelationEntity = <span class="keyword">new</span> CategoryBrandRelationEntity();</span><br><span class="line">    categoryBrandRelationEntity.setBrandId(brandId);</span><br><span class="line">    categoryBrandRelationEntity.setBrandName(name);</span><br><span class="line">    <span class="keyword">this</span>.update(categoryBrandRelationEntity,<span class="keyword">new</span> UpdateWrapper&lt;CategoryBrandRelationEntity&gt;().eq(<span class="string">&quot;brand_id&quot;</span>,brandId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCategory</span><span class="params">(Long catId, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.baseMapper.updateCategory(catId,name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="属性分组"><a href="#属性分组" class="headerlink" title="属性分组"></a>属性分组</h1><p>spu和sku</p><p>使用mybatisplus的QueryWrapper条件查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String key = (String) params.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">QueryWrapper&lt;AttrGroupEntity&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;AttrGroupEntity&gt;().eq(<span class="string">&quot;catelog_id&quot;</span>,catelogId);</span><br><span class="line"><span class="keyword">if</span>(!StringUtils.isEmpty(key))&#123;</span><br><span class="line">    queryWrapper.and(obj -&gt; &#123;</span><br><span class="line">        obj.eq(<span class="string">&quot;attr_group_id&quot;</span>,key).or().like(<span class="string">&quot;attr_group_name&quot;</span>,key);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">page = <span class="keyword">this</span>.page(<span class="keyword">new</span> Query&lt;AttrGroupEntity&gt;().getPage(params),queryWrapper);</span><br></pre></td></tr></table></figure><p>配置分页插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.baobingjiang.mall.product.dao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PaginationInterceptor paginationInterceptor = <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">        <span class="comment">//如果请求的页码大于最后一页 返回首页</span></span><br><span class="line">        paginationInterceptor.setOverflow(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//设置最大单页限制数量 默认500</span></span><br><span class="line">        paginationInterceptor.setLimit(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> paginationInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义更新两种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBrand</span><span class="params">(Long brandId, String name)</span> </span>&#123;</span><br><span class="line">    CategoryBrandRelationEntity categoryBrandRelationEntity = <span class="keyword">new</span> CategoryBrandRelationEntity();</span><br><span class="line">    categoryBrandRelationEntity.setBrandId(brandId);</span><br><span class="line">    categoryBrandRelationEntity.setBrandName(name);</span><br><span class="line">    <span class="keyword">this</span>.update(categoryBrandRelationEntity,<span class="keyword">new</span> UpdateWrapper&lt;CategoryBrandRelationEntity&gt;().eq(<span class="string">&quot;brand_id&quot;</span>,brandId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCategory</span><span class="params">(Long catId, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.baseMapper.updateCategory(catId,name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Elasctic-search"><a href="#Elasctic-search" class="headerlink" title="Elasctic search"></a>Elasctic search</h1><p>es:索引-&gt;文档-&gt;属性</p><p>sql:库-&gt;表-&gt;行-&gt;属性</p><p><strong>乐观锁修改</strong></p><p>字段信息：</p><ul><li><p>if_seq_no:并发控制字段 每次更新就会+1 用来做乐观锁</p></li><li><p>if_primary_term:同上 主分片重新分配 如重启就会变化</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT <span class="regexp">/customer/</span>_doc/<span class="number">1</span>?if_primary_term = <span class="number">1</span>&amp;if_seq_no = <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用elasticsearch-rest-high-level-client操作ES 需要手动编写配置类 如果使用springdataES就不用</p><p>nested数据类型：用于嵌套数据 如果嵌套的数据不使用此类型就会扁平化处理</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210301204040670.png" alt="image-20210301204040670"><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210301204128260.png" alt="image-20210301204128260"></p><h1 id="商城服务"><a href="#商城服务" class="headerlink" title="商城服务"></a>商城服务</h1><p>使用thymeleaf渲染页面</p><p>使用nginx动静分离 </p><h1 id="性能压测"><a href="#性能压测" class="headerlink" title="性能压测"></a>性能压测</h1><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><p><strong>jmeter</strong></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210303175000122.png" alt="image-20210303175000122"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210303175105717.png" alt="image-20210303175105717"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210303175242261.png" alt="image-20210303175242261"></p><h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><p>使用nginx设置域名 </p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210304225009660.png" alt="image-20210304225009660"></p><p><strong>nginx配置</strong></p><p>mall.conf</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210408193950651.png" alt="image-20210408193950651"></p><p>nginx.conf</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210408194636512.png" alt="image-20210408194636512"></p><ul><li>server_name会监听来自mall.com或者*.mall.com域名下的请求 这些请求的请求头的host属性为*.mall.com根据这个host属性 把请求转交给上有服务器<a href="http://mall/">http://mall</a> mall是在nginx.conf中配置的项目gateway服务的url。当nginx把请求转给网关的时候会丢失请求头中的host所以要在配置文件中配置$host表示取出当前请求真正的host的值</li></ul><p>网关增加设置：当访问mall.com的时候经过网关路由到商品服务 这条设置要放在最后 不然不能路由到具体服务</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210304225023610.png" alt="image-20210304225023610"></p><p>动静分离 </p><p>当访问静态资源例如<a href="http://mall.com/static/index/img/lunbo6.png%E4%BC%9A%E5%8E%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84html/static%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%9F%A5%E6%89%BE">http://mall.com/static/index/img/lunbo6.png会去服务器的html/static目录下查找</a></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210304225131282.png" alt="image-20210304225131282"></p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p><strong>redis</strong></p><p>导入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用jedis而不使用lettuce的原因：lettuce使用netty进行网络通信 有bug会导致堆外内存移除</p><p>解决问题</p><ul><li>缓存穿透：空结果缓存</li><li>缓存雪崩：设置随机过期时间</li><li>加锁：解决缓存击穿</li></ul><p><strong>使用Redisson作为分布式锁等功能框架</strong></p><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedissonConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean(destroyMethod = &quot;shutdown&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redissonClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.52.131:6379&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 阻塞时等待 默认加锁是<span class="number">30</span>s</span><br><span class="line"> * RLock锁有看门狗机制 如果业务超长，会自动帮我们续期，默认三十秒（续期时间为占锁之后 看门狗时间[<span class="number">30</span>] / <span class="number">3</span>）</span><br><span class="line"> * 只要业务完成 就不会为当前锁续期 即使不手动解锁 也会在<span class="number">30</span>s后自动删除</span><br><span class="line"> * 如果指定过期事件 lock.lock(<span class="number">10</span>,TimeUnit.SECONDS); 指定的时间一定要大于业务的时间 否则会出现死锁的情况</span><br><span class="line"> * 建议指定时间 省掉了续期操作</span><br><span class="line"> */</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/index/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RLock lock = redissonClient.getLock(<span class="string">&quot;my-lock&quot;</span>);</span><br><span class="line">   <span class="comment">// 阻塞式等待</span></span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缓存一致性</strong></p><ul><li>双写模式：修改数据库后 修改缓存<ul><li><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210312162006542.png" alt="image-20210312162006542"></li></ul></li><li>失效模式：修改数据库后 删除缓存<ul><li><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210312162309012.png" alt="image-20210312162309012"></li></ul></li></ul><p>解决方法</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210312162639760.png" alt="image-20210312162639760"></p><p><strong>SpringCache</strong></p><p>使用SpringCache可以方便的操作缓存</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置使用redis作为缓存</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cache</span>:</span><br><span class="line">  <span class="keyword">type</span>: redis</span><br><span class="line">  redis:</span><br><span class="line">    <span class="built_in">time</span>-<span class="keyword">to</span>-live: <span class="number">60000</span></span><br><span class="line">    <span class="keyword">cache</span>-<span class="literal">null</span>-<span class="keyword">values</span>: <span class="literal">true</span> <span class="comment">#解决缓存穿透问题</span></span><br><span class="line">    <span class="keyword">use</span>-<span class="keyword">key</span>-prefix: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210312165037949.png" alt="image-20210312165037949"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将结果放入缓存中 命名空间为category key如果不指定自动生成 value默认使用java序列化机制 默认过期时间为-1</span></span><br><span class="line"><span class="comment">//spring.cache.redis.time-to-live指定过期时间</span></span><br><span class="line"><span class="comment">//sync表示同步方法 进行加锁 解决缓存击穿问题</span></span><br><span class="line"><span class="meta">@Cacheable(value = &#123;&quot;category&quot;&#125;, key = &quot;#root.method.name&quot;, sync = true)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;CategoryEntity&gt; <span class="title">getOneLevelCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> baseMapper.selectList(<span class="keyword">new</span> QueryWrapper&lt;CategoryEntity&gt;().eq(<span class="string">&quot;cat_level&quot;</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置序列化并且让配置文件中的内容生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(CacheProperties.class)</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCacheConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 配置文件中 TTL设置没用上</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 原来:</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@ConfigurationProperties</span>(prefix = &quot;spring.cache&quot;)</span></span><br><span class="line"><span class="comment">    * public class CacheProperties</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 现在要让这个配置文件生效    : <span class="doctag">@EnableConfigurationProperties</span>(CacheProperties.class)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function">RedisCacheConfiguration <span class="title">redisCacheConfiguration</span><span class="params">(CacheProperties cacheProperties)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置kv的序列化机制</span></span><br><span class="line">      config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> StringRedisSerializer()));</span><br><span class="line">      config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer()));</span><br><span class="line">      CacheProperties.Redis redisproperties = cacheProperties.getRedis();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置配置</span></span><br><span class="line">      <span class="keyword">if</span>(redisproperties.getTimeToLive() != <span class="keyword">null</span>)&#123;</span><br><span class="line">         config = config.entryTtl(redisproperties.getTimeToLive());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(redisproperties.getKeyPrefix() != <span class="keyword">null</span>)&#123;</span><br><span class="line">         config = config.prefixKeysWith(redisproperties.getKeyPrefix());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(!redisproperties.isCacheNullValues())&#123;</span><br><span class="line">         config = config.disableCachingNullValues();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(!redisproperties.isUseKeyPrefix())&#123;</span><br><span class="line">         config = config.disableKeyPrefix();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> config;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步</p><p>使用CompletableFuture查询商品详情页</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315224725781.png" alt="image-20210315224725781"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315201921385.png" alt="image-20210315201921385"></p><p>可以传入线程池也可以用默认的线程池 </p><p>计算完成时四种回调方法</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315202333923.png" alt="image-20210315202333923"></p><p>​    <img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315202450608.png" alt="image-20210315202450608"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315202725005.png" alt="image-20210315202725005"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315202759835.png" alt="image-20210315202759835"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315203322054.png" alt="image-20210315203322054"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315203129342.png" alt="image-20210315203129342"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315203625063.png" alt="image-20210315203625063"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315203651895.png" alt="image-20210315203651895"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315203834812.png" alt="image-20210315203834812"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315204000061.png" alt="image-20210315204000061"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315204112240.png" alt="image-20210315204112240"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315204137458.png" alt="image-20210315204137458"></p><p>两任务组合 一个完成</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315204245453.png" alt="image-20210315204245453"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315204252228.png" alt="image-20210315204252228"></p><p>多任务组合</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315210854511.png" alt="image-20210315210854511"></p><h1 id="短信验证"><a href="#短信验证" class="headerlink" title="短信验证"></a>短信验证</h1><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318153820543.png" alt="image-20210318153820543"></p><p>购买开通服务</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318154220934.png" alt="image-20210318154220934"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318154209250.png" alt="image-20210318154209250"><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318154158785.png" alt="image-20210318154158785"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318154238215.png" alt="image-20210318154238215"></p><p>配置文件</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318155247830.png" alt="image-20210318155247830"></p><p>添加配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.cloud.alicloud.sms&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String skin;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String sign;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String appCode;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">sendSmsCode</span><span class="params">(String phone, String code)</span></span>&#123;</span><br><span class="line">      String method = <span class="string">&quot;GET&quot;</span>;</span><br><span class="line">      Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">      <span class="comment">//最后在header中的格式(中间是英文空格)为Authorization:APPCODE 83359fd73fe94948385f570e3c139105</span></span><br><span class="line">      headers.put(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;APPCODE &quot;</span> + <span class="keyword">this</span>.appCode);</span><br><span class="line">      Map&lt;String, String&gt; querys = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">      querys.put(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line">      querys.put(<span class="string">&quot;phone&quot;</span>, phone);</span><br><span class="line">      querys.put(<span class="string">&quot;skin&quot;</span>, <span class="keyword">this</span>.skin);</span><br><span class="line">      querys.put(<span class="string">&quot;sign&quot;</span>, <span class="keyword">this</span>.sign);</span><br><span class="line">      HttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         response = HttpUtils.doGet(<span class="keyword">this</span>.host, <span class="keyword">this</span>.path, method, headers, querys);</span><br><span class="line">         <span class="comment">//获取response的body</span></span><br><span class="line">         <span class="keyword">if</span>(response.getStatusLine().getStatusCode() == <span class="number">200</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> EntityUtils.toString(response.getEntity());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;fail_&quot;</span> + response.getStatusLine().getStatusCode();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/sms&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSendController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> SmsComponent smsComponent;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 提供给别的服务进行调用的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/sendcode&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> R <span class="title">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone, <span class="meta">@RequestParam(&quot;code&quot;)</span> String code)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!<span class="string">&quot;fail&quot;</span>.equals(smsComponent.sendSmsCode(phone, code).split(<span class="string">&quot;_&quot;</span>)[<span class="number">0</span>]))&#123;</span><br><span class="line">         <span class="keyword">return</span> R.ok();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> R.error(BizCodeEnum.SMS_SEND_CODE_EXCEPTION.getCode(), BizCodeEnum.SMS_SEND_CODE_EXCEPTION.getMsg());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>md5加盐加密</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318165754894.png" alt="image-20210318165754894"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318181950449.png" alt="image-20210318181950449"></p><p>每次验证密码的时候 对输入的密码进行加密 再加盐 与数据库中的密码进行比较</p><p>加密工具类：这种方式不用在数据库中存放盐值</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318182206735.png" alt="image-20210318182206735"></p><h1 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h1><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318204701452.png" alt="image-20210318204701452"></p><p><strong>微博登录</strong></p><p>首先创建一个微连接</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210322190331191.png" alt="image-20210322190331191"></p><p>根据文档进行操作：<a href="https://open.weibo.com/wiki/%E6%8E%88%E6%9D%83%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E">https://open.weibo.com/wiki/%E6%8E%88%E6%9D%83%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E</a></p><p>获取到token之后 可以根据接口进行一些操作</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210322190950142.png" alt="image-20210322190950142"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210322191945969.png" alt="image-20210322191945969"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210322202853884.png" alt="image-20210322202853884"></p><ul><li>不能跨域名就行共享</li><li>同一个服务 复制多份 session不同步的问题</li></ul><p><strong>session共享问题解决</strong></p><p>方案一</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210322203932791.png" alt="image-20210322203932791"></p><p>方案二</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210322204057403.png" alt="image-20210322204057403"></p><p>方案三</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210322204146229.png" alt="image-20210322204146229"></p><p>方案四</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210322204312176.png" alt="image-20210322204312176"></p><p><strong>SpringSession</strong></p><p>导入依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.8.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置</p><ul><li><p>spring-session-store-type=redis</p></li><li><p>server.serlvet.session.timeout=30m #30分钟</p></li></ul><p>在启动类添加注解：@EnableRedisHttpSession</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//页面之间共享用户信息 session会存到redis中</span></span><br><span class="line">httpSession.set<span class="constructor">Attribute(AuthServerConstant.LOGIN_USER, <span class="params">rsepVo</span>)</span>;</span><br></pre></td></tr></table></figure><p>在product服务中也引入springsession 在首页就可以取出session中的数据</p><p>问题：</p><ul><li>默认使用java的序列化机制 需要实现Serializable 接口，推荐使用JSON的方式序列化到redis</li><li>默认发的当前域的session (需要解决子域session共享问题)</li></ul><p>自定义session</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MallSessionConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> CookieSerializer <span class="title">cookieSerializer</span><span class="params">()</span></span>&#123;</span><br><span class="line">      DefaultCookieSerializer cookieSerializer = <span class="keyword">new</span> DefaultCookieSerializer();</span><br><span class="line">      <span class="comment">// 明确的指定Cookie的作用域</span></span><br><span class="line">      cookieSerializer.setDomainName(<span class="string">&quot;mall.com&quot;</span>);<span class="comment">//auth.mall.com的父域 *.mall.com可以访问到</span></span><br><span class="line">      cookieSerializer.setCookieName(<span class="string">&quot;FIRESESSION&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> cookieSerializer;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 自定义序列化机制</span></span><br><span class="line"><span class="comment">    * 这里方法名必须是：springSessionDefaultRedisSerializer</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RedisSerializer&lt;Object&gt; <span class="title">springSessionDefaultRedisSerializer</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> GenericJackson2JsonRedisSerializer();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单点登录</strong></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210323193007455.png" alt="image-20210323193007455"></p><p>不能使用session解决单点登录问题 比如在auth.gulimall.com登录之后 session的作用域只能放大到gulimall.com 其他的域名下的服务不能得到这个session    </p><h1 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h1><p>离线购物车和在线购物车 </p><p>购物车的内容存在redis中 使用redis持久化存储</p><p>当离线使用购物车的时候 在cookie中存储一个user-key标识身份  每次添加购物车的时候通过一个拦截器(拦截器在controller之前执行)如果没有的话创建一个user-key</p><p>把用户信息放在threadLocal中 ThreadLocal本质是一个Map&lt;Thread,Object&gt; </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MallWebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">   <span class="comment">//添加拦截器</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">      registry.addInterceptor(<span class="keyword">new</span> CartInterceptor()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;UserInfoTo&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">      UserInfoTo userInfoTo = <span class="keyword">new</span> UserInfoTo();</span><br><span class="line">      HttpSession session = request.getSession();</span><br><span class="line">      MemberRsepVo user = (MemberRsepVo) session.getAttribute(AuthServerConstant.LOGIN_USER);</span><br><span class="line">      <span class="keyword">if</span> (user != <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="comment">// 用户登陆了</span></span><br><span class="line">         userInfoTo.setUsername(user.getUsername());</span><br><span class="line">         userInfoTo.setUserId(user.getId());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//从cookie中获取user-key</span></span><br><span class="line">      Cookie[] cookies = request.getCookies();</span><br><span class="line">      <span class="keyword">if</span>(cookies != <span class="keyword">null</span> &amp;&amp; cookies.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            String name = cookie.getName();</span><br><span class="line">            <span class="keyword">if</span>(name.equals(CartConstant.TEMP_USER_COOKIE_NAME))&#123;</span><br><span class="line">               userInfoTo.setUserKey(cookie.getValue());</span><br><span class="line">               userInfoTo.setTempUser(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果没有临时用户 则分配一个临时用户</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isEmpty(userInfoTo.getUserKey()))&#123;</span><br><span class="line">         String uuid = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">         userInfoTo.setUserKey(<span class="string">&quot;FIRE-&quot;</span> + uuid);</span><br><span class="line">      &#125;</span><br><span class="line">      threadLocal.set(userInfoTo);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 执行完毕之后分配临时用户让浏览器保存</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">      UserInfoTo userInfoTo = threadLocal.get();</span><br><span class="line">      <span class="keyword">if</span>(!userInfoTo.isTempUser())&#123;</span><br><span class="line">         Cookie cookie = <span class="keyword">new</span> Cookie(CartConstant.TEMP_USER_COOKIE_NAME, userInfoTo.getUserKey());</span><br><span class="line">         <span class="comment">// 设置这个cookie作用域 过期时间</span></span><br><span class="line">         cookie.setDomain(<span class="string">&quot;mall.com&quot;</span>);</span><br><span class="line">         cookie.setMaxAge(CartConstant.TEMP_USER_COOKIE_TIME_OUT);</span><br><span class="line">         response.addCookie(cookie);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.52</span><span class="number">.131</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">      <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">admin</span></span><br></pre></td></tr></table></figure><p>在启动类上加入注解@EnableRabbit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AmqpAdmin amqpAdmin;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DirectExchange directExchange = <span class="keyword">new</span> DirectExchange(<span class="string">&quot;mall-exchange&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br><span class="line">    amqpAdmin.declareExchange(directExchange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Queue queue = <span class="keyword">new</span> Queue(<span class="string">&quot;mall-queue&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>);</span><br><span class="line">    amqpAdmin.declareQueue(queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Binding binding = <span class="keyword">new</span> Binding(<span class="string">&quot;mall-queue&quot;</span>,Binding.DestinationType.QUEUE,<span class="string">&quot;mall-exchange&quot;</span>,<span class="string">&quot;mall.*&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">    amqpAdmin.declareBinding(binding);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果想把传入的内容转换为json格式 需要创建配置类MyRabbitConfig进行注入Jackson2JsonMessageConverter</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;mall-exchange&quot;</span>,<span class="string">&quot;mall.order&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RabbitListener监听队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(value = &quot;spring.test.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(</span></span><br><span class="line"><span class="meta">                    value = &quot;spring.test.exchange&quot;,</span></span><br><span class="line"><span class="meta">                    ignoreDeclarationExceptions = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">                    type = ExchangeTypes.TOPIC</span></span><br><span class="line"><span class="meta">            ),</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;#.#&quot;&#125;))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多个服务监听 同一个消息只能有一个客户端收到</li><li>只有一个消息处理完 方法运行结束 才可以接受下一条消息</li></ul><p>@RabbitListener可以用在方法和类上 </p><p>@RabbitHandler只能用在方法上 根据不同的方法 对消息进行不同的处理</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210327233040000.png" alt="image-20210327233040000"></p><p>进行重载处理 不同的handler处理不同内容的消息 如果是OrderEntity格式的消息就进入2方法 否则进入1方法</p><h2 id="可靠投递"><a href="#可靠投递" class="headerlink" title="可靠投递"></a><strong>可靠投递</strong></h2><p>如果使用事务 会使吞吐量下降250倍 所以要使用可靠抵达</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329145159509.png" alt="image-20210329145159509"></p><p><strong>ConfirmCallBach</strong></p><p>spring.rabbitmq.publisher-confirms=true #开启发送端确认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initRabbitTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//当收到消息的时候 执行这个回调</span></span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> correlationData 消息的唯一关联数据</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> ack 消息是否成功收到</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> cause 失败原因</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">            System.out.println(cause + ack + correlationData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>returnCallBack</strong>:未投递到queue退回模式</p><p>spring.rabbitmq.publisher-returns=true #开启发送端消息抵达队列的确认</p><p>spring.rabbit.template.mandatory=true #只要抵达队列，以异步发送的方式优先回调returnCallback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initRabbitTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//当收到消息的时候 执行这个回调</span></span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> correlationData 消息的唯一关联数据</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> ack 消息是否成功收到</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> cause 失败原因</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">            System.out.println(cause + ack + correlationData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息没有投递到指定队列 执行这个失败回调</span></span><br><span class="line">    rabbitTemplate.setReturnCallback(<span class="keyword">new</span> RabbitTemplate.ReturnCallback() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> message 投递失败的消息详细信息</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> replyCode 回复的状态码</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> replyText 回复的文本内容</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> exchange 当时整个消息发送给了哪个交换机</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> routingKey 当时这个消息用哪个路由键</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费端确认：如果是自动确认 当宕机的时候 没有确认的消息会丢失 所以要采用 手动确认</p><p>spirng.rabbitmq.listener.simple.acknowledge-mode = manual </p><p>使用Channel的basicAck方法进行手动确认 使用basicNack和basicReject进行拒绝</p><h1 id="订单服务"><a href="#订单服务" class="headerlink" title="订单服务"></a>订单服务</h1><p><strong>远程调用丢失请求头的问题</strong></p><p>feign远程调用丢失请求头的问题：用户信息存储在cookie中 当order服务进行远程调用的时候 feign会重新构建一个Request 但是这个请求没有任何请求头 。 </p><p>解决方法：使用拦截器进行增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;requestInterceptor&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestInterceptor <span class="title">requestInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// Feign在远程调用之前都会先经过这个方法</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> RequestInterceptor() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// RequestContextHolder拿到刚进来这个请求:当一开始收到请求时就把request放在其中</span></span><br><span class="line">         ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">         <span class="keyword">if</span>(attributes != <span class="keyword">null</span>)&#123;</span><br><span class="line">            HttpServletRequest request = attributes.getRequest();</span><br><span class="line">            <span class="keyword">if</span>(request != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">// 同步请求头数据</span></span><br><span class="line">               String cookie = request.getHeader(<span class="string">&quot;Cookie&quot;</span>);</span><br><span class="line">               <span class="comment">// 给新请求同步Cookie</span></span><br><span class="line">               template.header(<span class="string">&quot;Cookie&quot;</span>, cookie);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>异步调用丢失请求头的问题</strong></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329184323469.png" alt="image-20210329184323469"></p><p>request再72线程上 当101 和 102 获取不到request</p><p>解决方法：</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329184440551.png" alt="image-20210329184440551"></p><p><strong>接口幂等性</strong></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329192433223.png" alt="image-20210329192433223"></p><p>解决方案</p><p><strong>锁机制</strong></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329193508214.png" alt="image-20210329193508214"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329193618788.png" alt="image-20210329193618788"></p><p><strong>唯一约束</strong></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329193645549.png" alt="image-20210329193645549"></p><p><strong>防重表</strong></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329193953028.png" alt="image-20210329193953028"></p><p><strong>全局请求唯一id</strong></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329194038739.png" alt="image-20210329194038739"></p><p><strong>token机制</strong></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329194534250.png" alt="image-20210329194534250"></p><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330200638297.png" alt="image-20210330200638297"></p><p>传播行为</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330201230382.png" alt="image-20210330201230382"></p><p>a和b会回滚 因为用的是一个事务 c不会回滚 他是单独的一个事务    并且b事务 会继承a事务的特性 超时时间为30s 自己设置也不会覆盖</p><p><strong>事务失效问题</strong></p><p><a href="https://blog.csdn.net/zsycode/article/details/109630940">https://blog.csdn.net/zsycode/article/details/109630940</a></p><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="constructor">EnableAspectJAutoProxy(<span class="params">exposeProxy</span> = <span class="params">true</span>)</span></span><br></pre></td></tr></table></figure><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330213827403.png" alt="image-20210330213827403"></p><p><strong>几种分布式事务</strong></p><p>2pc</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330231420073.png" alt="image-20210330231420073"></p><p>柔性事务 TCC事务补偿方案</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330231521134.png" alt="image-20210330231521134"></p><p>柔性事务 最大努力通知型方案</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330231730835.png" alt="image-20210330231730835"></p><p>柔性事务：可靠消息+最终一致性方案</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330232008685.png" alt="image-20210330232008685"></p><p>Seata</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330232234617.png" alt="image-20210330232234617"></p><p>seata术语</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330232341751.png" alt="image-20210330232341751"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330232428409.png" alt="image-20210330232428409"></p><p>如果Account失败了 就通知TC TC通知Order和Storage也回滚</p><p><strong>seata实战</strong></p><p>每一个微服务中创建一个undo表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;undo_log&#96; (</span><br><span class="line">  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;branch_id&#96; bigint(20) NOT NULL,</span><br><span class="line">  &#96;xid&#96; varchar(100) NOT NULL,</span><br><span class="line">  &#96;context&#96; varchar(128) NOT NULL,</span><br><span class="line">  &#96;rollback_info&#96; longblob NOT NULL,</span><br><span class="line">  &#96;log_status&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;log_created&#96; datetime NOT NULL,</span><br><span class="line">  &#96;log_modified&#96; datetime NOT NULL,</span><br><span class="line">  &#96;ext&#96; varchar(100) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;ux_undo_log&#96; (&#96;xid&#96;,&#96;branch_id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><p>安装seata的TC：<a href="https://blog.csdn.net/weixin_43835659/article/details/103920319">https://blog.csdn.net/weixin_43835659/article/details/103920319</a></p><ul><li>在该项目中只修改了nacos地址 没有做db相关的修改</li></ul><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-starter-alibaba-seata --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>开启全局事务</p><p>@GlobalTransactional</p><p>所有想要用到分布式服务的微服务使用sesata 都要用DataSourceProxy代理自己的数据源</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210331232657313.png" alt="image-20210331232657313"></p><p>项目中采用的是 可靠消息+最终一致性方案</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210331234809440.png" alt="image-20210331234809440"></p><p>定时任务的时效性问题</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210331235025742.png" alt="image-20210331235025742"></p><p>延时队列场景</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210331234839434.png" alt="image-20210331234839434"></p><p>消息的TTL</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210331235356724.png" alt="image-20210331235356724"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210331235616030.png" alt="image-20210331235616030"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401001119884.png" alt="image-20210401001119884"></p><p>升级版：省去了一个exchange</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401001331160.png" alt="image-20210401001331160"></p><p>订单消息过了30min 被死信路由传送到死信队列中 处理死信队列中的消息 如果订单被取消或者不存在 就自动关单 锁库存</p><p>延时队列实现1(推荐)</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401000259018.png" alt="image-20210401000259018"></p><p>延时队列实现2</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401000344064.png" alt="image-20210401000344064"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401222103061.png" alt="image-20210401222103061"></p><p>如果网络延时 库存解锁的时候看订单为新建状态就不解锁了 当订单响应过来 状态改变的时候 库存不会被释放 所以当订单服务被释放的时候就发送消息 告诉交换机 交换机通知库存服务解锁</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401223019011.png" alt="image-20210401223019011"></p><p><strong>消息丢失</strong></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401230137822.png" alt="image-20210401230137822"></p><ul><li>建立一张关于消息日志的表 每次发送消息 利用回调函数(setConfirmCallback) 都在表中记录 定期扫描数据库 将失败的消息再发送一遍 //待完善<ul><li><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401232340983.png" alt="image-20210401232340983"></li></ul></li></ul><p><strong>重复消费</strong></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401231554346.png" alt="image-20210401231554346"></p><p><strong>消息挤压</strong></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401231859860.png" alt="image-20210401231859860"></p><h1 id="支付宝"><a href="#支付宝" class="headerlink" title="支付宝"></a>支付宝</h1><p>异步通知</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210402233947791.png" alt="image-20210402233947791"></p><p>收单</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210403190829087.png" alt="image-20210403190829087"></p><p>传入参数timeout_express自动收单</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210403191143687.png" alt="image-20210403191143687"></p><p>手动收单</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210403191539698.png" alt="image-20210403191539698"></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210403191527587.png" alt="image-20210403191527587"></p><h1 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h1><p>秒杀商品上架流程</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406182508787.png" alt="image-20210406182508787"></p><p>在线cron表达式生成器：<a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSchedule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在Spring中 只允许6位 [* * * ? * 1] : 每周一每秒执行一次</span></span><br><span class="line"><span class="comment">    *                    [* /5 * * ? * 1] : 每周一 每5秒执行一次</span></span><br><span class="line"><span class="comment">    *     1.定时任务不应阻塞 [默认是阻塞的]</span></span><br><span class="line"><span class="comment">    *     2.定时任务线程池 spring.task.scheduling.pool.size=5</span></span><br><span class="line"><span class="comment">    *     3.让定时任务异步执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Async</span></span><br><span class="line">   <span class="meta">@Scheduled(cron = &quot;*/5 * * ? * 1&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;i love you...&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一个商品可能上架很多次 所以要加分布式锁保证幂等性 避免重复上架</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406161847358.png" alt="image-20210406161847358"></p><p>秒杀流程 </p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406182522103.png" alt="image-20210406182522103"></p><h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><p>集限流 熔断 降级为一身的微服务组件</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406191721581.png" alt="image-20210406191721581"></p><ul><li>线程池隔离 会为每个请求创建一个线程池 如果请求很多 线程池也会很多 占用大量资源 </li></ul><p><strong>整合springboot</strong></p><p>导入依赖 ，下载dashboard(dashboard启动 nohup java -jar sentinel-dashboard-1.7.0.jar –server.port=8333 )</p><p>配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">cloud:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">   <span class="attr">transport:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line">    <span class="attr">dashboard:</span> <span class="string">$&#123;ipaddr&#125;:8333</span></span><br></pre></td></tr></table></figure><p>这里的 spring.cloud .sentinel.transport.port端口配置会在应用对应的机器上启动一个Http Server,该Server会与Sentinel控制台做交互</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406201357783.png" alt="image-20210406201357783"></p><p><strong>流量控制</strong></p><p>自定义流控响应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKillSentinelConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SecKillSentinelConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//被限制之后返回自定义的R对象 而不是默认的一句话</span></span><br><span class="line">      WebCallbackManager.setUrlBlockHandler((request, response, exception) -&gt; &#123;</span><br><span class="line">         R error = R.error(BizCodeEnum.TO_MANY_REQUEST.getCode(), BizCodeEnum.TO_MANY_REQUEST.getMsg());</span><br><span class="line">         response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">         response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">         response.getWriter().write(JSON.toJSONString(error));</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>熔断降级</strong></p><p>熔断：</p><p>调用方开启配置<code>feign.sentinel.enabled=true</code></p><p>熔断方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKillFeignServiceFalback</span> <span class="keyword">implements</span> <span class="title">SeckillFeignService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> R <span class="title">getSkuSeckillInfo</span><span class="params">(Long skuId)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;触发熔断&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> R.error(BizCodeEnum.TO_MANY_REQUEST.getCode(), BizCodeEnum.TO_MANY_REQUEST.getMsg());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用方指定默认回调方法 当访问远程服务的时候 进行降级处理</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406203417097.png" alt="image-20210406203417097"></p><p>降级：当有超大流量的时候 需要牺牲一部分不重要的远程服务 可以在远程服务设置熔断降级 返回的是默认的降级数据</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406204842517.png" alt="image-20210406204842517"></p><p>返回这个json数据</p><p><strong>自定义受保护的资源</strong></p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406214238941.png" alt="image-20210406214238941"></p><p>把要被保护的代码放在try中 并且在catch中调用entry.close()进行关闭</p><p>利用这个资源名可以在dashboard中进行流控等操作</p><p><strong>网关流控</strong></p><p>服务转发到网关的时候sentinel就进行处理</p><p>在网关微服务中导入依赖:spring-icloud-alibaba-sentinel-gateway</p><p>在dashboard中进行设置</p><h1 id="Sleuth-Zipkin服务链路追踪"><a href="#Sleuth-Zipkin服务链路追踪" class="headerlink" title="Sleuth+Zipkin服务链路追踪"></a>Sleuth+Zipkin服务链路追踪</h1><p>基本术语</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406225319096.png" alt="image-20210406225319096"></p><p><strong>整合sleuth</strong></p><p>导入依赖：spring-cloud-starter-sleuth</p><p><strong>整合Zipkin可视化观察</strong></p><p>在docker中安装：docker run -d -p 9411:9411 openzipkin/zipkin</p><p>导入依赖：spring-cloud-starter-zipkin</p><p>在每个服务中进行配置</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406230319341.png" alt="image-20210406230319341"></p><p>zipkin数据持久化：默认存储在内存中 重启会丢失，存储在es中</p><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406230749235.png" alt="image-20210406230749235"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>nacos作为注册中心和配置中心</p><p>open-feign进行远程服务调用</p><p>getway作为网关</p><p>前端为vue</p><p>商品服务</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><h2 id="Product"><a href="#Product" class="headerlink" title="Product"></a>Product</h2><p>获取分类及其子分类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/list/tree&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;CategoryEntityDTO&gt; entityDTOS = categoryService.listWithTree();</span><br><span class="line">    <span class="keyword">return</span> R.ok().put(<span class="string">&quot;data&quot;</span>, entityDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Oss对象存储</p><p>后端引用ingJSR-303进行数据校验：<a href="https://blog.csdn.net/weixin_44440642/article/details/106335653">https://blog.csdn.net/weixin_44440642/article/details/106335653</a></p><p>spu和sku</p><ul><li>SPU是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，属性值、特性相同的商品就可以称为一个SPU。</li><li>SKU是物理上不可分割的最小存货单元。在使用时要根据不同业态，不同管理模式来处理。在服装、鞋类商品中使用最多最普遍。</li></ul><p>根据三级分类id获取</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;商品服务&quot;&gt;&lt;a href=&quot;#商品服务&quot; class=&quot;headerlink&quot; title=&quot;商品服务&quot;&gt;&lt;/a&gt;商品服务&lt;/h1&gt;&lt;h1 id=&quot;Oss对象存储&quot;&gt;&lt;a href=&quot;#Oss对象存储&quot; class=&quot;headerlink&quot; title=&quot;Oss</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql笔记</title>
    <link href="http://example.com/2021/02/02/mysql%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/02/02/mysql%E7%AC%94%E8%AE%B0/</id>
    <published>2021-02-02T07:36:24.000Z</published>
    <updated>2021-04-07T14:49:42.294Z</updated>
    
    <content type="html"><![CDATA[<p>常用命令</p><ul><li><p>显示数据库 show databases ; </p></li><li><p>显示表：1)show tables; 2) show table from test;</p></li><li><p>当前所在的库：select database();</p></li><li><p>查看表的属性 desc tableName;</p></li><li><p>查看mysql版本 1)select version(); 2)在cmd输入mysql –version</p></li><li><p>注释 # ，– (后面要加一个空格)，/* */</p></li></ul><p>起别名用<strong>AS</strong> 且AS可以省略</p><p>truncate 清空数据 :truncate table user</p><p>auto_increment要搭配key（主键 唯一 外键等）使用 且一个表中只能有一个标识列且类型是数字</p><p><strong>DISTINCT</strong>去重</p><p><strong>+号</strong>的作用</p><ul><li>select 100+90 做加法操作</li><li>select ‘12’ + 90 把字符串转换为整数做加法操作 如果转换失败字符串值为0</li><li>select null + 21 结果为null</li></ul><p><strong>逻辑运算符</strong>：and,or,not</p><p><strong>分页查询limit（m,n）m是初始索引 n是要显示的条目个数 limit放在查询语句的最后</strong></p><p>**安全等于&lt;=&gt;**：可以判断null和数值 </p><ul><li>select 2 &lt;=&gt; null 结果为 0</li><li>select 2 = null 结果为空</li><li>select null &lt;=&gt; null结果为1</li></ul><p><strong>ORDER BY</strong> 【asc | desc】默认是asc ：select * from user order by salary desc</p><p><strong>IFNULL</strong>：如果不是null显示第一个参数 是null显示第二个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ifnull(commission_pct,0),commission_pct from employees</span><br></pre></td></tr></table></figure><h1 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a><strong>模糊查询</strong></h1><p><strong>LIKE</strong>：% 匹配任意多个字符 包含0个字符，_ 匹配一个或一个以上字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查询第三个字母为e第五个字母为a的员工名 不区分大小写</span><br><span class="line">select last_name from employees where last_name like &#39;__e_a%&#39;;</span><br><span class="line">#查询第二个字符为_的员工名</span><br><span class="line">select last_name from employees where last_name like &#39;_\_%&#39;;</span><br></pre></td></tr></table></figure><p><strong>BETWEEN</strong>：between a and b 包含临界值a和b</p><p><strong>IN</strong>：in列表中的值必须是互相兼容的且不能使用%</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select last_name,job_id from employees where job_id in(&#39;IT_PORT&#39;,&#39;AD_VP&#39;,&#39;AD_PRES&#39;)</span><br></pre></td></tr></table></figure><p><strong>IS NULL</strong>和<strong>IS NOT NULL</strong>：select * from user where id is null</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h2><h3 id="字母函数"><a href="#字母函数" class="headerlink" title="字母函数"></a>字母函数</h3><p>Length 获取参数值的字节个数 SELECT length(1232)</p><p>concat拼接字符串：select concat(id,’-‘,name) from user;</p><p>Upper ,Lowwer</p><p>substr:下标从1开始 包含开始位置和结束位置 一个汉字是一个符文为两个字节或三个字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select substr(&#39;today is a good day&#39;,7,2); #第三个参数可以省略</span><br></pre></td></tr></table></figure><p>insrt（A，B） : 返回子串B在主串A中第一次出现的起始索引 找不到返回0</p><p>trim , ltirm, rtirm 去掉空格 trim(x from b)去掉b首位出现的x</p><p>​           <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image006.png" alt="img"></p><p>lpad和rpad</p><p>​           <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image008.png" alt="img"></p><p>replace</p><p>​           <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image010.png" alt="img"></p><h3 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h3><p>round 四舍五入</p><p>​           <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612253586742.png" alt="img"></p><p>ceil向上取整 floor向下取整</p><p>truncate 截断：第二个参数是小数点后的位数</p><p>​           <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image004-1612253586743.png" alt="img"></p><p>mod取余 公式为：a-a/b*b</p><h2 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h2><p>IF：<code>select if(10 &gt; 5,true,false)</code></p><p>CASE</p><ul><li><pre><code class="mysql">select salary,department_id,case department_idwhen 30 then salary * 1.1when 40 then salary * 1.2when 50 then salary * 1.3else salary end as newSalaryfrom employees<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```mysql</span><br><span class="line">  <span class="keyword">select</span> salary,</span><br><span class="line">  <span class="keyword">case</span></span><br><span class="line">  <span class="keyword">when</span> salary &gt; <span class="number">20000</span> <span class="keyword">then</span> <span class="comment">&#x27;a&#x27;</span></span><br><span class="line">  <span class="keyword">when</span> salary &gt; <span class="number">15000</span> <span class="keyword">then</span> <span class="comment">&#x27;b&#x27;</span></span><br><span class="line">  <span class="keyword">when</span> salary &gt; <span class="number">10000</span> <span class="keyword">then</span> <span class="comment">&#x27;c&#x27;</span></span><br><span class="line">  <span class="keyword">else</span> <span class="comment">&#x27;d&#x27;</span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">as</span> salaryLevel</span><br><span class="line">  <span class="keyword">from</span> employees</span><br></pre></td></tr></table></figure></code></pre></li></ul><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>sum avg max min count 忽略null值 可以和distinct搭配 sum (distinct salary)</p><h1 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h1><p>查询列表必须是分组函数或group by后出现的字段</p><p>查询有奖金的每个领导手下的员工的最高工资 且最高工资大于12000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select max(salary),manager_id from employees where commission_pct !&#x3D; null group by manager_id having max(salary) &gt; 12000 #having对分组后的结果进行筛选</span><br></pre></td></tr></table></figure><p>查询每个部门每个工种的员工的平均工资</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(salary),departmeng_id,job_id from employees group by department_id,job_id;</span><br></pre></td></tr></table></figure><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p>inner可以省略</p><p><strong>等值查询</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询名字中包含e的员工名和工种名 </span><br><span class="line">select last_name,job_title from employees e inner join jobs j on e.job_id &#x3D; j.job_id where e.last_name like &#39;%e%&#39;</span><br></pre></td></tr></table></figure><p><strong>非等值连接</strong></p><p><strong>自连接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.last_name,m.last_name from employees e inner join employees m on e.manager_id &#x3D; m.manager_id</span><br></pre></td></tr></table></figure><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a><strong>外连接</strong></h2><p>查询结果为主表的全部记录 左外连接中left左边的是主表</p><p><strong>左外连接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select b.name,bo.* from beauty b left outer join boys bo on b.boyfrientd_id &#x3D; bo.id</span><br></pre></td></tr></table></figure><p><strong>右外连接</strong></p><p><strong>全外连接</strong>：全外连接=左表全部记录+右表全部记录+相关联结果=左外连接+右外连接-相关联结果（即去重复）</p><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。</p><p>可以使用union操作符实现全外连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM emp e LEFT JOIN dept d ON e.deptno&#x3D;d.deptno</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM emp e RIGHT JOIN dept d ON e.deptno&#x3D;d.deptno;</span><br></pre></td></tr></table></figure><p><strong>内连接和外连接的区别</strong></p><p>内连接：取出两张表中匹配到的数据，匹配不到的不保留</p><p>外连接：取出连接表中匹配到的数据，匹配不到的也会保留，其值为NULL</p><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>按子查询的位置可分为</p><ul><li>select后面：仅支持标量子查询</li><li>from后面：支持表子查询</li><li>where或having后面：标量子查询，列子查询，行子查询</li><li>exits后面：表子查询</li></ul><p>按结果集的行列数不同可分为</p><ul><li>标量子查询：结果集只有一行一列</li><li>行子查询：结果集中有一行多列</li><li>列子查询：结果集中有一列多行</li><li>表子查询：结果集中有多行多列</li></ul><p>where后面的标量子查询where后面的行子查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询员工编号最小并且工资最高的员工信息</span><br><span class="line">select * from employees where (employee_id,salary)&#x3D;(select MIN(employee_id),MAX(salary) from employees)</span><br></pre></td></tr></table></figure><p>where后面的列子查询：使用多行比较操作符 in,not in,any/some,all</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查询location_id是1400或1700的部门编号</span><br><span class="line">select distinct department_id from departments where location_id in(1400,1700)</span><br><span class="line">#查询员工姓名，要求部门号是上面查询结果列表中的某一个</span><br><span class="line">select last_name from employees where department_id in(select distinct department_id from departments where location_id in(1400,1700))</span><br></pre></td></tr></table></figure><p>having后面的标量子查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查询最低工资大于50号部门最低工资的部门id和其最低工资</span><br><span class="line">#先查询50号部门的最低工资</span><br><span class="line">select min(salary) from employees where department_id &#x3D; 50</span><br><span class="line">#再查询每个部门的最低工资</span><br><span class="line">select min(salary),department_id from employees group by department_id</span><br><span class="line">#总查询</span><br><span class="line">select min(salary),department_id from employees group by department_id having MIN(salary) &gt; (select MIN(salary) from employees where department_id &#x3D; 50)</span><br></pre></td></tr></table></figure><p>select后面的子查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询每个部门的员工个数</span><br><span class="line">select d.*,(select count(*) from employee e where e.department_id &#x3D; d.department_id ) as count from departments d</span><br></pre></td></tr></table></figure><p>from后面的子查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查询每个部门的平均工资的工资等级</span><br><span class="line">select AVG(salary),department_id from employees group by department_id</span><br><span class="line">#连接上面的结果集和job_grades表 筛选条件平均工资 between lowest_sal and highest_sal</span><br><span class="line">select ag_dep.*,g.grade_level from(select AVG(salaru) ag.department_id from employees group by department_id) ag_dep inner join job_grades g on ag_dep.ag between lowest_sal and hisgest_sal</span><br></pre></td></tr></table></figure><p>exit后面的子查询：<code>select exists(select employee_id from employees where salary = 3000) #结果0或1</code></p><h1 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h1><p><strong>INSERT</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#方法一</span><br><span class="line">insert into study(id,name,sex) values(12,&#39;bob&#39;,&#39;male&#39;)；</span><br><span class="line">insert into study values(12,&#39;bob&#39;,null);</span><br><span class="line">#方法二</span><br><span class="line">insert into study set id &#x3D; 1,name &#x3D; &#39;bob&#39;,sex &#x3D; &#39;male&#39;;</span><br><span class="line">#方法一支持同时插入多行和子查询</span><br></pre></td></tr></table></figure><p><strong>UPDATE</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#修改单表</span><br><span class="line">update user set name &#x3D; &#39;bob&#39; where name &#x3D; &#39;zhangsan&#39;</span><br><span class="line">#修改多表:修改bob的女朋友的手机号为114</span><br><span class="line">update boys bo inner join beauty b on bo.id &#x3D; b.boyfriend_id set b.phone &#x3D; 114 where bo.boyName &#x3D; &#39;bob&#39;</span><br></pre></td></tr></table></figure><p><strong>DELETE</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#单表删除</span><br><span class="line">delete from user where id &#x3D; 1;</span><br><span class="line">#多表删除：删除bob以及他女朋友的信息</span><br><span class="line">delete b,bo from beauty b inner join boys bo on b.boyfriend_id &#x3D; bo.id where bo.boyName &#x3D; &#39;bob&#39;</span><br></pre></td></tr></table></figure><p>delete和truncate的区别：如果表中有自增长的列 delete删除后自增长的列值从断点开始而truncate从0开始。truncate没有返回值不能回滚 delete有返回值能回滚</p><h1 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h1><p><strong>库的管理</strong></p><ul><li><p>创建数据库 Create databases (if not exists) mydata;</p></li><li><p>更改库的字符集 alter database mydata character set utf8</p></li><li><p>删除库 drop database (if exists) mydata;</p></li></ul><p><strong>表的管理</strong></p><p>表的创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table user(id int,name varchar(20),sex varchar(8));</span><br></pre></td></tr></table></figure><p>表的修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#修改列名，必须要带上类型</span><br><span class="line">alter table user change column id newId int;</span><br><span class="line">#修改列的类型或约束</span><br><span class="line">alter table user modify column name char;</span><br><span class="line">#添加新列</span><br><span class="line">alter table user add column hobby varchar(20);</span><br><span class="line">#删除列</span><br><span class="line">alter table user drop column hobby;</span><br><span class="line">#修改表名</span><br><span class="line">alter table user rename to users;</span><br><span class="line">#删除表</span><br><span class="line">drop table (if exists) user;</span><br></pre></td></tr></table></figure><p>表的复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#仅复制表的结构</span><br><span class="line">create table myCopy like user;</span><br><span class="line">#复制表的结构和数据</span><br><span class="line">create  table myCopy select * from user;</span><br><span class="line">#只复制一部分数据 全部结构</span><br><span class="line">create  table myCopy select id,name from user where name &#x3D; ‘bob’;</span><br><span class="line">#仅复制某些字段</span><br><span class="line">create  table myCopy select id,name from user where 0;</span><br></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>整型：Tinyint(1字节)  Smallint（2字节） Mediumint（3字节） Int ，integer（四字节） Bigint（8字节）后面加unsigned表示无符号</p><p>小数</p><ul><li><p>浮点数 ：float(4byte) double（8byte）</p></li><li><p>定点数 ：DEC(M,D) 共M位 小数占D位 默认M=10 D=0</p></li></ul><p>较短的文本：varchar(M)和char(M)， M表示最多字符数 char可以省略M 默认为1 varchar长度可变</p><p>较长的文本: blob(较大的二进制)，text </p><p>保存较短的二进制 binary varbinary</p><p>set  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table tab_char(c1 set(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;))</span><br><span class="line">#只能插入 1，2，3，a,b,c,A,B,C</span><br><span class="line">insert into tab_char values(&#39;a&#39;);</span><br><span class="line">insert into tab_char values(&#39;a,b&#39;);</span><br><span class="line">insert into tab_char values(&#39;b,c&#39;);</span><br></pre></td></tr></table></figure><p>enum    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table tab_char(c1 enum(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;))</span><br><span class="line">#只能插入 1，2，3，a,b,c,A,B,C</span><br><span class="line">insert into tab_char values(&#39;a&#39;);</span><br></pre></td></tr></table></figure><p>字符型</p><ul><li><p>较短的文本：varchar(M)和char(M)， M表示最多字符数 char可以省略M 默认为1 varchar长度可变</p></li><li><p>较长的文本: blob(较大的二进制)，text </p></li><li><p>保存较短的二进制 binary varbinary</p></li></ul><p>日期型</p><table><thead><tr><th align="center">类型</th><th align="center">字节</th><th align="center">最小值</th><th align="center">最大值</th></tr></thead><tbody><tr><td align="center">date</td><td align="center">4</td><td align="center">1000-01-01</td><td align="center">9999-12-31</td></tr><tr><td align="center">datatime</td><td align="center">8</td><td align="center">1000-01-01 00:00:00</td><td align="center">9999-12-31 23:59:59</td></tr><tr><td align="center">stamptime</td><td align="center">4</td><td align="center">19700101000001</td><td align="center">2038年的某个时刻</td></tr><tr><td align="center">time</td><td align="center">3</td><td align="center">-838:59:59</td><td align="center">838:59:59</td></tr><tr><td align="center">year</td><td align="center">1</td><td align="center">1901</td><td align="center">2155</td></tr></tbody></table><ul><li>timestamp会根据时区变化</li></ul><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p><strong>六大约束</strong></p><p><strong>NOT NULL</strong> ：非空约束，用于保证该字段的值不能为空 </p><p><strong>DEFAULT</strong> ：默认约束，用于保证该字段有默认值 </p><p><strong>PRIMARY KEY</strong> ：主键约束，用于保证该字段的值具有唯一性，并且非空 </p><p><strong>UNIQUE</strong> : 唯一约束，用于保证该字段的值具有唯一性，可以为空     </p><p><strong>CHECK</strong>：检查约束【mysql中不支持，sql语法支持，语法不报错，但是没效果】     比如年龄、性别，可以设置一个范围     </p><p><strong>FOREIGN KEY</strong> ：外键约束，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值</p><ul><li>PRIMARY KEY 和UNIQUE的区别：都可以保证唯一 主键不允许为空，unique允许 但是只能有一个null 主键只能有一个 unique可以多个 都支持组合列 </li><li>FOREIGN KEY ：从表的外键列类型和主表的关联列的类型要求一致或兼容，主表的关联列必须是一个key，插入数据时先插入主表，删除数据时先删除从表</li></ul><p>列级约束都支持但foreign key无效</p><p>表级约束除了default,not null都支持 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create table stuinfo(</span><br><span class="line">id int,</span><br><span class="line">    stuName varchar(20),</span><br><span class="line">    gender char(1),</span><br><span class="line">    seat int,</span><br><span class="line">    age int,</span><br><span class="line">    majorId int.</span><br><span class="line">    constraint pk primary key(id), #constarint 约束名 可以省略 </span><br><span class="line">    Unique(seat),</span><br><span class="line">    check(gender &#x3D; &#39;male&#39; or gender &#x3D; &#39;female&#39;).</span><br><span class="line">    foreign key(majorid) references major(id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>修改表示添加约束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alter table stuinfo modify column stuname varchar(20) not null</span><br><span class="line">alter table stuinfo modify column id int primary key </span><br><span class="line">alter table stuinfo add primary key(id)</span><br><span class="line"> #constarin &lt;name&gt; 是为了删除方便</span><br><span class="line">alter table stuinfo add constarin fk_stuinfo_major foreign key(majorid) references user(id)</span><br></pre></td></tr></table></figure><p>修改表示删除约束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#删除非空约束和默认约束</span><br><span class="line">alter talble stuinfo modify column stuname varchar(20) null #null可以省略</span><br><span class="line">#删除主键</span><br><span class="line">alter table stuinfo drop primary key</span><br><span class="line">#删除唯一</span><br><span class="line">alter table stuinfo drop index seat</span><br><span class="line">#删除外键</span><br><span class="line">alter table stuinfo drop foreign key fk_stuinfo_major</span><br></pre></td></tr></table></figure><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是由一组SQL语句组成的逻辑处理单元</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set autocommit &#x3D; 0 #关闭自动提交</span><br><span class="line">start transaction; #开始事务</span><br><span class="line">delete from user where name &#x3D; &#39;bob&#39;</span><br><span class="line">savepoint a; #设置回滚点</span><br><span class="line">delete from user where id &#x3D; 1;</span><br><span class="line">rollback to a;</span><br><span class="line">commit; #提交事务</span><br></pre></td></tr></table></figure><p><strong>ACID属性</strong></p><p>原子性(Atomicity)：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全不执行</p><p>一致性(Consistent)：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性;事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。 </p><p>隔离性：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</p><p>持久性：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持</p><p><strong>并发问题</strong>：对于同时运行的多个事务，当这些事务访问数据库中相同的数据时,如果没有采取必要的隔离机制,就会导致各种并发问题</p><ul><li><p>脏读：对于两个事务T1,T2,T1读取了已经被T2更新但还没有被提交的字段.之后,若T2回滚,T1读取的内容就是临时且无效的.</p></li><li><p>不可重复读:对于两个事务T1,T2,T1读取了一个字段,然后T2更新了该字段.之后,T1再次读取同一个字段,值就不同了.</p></li><li><p>幻读:对于两个事务T1,T2,T1从一个表中读取了一个字段,然后T2在该表中插入了一些新的行.之后,如果T1再次读取同一个表,就会多出几行.</p></li></ul><p><strong>事务隔离级别</strong></p><p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/image-20210204153156245.png" alt="image-20210204153156245"></p><p>mysql默认隔离级别为可重复读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看当前隔离级别</span><br><span class="line">select @@tx_isolation</span><br><span class="line">#修改隔离级别</span><br><span class="line">set session transaction isolation level read uncommitted</span><br></pre></td></tr></table></figure><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图在使用时动态生成 只保存sql逻辑 不保存查询结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#创建视图</span><br><span class="line">create or replace view myview as </span><br><span class="line">select last_name,department_name,job_title from employees e join departments d on e.department_id &#x3D; d.department_id join jobs j on j.job_id &#x3D; e.job_id</span><br><span class="line">#使用视图</span><br><span class="line">select * from myview where last_name like &#39;%a%&#39;</span><br><span class="line">#修改视图</span><br><span class="line">alter vim myview as select * from employees</span><br><span class="line">#删除视图</span><br><span class="line">drop view name1,name2,name...</span><br><span class="line">#查看视图</span><br><span class="line">desc name1 或者 show create view name1</span><br><span class="line">#视图的更新 把视图当作一张表进行操（不建议更新）</span><br><span class="line">insert into myview values(‘zhangfei’)</span><br></pre></td></tr></table></figure><p>以下视图不能更新</p><ul><li><p>视图中包含 聚合函数。</p></li><li><p>视图中包含 UNION、UNION ALL、DISTINCT、 GROUP BY 和 HAVING 等关键字。</p></li><li><p>常量视图</p></li><li><p>视图中的select中包含子查询</p></li><li><p>由不可更新的视图导出的视图</p></li><li><p>创建视图时，ALGORITHM 为 TEMPTABLE 类型</p></li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h1 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h1><p>全局变量与会话变量的区别就在于，对全局变量的修改会影响到整个服务器，但是对会话变量的修改，只会影响到当前的会话</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>查看: show global variables like ‘%xxx%’ 如果不加模糊查询就是查询所有变量</p><p>查看具体的值 select @@global.&lt;系统变量名&gt;</p><p> 赋值：set global 系统变量名 = 值</p><p>作用域：服务器每次启动为所有的全局变量赋初始值 针对于所有会话有效 但不能跨重启</p><h3 id="会话变量"><a href="#会话变量" class="headerlink" title="会话变量"></a>会话变量</h3><p>查看：show 【session】 variables </p><p>查看具体值 select @@【session】变量名</p><p>赋值：set 【session】变量名=值</p><p>作用域：仅对于当前会话有效</p><p>注：以上的session可以省略</p><h2 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h2><h3 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h3><p>当前会话有效</p><p>初始化或赋值：set @变量名=值</p><p>赋值：select count(*) into @count from…</p><p>查看：select @用户变量名</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>仅仅在定义它的begin end中有效</p><p>声明：declare 变量名 类型 【default 值】</p><p>赋值：set 或select into 不用加@</p><p>查看 select 变量名</p><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>参数模式有输入in，输出out，输入兼输出inout</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">create procedure mypro(inout a int,inout b int)</span><br><span class="line">begin </span><br><span class="line">set a &#x3D; a * 2;</span><br><span class="line">set b &#x3D; b + a;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">set @a &#x3D; 1;</span><br><span class="line">set @b &#x3D; 2;</span><br><span class="line">#调用存储过程</span><br><span class="line">#如果时参数模式是in a和b的值不会被修改</span><br><span class="line">call mypro(@a,@b);</span><br><span class="line">#查看存储过程</span><br><span class="line">show create procedure mypro</span><br><span class="line">#删除存储过程</span><br><span class="line">drop procedure mypro</span><br></pre></td></tr></table></figure><h1 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#启用函数</span><br><span class="line">set global log_bin_trust_function_creators &#x3D; on</span><br><span class="line">#创建</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION genPerson(name varchar(20)) RETURNS varchar(50)</span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE str VARCHAR(50) DEFAULT &#39;&#39;;</span><br><span class="line">  SET @tableName&#x3D;name;</span><br><span class="line">  SET str&#x3D;CONCAT(&#39;create table &#39;, @tableName,&#39;(id int, name varchar(20));&#39;);</span><br><span class="line">  return str;</span><br><span class="line">end</span><br><span class="line">#执行函数</span><br><span class="line">select genPerson(&#39;student&#39;);</span><br><span class="line">#查看函数</span><br><span class="line">show create function genPerson()</span><br><span class="line">#删除函数</span><br><span class="line">drop function genPerson</span><br></pre></td></tr></table></figure><h1 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h1><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p>CASE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create procedure test_case(in score int)</span><br><span class="line">begin</span><br><span class="line">case </span><br><span class="line">when score &gt;&#x3D; 90 and score &lt;&#x3D; 100 then select &#39;A&#39;</span><br><span class="line">when score &gt;&#x3D; 80 and then select &#39;B&#39;</span><br><span class="line">when score &gt;&#x3D; 70 and then select &#39;C&#39;</span><br><span class="line">else select &#39;D&#39;</span><br><span class="line">end case;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>IF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create procedure test_case(in score int)</span><br><span class="line">begin</span><br><span class="line">if score &gt;&#x3D; 90 and score &lt;&#x3D; 100 then return &#39;A&#39;;</span><br><span class="line">elseif score &gt;&#x3D; 80 then return &#39;B&#39;</span><br><span class="line">elseif score &gt;&#x3D; 70 then return &#39;C&#39;</span><br><span class="line">else return &#39;D&#39;</span><br><span class="line">end if</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>leave相当于break iterate相当于continue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#while</span><br><span class="line">while 循环条件 do</span><br><span class="line">循环体</span><br><span class="line">end while 标签</span><br><span class="line">#loop</span><br><span class="line">loop </span><br><span class="line">循环体</span><br><span class="line">end loop 标签 </span><br><span class="line">#repeat</span><br><span class="line">repeat </span><br><span class="line">循环体</span><br><span class="line">until 结束循环的条件</span><br><span class="line">end repeat 标签</span><br><span class="line"></span><br><span class="line">#举例</span><br><span class="line">create procedure test_while(in insertCount int)</span><br><span class="line">begin</span><br><span class="line">declare i int default 1;</span><br><span class="line">a:while i&lt;&#x3D;insertCount Do</span><br><span class="line">insert into admin(username,password) values (&#39;bob&#39;,&#39;123&#39;);</span><br><span class="line">if i &gt;&#x3D; 20 then leave a;</span><br><span class="line">end if;</span><br><span class="line">set i &#x3D; i + 1;</span><br><span class="line">end while a;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h1><p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612428706122.png" alt="img"></p><p>sql执行加载顺序 </p><p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612428715733.png" alt="img"></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是帮助mysql高效获取数据的数据结构,一般是Btree 索引本身也很大 一般以索引文件的形式存储在磁盘上</p><p>优点：提高数据检索效率 降低数据库io成本 通过索引列对数据进行排序 降低数据排序的成本 降低了cpu的消耗 </p><p>缺点：降低更新表的速度<br><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612440213371.png" alt="img"></p><ul><li>非叶子节点不存储数据 只存储指引搜索方向的数据项</li></ul><p>索引分为以下几类</p><ul><li><p>单值索引：一个索引只包含单个列 </p></li><li><p>唯一索引：索引列的值必须唯一 但允许有空值 primary key ，unique</p></li><li><p>复合索引：一个索引包含多个列</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#创建索引</span><br><span class="line">CREATE [UNIQUE] INDEX indexName on tableName(columnName) #如果有unique是唯一索引 如果多个列是复合索引</span><br><span class="line">ALTER tableName ADD [UNIQUE] INDEX INDEXNAME on(columnName)</span><br><span class="line">#删除索引</span><br><span class="line">DROP INDEX indexName on tableName</span><br><span class="line">#查看索引</span><br><span class="line">SHOW INDEX FROM tableName</span><br></pre></td></tr></table></figure><p>需要创建索引的情况</p><ul><li><p>主键自动创建唯一索引</p></li><li><p>频繁作为查询条件的字段应该创建索引</p></li><li><p>查询中与其他表关联的字段，外键关系建立索引</p></li><li><p>频繁更新的字段不适合创建索引 因为更新不仅更新记录还会更新索引</p></li><li><p>where条件里用不到的字段不创建索引</p></li><li><p>单键/组合索引选择问题：高并发下倾向创建组合索引</p></li><li><p>查询中排序的字段 排序字段若通过索引去访问将大大提高查询速度</p></li><li><p>查询中统计或者分组字段</p></li></ul><p>不需要创建索引的情况</p><ul><li><p>表记录太少 </p></li><li><p>经常增删改的表</p></li><li><p>如果某个数据列包含许多重复的内容 为他建立索引没有太大实际效果</p></li></ul><h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><p>使用explain关键字可以模拟优化器执行sql查询的语句 从而知道mysql是如何处理你的sql语句的 分析你的查询语句或表结构的性能瓶颈</p><p>Explain各字段</p><ul><li><p>id：select查询的序列号 包含一组数字 表示查询中select或操作表的执行顺序如果id相同 执行顺序由上至下 id不同的话id大的优先级高 先执行</p></li><li><p>select_type：<a href="https://www.cnblogs.com/danhuangpai/p/8475458.html">https://www.cnblogs.com/danhuangpai/p/8475458.html</a></p></li><li><p>table：这行数据关于哪张表</p></li><li><p>type：查询使用的类型 性能从最好到最差 system-&gt;cosnt-&gt;eq_ref-&gt;ref-&gt;range-&gt;index-&gt;all 至少能达到range级别 最好到ref</p><ul><li>system：表中只有一条记录 等于系统表 是const类型的特例</li><li>const：表示通过索引一次就找到了 用于比较primary key 和 unique索引</li><li>eq_ref：唯一性索引扫描 用于联表查询的情况,按联表的主键或唯一键联合查询 表中只有一条记录与之匹配</li><li>ref：非唯一性索引扫描 返回匹配某个单独值 的所有行</li><li>range：检索给定范围的行 使用一个索引来选择行 key列显示了用哪个索引  </li><li>index：index和all都是全表扫描 但index从索引中读取</li><li>all：全表扫描</li></ul></li><li><p>possible_keys：显示可能应用在这张表上的索引，查询涉及到的字段上如果存在索引 该索引将被列出</p></li><li><p>key：实际使用的索引 如果为null则没用到索引 查询中如果用到覆盖索引 该索引只出现在key列表</p><ul><li><p>覆盖索引：查询的字段和建立索引的个数 顺序刚好一致 或是其子集</p><ul><li><pre><code class="mysql">create index ide_col1_col2 on mytalbe(col1,col2)select col1,col2 from mytable;<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">* 覆盖索引中<span class="keyword">select</span>的数据列只用从索引中就能够取得 不必读取数据行，mysql可以利用索引返回<span class="keyword">select</span>列表中的字段 而不必根据索引再次读取数据文件 也就是说查询列要被所建的索引覆盖</span><br><span class="line">  </span><br><span class="line">* 如果要使用覆盖索引 一定要注意<span class="keyword">select</span>列表中只取出所需要的列 不可用<span class="keyword">select</span>*，因为如果将所有字段一起做索引会导致索引文件过大 查询新能下降</span><br><span class="line">  </span><br><span class="line">* key_len：表示索引中使用的字节数 显示的值为索引字段的最大可能长度 并非实际使用长度 这个值根据表定义计算得出 不是通过表内检索得出 在不失精度的前提下 长度越短越好</span><br><span class="line"></span><br><span class="line">* <span class="keyword">ref</span>：库.表.字段或const 显示索引的哪一列被使用了，有时候会是一个常量：表示哪些列或常量被用于查找索引列上的值 只有当<span class="keyword">type</span>为<span class="keyword">ref</span>和eq_ref的时候，<span class="keyword">ref</span>这列才会有值</span><br><span class="line"></span><br><span class="line">  * ![img](mysql笔记/clip_image002<span class="number">-1612446344425.</span>png)</span><br><span class="line"></span><br><span class="line">* <span class="keyword">rows</span>：查询所需要读取的行数</span><br><span class="line"></span><br><span class="line">* Extra：不适合在其他列中显示但十分重要的额外信息</span><br><span class="line"></span><br><span class="line">  * <span class="keyword">Using</span> fileSort：在使用<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">group</span> <span class="keyword">by</span>关键字的时候 没有使用索引的排序</span><br><span class="line"></span><br><span class="line">    * ```mysql</span><br><span class="line">      <span class="keyword">create</span> <span class="keyword">index</span> idx_salary_name <span class="keyword">user</span>(salary,<span class="type">name</span>)</span><br><span class="line">      #建立索引的顺序是salary <span class="type">name</span> 使用时直接使用<span class="type">name</span> 不符合最左匹配原则 </span><br><span class="line">      <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="type">name</span>;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>using temporary：排序没有走索引、使用union、子查询连接查询、使用某些视图等原因，因此创建了一个内部临时表</p></li><li><p>using index：表示相应的select操作中使用了覆盖索引 如果同时出现using where 表示索引被用来执行索引键值的查找 如果没有using where 表明索引被用来执行读取数据而不是查找动作</p><ul><li><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612446539518.png" alt="img"></li></ul></li><li><p>using where：表明使用了where过滤 </p></li><li><p>using join buffer ：使用了连接缓存</p></li><li><p>impossible where：where子句的值总是false 不能用来获取任何元组</p></li></ul></li></ul><h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><p>​    最佳左前缀法则：如果索引了多列 查询从索引的最左前列开始并且不跳过索引中的列</p><p>​    在索引列上做任何操作（计算 函数 自动或手动转换）会使索引失效</p><p>​    范围条件右边的列索引失效</p><p>​    使用!= &lt;&gt;会使索引失效</p><p>​    like以通配符开头会使索引失效</p><p>​    字符串不加单引号使索引失效</p><p>​    用or连接会使索引失效</p><p>​    is null ，is not null 无法使用索引</p><p>​    尽量使用覆盖索引减少使用select*</p><p>​    order by中的字段要么全是升序排列 要么全是降序排列 否则会使索引失效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#首先创建复合索引c1 ~ c4</span><br><span class="line">#查询时用到了c1c2排序时用到了c3 没用到c4</span><br><span class="line">explain  select * from test where c1 &#x3D; &#39;a1&#39; and c2 &#x3D; &#39;a2&#39; and c4 &#x3D; &#39;c4&#39; order by c3</span><br><span class="line">#查询时用到了c1 c2 但不会出现fillSort因为 c2已经是常量了 所以排序时进行优化只用到了c3 </span><br><span class="line">explain  select * from test where c1 &#x3D; &#39;a1&#39; and c2 &#x3D; &#39;a2&#39; and c5 &#x3D; &#39;c5&#39; order by c3,c2</span><br><span class="line">#分组之前必排序：第二个sql没用到索引c2和c3 所以要建立临时表自己进行排序 第一个sql用c2和c3进行排序和分组</span><br><span class="line">explain  select * from test where c1 &#x3D; &#39;a1&#39; and c4 &#x3D; &#39;c4&#39; order by c2,c3</span><br><span class="line">explain  select * from test where c1 &#x3D; &#39;a1&#39; and c4 &#x3D; &#39;c4&#39; order by c3,c2</span><br></pre></td></tr></table></figure><h1 id="In和Exist"><a href="#In和Exist" class="headerlink" title="In和Exist"></a>In和Exist</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#当B表的数据集必须小于A表的数据集时，用in优于exists</span><br><span class="line">select * from A where id in (select id from B)</span><br><span class="line">等价于</span><br><span class="line">for select id from B</span><br><span class="line">for select * from A where A.id &#x3D; B.id</span><br><span class="line">#当A表的数据集必须小于B表的数据集时，用exists优于in</span><br><span class="line">#select 1也可以是 select * 因为exists结果返回bool值 实际执行会忽略select清单</span><br><span class="line">select * from A where exists (select 1 from B where B.id &#x3D; A.id)</span><br><span class="line">等价于</span><br><span class="line">for select * from A</span><br><span class="line">for select * from B Where B.id &#x3D; A.id</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>select … from table where exists(subquery) 该语法可理解为：将主查询的数据放到子查询中做认证 根据验证结果(true,false)来决定著查询的数据是否得以保留</p><h1 id="FileSort"><a href="#FileSort" class="headerlink" title="FileSort"></a>FileSort</h1><p>mysql4.1之前是双路排序：从磁盘取排序字段 在buffer进行排序 在从磁盘取其他字段 两次io</p><p>单路排序：读出所有查询的列在buffer中进行排序 然后输出 一次io</p><p>在sort_buffer中，方法B比方法A要多占用很多空间，因为方法B是把所有字段都取出,所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并)，排完再取sort_buffer容量大小，再排……从而多次lO。本来想省一次lO操作，反而导致了大量的I/O操作，反而得不偿失。可以增大sort_buffer_size和max_length_for_sort_data进行优化</p><h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><p>慢查询日志用来记录在mysql中响应速度超过阈值的语句 具体指运行时间超过long_query_time值得sql 则会被记录到慢查询日志中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#查看是否开启</span><br><span class="line">show variables like &#39;%slow_query_log%&#39;</span><br><span class="line">#查看阈值 超过这个时间显示的sql语句被记录到日志中</span><br><span class="line">show variables like &#39;%slow_query_time%&#39;</span><br><span class="line">#开启慢查询</span><br><span class="line">set global general_log &#x3D; 1</span><br><span class="line">set global log_output &#x3D; &#39;table&#39;</span><br><span class="line">#被记录到mysql库中的general_log表中 可以用以下语句进行查看</span><br><span class="line">select * from mysql.general_log</span><br></pre></td></tr></table></figure><h1 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h1><p>​    优化顺序：慢查询-&gt;explain-&gt;show profile</p><p>​    showfile是mysql提供用来分析当前会话中语句执行的资源消耗情况 默认情况关闭 可以保存最近15次的运行结果</p><p>​    查看是否支持show variables like ‘profiling%’  开启:set profiling = on</p><p>​    查看语句的执行结果 show profiles  </p><p>​    诊断sql：show profile cpu,block io for query 9; 数字是要诊断的sql对应于show profiles列表中的id</p><p>​    showfile各字段</p><p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612450485937.png" alt="img"></p><p>出现以下几种情况很危险</p><ul><li>converting heap to myisam : 查询结果太大 内存不够用忘内存上搬</li><li>creating tmp table ：创建临时表，拷贝数据到临时表 用完再删除</li><li>copying to tmp  table on disk：把内存中临时表复制到磁盘</li></ul><h1 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h1><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>偏向myisam存储引擎 开销小 加锁块 无死锁 锁定粒度大 发生锁冲突的概率最高 并发程度低</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查看表的上锁情况 </span><br><span class="line">show open tables;</span><br><span class="line">#解锁</span><br><span class="line">unlock tables;</span><br><span class="line">#读锁：上了读锁之后不能修改此表 不能访问别的表 其他用户可以读其他表和此表 但修改表时会阻塞 直到解锁</span><br><span class="line">lock table user read </span><br><span class="line">#写锁：上了读锁之后可以读写此表 不能读其他表  其他用户可以读其他表 读此表的时候阻塞 不能写此表</span><br><span class="line">lock table user write</span><br></pre></td></tr></table></figure><p>​     <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612450686998.png" alt="img"></p><p>​     <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image004-1612450686996.png" alt="img">    </p><p>​     <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image006-1612450686997.png" alt="img"></p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>行锁：偏向InnoDb存储引擎 开销大 加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低 并发度也最高</p><p>如果使用针对InnoDB的表使用行锁，被锁定字段不是主键，也没有针对它建立索引的话。行锁锁定的也是整张表。锁整张表会造成程序的执行效率会很低。</p><p>索引失效会使行锁变表锁</p><p>事务未提交时 事务所涉及的行会自动锁住 其他行不会</p><p>​        <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612450784685.png" alt="img"></p><p>解决不可重复读：在会话一中更新一条数据 在会话二中开启自动提交 再在会话一中提交 会话二中查询出的数据是更新后的数据</p><h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁;对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，</p><p>InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁_(Next-key锁）</p><p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/image-20210216134205633.png" alt="image-20210216134205633"></p><p>间隙锁的危害</p><ul><li>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。</li><li>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</li></ul><p>如何锁定一行</p><p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612450977750.png" alt="img"></p><p>如何分析行锁定</p><p>通过检查Innodb_row_lock状态变量来分析系统上的行锁的争夺情况</p><p>show status like ‘%innodb_row_lock%’</p><p>各个字段</p><p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/image-20210204230741935.png" alt="image-20210204230741935"></p>]]></content>
    
    
    <summary type="html">MySQL是一个关系型数据库</summary>
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper</title>
    <link href="http://example.com/2021/02/01/zookeeper/"/>
    <id>http://example.com/2021/02/01/zookeeper/</id>
    <published>2021-02-01T10:58:14.000Z</published>
    <updated>2021-05-12T07:39:30.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h1><ul><li>维护配置信息</li><li>分布式锁服务</li><li>集群管理</li><li>生成分布式唯一ID</li></ul><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h1><ul><li>高性能：zookeeper将全量数据存储在内存中，并直接用于客户端的所有非事务请求，尤其适用于以读为主的应用场景</li><li>高可用：zooKeeper一般以集群的方式对外提供服务，一般3~5台机器就可以组成一个可用的Zookeeper集群了，每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都相互保持着通信。只要集群中超过一半的机器都能够正常工作，那么整个集群就能够正常对外服务</li><li>严格顺序访问：对于来自客户端的每个更新请求，ZooKeeper都会分配一个全局唯一的递增编号，这个编号反映了所有事务操作的先后顺序</li></ul><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a><strong>数据模型</strong></h1><p>zookeeper的数据节点可以视为树状结构（或者目录），树中的各节点被称为 znode（即zookeeper node），一个znode可以有多个子节点。zookeeper节点在结构 上表现为树状；使用路径path来定位某个znode，比如/ns1/itcast/mysql/schema1/table1。 znode，兼具文件和目录两种特点。既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分。</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210201193107146.png" alt="image-20210201193107146"></p><p>一个znode大体上分为3各部分： 节点的数据：即znode data(节点path, 节点data)的关系就像是java map中(key, value)的关系 节点的子节点children 节点的状态stat：用来描述当前节点的创建、修改记录，包括cZxid、ctime等</p><p>在zookeeper shell中使用get命令查看指定路径节点的data、stat信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 7] get /ns-1/tenant</span><br><span class="line">cZxid = 0x6a0000000a</span><br><span class="line">ctime = Wed Mar 27 09:56:44 CST 2019</span><br><span class="line">mZxid = 0x6a0000000a</span><br><span class="line">mtime = Wed Mar 27 09:56:44 CST 2019</span><br><span class="line">pZxid = 0x6a0000000e</span><br><span class="line">cversion = 2</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 2</span><br></pre></td></tr></table></figure><p>属性说明： </p><ul><li>cZxid：数据节点创建时的事务 </li><li>ID ctime：数据节点创建时的时间 </li><li>mZxid：数据节点最后一次更新时的事务 ID</li><li>mtime：数据节点最后一次更新时的时间 </li><li>pZxid：数据节点的子节点最后一次被修改时的事务 ID </li><li>cversion：子节点的更改次数 </li><li>dataVersion：节点数据的更改次数 </li><li>aclVersion：节点的 ACL 的更改次数 </li><li>ephemeralOwner：如果节点是临时节点，则表示创建该节点的会话的 SessionID；如果节点是持久节点，则该属性值为 0 </li><li>dataLength：数据内容的长度 </li><li>numChildren：数据节点当前的子节点个数</li></ul><h1 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a><strong>节点类型</strong></h1><p>zookeeper中的节点有两种，分别为临时节点和永久节点。节点的类型在创建时即 被确定，并且不能改变。</p><ul><li>临时节点：该节点的生命周期依赖于创建它们的会话。一旦会话(Session)结束，临 时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的Znode都会绑定到 一个客户端会话，但他们对所有的客户端还是可见的。另外，ZooKeeper的临时节 点不允许拥有子节点。</li><li>持久化节点：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作 的时候，他们才能被删除</li></ul><h1 id="zookeeper单机安装"><a href="#zookeeper单机安装" class="headerlink" title="zookeeper单机安装"></a>zookeeper单机安装</h1><p>zookeeper-3.4.10.tar.gz，上传并解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 进入conf目录</span><br><span class="line">cd /home/zookeeper/zookeeper-3.4.10/conf</span><br><span class="line">// 复制配置文件</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line">// zookeeper根目录下新建data目录</span><br><span class="line">mkdir data</span><br><span class="line">// vi 修改配置文件中的dataDir</span><br><span class="line">// 此路径用于存储zookeeper中数据的内存快照、及事物日志文件</span><br><span class="line">dataDir=/home/zookeeper/zookeeper-3.4.10/data</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 进入zookeeper的bin目录</span><br><span class="line">cd /home/zookeeper/zookeeper-3.4.10/bin</span><br><span class="line">// 启动zookeeper</span><br><span class="line">./zkServer.sh start</span><br><span class="line">//启动：zkServer.sh start</span><br><span class="line">//停止：zkServer.sh stop</span><br><span class="line">//查看状态：zkServer.sh status</span><br><span class="line">登录客户端：./zkCli.sh -server localhost:2181</span><br></pre></td></tr></table></figure><h1 id="常用shell命令"><a href="#常用shell命令" class="headerlink" title="常用shell命令"></a>常用shell命令</h1><p><strong>新增节点</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create [-s] [-e] path data #其中-s 为有序节点，-e 临时节点</span><br><span class="line"><span class="meta">#</span><span class="bash">创建持久化节点</span></span><br><span class="line">create /hadoop &quot;123&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">创建持久化有序节点</span></span><br><span class="line">create -s /a &quot;a&quot; </span><br><span class="line">Created /a0000000001</span><br><span class="line">create -s /a &quot;b&quot;</span><br><span class="line">Created /b0000000002</span><br><span class="line">create -s /a &quot;c&quot;</span><br><span class="line">Created /c0000000003</span><br><span class="line"><span class="meta">#</span><span class="bash">创建临时节点 当当前会话过期后被删除[quit命令退出]</span></span><br><span class="line">create -e /tmp &quot;hhh&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">创建临时有序节点</span></span><br><span class="line">create -s -e /orderTmp &quot;ttt&quot;</span><br></pre></td></tr></table></figure><p><strong>更新节点</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set /hadoop &quot;345&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">也可以基于版本号进行更改，此时类似于乐观锁机制，当你传入的数据版本号(dataVersion) 和当前节点的数据版本号不符合时，会拒绝本次修改</span></span><br><span class="line">set /hadoop &quot;3456&quot; 1</span><br></pre></td></tr></table></figure><p><strong>删除节点</strong></p><p>与更新节点类似：delete path [version]</p><p><strong>查看节点</strong></p><p>get path</p><p><strong>查看节点状态</strong></p><p>state path:它的返回值和 get 命令类似，但不会返回 节点数据</p><p><strong>查看节点列表</strong></p><p>查看节点列表有 ls path 和 ls2 path 两个命令，后者是前者的增强，不仅可以查看指定路径下的所有节点，还可以查看当前节点的信息</p><p><strong>监听器</strong></p><p>get path [watch] ：注册的监听器能够在节点内容发生改变的时候，向客户端发出通知。需要注意的是 zookeeper 的触发器是一次性的 (One-time trigger)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] get /hadoop watch</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] set /hadoop 45678</span><br><span class="line">WATCHER::</span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDataChanged path:/hadoop #节点值改变</span><br></pre></td></tr></table></figure><p>ls\ls2 path [watch]：ls path [watch] 或 ls2 path [watch] 注册的监听器能够监听该节点下 所有子节点的增加和删除操作。也是一次性的</p><h1 id="ACL权限控制"><a href="#ACL权限控制" class="headerlink" title="ACL权限控制"></a>ACL权限控制</h1><p>zookeeper 类似文件系统，client 可以创建节点、更新节点、删除节点，那么 如何做到节点的权限的控制呢？zookeeper的access control list 访问控制列表可以做到 这一点。</p><p>acl 权限控制，使用scheme：id：permission 来标识，主要涵盖 3 个方面</p><ul><li>权限模式（scheme）：授权的策略</li><li>授权对象（id）：授权的对象</li><li>权限（permission）：授予的权限</li></ul><p>其特性如下</p><ul><li>zooKeeper的权限控制是基于每个znode节点的，需要对每个节点设置权限</li><li>每个znode支持设置多种权限控制方案和多个权限</li><li>子节点不会继承父节点的权限，客户端无权访问某节点，但可能可以访问它的子节点</li></ul><p><strong>权限模式</strong></p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210202170003037.png" alt="image-20210202170003037"></p><p><strong>授予的权限</strong></p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210202170113833.png" alt="image-20210202170113833"></p><p><strong>授权的相关命令</strong></p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210202170241887.png" alt="image-20210202170241887"></p><p>world授权模式 <code>setAcl /node1 world:anyone:cdrwa</code></p><p>IP授权模式 <code>setAcl /node2 ip:192.168.60.129:cdrwa</code></p><p>Auth授权模式 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addauth digest itcast:123456</span><br><span class="line">setAcl /node3 auth:itcast:cdrwa</span><br></pre></td></tr></table></figure><p>Digest授权模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">通过以下命令计算密文</span></span><br><span class="line">echo -n &lt;user&gt;:&lt;password&gt; | openssl dgst -binary -sha1 | openssl base64</span><br><span class="line">echo -n bob:123465 | openssl dgst -binary -sha1 | openssl base64</span><br><span class="line"><span class="meta">#</span><span class="bash">使用算出的密文添加权限</span></span><br><span class="line">setAcl /node digest:bob:qlzQzCLKhBROghkooLvb+Mlwv4A=:cdrwa</span><br><span class="line"><span class="meta">#</span><span class="bash">添加认证用户后 才可以得到数据</span></span><br><span class="line">addauth digest bob:123456</span><br><span class="line">get /node</span><br></pre></td></tr></table></figure><p><strong>超级管理员</strong></p><p>首先为超管生成密文</p><p>比如<code>echo -n super:admin | openssl dgst -binary -sha1 | openssl base64</code></p><p>么打开zookeeper目录下的/bin/zkServer.sh服务器脚本文件，找到如下一行</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210202171936529.png" alt="image-20210202171936529"></p><p>在后面添加</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210202172025240.png" alt="image-20210202172025240"></p><h1 id="javaAPI"><a href="#javaAPI" class="headerlink" title="javaAPI"></a><strong>javaAPI</strong></h1><h2 id="连接到zookeeper"><a href="#连接到zookeeper" class="headerlink" title="连接到zookeeper"></a><strong>连接到zookeeper</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperConnection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 计数器对象</span></span><br><span class="line">            CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// arg1:服务器的ip和端口</span></span><br><span class="line">            <span class="comment">// arg2:客户端与服务器之间的会话超时时间 以毫秒为单位的</span></span><br><span class="line">            <span class="comment">// arg3:连接是异步的 需要实现“监视器”对象 zookeeper集合通过监视器对象返回连接状态</span></span><br><span class="line">            ZooKeeper zooKeeper=<span class="keyword">new</span> ZooKeeper(<span class="string">&quot;192.168.52.131:2181&quot;</span>,</span><br><span class="line">                    <span class="number">5000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(event.getState()==Event.KeeperState.SyncConnected)</span><br><span class="line">                    &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;连接创建成功!&quot;</span>);</span><br><span class="line">                        countDownLatch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 主线程阻塞等待连接对象的创建成功</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="comment">// 会话编号</span></span><br><span class="line">            System.out.println(zooKeeper.getSessionId());</span><br><span class="line">            zooKeeper.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a><strong>新增节点</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方式</span></span><br><span class="line">create(String path, <span class="keyword">byte</span>[] data, List&lt;ACL&gt; acl, CreateMode createMode)</span><br><span class="line"><span class="comment">// 异步方式</span></span><br><span class="line">create(String path, <span class="keyword">byte</span>[] data, List&lt;ACL&gt; acl, CreateMode createMode，AsyncCallback.StringCallback callBack,Object ctx)</span><br></pre></td></tr></table></figure><ul><li>path - znode路径。例如/node1 </li><li>data - 要存储在指定znode路径中的数据</li><li>acl - 要创建的节点的访问控制列表。zookeeper API提供了一个静态接口 ZooDefs.Ids 来获取一些基本的acl列表。例如，ZooDefs.Ids.OPEN_ACL_UNSAFE 返回打开znode的acl列表。</li><li>createMode - 节点的类型,这是一个枚举。 </li><li>callBack-异步回调接口 </li><li>ctx-传递上下文参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKCreate</span> </span>&#123;</span><br><span class="line">    ZooKeeper zooKeeper ;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 计数器对象</span></span><br><span class="line">        CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// arg1:服务器的ip和端口</span></span><br><span class="line">        <span class="comment">// arg2:客户端与服务器之间的会话超时时间 以毫秒为单位的</span></span><br><span class="line">        <span class="comment">// arg3:连接是异步的 需要实现“监视器”对象 zookeeper集合通过监视器对象返回连接状态</span></span><br><span class="line">        zooKeeper=<span class="keyword">new</span> ZooKeeper(<span class="string">&quot;192.168.52.131:2181&quot;</span>,</span><br><span class="line">                <span class="number">5000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(event.getState()==Event.KeeperState.SyncConnected)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接创建成功!&quot;</span>);</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * Decrements the count of the latch, releasing all waiting threads if the count reaches zero.</span></span><br><span class="line"><span class="comment">                     * If the current count is greater than zero then it is decremented. If the new count is zero then all waiting threads are re-enabled for thread scheduling purposes.</span></span><br><span class="line"><span class="comment">                     * If the current count equals zero then nothing happens.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程阻塞等待连接对象的创建成功</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createSync</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * READ_ACL_UNSAFE:world:anyone:r 只读的</span></span><br><span class="line"><span class="comment">         * CREATOR_ALL_ACL:赋予了节点的创建者所有的权限，在创建者采用此ACL创建节点之前，已经被服务器所认证（例如，采用 “ digest”方案）。</span></span><br><span class="line"><span class="comment">         * OPEN_ACL_UNSAFE:world:anyone:cdrwa 任何应用程序在节点上可进行任何操作，能创建、列出和删除它的子节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node1&quot;</span>,<span class="string">&quot;i am node1&quot;</span>.getBytes(StandardCharsets.UTF_8), ZooDefs.Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAcl</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//自定义权限</span></span><br><span class="line">        <span class="comment">//world授权</span></span><br><span class="line">        List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//授权模式和授权对象</span></span><br><span class="line">        Id id = <span class="keyword">new</span> Id(<span class="string">&quot;world&quot;</span>,<span class="string">&quot;anyone&quot;</span>);</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.READ,id));</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.WRITE,id));</span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node2&quot;</span>,<span class="string">&quot;i am node2&quot;</span>.getBytes(StandardCharsets.UTF_8),acls,CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAcl2</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//ip授权</span></span><br><span class="line">        List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Id id = <span class="keyword">new</span> Id(<span class="string">&quot;ip&quot;</span>,<span class="string">&quot;192.168.52.131&quot;</span>);</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.ALL,id));</span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node2&quot;</span>,<span class="string">&quot;i am node2&quot;</span>.getBytes(StandardCharsets.UTF_8),acls,CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAcl3</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//auth授权</span></span><br><span class="line">        zooKeeper.addAuthInfo(<span class="string">&quot;digest&quot;</span>,<span class="string">&quot;admin:123456&quot;</span>.getBytes());</span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node2&quot;</span>,<span class="string">&quot;i am node2&quot;</span>.getBytes(StandardCharsets.UTF_8),ZooDefs.Ids.CREATOR_ALL_ACL,CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAcl4</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//auth授权</span></span><br><span class="line">        zooKeeper.addAuthInfo(<span class="string">&quot;digest&quot;</span>,<span class="string">&quot;admin:123456&quot;</span>.getBytes());</span><br><span class="line">        List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Id id = <span class="keyword">new</span> Id(<span class="string">&quot;auth&quot;</span>,<span class="string">&quot;bob&quot;</span>);</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.ALL,id));</span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node2&quot;</span>,<span class="string">&quot;i am node2&quot;</span>.getBytes(StandardCharsets.UTF_8),acls,CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAcl5</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//digest授权</span></span><br><span class="line">        List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Id id = <span class="keyword">new</span> Id(<span class="string">&quot;digest&quot;</span>,<span class="string">&quot;bob:qlzQzCLKhBROghkooLvb+Mlwv4A=&quot;</span>);</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.ALL,id));</span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node2&quot;</span>,<span class="string">&quot;i am node2&quot;</span>.getBytes(StandardCharsets.UTF_8),acls,CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPer</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建持久化顺序节点</span></span><br><span class="line">        String result = zooKeeper.create(<span class="string">&quot;/create/node1&quot;</span>,<span class="string">&quot;i am node1&quot;</span>.getBytes(StandardCharsets.UTF_8), ZooDefs.Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAsunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node2&quot;</span>,<span class="string">&quot;i am node2&quot;</span>.getBytes(StandardCharsets.UTF_8),ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, <span class="keyword">new</span> AsyncCallback.StringCallback()&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> rc 0代表创建成功</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> path 节点路径</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> ctx  上下文参数</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> name 节点路径</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, String name)</span> </span>&#123;</span><br><span class="line">                System.out.println(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;i am ctx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        zooKeeper.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方式</span></span><br><span class="line">set<span class="constructor">Data(String <span class="params">path</span>, <span class="params">byte</span>[] <span class="params">data</span>, <span class="params">int</span> <span class="params">version</span>)</span></span><br><span class="line"><span class="comment">// 异步方式:callback是异步回调接口 ctx传递上下文对象</span></span><br><span class="line">set<span class="constructor">Data(String <span class="params">path</span>, <span class="params">byte</span>[] <span class="params">data</span>,,<span class="params">int</span> <span class="params">version</span>,AsyncCallback.StatCallback <span class="params">callBack</span>,Object <span class="params">ctx</span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSyn</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Stat stat=zookeeper.setData(<span class="string">&quot;/set/node1&quot;</span>,<span class="string">&quot;node13&quot;</span>.getBytes(),<span class="number">2</span>);</span><br><span class="line">    System.out.println(stat.getVersion());</span><br><span class="line">    System.out.println(stat.getCtime());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsyn</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//版本号—1表示不参与更新 版本号一致才可以更新成功 每次更新版本号+1</span></span><br><span class="line">    zookeeper.setData(<span class="string">&quot;/set/node2&quot;</span>, <span class="string">&quot;node21&quot;</span>.getBytes(), -<span class="number">1</span>, <span class="keyword">new</span></span><br><span class="line">                      AsyncCallback.StatCallback() &#123;</span><br><span class="line">                          <span class="meta">@Override</span></span><br><span class="line">                          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, Stat stat)</span> </span>&#123;</span><br><span class="line">                              System.out.println(rc);</span><br><span class="line">                              System.out.println(path);</span><br><span class="line">                              System.out.println(ctx);</span><br><span class="line">                              System.out.println(stat.getVersion());</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;,<span class="string">&quot;I am Context&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 同步方式</span><br><span class="line"><span class="keyword">delete</span>(<span class="keyword">String</span> <span class="keyword">path</span>, <span class="built_in">int</span> <span class="keyword">version</span>)</span><br><span class="line">// 异步方式</span><br><span class="line"><span class="keyword">delete</span>(<span class="keyword">String</span> <span class="keyword">path</span>, <span class="built_in">int</span> <span class="keyword">version</span>, AsyncCallback.VoidCallback callBack,<span class="keyword">Object</span> ctx)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// arg2:数据版本信息 -1代表删除节点时不考虑版本信息</span></span><br><span class="line">    zooKeeper.delete(<span class="string">&quot;/delete/node1&quot;</span>,-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 异步使用方式</span></span><br><span class="line">    zooKeeper.delete(<span class="string">&quot;/delete/node2&quot;</span>, -<span class="number">1</span>, <span class="keyword">new</span></span><br><span class="line">                     AsyncCallback.VoidCallback() &#123;</span><br><span class="line">                         <span class="meta">@Override</span></span><br><span class="line">                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx)</span> </span>&#123;</span><br><span class="line">                             <span class="comment">// 0代表删除成功</span></span><br><span class="line">                             System.out.println(rc);</span><br><span class="line">                             System.out.println(path);</span><br><span class="line">                             System.out.println(ctx);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;,<span class="string">&quot;I am Context&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看节点"><a href="#查看节点" class="headerlink" title="查看节点"></a>查看节点</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方式</span></span><br><span class="line">get<span class="constructor">Data(String <span class="params">path</span>, <span class="params">boolean</span> <span class="params">b</span>, Stat <span class="params">stat</span>)</span></span><br><span class="line"><span class="comment">// 异步方式</span></span><br><span class="line">get<span class="constructor">Data(String <span class="params">path</span>, <span class="params">boolean</span> <span class="params">b</span>，AsyncCallback.DataCallback <span class="params">callBack</span>，Object <span class="params">ctx</span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// arg1:节点的路径</span></span><br><span class="line">    <span class="comment">// arg3:读取节点属性的对象</span></span><br><span class="line">    Stat stat=<span class="keyword">new</span> Stat();</span><br><span class="line">    <span class="keyword">byte</span> [] bys=zooKeeper.getData(<span class="string">&quot;/get/node1&quot;</span>,<span class="keyword">false</span>,stat);</span><br><span class="line">    <span class="comment">// 打印数据</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(bys));</span><br><span class="line">    <span class="comment">// 版本信息</span></span><br><span class="line">    System.out.println(stat.getVersion());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    zooKeeper.getData(<span class="string">&quot;/get/node1&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span></span><br><span class="line">            AsyncCallback.DataCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">byte</span>[] data, Stat stat)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 0代表读取成功</span></span><br><span class="line">                    System.out.println(rc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;I am Context&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看子节点"><a href="#查看子节点" class="headerlink" title="查看子节点"></a>查看子节点</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方式</span></span><br><span class="line">get<span class="constructor">Children(String <span class="params">path</span>, <span class="params">boolean</span> <span class="params">b</span>)</span></span><br><span class="line"><span class="comment">// 异步方式</span></span><br><span class="line">get<span class="constructor">Children(String <span class="params">path</span>, <span class="params">boolean</span> <span class="params">b</span>,AsyncCallback.ChildrenCallback <span class="params">callBack</span>,Object <span class="params">ctx</span>)</span></span><br></pre></td></tr></table></figure><ul><li>b- 是否使用连接对象中注册的监视器。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//arg2:如果watch为true，并且调用成功（没有抛出异常），将在给定路径的节点上留下一个watch。</span></span><br><span class="line">    <span class="comment">//如果成功地删除给定路径的节点或在该节点下创建/删除一个子节点的操作将触发该监视。</span></span><br><span class="line">    List&lt;String&gt; list = zooKeeper.getChildren(<span class="string">&quot;/get&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    zooKeeper.getChildren(<span class="string">&quot;/get&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span></span><br><span class="line">                          AsyncCallback.ChildrenCallback() &#123;</span><br><span class="line">                              <span class="meta">@Override</span></span><br><span class="line">                              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        List&lt;String&gt; children)</span> </span>&#123;</span><br><span class="line">                                  <span class="comment">// 0代表读取成功</span></span><br><span class="line">                                  System.out.println(rc);</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;,<span class="string">&quot;I am Context&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看节点是否存在"><a href="#查看节点是否存在" class="headerlink" title="查看节点是否存在"></a>查看节点是否存在</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方法</span></span><br><span class="line"><span class="built_in">exists</span>(<span class="keyword">String</span> path, <span class="keyword">boolean</span> b)</span><br><span class="line"><span class="comment">// 异步方法</span></span><br><span class="line"><span class="built_in">exists</span>(<span class="keyword">String</span> path, <span class="keyword">boolean</span> b，AsyncCallback.StatCallback callBack,Object ctx)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exists1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Stat stat = zookeeper.exists(<span class="string">&quot;/exists1&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    System.out.println(stat.getVersion());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exists2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    zookeeper.exists(<span class="string">&quot;/exists1&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span></span><br><span class="line">            AsyncCallback.StatCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Stat stat)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 0 判断成功</span></span><br><span class="line">                    System.out.println(rc);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;I am Context&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h1><p>​    zookeeper提供了数据的发布/订阅功能，多个订阅者可同时监听某一特定主题对 象，当该主题对象的自身状态发生变化时(例如节点内容改变、节点下的子节点列表改变 等)，会实时、主动通知所有订阅者</p><p>​    zookeeper采用了Watcher机制实现数据的发布/订阅功能。该机制在被订阅对 象发生变化时会异步通知客户端，因此客户端不必在Watcher注册后轮询阻塞，从而减轻 了客户端压力</p><h2 id="watcher架构"><a href="#watcher架构" class="headerlink" title="watcher架构"></a>watcher架构</h2><p>watcher由三部分组成：zookeeper服务端，zookeeper客户端，客户端的ZKWatchManager对象</p><p>客户端首先将Watcher注册到服务端，同时将Watcher对象保存到客户端的Watch管理器中。当ZooKeeper服务端监听的数据状态发生变化时，服务端会主动通知客户端， 接着客户端的Watch管理器会触发相关Watcher来回调相应处理逻辑，从而完成整体的数据发布/订阅流程。</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210215104851771.png" alt="image-20210215104851771"></p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>一次性</td><td>watcher是一次性的，一旦被触发就会移除，再次使用时需要重新注册</td></tr><tr><td>客户端顺序回调</td><td>watcher回调是顺序串行化执行的，只有回调后客户端才能看到最新的数据状态。一个watcher回调逻辑不应该太多，以免影响别的watcher执行</td></tr><tr><td>轻量级</td><td>WatchEvent是最小的通信单元，结构上只包含通知状态、事件类型和节点路径，并不会告诉数据节点变化前后的具体内容</td></tr><tr><td>时效性</td><td>watcher只有在当前session彻底失效时才会无效，若在session有效期内快速重连成功，则watcher依然存在，仍可接收到通知</td></tr></tbody></table><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>Watcher是一个接口，任何实现了Watcher接口的类就是一个新的Watcher。 Watcher内部包含了两个枚举类：KeeperState、EventType</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210215105441596.png" alt="image-20210215105441596"></p><p>Watcher通知状态(KeeperState)：KeeperState是客户端与服务端连接状态发生变化时对应的通知类型。路径为 org.apache.zookeeper.Watcher.Event.KeeperState，是一个枚举类，其枚举属性 如下</p><table><thead><tr><th>枚举属性</th><th>说明</th></tr></thead><tbody><tr><td>SyncConnected</td><td>客户端与服务器正常连接时</td></tr><tr><td>Disconnected</td><td>客户端与服务器断开连接时</td></tr><tr><td>Expired</td><td>会话session失效时</td></tr><tr><td>AuthFailed</td><td>身份认证失败时</td></tr></tbody></table><p>Watcher事件类型(EventType)：EventType是数据节点(znode)发生变化时对应的通知类型。EventType变化时 KeeperState永远处于SyncConnected通知状态下；当KeeperState发生变化时， EventType永远为None。其路径为org.apache.zookeeper.Watcher.Event.EventType，是一个枚举类，枚举属性如下</p><table><thead><tr><th>枚举属性</th><th>说明</th></tr></thead><tbody><tr><td>None</td><td>无</td></tr><tr><td>NodeCreated</td><td>Watcher监听的数据节点被创建时</td></tr><tr><td>NodeDeleted</td><td>Watcher监听的数据节点被删除时</td></tr><tr><td>NodeDataChanged</td><td>Watcher监听的数据节点内容发生变更时(无论内容数据 是否变化)</td></tr><tr><td>NodeChildrenChanged</td><td>Watcher监听的数据节点的子节点列表发生变更时</td></tr></tbody></table><h2 id="捕获相应的事件"><a href="#捕获相应的事件" class="headerlink" title="捕获相应的事件"></a>捕获相应的事件</h2><p>建立zookeeper的watcher监听</p><table><thead><tr><th>注册方式</th><th>Created</th><th>ChildChanged</th><th>Changed</th><th>Deleted</th></tr></thead><tbody><tr><td>zk.exists(“/nodex”,watcher)</td><td>可监控</td><td></td><td>可监控</td><td>可监控</td></tr><tr><td>zk.getData(“/nodex”,watcher)</td><td></td><td></td><td>可监控</td><td>可监控</td></tr><tr><td>zk.getChildren(“/nodex”,watcher)</td><td></td><td>可监控</td><td></td><td>可监控</td></tr></tbody></table><h2 id="注册watcher的方法"><a href="#注册watcher的方法" class="headerlink" title="注册watcher的方法"></a>注册watcher的方法</h2><h3 id="客户端与服务器的连接状态"><a href="#客户端与服务器的连接状态" class="headerlink" title="客户端与服务器的连接状态"></a>客户端与服务器的连接状态</h3><p>事件类型为none时 不同的通知状态的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.watcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKConnectionWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器对象</span></span><br><span class="line">    <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 连接对象</span></span><br><span class="line">    <span class="keyword">static</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 事件类型</span></span><br><span class="line">            <span class="keyword">if</span> (event.getType() == Event.EventType.None) &#123;</span><br><span class="line">                <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接创建成功!&quot;</span>);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == Event.KeeperState.Disconnected) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;断开连接！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == Event.KeeperState.Expired) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;会话超时!&quot;</span>);</span><br><span class="line">                    zooKeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;192.168.52.131:2181&quot;</span>, <span class="number">5000</span>, <span class="keyword">new</span> ZKConnectionWatcher());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == Event.KeeperState.AuthFailed) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;认证失败！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zooKeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;192.168.52.131:2181&quot;</span>, <span class="number">5000</span>, <span class="keyword">new</span> ZKConnectionWatcher());</span><br><span class="line">            <span class="comment">// 阻塞线程等待连接的创建</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="comment">// 会话id</span></span><br><span class="line">            System.out.println(zooKeeper.getSessionId());</span><br><span class="line">            <span class="comment">// 添加授权用户</span></span><br><span class="line">            zooKeeper.addAuthInfo(<span class="string">&quot;digest1&quot;</span>,<span class="string">&quot;itcast1:1234561&quot;</span>.getBytes());</span><br><span class="line">            <span class="keyword">byte</span> [] bs=zooKeeper.getData(<span class="string">&quot;/node1&quot;</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bs));</span><br><span class="line">            Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">            zooKeeper.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检查节点是否存在"><a href="#检查节点是否存在" class="headerlink" title="检查节点是否存在"></a>检查节点是否存在</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用连接对象的监视器</span></span><br><span class="line"><span class="function"><span class="title">exists</span><span class="params">(String path, boolean b)</span></span></span><br><span class="line"><span class="comment">// 自定义监视器</span></span><br><span class="line"><span class="function"><span class="title">exists</span><span class="params">(String path, Watcher w)</span></span></span><br><span class="line"></span><br><span class="line">path- znode路径。</span><br><span class="line">b- 是否使用连接对象中注册的监视器。</span><br><span class="line">w-监视器对象。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKWatcherExists</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String IP = <span class="string">&quot;192.168.52.131:2181&quot;</span>;</span><br><span class="line">    ZooKeeper zooKeeper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 连接zookeeper客户端</span></span><br><span class="line">        zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">6000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接对象的参数!&quot;</span>);</span><br><span class="line">                <span class="comment">// 连接成功</span></span><br><span class="line">                <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        zooKeeper.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherExists1</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// arg1:节点的路径</span></span><br><span class="line">        <span class="comment">// arg2:使用连接对象中的watcher</span></span><br><span class="line">        <span class="comment">//启动之后 再创建watcher1节点 控制台会显示出结果</span></span><br><span class="line">        zooKeeper.exists(<span class="string">&quot;/watcher1&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherExists2</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// arg1:节点的路径</span></span><br><span class="line">        <span class="comment">// arg2:自定义watcher对象</span></span><br><span class="line">        zooKeeper.exists(<span class="string">&quot;/watcher1&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;自定义watcher&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherExists3</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// watcher一次性</span></span><br><span class="line">        Watcher watcher = <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;自定义watcher&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    zooKeeper.exists(<span class="string">&quot;/watcher1&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        zooKeeper.exists(<span class="string">&quot;/watcher1&quot;</span>, watcher);</span><br><span class="line">        Thread.sleep(<span class="number">80000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherExists4</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 注册多个监听器对象</span></span><br><span class="line">        zooKeeper.exists(<span class="string">&quot;/watcher1&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        zooKeeper.exists(<span class="string">&quot;/watcher1&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(<span class="number">80000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看节点-1"><a href="#查看节点-1" class="headerlink" title="查看节点"></a>查看节点</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用连接对象的监视器</span></span><br><span class="line">get<span class="constructor">Data(String <span class="params">path</span>, <span class="params">boolean</span> <span class="params">b</span>, Stat <span class="params">stat</span>)</span></span><br><span class="line"><span class="comment">// 自定义监视器</span></span><br><span class="line">get<span class="constructor">Data(String <span class="params">path</span>, Watcher <span class="params">w</span>, Stat <span class="params">stat</span>)</span></span><br><span class="line"></span><br><span class="line">path- znode路径。</span><br><span class="line">b- 是否使用连接对象中注册的监视器。</span><br><span class="line">w-监视器对象。</span><br><span class="line">stat- 返回znode的元数据。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKWatcherGetData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String IP = <span class="string">&quot;192.168.60.130:2181&quot;</span>;</span><br><span class="line">    ZooKeeper zooKeeper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 连接zookeeper客户端</span></span><br><span class="line">        zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">6000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接对象的参数!&quot;</span>);</span><br><span class="line">                <span class="comment">// 连接成功</span></span><br><span class="line">                <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        zooKeeper.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetData1</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// arg1:节点的路径</span></span><br><span class="line">        <span class="comment">// arg2:使用连接对象中的watcher</span></span><br><span class="line">        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetData2</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// arg1:节点的路径</span></span><br><span class="line">        <span class="comment">// arg2:自定义watcher对象</span></span><br><span class="line">        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;自定义watcher&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">null</span>);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetData3</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 一次性</span></span><br><span class="line">        Watcher watcher = <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;自定义watcher&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    <span class="keyword">if</span>(event.getType()==Event.EventType.NodeDataChanged) &#123;</span><br><span class="line">                        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, watcher, <span class="keyword">null</span>);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetData4</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 注册多个监听器对象</span></span><br><span class="line">        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    <span class="keyword">if</span>(event.getType()==Event.EventType.NodeDataChanged) &#123;</span><br><span class="line">                        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">null</span>);</span><br><span class="line">        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    <span class="keyword">if</span>(event.getType()==Event.EventType.NodeDataChanged) &#123;</span><br><span class="line">                        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">null</span>);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看子节点-1"><a href="#查看子节点-1" class="headerlink" title="查看子节点"></a>查看子节点</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get<span class="constructor">Children(String <span class="params">path</span>, <span class="params">boolean</span> <span class="params">b</span>)</span></span><br><span class="line"></span><br><span class="line">get<span class="constructor">Children(String <span class="params">path</span>, Watcher <span class="params">w</span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKWatcherGetChild</span> </span>&#123;</span><br><span class="line">    String IP = <span class="string">&quot;192.168.60.130:2181&quot;</span>;</span><br><span class="line">    ZooKeeper zooKeeper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch connectedSemaphore = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 连接zookeeper客户端</span></span><br><span class="line">        zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">6000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接对象的参数!&quot;</span>);</span><br><span class="line">                <span class="comment">// 连接成功</span></span><br><span class="line">                <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                    connectedSemaphore.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        connectedSemaphore.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        zooKeeper.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetChild1</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// arg1:节点的路径</span></span><br><span class="line">        <span class="comment">// arg2:使用连接对象中的watcher</span></span><br><span class="line">        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetChild2</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// arg1:节点的路径</span></span><br><span class="line">        <span class="comment">// arg2:自定义watcher</span></span><br><span class="line">        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;自定义watcher&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetChild3</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 一次性</span></span><br><span class="line">        Watcher watcher = <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;自定义watcher&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    <span class="keyword">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">                        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, watcher);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetChild4</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 多个监视器对象</span></span><br><span class="line">        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    <span class="keyword">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">                        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    <span class="keyword">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">                        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用zookeeper作为配置中心"><a href="#使用zookeeper作为配置中心" class="headerlink" title="使用zookeeper作为配置中心"></a>使用zookeeper作为配置中心</h2><p>设计思路： </p><ol><li>连接zookeeper服务器 </li><li>读取zookeeper中的配置信息，注册watcher监听器，存入本地变量 3</li><li>. 当zookeeper中的配置信息发生变化时，通过watcher的回调方法捕获数据变化事件 4. 重新获取配置信息</li></ol><p>首先要在zookeeper中创建相关的节点 存放配置信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfigCenter</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  zk的连接串</span></span><br><span class="line">    String IP = <span class="string">&quot;192.168.52.131:2181&quot;</span>;</span><br><span class="line">    <span class="comment">//  计数器对象</span></span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 连接对象</span></span><br><span class="line">    <span class="keyword">static</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于本地化存储配置信息</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 捕获事件状态</span></span><br><span class="line">            <span class="keyword">if</span> (event.getType() == EventType.None) &#123;</span><br><span class="line">                <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == Event.KeeperState.Disconnected) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接断开!&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == Event.KeeperState.Expired) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接超时!&quot;</span>);</span><br><span class="line">                    <span class="comment">// 超时后服务器端已经将连接释放，需要重新连接服务器端</span></span><br><span class="line">                    zooKeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;192.168.60.130:2181&quot;</span>, <span class="number">6000</span>,</span><br><span class="line">                            <span class="keyword">new</span> ZKConnectionWatcher());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == Event.KeeperState.AuthFailed) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;验证失败!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当配置信息发生变化时</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType() == EventType.NodeDataChanged) &#123;</span><br><span class="line">                initValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyConfigCenter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接zookeeper服务器，读取配置信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建连接对象</span></span><br><span class="line">            zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">5000</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 阻塞线程，等待连接的创建成功</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="comment">// 读取配置信息</span></span><br><span class="line">            <span class="keyword">this</span>.url = <span class="keyword">new</span> String(zooKeeper.getData(<span class="string">&quot;/config/url&quot;</span>, <span class="keyword">true</span>, <span class="keyword">null</span>));</span><br><span class="line">            <span class="keyword">this</span>.username = <span class="keyword">new</span> String(zooKeeper.getData(<span class="string">&quot;/config/username&quot;</span>, <span class="keyword">true</span>, <span class="keyword">null</span>));</span><br><span class="line">            <span class="keyword">this</span>.password = <span class="keyword">new</span> String(zooKeeper.getData(<span class="string">&quot;/config/password&quot;</span>, <span class="keyword">true</span>, <span class="keyword">null</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyConfigCenter myConfigCenter = <span class="keyword">new</span> MyConfigCenter();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;url:&quot;</span>+myConfigCenter.getUrl());</span><br><span class="line">                System.out.println(<span class="string">&quot;username:&quot;</span>+myConfigCenter.getUsername());</span><br><span class="line">                System.out.println(<span class="string">&quot;password:&quot;</span>+myConfigCenter.getPassword());</span><br><span class="line">                System.out.println(<span class="string">&quot;########################################&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成分布式唯一ID"><a href="#生成分布式唯一ID" class="headerlink" title="生成分布式唯一ID"></a>生成分布式唯一ID</h2><p>设计思路： </p><p>1.连接zookeeper服务器 </p><p>2.指定路径生成临时有序节点 </p><p>3.取序列号及为分布式环境下的唯一ID</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GloballyUniqueId</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  zk的连接串</span></span><br><span class="line">    String IP = <span class="string">&quot;192.168.52.131:2181&quot;</span>;</span><br><span class="line">    <span class="comment">//  计数器对象</span></span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//  用户生成序号的节点</span></span><br><span class="line">    String defaultPath = <span class="string">&quot;/uniqueId&quot;</span>;</span><br><span class="line">    <span class="comment">//  连接对象</span></span><br><span class="line">    ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 捕获事件状态</span></span><br><span class="line">            <span class="keyword">if</span> (event.getType() == Event.EventType.None) &#123;</span><br><span class="line">                <span class="keyword">if</span> (event.getState() == KeeperState.SyncConnected) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == KeeperState.Disconnected) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接断开!&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == KeeperState.Expired) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接超时!&quot;</span>);</span><br><span class="line">                    <span class="comment">// 超时后服务器端已经将连接释放，需要重新连接服务器端</span></span><br><span class="line">                    zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">6000</span>,</span><br><span class="line">                            <span class="keyword">new</span> ZKConnectionWatcher());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == KeeperState.AuthFailed) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;验证失败!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GloballyUniqueId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//打开连接</span></span><br><span class="line">            zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">5000</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 阻塞线程，等待连接的创建成功</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成id的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUniqueId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String path = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建临时有序节点</span></span><br><span class="line">            path = zooKeeper.create(defaultPath, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// /uniqueId0000000001</span></span><br><span class="line">        <span class="keyword">return</span> path.substring(<span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GloballyUniqueId globallyUniqueId = <span class="keyword">new</span> GloballyUniqueId();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            String id = globallyUniqueId.getUniqueId();</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>设计思路：</p><p>1.每个客户端往/Locks下创建临时有序节点如/Locks/Lock_000000001 </p><p>2.客户端取得/Locks下子节点，并进行排序，判断排在最前面的是否为自己，如果自己的 锁节点在第一位，代表获取锁成功 </p><p>3.如果自己的锁节点不在第一位，则监听自己前一位的锁节点。例如，自己锁节点 Lock_000000001那么则监听锁几点Lock_000000002</p><p> 4.当前一位锁节点（Lock_000000001）对应的客户端完成执行完成，释放了锁，将会触发监听客户端（Lock_000000002）的逻辑</p><p> 5.监听客户端重新执行第2步逻辑，判断自己是否获得了锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  zk的连接串</span></span><br><span class="line">    String IP = <span class="string">&quot;192.168.60.130:2181&quot;</span>;</span><br><span class="line">    <span class="comment">//  计数器对象</span></span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//ZooKeeper配置信息</span></span><br><span class="line">    ZooKeeper zooKeeper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_ROOT_PATH = <span class="string">&quot;/Locks&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_NODE_NAME = <span class="string">&quot;Lock_&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String lockPath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开zookeeper连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">5000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getType() == Event.EventType.None) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;连接成功!&quot;</span>);</span><br><span class="line">                            countDownLatch.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建锁节点</span></span><br><span class="line">        createLock();</span><br><span class="line">        <span class="comment">//尝试获取锁</span></span><br><span class="line">        attemptLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建锁节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//判断Locks是否存在，不存在创建</span></span><br><span class="line">        Stat stat = zooKeeper.exists(LOCK_ROOT_PATH, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (stat == <span class="keyword">null</span>) &#123;</span><br><span class="line">            zooKeeper.create(LOCK_ROOT_PATH, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建临时有序节点</span></span><br><span class="line">        lockPath = zooKeeper.create(LOCK_ROOT_PATH + <span class="string">&quot;/&quot;</span> + LOCK_NODE_NAME, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        System.out.println(<span class="string">&quot;节点创建成功:&quot;</span> + lockPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监视器对象，监视上一个节点是否被删除</span></span><br><span class="line">    Watcher watcher = <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (event.getType() == Event.EventType.NodeDeleted) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attemptLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Locks节点下的所有子节点</span></span><br><span class="line">        List&lt;String&gt; list = zooKeeper.getChildren(LOCK_ROOT_PATH, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 对子节点进行排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="comment">// /Locks/Lock_000000001</span></span><br><span class="line">        <span class="keyword">int</span> index = list.indexOf(lockPath.substring(LOCK_ROOT_PATH.length() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取锁成功!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 上一个节点的路径</span></span><br><span class="line">            String path = list.get(index - <span class="number">1</span>);</span><br><span class="line">            Stat stat = zooKeeper.exists(LOCK_ROOT_PATH + <span class="string">&quot;/&quot;</span> + path, watcher);</span><br><span class="line">            <span class="keyword">if</span> (stat == <span class="keyword">null</span>) &#123;</span><br><span class="line">                attemptLock();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (watcher) &#123;</span><br><span class="line">                    watcher.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                attemptLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//删除临时有序节点</span></span><br><span class="line">            zooKeeper.delete(<span class="keyword">this</span>.lockPath,-<span class="number">1</span>);</span><br><span class="line">            zooKeeper.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;锁已经释放:&quot;</span>+<span class="keyword">this</span>.lockPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyLock myLock = <span class="keyword">new</span> MyLock();</span><br><span class="line">            myLock.createLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h1><p>事务需要跨多个分布式节点时，为了保证事务的ACID特性，需要选举出一个协调者来协调分布式各个节点的调度，基于这个思想衍生了多种一致性协议</p><h2 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h2><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210302193523354.png" alt="image-20210302193523354"></p><p>参与者提交后返回ack协调者再次提交 保证了一致性</p><p>中断事务：当有的参与者在任意阶段没有返回ack 参与者和协调者会回滚</p><p>二阶段提交存在的问题</p><ul><li>同步阻塞：二阶段提交过程中 所有参与事务的节点处于同步阻塞状态 无法进行其他操作</li><li>单点问题：一旦协调者出现单点故障 无法保证事务的一致性操作</li><li>脑裂导致数据不一致：如果分布式节点出现网络分区，某些参与者未收到commit提交命令或者选举了其他节点作为协调者。则出现部分参与者完成数据提交。未收到commit的命令的参与者则无法进行事务提交，整个分布式系统便出现了数据不一致性现象。</li></ul><h2 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h2><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210302194659679.png" alt="image-20210302194659679"></p><p>阶段一：CanCommit</p><ol><li>事务询问</li><li>各参与者向协调者反馈事务询问的相应</li></ol><p>阶段二：PreCommit</p><p>根据阶段一的反馈结果分为两种情况</p><ol><li>执行事务预提交<ul><li>发送预提交请求：协调者向所有参与者发送preCommit请求，进入prepared阶段</li><li>事务预提交：各参与者节点接受到preCommit请求后，执行事务操作</li><li>各参与者节点向协调者反馈事务执行</li></ul></li><li>中断事务：任意一个参与者节点反馈给协调者响应No时，或者在等待超时后，协调者还未收到参与者的反馈，就中断事务，中断事务分为两步<ul><li>协调者向各个参与者节点发送abort请求</li><li>参与者收到abort请求，或者等待超时时间后，中断事务</li></ul></li></ol><p>阶段三：doCommit</p><ol><li>执行提交</li><li>中断事务</li></ol><p>三阶段中引入了超时时间解决了同步阻塞问题</p><p>当协调者故障的时候 参与者如果长时间接收不到参与者请求之后 会自动提交事务，解决了单点故障问题</p><p>无法解决脑裂问题</p><h2 id="paxos算法"><a href="#paxos算法" class="headerlink" title="paxos算法"></a>paxos算法</h2><p>paxos算法:基于消息传递且具有高度容错性的一种算法，是目前公认的解决分布式一致性问题最有效的算法</p><p>解决问题:在分布式系统中，如果产生容机或者网络异常情况，快速的正确的在集群内部对某个数据的值达成一致，并且不管发生任何异常，都不会破坏整个系统的一致性;</p><p>半数原则:少数服从多数</p><p>paxos中的四个角色</p><ul><li>client:系统外部角色，请求发起者，不参与决策</li><li>proposer:提案提议者</li><li>acceptor:提案的表决者，即是否accept该提案，只有超过半数以上的acceptor接受了提案，该提案才被认为被””选定”</li><li>learners:提案的学习者，当提案被选定后，其同步执行提案，不参与决策 </li></ul><p>两个阶段</p><ul><li>prepare阶段：<ul><li>proposer提出一个提案，编号为N,发送给所有的acceptor。</li><li>每个表决者都保存自己的accept的最大提案编号maxN，当表决者收到prepare(N)请求时，会比较N与maxN的值，若N小于maxN,则提案已过时，拒绝prepare(N)请求。若N大于等于maxN，则接受提案，并将该表决者曾经接受过的编号最大的提案Proposal(myid,maxN,value)反馈给提议者:其中myid表示表决者acceptor的标识id，maxN表示接受过的最大提案编号maxN,value表示提案内容。若当前表决者未曾accept任何提议，会将proposal(myid,null,null)反馈给提议者。</li></ul></li><li>accept阶段：<ul><li>提议者proposal发出prepare(N),若收到超过半数表决者acceptor的反馈，proposal将真正的提案内容proposal(N,value)发送给所有表决者。</li><li>表决者acceptor接受提议者发送的proposal(N,value)提案后，会将自己曾经accept过的最大提案编号maxN和反馈过的prepare的最大编号比较，若N大于这两个编号，则当前表决者accept该提案，并反馈给提议者。否则拒绝该提议。</li><li>若提议者没有收到半数以上的表决者accept反馈，则重新进入prepare阶段，递增提案编号，重新提出prepare请求。若收到半数以上的accept，则其他未向提议者反馈的表决者称为learner，主动同步提议者的提案。</li></ul></li></ul><p>正常流程</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210302213055055.png" alt="image-20210302213055055"></p><p>单点故障，部分节点失败</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210302213116146.png" alt="image-20210302213116146"></p><ul><li>虽然有一个acceptor挂掉 但是满足半数原则 仍可以继续执行</li></ul><p>proposer失败</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210302213218757.png" alt="image-20210302213218757"></p><ul><li>会重新创建一个proposer 并且编号+1</li></ul><p>活锁问题</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210302213549531.png" alt="image-20210302213549531"></p><p>当proposer1请求1的时候 proposer2请求2  当proposer1再请求的时候 编号小于2 重新执行第一阶段 请求3 这样两个proposer互相改变请求条件 谁都不能提交提议</p><p>解决方法： 执行时间错开</p><h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>由于paxos算法实现起来较难，存在活锁和全序问题（无法保证两次最终提交的顺序)，所以zookeeper并没有使用paxos作为一致性协议，而是使用了ZAB协议。</p><p>ZAB (zookeeper atomic broadcast) :是一种支持崩溃恢复的原子广播协议，基于Fast paxos实现</p><p>ZooKeeper使用单一主进程Leader用于处理客户端所有事务请求,，即写请求。当服务器数据发生变更好，集群采用ZAB原子广播协议，以事务提交proposal的形式广播到所有的副本进程，每一个事务分配一个全局的递增的事务编号xid。</p><p>若客户端提交的请求为读请求时，则接受请求的节点直接根据自己保存的数据响应。若是写请求，且当前节点不是leader，那么该节点就会将请求转发给leader，leader会以提案的方式广播此写请求，如果超过半数的节点同意写请求，则该写请求就会提交。leader会通知所有的订阅者同步数据。</p><p>zab协议 的全称是 Zookeeper Atomic Broadcast （zookeeper原子广播）。 zookeeper 是通过 zab协议来保证分布式事务的最终一致性</p><p>基于zab协议，zookeeper集群中的<strong>角色</strong>主要有以下三类，如下表所示：</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210216193555107.png" alt="image-20210216193555107"></p><p>zab广播模式<strong>工作原理</strong>，通过类似两阶段提交协议的方式解决数据一致性：</p><p>一旦进入广播模式，集群中非leader节点接受到事务请求，首先会将事务请求转发给服务器，leader服务器为其生成对应的事务提案proposal,并发送给集群中其他节点，如果过半则事务提交;</p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210216194010598.png" alt="image-20210216194010598"></p><ol><li><p>leader接受到消息后，消息通过全局唯一的64位自增事务id，zxid标识</p></li><li><p>leader发送给follower的提案是有序的，leader会创建一个FIFO队列，将提案顺序写入队列中发送给follower</p></li><li><p>follower接受到提案后，会比较提案zxid和本地事务日志最大的zxid，若提案zxid比本地事务id大，将提案记录到本地日志中，反馈ack给leader，否则拒绝</p></li><li><p>leader接收到过半ack后，leader向所有的follower发送commit，通知每个follower执行本地事务</p></li></ol><p><strong>zookeeper两种模式</strong></p><ul><li>恢复模式<ul><li>当服务启动或领导崩溃后，zk进入恢复状态，选举leader，leader选出后，将完成leader和其他机器的数据同步，当大多数server完成和leader的同步后，恢复模式结束</li></ul></li><li>广播模式<ul><li>一旦Leader已经和多数的Follower进行了状态同步后，进入广播模式。进入广播模式后，如果有新加入的服务器，会自动从leader中同步数据。leader在接收客户端请求后，会生成事务提案广播给其他机器，有超过半数以上的follower同意该提议后，再提交事务。</li><li>再zab的二阶段提交中，移除了事务中断的逻辑，follower要么ack要么放弃，leader无需等待所有的follower的ack(因为有半数原则的支持)</li></ul></li></ul><p><strong>zxid</strong></p><p>zxid是64位长度的Long类型，其中高32位表示纪元epoch，低32位表示事务标识xid。即zxid由两部分构成: epoch和xid</p><p>每个leader都会具有不同的epoch值，表示一个纪元，每一个新的选举开启时都会生成一个新的epoch，新的leader产生，会更新所有的zkSeiezookeeper的leader选举</p><p><strong>服务器状态</strong></p><p>looking：寻找leader状态。当服务器处于该状态时，它会认为当前集群中没有 leader，因此需要进入leader选举状态。</p><p>leading： 领导者状态。表明当前服务器角色是leader。</p><p>following： 跟随者状态。表明当前服务器角色是follower。</p><p>observing：观察者状态。表明当前服务器角色是observer。</p><p><strong>服务器启动时期的leader选举</strong></p><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210303153439976.png" alt="image-20210303153439976"></p><p>如果leader挂掉，集群中其他follower会将状态改为looking重新进行选举</p>]]></content>
    
    
    <summary type="html">zooKeeper是一个经典的分布式数据—致性解决方案，致力于为分布式应用提供一个高性能、高可用，且具有严格顺序访问控制能力的分布式协调存储服务</summary>
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>解决chrome访问https网站出现您的连接不是私密的问题</title>
    <link href="http://example.com/2021/01/29/%E8%A7%A3%E5%86%B3chrome%E8%AE%BF%E9%97%AEhttps%E7%BD%91%E7%AB%99%E5%87%BA%E7%8E%B0%E6%82%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%98%AF%E7%A7%81%E5%AF%86%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/01/29/%E8%A7%A3%E5%86%B3chrome%E8%AE%BF%E9%97%AEhttps%E7%BD%91%E7%AB%99%E5%87%BA%E7%8E%B0%E6%82%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%98%AF%E7%A7%81%E5%AF%86%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-01-29T06:49:22.000Z</published>
    <updated>2021-02-03T15:00:53.508Z</updated>
    
    <content type="html"><![CDATA[<p>今天访问博客codebob111.github.io的时候chrome显示连接不是私密连接 无法访问</p><p><img src="%E8%A7%A3%E5%86%B3chrome%E8%AE%BF%E9%97%AEhttps%E7%BD%91%E7%AB%99%E5%87%BA%E7%8E%B0%E6%82%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%98%AF%E7%A7%81%E5%AF%86%E7%9A%84%E9%97%AE%E9%A2%98/image-20210129145042596.png" alt="image-20210129145042596"></p><p>在网上看了好多博客 最后终于找到了解决方法 开启使用安全dns并勾上第二个选项</p><p><img src="%E8%A7%A3%E5%86%B3chrome%E8%AE%BF%E9%97%AEhttps%E7%BD%91%E7%AB%99%E5%87%BA%E7%8E%B0%E6%82%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%98%AF%E7%A7%81%E5%AF%86%E7%9A%84%E9%97%AE%E9%A2%98/image-20210129145207994.png" alt="image-20210129145207994"></p>]]></content>
    
    
    <summary type="html">解决chrome访问https网站出现您的连接不是私密连接的问题</summary>
    
    
    
    <category term="bug" scheme="http://example.com/categories/bug/"/>
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
