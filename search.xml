<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Jenkins</title>
    <url>/2020/10/07/Jenkins/</url>
    <content><![CDATA[<h1 id="持续集成及Jenkins介绍"><a href="#持续集成及Jenkins介绍" class="headerlink" title="持续集成及Jenkins介绍"></a>持续集成及Jenkins介绍</h1><h2 id="软件开发生命周期"><a href="#软件开发生命周期" class="headerlink" title="软件开发生命周期"></a><strong>软件开发生命周期</strong></h2><p><img src="/2020/10/07/Jenkins/image-20201007082212395.png" alt="image-20201007082212395"></p>
<pre><code>* 需求分析是第一阶段</code></pre>
<h2 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a><strong>瀑布模型</strong></h2><p>​    瀑布模型是最著名和最常使用的软件开发模型。瀑布模型就是一系列的软件开发过程。它是由制造业繁 衍出来的。一个高度化的结构流程在一个方向上流动，有点像生产线一样。在瀑布模型创建之初，没有 其它开发的模型，有很多东西全靠开发人员去猜测，去开发。这样的模型仅适用于那些简单的软件开 发， 但是已经不适合现在的开发了。</p>
<p><img src="/2020/10/07/Jenkins/image-20201007083426392.png"></p>
<h2 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a><strong>敏捷开发</strong></h2><p>敏捷开发的核心是迭代开发和增量开发</p>
<p>​    迭代开发：对于大型软件项目，传统的开发方式是采用一个大周期（比如一年）进行开发，整个过程就是一次”大 开发”；迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次”大开发”变成多次”小开 发”，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤。</p>
<p>​    增量开发：软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代</p>
<p>​    敏捷开发的迭代：虽然敏捷开发将软件开发分成多个迭代，但是也要求，每次迭代都是一个完整的软件开发周期，必须按 照软件工程的方法论，进行正规的流程管理。</p>
<p><img src="/2020/10/07/Jenkins/image-20201007083610059.png"></p>
<p>​    敏捷开发的好处</p>
<pre><code>* 敏捷开发的第一个好处，就是早期交付，从而大大降低成本。 还是以上一节的房产公司为例，如果按照 传统的&quot;瀑布开发模式&quot;，先挖10栋楼的地基、再盖骨架、然后架设屋顶，每个阶段都等到前一个阶段完 成后开始，可能需要两年才能一次性交付10栋楼。也就是说，如果不考虑预售，该项目必须等到两年后 才能回款。 敏捷开发是六个月后交付一号楼，后面每两个月交付一栋楼。因此，半年就能回款10%，后 面每个月都会有现金流，资金压力就大大减轻了。
* 敏捷开发的第二个好处是，及时了解市场需求，降低产品不适用的风险。 请想一想，哪一种情况损失比 较小：10栋楼都造好以后，才发现卖不出去，还是造好第一栋楼，就发现卖不出去，从而改进或停建后 面9栋楼？</code></pre>
<p><img src="/2020/10/07/Jenkins/image-20201007082643153.png" alt="image-20201007082643153"></p>
<h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a><strong>持续集成</strong></h2><p>​    持续集成（ Continuous integration ， 简称 CI ）指的是，频繁地（一天多次）将代码集成到主干。 持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干 之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。 通过持续集成， 团队可以快速的从一个功能到另一个功能，简而言之，敏捷软件开发很大一部分都要归 功于持续集成。</p>
<p>​    持续集成的流程</p>
<p>​    <img src="/2020/10/07/Jenkins/image-20201007084410402.png" alt="image-20201007084410402"></p>
<p>持续集成的组成要素</p>
<ul>
<li>一个自动构建过程， 从检出代码、 编译构建、 运行测试、 结果记录、 测试统计等都是自动完成 的， 无需人工干预。</li>
<li>一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库，一般 使用SVN或Git</li>
<li>一个持续集成服务器， Jenkins 就是一个配置简单和使用方便的持续集成服务器</li>
</ul>
<p><img src="/2020/10/07/Jenkins/image-20201007083014385.png" alt="image-20201007083014385"></p>
<h1 id="Jenkins安装和持续集成环境配置"><a href="#Jenkins安装和持续集成环境配置" class="headerlink" title="Jenkins安装和持续集成环境配置"></a>Jenkins安装和持续集成环境配置</h1><h2 id="持续集成流程说明"><a href="#持续集成流程说明" class="headerlink" title="持续集成流程说明"></a>持续集成流程说明</h2><p><img src="/2020/10/07/Jenkins/image-20201007085649486.png" alt="image-20201007085649486"></p>
<ul>
<li>首先，开发人员每天进行代码提交，提交到Git仓库</li>
<li>然后，Jenkins作为持续集成工具，使用Git工具到Git仓库拉取代码到集成服务器，再配合JDK， Maven等软件完成代码编译，代码测试与审查，测试，打包等工作，在这个过程中每一步出错，都重新 再执行一次整个流程。</li>
<li>最后，Jenkins把生成的jar或war包分发到测试服务器或者生产服务器，测试人员或用户就可以访问 应用。</li>
</ul>
<h2 id="Gitlab代码托管服务器安装"><a href="#Gitlab代码托管服务器安装" class="headerlink" title="Gitlab代码托管服务器安装"></a>Gitlab代码托管服务器安装</h2><h3 id="gitlab介绍"><a href="#gitlab介绍" class="headerlink" title="gitlab介绍"></a>gitlab介绍</h3><p>GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的 web服务。</p>
<p>GitLab和GitHub一样属于第三方基于Git开发的作品，免费且开源（基于MIT协议），与Github类似， 可以注册用户，任意提交你的代码，添加SSHKey等等。不同的是，GitLab是可以部署到自己的服务器 上，数据库等一切信息都掌握在自己手上，适合团队内部协作开发，你总不可能把团队内部的智慧总放 在别人的服务器上吧？简单来说可把GitLab看作个人版的GitHub。</p>
<h3 id="gitlab安装"><a href="#gitlab安装" class="headerlink" title="gitlab安装"></a>gitlab安装</h3>]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>Debug</title>
    <url>/2020/11/08/DeBug/</url>
    <content><![CDATA[<p>centos 7 docker 启动一个web服务的时候 启动报错</p>
<p>WARNING: IPv4 forwarding is disabled. Networking will not work.</p>
<p>在宿主机上修改配置文件 <code>/usr/lib/sysctl.d/00-system.conf</code> 追加  <code>net.ipv4.ip_forward=1</code></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&quot;net.ipv4.ip_forward=1&quot;</span> &gt;&gt;<span class="regexp">/usr/</span>lib<span class="regexp">/sysctl.d/</span><span class="number">00</span>-system.conf</span><br></pre></td></tr></table></figure>

<p>重启network和docker服务</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">systemctl restart<span class="built_in"> network </span>&amp;&amp; systemctl restart docker</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>bug</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码分析</title>
    <url>/2020/11/16/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>参考：<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap(JDK1.8)%E6%BA%90%E7%A0%81+%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90">https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap(JDK1.8)%E6%BA%90%E7%A0%81+%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90</a></p>
<h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>
<ul>
<li><p><strong>loadFactor 加载因子</strong></p>
<p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>
<p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</p>
<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
</li>
<li><p><strong>threshold</strong></p>
<p><strong>threshold = capacity * loadFactor</strong>，<strong>当 Size&gt;=threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/qq_42034205/article/details/90384772">为什么与hashcode &gt;&gt;&gt; 16异或？</a></p>
<p><a href="https://www.cnblogs.com/loading4/p/6239441.html">返回大于输入参数且最近的2的整数次幂的数</a></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">static final <span class="built_in">int</span> tableSizeFor(<span class="built_in">int</span> cap) &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">n</span> = cap - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    return (<span class="built_in">n</span> &lt; <span class="number">0</span>) ? <span class="number">1</span> <span class="symbol">:</span> (<span class="built_in">n</span> &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY <span class="symbol">:</span> <span class="built_in">n</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以cap = 5为例</p>
<p><img src="/2020/11/16/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image.png"></p>
<p>参考：</p>
<p>​    <a href="https://blog.csdn.net/woshimaxiao1/article/details/83661464">https://blog.csdn.net/woshimaxiao1/article/details/83661464</a></p>
<p>​    <a href="https://blog.csdn.net/qq_40574571/article/details/97612100">https://blog.csdn.net/qq_40574571/article/details/97612100</a></p>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p><a href="https://segmentfault.com/a/1190000016143805">https://segmentfault.com/a/1190000016143805</a></p>
<p><a href="https://www.jianshu.com/p/78989cd553b4">https://www.jianshu.com/p/78989cd553b4</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/11/23/MongoDB/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>在mongodb/bin目录下执行./mongod  -f  mongodb.conf</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>数据库：存放集合的仓库</p>
<p>集合：类似于数组 存放文档</p>
<p>文档：文档是数据库中最小的单位</p>
<p>数据库和集合不需要手动创建 当创建的文档所在的集合或数据库不存在会自动创建（在第一次往里插入文档的时候创建）</p>
<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>show dbs：显示当前所有数据库</p>
<p>use 数据库名：进入到指定数据库中</p>
<p>db：显示当前所在的数据库</p>
<p>show collections：显示数据库的所有集合</p>
<h2 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h2><p>insert：同时插入多条或一条数据（如果插入一条去掉[]）</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">db.students.insert([</span><br><span class="line">	&#123;<span class="attr">name:</span><span class="string">&quot;bob&quot;</span>,<span class="attr">age:</span><span class="number">23</span>,<span class="attr">gender:</span><span class="string">&quot;male&quot;</span>&#125;,</span><br><span class="line">	&#123;<span class="attr">name:</span><span class="string">&quot;jack&quot;</span>,<span class="attr">age:</span><span class="number">23</span>,<span class="attr">gender:</span><span class="string">&quot;male&quot;</span>&#125;,</span><br><span class="line">	&#123;<span class="attr">name:</span><span class="string">&quot;rose&quot;</span>,<span class="attr">age:</span><span class="number">23</span>,<span class="attr">gender:</span><span class="string">&quot;male&quot;</span>&#125;,</span><br><span class="line">	&#123;<span class="attr">name:</span><span class="string">&quot;tom&quot;</span>,<span class="attr">age:</span><span class="number">23</span>,<span class="attr">gender:</span><span class="string">&quot;male&quot;</span>&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<ul>
<li>自动生成一个字段_id该字段由ObjectId()生成 可以自己指定</li>
</ul>
<p>insertOne：插入一条数据</p>
<p>insertMany：插入多条数据</p>
<h2 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h2><p>find:查询集合所有文档 可以接收一个文档作为条件参数                  </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.find</span>(&#123;<span class="attribute">name</span>:<span class="string">&quot;bob&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>findOne：查询集合中符合条件的第一个文档 返回的是一个文档替换</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.findOne</span>(&#123;<span class="attribute">name</span>:<span class="string">&quot;bob&quot;</span>&#125;)<span class="selector-class">.name</span></span><br></pre></td></tr></table></figure>

<p>count和length</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.find</span>()<span class="selector-class">.count</span>()</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.find</span>()<span class="selector-class">.length</span>()</span><br></pre></td></tr></table></figure>

<h2 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h2><p>update:第一个参数为查询条件 第二个参数为新替换  默认情况下会使用新替换替换旧替换 如果想只替换指定的属性 需要使用修改操作符$set</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.update</span>(</span><br><span class="line">	&#123;<span class="attribute">name</span>:<span class="string">&quot;bob&quot;</span>&#125;,</span><br><span class="line">	&#123;$<span class="attribute">set</span>:&#123;</span><br><span class="line">		<span class="attribute">name</span>:<span class="string">&quot;bao&quot;</span>,</span><br><span class="line">		<span class="attribute">age</span>:<span class="number">121</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>$unset可以删除指定属性</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.update</span>(</span><br><span class="line">	&#123;<span class="attribute">name</span>:<span class="string">&quot;bao&quot;</span>&#125;,</span><br><span class="line">	&#123;$<span class="attribute">unset</span>:&#123;</span><br><span class="line">		<span class="attribute">age</span>:<span class="number">1</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>updateOne:删除第一个符合条件的文档</p>
<p>updateMany:删除所有符合条件的文档</p>
<p>update默认是只修改一个 如果想修改多个 需要增加属性</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.update</span>(</span><br><span class="line">	&#123;<span class="attribute">name</span>:<span class="string">&quot;bob&quot;</span>&#125;,</span><br><span class="line">	&#123;$<span class="attribute">set</span>:&#123;</span><br><span class="line">		<span class="attribute">name</span>:<span class="string">&quot;bao&quot;</span>,</span><br><span class="line">		<span class="attribute">age</span>:<span class="number">121</span>&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attribute">multi</span>:true</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><p>很少调用删除方法 一般进行逻辑删除</p>
<p>remove:默认删除所有符合条件的文档 如果有第二个参数且为true则只删除一个 如果传入空参则删除所有文档</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.remove</span>(&#123;<span class="attribute">age</span>:<span class="number">121</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>removeOne:删除一个</p>
<p>removeMany:删除多个</p>
<p>db.集合名.drop():删除集合</p>
<p>db.dropDatabase():删除当下的数据库</p>
<h2 id="sort-投影"><a href="#sort-投影" class="headerlink" title="sort 投影"></a>sort 投影</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>(&#123;<span class="attribute">age</span>:<span class="number">1</span>&#125;) <span class="comment">//升序</span></span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>(&#123;<span class="attribute">age</span>:-<span class="number">1</span>&#125;) <span class="comment">//降序</span></span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>(&#123;<span class="attribute">age</span>:<span class="number">1</span>,<span class="attribute">sal</span>:<span class="number">1</span>&#125;) <span class="comment">//按多个条件进行排序</span></span><br></pre></td></tr></table></figure>

<p>find可以传入第二个参数设置查询结果的投影(只显示指定的字段)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.students</span><span class="selector-class">.find</span>(&#123;&#125;,&#123;<span class="attribute">name</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>mongoose是nodeJS提供连接 mongodb的一个库.遵循的是一种, 模板式方法, 能够对你输入的数据进行自动处理</p>
<p>mongoose提供了几个新的对象</p>
<ul>
<li>Schema：定义了约束数据库的文档结构</li>
<li>Model：表示集合中的所有文档，对应collection</li>
<li>Document：表示集合中的具体文档</li>
</ul>
<p>安装:npm i mongoose –save</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入mongoose</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&quot;mongoose&quot;</span>)</span><br><span class="line"><span class="comment">//链接数据库 如果端口是默认端口可以省略</span></span><br><span class="line">mongoose.connect(<span class="string">&quot;mongodb://192.168.52.131/test&quot;</span> )</span><br><span class="line"><span class="comment">//监视连接状态 mongoose.connection.once(&quot;open&quot;,function()&#123;&#125;) , mongoose.connection.once(&quot;close&quot;,function()&#123;&#125;)</span></span><br><span class="line">mongoose.connection.once(<span class="string">&quot;open&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;数据库 链接成功&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//断开数据库</span></span><br><span class="line">mongoose.disconnect()</span><br><span class="line"></span><br><span class="line">mongoose.connection.once(<span class="string">&quot;close&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;数据库 链接断开&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Schema和Model"><a href="#Schema和Model" class="headerlink" title="Schema和Model"></a>Schema和Model</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入mongoose</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&quot;mongoose&quot;</span>)</span><br><span class="line"><span class="comment">//链接数据库 如果端口是默认端口可以省略</span></span><br><span class="line">mongoose.connect(<span class="string">&quot;mongodb://192.168.52.131/test&quot;</span> )</span><br><span class="line"><span class="comment">//创建schema对象</span></span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema</span><br><span class="line"><span class="keyword">const</span> studentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    age: <span class="built_in">Number</span>,</span><br><span class="line">    gender: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">&quot;male&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//创建model:第一个参数是映射的数据库中的集合名,可以将集合名自动变为复数可以是student</span></span><br><span class="line"><span class="keyword">let</span> studentModel = mongoose.model(<span class="string">&quot;students&quot;</span>,studentSchema)</span><br><span class="line"><span class="comment">//操作文档</span></span><br><span class="line">studentModel.create(&#123;<span class="attr">name</span>:<span class="string">&quot;zhao&quot;</span>,<span class="attr">age</span>:<span class="number">12</span>,<span class="attr">gender</span>:<span class="string">&quot;female&quot;</span>&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;插入成功&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="model的方法"><a href="#model的方法" class="headerlink" title="model的方法"></a>model的方法</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><img src="/2020/11/23/MongoDB/image-20201125235035148.png" alt="image-20201125235035148"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询:docs是查询到的集合 project有两种形式(&quot;name -age&quot;),&#123;name:1,age:0&#125;</span></span><br><span class="line"><span class="comment">//skip是跳过几个文档 limit是显示几个文档</span></span><br><span class="line"><span class="comment">//返回一个docs</span></span><br><span class="line">studentModel.find(&#123;<span class="attr">age</span>:<span class="number">23</span>&#125;,<span class="string">&quot;name age&quot;</span>,&#123;<span class="attr">skip</span>:<span class="number">1</span>,<span class="attr">limit</span>:<span class="number">1</span>&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err,docs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(docs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">studentModel.find(<span class="string">&quot;5fbe5d6c575e000016001b71&quot;</span>,<span class="string">&quot;name age&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(doc)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p><img src="/2020/11/23/MongoDB/image-20201126000554126.png" alt="image-20201126000554126"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">studentModel.updateOne(&#123;<span class="attr">name</span>:<span class="string">&quot;zhao&quot;</span>&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="attr">age</span>:<span class="number">100</span>&#125;&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;更新成功&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><img src="/2020/11/23/MongoDB/image-20201126000636656.png" alt="image-20201126000636656"></p>
<p>查询文档数量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">studentModel.count(&#123;&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err,count</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(count)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="document的方法"><a href="#document的方法" class="headerlink" title="document的方法"></a>document的方法</h2><p><img src="/2020/11/23/MongoDB/image-20201126001448733.png" alt="image-20201126001448733"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个document</span></span><br><span class="line"><span class="keyword">let</span> student = <span class="keyword">new</span> studentModel(&#123;</span><br><span class="line">    name:<span class="string">&quot;zhao&quot;</span>,</span><br><span class="line">    age:<span class="number">21</span>,</span><br><span class="line">    gender: <span class="string">&quot;female&quot;</span></span><br><span class="line">&#125;)moku</span><br><span class="line">student.save()</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">studentModel.findOne(&#123;&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="comment">//修改1</span></span><br><span class="line">        doc.update(&#123;<span class="attr">$set</span>:&#123;<span class="attr">age</span>:<span class="number">28</span>&#125;&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;修改成功&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//修改2</span></span><br><span class="line">        doc.age = <span class="number">12</span></span><br><span class="line">        doc.save()</span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        doc.remove(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;删除成功&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>直接使用doc删除属性是删不掉的 需要用toObject转换成对象 在删除</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="meta">doc</span> = <span class="meta">doc</span>.toObject()</span><br><span class="line">delete <span class="meta">doc</span>.age</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>RuoYi</title>
    <url>/2020/11/09/RuoYi/</url>
    <content><![CDATA[<h1 id="Common"><a href="#Common" class="headerlink" title="Common"></a>Common</h1><h2 id="BaseController"><a href="#BaseController" class="headerlink" title="BaseController"></a>BaseController</h2><h3 id="initBinder"><a href="#initBinder" class="headerlink" title="initBinder"></a>initBinder</h3><p>@InitBinder:<a href="https://blog.csdn.net/qq_38016931/article/details/82080940">博客1</a>       <a href="https://www.cnblogs.com/lvbinbin2yujie/p/10459303.html">博客2</a></p>
<h3 id="startPage"><a href="#startPage" class="headerlink" title="startPage"></a>startPage</h3><h2 id="Convert"><a href="#Convert" class="headerlink" title="Convert"></a>Convert</h2><h3 id="toEnum"><a href="#toEnum" class="headerlink" title="toEnum"></a>toEnum</h3><p>isAssignableFrom:<a href="https://blog.csdn.net/qq_36666651/article/details/81215221">博客</a></p>
<h3 id="toStr"><a href="#toStr" class="headerlink" title="toStr"></a>toStr</h3><p>ChatSet:<a href="https://blog.csdn.net/qq_36691683/article/details/81608244?utm_medium=distribute.pc_relevant.none-task-blog-title-2&spm=1001.2101.3001.4242">博客</a></p>
<h2 id="ServletUtils"><a href="#ServletUtils" class="headerlink" title="ServletUtils"></a>ServletUtils</h2><h3 id="getRequestAttributes"><a href="#getRequestAttributes" class="headerlink" title="getRequestAttributes"></a>getRequestAttributes</h3><p>RequestContextHolder:<a href="https://blog.csdn.net/asdfsadfasdfsa/article/details/79158459">博客1</a>,<a href="https://www.jianshu.com/p/3a3dc1c9bf4c">博客2</a></p>
<h3 id="isAjaxRequest"><a href="#isAjaxRequest" class="headerlink" title="isAjaxRequest"></a>isAjaxRequest</h3><p>X-Requested-With:<a href="https://blog.csdn.net/jokeMqc/article/details/78739677">博客</a></p>
<p>规定uri中有xml和json是异步请求</p>
<p><img src="/2020/11/09/RuoYi/image-20201110091906045.png" alt="image-20201110091906045"></p>
<h2 id="StrFormatter"><a href="#StrFormatter" class="headerlink" title="StrFormatter"></a>StrFormatter</h2><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><p>只是大概了解了一下 以后仔细研究这个类的原理</p>
<h2 id="IpUitls"><a href="#IpUitls" class="headerlink" title="IpUitls"></a>IpUitls</h2><h3 id="getIpAddr"><a href="#getIpAddr" class="headerlink" title="getIpAddr"></a>getIpAddr</h3><p>代理http请求获取客户端IP:<a href="https://blog.csdn.net/fengwind1/article/details/51992528">https://blog.csdn.net/fengwind1/article/details/51992528</a></p>
<h2 id="ExcelUitls"><a href="#ExcelUitls" class="headerlink" title="ExcelUitls"></a>ExcelUitls</h2><h3 id="getCellValue"><a href="#getCellValue" class="headerlink" title="getCellValue"></a>getCellValue</h3><p>判断是否为小数 </p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">if ((<span class="name">Double</span>) val % <span class="number">1</span> &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>使用DecimalFormat可以将数字进行格式化 <a href="https://www.cnblogs.com/Small-sunshine/p/11648652.html">参考博客</a></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">DecimalFormat(<span class="string">&quot;0&quot;</span>)</span>.format(<span class="keyword">val</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Generate"><a href="#Generate" class="headerlink" title="Generate"></a>Generate</h1>]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>dubbo</title>
    <url>/2020/10/03/dubbo/</url>
    <content><![CDATA[<p>dubbo是一款RPC框架 </p>
<p><img src="https://bkimg.cdn.bcebos.com/pic/d01373f082025aaf111c708cfbedab64034f1a4e?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5" alt="img"></p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="注册中心zookeeper"><a href="#注册中心zookeeper" class="headerlink" title="注册中心zookeeper"></a>注册中心zookeeper</h2><p>下载zookeeper 解压</p>
<p>conf下的zoo_sample.cfg重命名为zoo.cfg</p>
<p>创建一个data目录 修改配置文件中的dataDir为data目录</p>
<p>bin目录下zkCli.cmd是客户端 zkServer.cmd是服务端 点击启动</p>
<h2 id="管理控制台"><a href="#管理控制台" class="headerlink" title="管理控制台"></a>管理控制台</h2><p>dubbo_admin可以通过可视化界面管理服务</p>
<p>dubbo-admin-0.0.1-SNAPSHOT.jar</p>
<p>在github上下载dubbo-admin压缩包 解压之后是一个maven项目 修改类路径下的application.properties</p>
<p>​    <img src="/2020/10/03/dubbo/image-20201003102539890.png" alt="image-20201003102539890"></p>
<p>在项目路径下 的cmd窗口输入 mvn clean package 清理并打包</p>
<p>运行dubbo-admin-0.0.1-SNAPSHOT包 并访问7001端口（zookeeper服务必须开启） 账号名和密码都是root</p>
<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="Common"><a href="#Common" class="headerlink" title="Common"></a>Common</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化订单</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">initOrder</span><span class="params">(String userId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户服务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 按照用户id返回所有的收货地址</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><p>引入jar包:服务端也相同</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注册中心使用的是zookeeper，引入操作zookeeper的客户端端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">      UserAddress address1 = <span class="keyword">new</span> UserAddress(<span class="number">1</span>, <span class="string">&quot;北京市昌平区宏福科技园综合楼3层&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;李老师&quot;</span>, <span class="string">&quot;010-56253825&quot;</span>, <span class="string">&quot;Y&quot;</span>);</span><br><span class="line">      UserAddress address2 = <span class="keyword">new</span> UserAddress(<span class="number">2</span>, <span class="string">&quot;深圳市宝安区西部硅谷大厦B座3层（深圳分校）&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;王老师&quot;</span>, <span class="string">&quot;010-56253825&quot;</span>, <span class="string">&quot;N&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> Arrays.asList(address1,address2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1、指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;user-service-provider&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2、指定注册中心的位置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">&quot;zookeeper&quot;</span> <span class="attr">address</span>=<span class="string">&quot;127.0.0.1:2181&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:registry</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3、指定通信规则（通信协议？通信端口） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20882&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:protocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 4、暴露服务   ref：指向服务的真正的实现对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.atguigu.gmall.service.UserService&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">ref</span>=<span class="string">&quot;userServiceImpl&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;getUserAddressList&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;1000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--统一设置服务提供方的规则  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">timeout</span>=<span class="string">&quot;1000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:provider</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 服务的实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.gmall.service.impl.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.atguigu.gmall.service.UserService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userServiceImpl02&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;1000&quot;</span> &gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;getUserAddressList&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;1000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userServiceImpl02&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.gmall.service.impl.UserServiceImpl2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 连接监控中心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">&quot;registry&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:monitor</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      ClassPathXmlApplicationContext ioc = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;provider.xml&quot;</span>);</span><br><span class="line">      ioc.start();</span><br><span class="line">      </span><br><span class="line">      System.in.read();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   UserService userService;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">initOrder</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;用户id：&quot;</span>+userId);</span><br><span class="line">      <span class="comment">//1、查询用户的收货地址</span></span><br><span class="line">      List&lt;UserAddress&gt; addressList = userService.getUserAddressList(userId);</span><br><span class="line">      <span class="keyword">for</span> (UserAddress userAddress : addressList) &#123;</span><br><span class="line">         System.out.println(userAddress.getUserAddress());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> addressList;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.gmall.service.impl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;order-service-consumer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:registry</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.atguigu.gmall.service.UserService&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;5000&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;3&quot;</span> <span class="attr">version</span>=<span class="string">&quot;*&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置当前消费者的统一规则：所有的服务都不检查 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:consumer</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;5000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:consumer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">&quot;registry&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:monitor</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="监控中心"><a href="#监控中心" class="headerlink" title="监控中心"></a>监控中心</h1><p>dubbo-monitor-simple-2.0.0</p>
<p>配置文件</p>
<p><img src="/2020/10/03/dubbo/image-20201003144855619.png" alt="image-20201003144855619"></p>
<p>单机bin目录下的start.bat启动 访问8080端口</p>
<p>在消费方 服务方的spring配置文件中配置</p>
<p><img src="/2020/10/03/dubbo/image-20201003144528060.png" alt="image-20201003144528060"></p>
<p><img src="/2020/10/03/dubbo/image-20201003145015126.png" alt="image-20201003145015126"></p>
<h1 id="整合springboot"><a href="#整合springboot" class="headerlink" title="整合springboot"></a>整合springboot</h1><h2 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h2><p>创建boot-provider(普通)和一个boot-consumer(web) 把实现类从上一个项目复制过去 在consumer中创建一个controller</p>
<p><img src="/2020/10/03/dubbo/image-20201003160554779.png" alt="image-20201003160554779"></p>
<p>在provider中添加依赖</p>
<p><img src="/2020/10/03/dubbo/image-20201003160612955.png" alt="image-20201003160612955"></p>
<p>配置</p>
<p><img src="/2020/10/03/dubbo/image-20201003161355501.png" alt="image-20201003161355501"></p>
<p>使用dubbo的@service注解可以暴露服务</p>
<p><img src="/2020/10/03/dubbo/image-20201003161421552.png" alt="image-20201003161421552"></p>
<p>如果启动后出现这个错误  重启zookeeper服务</p>
<p><img src="https://img-blog.csdn.net/20180505100759686?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1OTI2NDkyNjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h2 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h2><p>配置</p>
<p><img src="/2020/10/03/dubbo/image-20201003162151252.png" alt="image-20201003162151252"></p>
<p>使用@Reference</p>
<p><img src="/2020/10/03/dubbo/image-20201003162133422.png" alt="image-20201003162133422"></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/preflight-check.html">官方文档</a></p>
<h2 id="启动时检查"><a href="#启动时检查" class="headerlink" title="启动时检查"></a>启动时检查</h2><p><img src="/2020/10/03/dubbo/image-20201003214740431.png" alt="image-20201003214740431"></p>
<h2 id="超时-amp-配置覆盖关系"><a href="#超时-amp-配置覆盖关系" class="headerlink" title="超时&amp;配置覆盖关系"></a>超时&amp;配置覆盖关系</h2><p>超时配置是timeout 默认是1000ms</p>
<p>不同粒度配置的覆盖关系</p>
<p><img src="/2020/10/03/dubbo/image-20201003215858136.png" alt="image-20201003215858136"></p>
<h2 id="重试次数"><a href="#重试次数" class="headerlink" title="重试次数"></a>重试次数</h2><p>retries 不包含第一次调用 仅在集群的值是故障回复/故障转移时才有效</p>
<p><img src="/2020/10/03/dubbo/image-20201005074539130.png" alt="image-20201005074539130"></p>
<p><img src="/2020/10/03/dubbo/image-20201005074704258.png" alt="image-20201005074704258"></p>
<h2 id="多版本"><a href="#多版本" class="headerlink" title="多版本"></a>多版本</h2><p><img src="/2020/10/03/dubbo/image-20201005075137450.png" alt="image-20201005075137450"></p>
<p>​        * 随机指定版本</p>
<h2 id="本地存根"><a href="#本地存根" class="headerlink" title="本地存根"></a>本地存根</h2><p><img src="/2020/10/03/dubbo/image-20201005080404592.png" alt="image-20201005080404592"></p>
<p><img src="/2020/10/03/dubbo/image-20201005080448146.png" alt="image-20201005080448146"></p>
<p><img src="/2020/10/03/dubbo/image-20201005080500196.png"></p>
<h2 id="与springboot整合的其他方式"><a href="#与springboot整合的其他方式" class="headerlink" title="与springboot整合的其他方式"></a>与springboot整合的其他方式</h2><p>1.之前的方式不能精确到方法配置 可以保留配置文件 在启动类上增加注解<code>@ImportResource(location=&quot;classpath:provider.xml&quot;)</code> </p>
<p>​    这种方式就不需要@Service和 @Reference</p>
<p>2.将每一个组件手动创建到容器中</p>
<p><img src="/2020/10/03/dubbo/image-20201005081447160.png" alt="image-20201005081447160"></p>
<h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><h2 id="zookeeper宕机"><a href="#zookeeper宕机" class="headerlink" title="zookeeper宕机"></a>zookeeper宕机</h2><p>zookeeper注册中心宕机 consumer还可以消费dubbo暴露的服务</p>
<p><img src="/2020/10/03/dubbo/image-20201005082351738.png" alt="image-20201005082351738"></p>
<h2 id="dubbo直连"><a href="#dubbo直连" class="headerlink" title="dubbo直连"></a>dubbo直连</h2><p>没有注册中心依然可以调取服务</p>
<p><img src="/2020/10/03/dubbo/image-20201005082615417.png" alt="image-20201005082615417"></p>
<h2 id="负载均衡机制"><a href="#负载均衡机制" class="headerlink" title="负载均衡机制"></a>负载均衡机制</h2><p>Random LoadBalance（基于权重的随机）:默认方式</p>
<p><img src="/2020/10/03/dubbo/image-20201005082847044.png" alt="image-20201005082847044"></p>
<p>RoundRobin LoadBalance(基于权重的轮询)</p>
<p><img src="/2020/10/03/dubbo/image-20201005082906629.png" alt="image-20201005082906629"></p>
<p>LeastActive LoadBalance：选择耗时最少的provider</p>
<p><img src="/2020/10/03/dubbo/image-20201005083232665.png" alt="image-20201005083232665"></p>
<p>ConsistenHash LoadBalance</p>
<p><img src="/2020/10/03/dubbo/image-20201005083339198.png" alt="image-20201005083339198"></p>
<p>配置</p>
<p><img src="/2020/10/03/dubbo/image-20201005083836390.png" alt="image-20201005083836390"></p>
<p><img src="/2020/10/03/dubbo/image-20201005083845336.png" alt="image-20201005083845336"></p>
<h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>什么是服务降级？</p>
<p><img src="/2020/10/03/dubbo/image-20201005093234276.png" alt="image-20201005093234276"></p>
<p>降级规则有一下两种规则：屏蔽和容错</p>
<p><img src="/2020/10/03/dubbo/image-20201005093326087.png" alt="image-20201005093326087"></p>
<p>zookeeper的消费者配置的屏蔽和容错设置分别对应上面的两个降级规则</p>
<p><img src="/2020/10/03/dubbo/image-20201005093336789.png" alt="image-20201005093336789"></p>
<h2 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h2><p>集群容错模式</p>
<p><img src="/2020/10/03/dubbo/image-20201005093731718.png" alt="image-20201005093731718"></p>
<p>设置：默认是failfast</p>
<p><img src="/2020/10/03/dubbo/image-20201005093817312.png" alt="image-20201005093817312"></p>
<h3 id="整合hystrix"><a href="#整合hystrix" class="headerlink" title="整合hystrix"></a>整合hystrix</h3><p><img src="/2020/10/03/dubbo/image-20201005094012294.png" alt="image-20201005094012294"></p>
<p>导入jar包 在主启动类上开启Hystrix<br>`<dependency><br>    <groupId>org.springframework.cloud</groupId><br>    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId><br>    <version>2.2.2.RELEASE</version></dependency></p>
<p>在provider方法上增加@HystrixCommand </p>
<p><img src="/2020/10/03/dubbo/image-20201005100352842.png" alt="image-20201005100352842"></p>
<p>在consumer上增加@HystrixCommand(fallbackMethod = “hello”)</p>
<p><img src="/2020/10/03/dubbo/image-20201005100816469.png" alt="image-20201005100816469"></p>
<p>出错后会调用hello方法</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客无法显示图片解决方法</title>
    <url>/2020/09/29/hexo%E5%8D%9A%E5%AE%A2%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>安装hexo-asset-image <code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></p>
<p>安装后 用hexo创建文章就会多出一个同名文件夹 把图片放在这个文件夹中 使用 <code>![](同名文件夹/logo.jpg) </code>就可以插入图片 </p>
]]></content>
      <categories>
        <category>bug</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>idea-debug</title>
    <url>/2020/10/06/idea-debug/</url>
    <content><![CDATA[<p>项目：debug_demo</p>
<h4 id="01-Debug简介和意义"><a href="#01-Debug简介和意义" class="headerlink" title="01_Debug简介和意义"></a>01_Debug简介和意义</h4><ul>
<li><p>什么是程序DeBug？</p>
<ul>
<li><p>Debug，是程序开发人员必会的一项调试程序的技能。</p>
</li>
<li><p>企业中程序开发和程序调试的比例为1:1.5，可以说如果你不会调试程序，你就没有办法从事编程工作。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>Debug能帮助我们做什么？<ol>
<li>追踪代码的运行流程。</li>
<li>程序运行异常定位。</li>
<li>线上问题追踪。</li>
</ol>
</li>
</ul>
<ul>
<li><p>Debug对于程序学习者的意义</p>
<ol>
<li>通过调试能够更好的查看程序的执行流程。</li>
<li>复杂的程序逻辑，通过老师的口述讲解，很难理解清楚，这个时候借助调试能够很好的帮助同学们理解程序。</li>
<li>定位问题，提高自我解决问题的能力。</li>
</ol>
</li>
</ul>
<h4 id="02-IDEA中的Debug步骤"><a href="#02-IDEA中的Debug步骤" class="headerlink" title="02_IDEA中的Debug步骤"></a>02_IDEA中的Debug步骤</h4><ul>
<li><p>设置断点（F9）</p>
</li>
<li><p>调试程序（8个按钮）</p>
<p><img src="/2020/10/06/idea-debug/2019-09-28_162216.jpg"></p>
<table>
<thead>
<tr>
<th>按钮</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/2020/10/06/idea-debug/2019-09-28_163744.jpg"></td>
<td>(Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行</td>
</tr>
<tr>
<td><img src="/2020/10/06/idea-debug/2019-09-28_164022.jpg"></td>
<td>(F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。</td>
</tr>
<tr>
<td><img src="/2020/10/06/idea-debug/2019-09-28_162345.jpg?lastModify=1569659273?lastModify=1569659273" alt="img"></td>
<td>(F7)：步入。如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法。</td>
</tr>
<tr>
<td><img src="/2020/10/06/idea-debug/2019-09-28_164200.jpg"></td>
<td>(Alt + Shift + F7)：强       制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。</td>
</tr>
<tr>
<td><img src="/2020/10/06/idea-debug/2019-09-28_164215.jpg"></td>
<td>(Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。</td>
</tr>
<tr>
<td><img src="/2020/10/06/idea-debug/2019-09-28_164428.jpg"></td>
<td>回退断点。</td>
</tr>
<tr>
<td><img src="/2020/10/06/idea-debug/2019-09-28_164418.jpg"></td>
<td>(Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。</td>
</tr>
<tr>
<td><img src="/2020/10/06/idea-debug/2019-09-28_164437.jpg"></td>
<td>(Alt + F8)：计算表达式。</td>
</tr>
</tbody></table>
</li>
<li><p>观察变量</p>
<ul>
<li>查看变量有三种方式：<ul>
<li>程序区查看变量</li>
<li>Debugger的Variables中查看变量</li>
<li>鼠标悬停到变量名上会弹出当前变量的值</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/06/idea-debug/2019-09-28_165050.jpg"></p>
</li>
<li><p>查看输出</p>
</li>
</ul>
<h4 id="03-跳转到当前代码执行的行"><a href="#03-跳转到当前代码执行的行" class="headerlink" title="03_跳转到当前代码执行的行"></a>03_跳转到当前代码执行的行</h4><ul>
<li><p>跳转到当前代码执行的行（Alt + F10）<img src="/2020/10/06/idea-debug/debug/images/2019-09-28_163744.jpg"></p>
</li>
<li><p>作用</p>
<ul>
<li>使程序窗口切换到当前正在运行的程序处。</li>
</ul>
</li>
</ul>
<h4 id="04-步过调试的使用"><a href="#04-步过调试的使用" class="headerlink" title="04_步过调试的使用"></a>04_步过调试的使用</h4><ul>
<li>步过调试<ul>
<li>步过调试按钮（F8）<img src="/2020/10/06/idea-debug/2019-09-28_164022.jpg"></li>
</ul>
</li>
<li>作用<ul>
<li>步过，一行一行地往下走，如果这一行上有方法不会进入方法。</li>
<li>常用于调试过程中不想进入调用的方法体的情况。</li>
</ul>
</li>
</ul>
<h4 id="05-步入调试的使用"><a href="#05-步入调试的使用" class="headerlink" title="05_步入调试的使用"></a>05_步入调试的使用</h4><ul>
<li><p>步入调试</p>
<ul>
<li>步过调试按钮（F7）<img src="/2020/10/06/idea-debug/2019-09-28_162345.jpg"></li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li><p>步入，一行一行地往下走，如果这一行上有方法，则进入方法内部。</p>
</li>
<li><p>一般用于进入自定义方法内，不会进入官方类库的方法。</p>
</li>
</ul>
</li>
</ul>
<h4 id="06-强制步入调试的使用"><a href="#06-强制步入调试的使用" class="headerlink" title="06_强制步入调试的使用"></a>06_强制步入调试的使用</h4><ul>
<li><p>强制步入调试</p>
<ul>
<li>强制步入调试按钮（Alt + Shift + F7）<img src="/2020/10/06/idea-debug/debug/images/2019-09-28_164200.jpg"></li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li><p>进入官方类库方法</p>
</li>
<li><p>帮助我们学习和查看JDK源码</p>
</li>
</ul>
</li>
</ul>
<h4 id="07-步出调试的使用"><a href="#07-步出调试的使用" class="headerlink" title="07_步出调试的使用"></a>07_步出调试的使用</h4><ul>
<li><p>步出调试</p>
<ul>
<li>步出调试按钮（Shift + F8）<img src="/2020/10/06/idea-debug/2019-09-28_164215.jpg"></li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>从方法内退出到方法调用处。</li>
<li>调试的时候，有时候会跳入到自己不想查看的方法体，这个时候使用步出。</li>
</ul>
</li>
</ul>
<h4 id="08-回退断点调试的使用"><a href="#08-回退断点调试的使用" class="headerlink" title="08_回退断点调试的使用"></a>08_回退断点调试的使用</h4><ul>
<li><p>回退断点</p>
<ul>
<li>回退断点按钮 <img src="/2020/10/06/idea-debug/2019-09-28_164428.jpg"></li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li><p>回退到当前方法的调用处。</p>
</li>
<li><p>当想重新查看该方法体的执行过程时，不用重新启动Debug，可以使用回退断点方式。</p>
</li>
</ul>
</li>
</ul>
<h4 id="09-运行到光标处"><a href="#09-运行到光标处" class="headerlink" title="09_运行到光标处"></a>09_运行到光标处</h4><ul>
<li>运行到光标处<ul>
<li>运行光标处按钮 （F9）<img src="/2020/10/06/idea-debug/2019-09-28_164418.jpg"></li>
<li>作用<ul>
<li>使程序运行到光标处，而无需设置断点。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="10-计算表达式"><a href="#10-计算表达式" class="headerlink" title="10_计算表达式"></a>10_计算表达式</h4><ul>
<li><p>计算表达式</p>
<ul>
<li><p>计算表达式按钮（Alt + F8）<img src="/2020/10/06/idea-debug/2019-09-28_164437.jpg"></p>
<p><img src="/2020/10/06/idea-debug/2019-10-03_182159.jpg"></p>
</li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>设置变量，在计算表达式的框里，可以改变变量的值，这样有时候就能很方便我们去调试各种值的情况了。 </li>
</ul>
</li>
</ul>
<h4 id="11-条件断点"><a href="#11-条件断点" class="headerlink" title="11_条件断点"></a>11_条件断点</h4><ul>
<li><p>条件断点</p>
<ul>
<li><p>右键单击断点处，可以设置进入断点的条件</p>
<p><img src="/2020/10/06/idea-debug/2019-10-03_182101.jpg"></p>
</li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。</li>
</ul>
</li>
</ul>
<h4 id="12-多线程调试"><a href="#12-多线程调试" class="headerlink" title="12_多线程调试"></a>12_多线程调试</h4><ul>
<li><p>步骤</p>
<ul>
<li><p>多线程调试，需要调整断点挂起级别为Thread</p>
<p><img src="/2020/10/06/idea-debug/2019-10-05_164127.jpg"></p>
</li>
<li><p>Frame中选择线程进行调试</p>
</li>
</ul>
</li>
</ul>
<h4 id="13-其他调试功能"><a href="#13-其他调试功能" class="headerlink" title="13_其他调试功能"></a>13_其他调试功能</h4><p><img src="/2020/10/06/idea-debug/image-20201006203423905.png" alt="image-20201006203423905"></p>
]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode</title>
    <url>/2020/12/28/leetcode/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(x))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(x),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h2><p>参考答案：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/</a></p>
<p>解法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> m = nums2.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = n + m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> aStart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bStart = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= sum / <span class="number">2</span>;i++)&#123;</span><br><span class="line">            left = right;</span><br><span class="line">            <span class="keyword">if</span>(aStart &lt; n &amp;&amp; (bStart &gt;= m || nums1[aStart] &lt; nums2[bStart]))&#123;</span><br><span class="line">                right = nums1[aStart++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = nums2[bStart++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            ans = (left + right) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解法二：使用二分法 假设我们要找第 <code>k</code> 小数，我们可以每次循环排除掉 <code>k/2</code> 个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums1.length;</span><br><span class="line">    <span class="keyword">int</span> m = nums2.length;</span><br><span class="line">    <span class="keyword">int</span> left = (n + m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> right = (n + m + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。</span></span><br><span class="line">    <span class="keyword">return</span> (getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, left) + getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, right)) * <span class="number">0.5</span>;  </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = end1 - start1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = end2 - start2 + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1 </span></span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> getKth(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = start1 + Math.min(len1, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = start2 + Math.min(len2, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h2><p>参考答案：<a href="https://leetcode-cn.com/problems/container-with-most-water/solution/container-with-most-water-shuang-zhi-zhen-fa-yi-do/">https://leetcode-cn.com/problems/container-with-most-water/solution/container-with-most-water-shuang-zhi-zhen-fa-yi-do/</a></p>
<p>消除状态：每次都移动较短的板 水槽面积才可能变大 若移动长板 下个水槽的面积一定小于当前水槽面积。所以无论是移动短板或者长板，我们都只关注移动后的新短板会不会变长，而每次移动的木板都只有三种情况，比原短板短，比原短板长，与原短板相等；如向内移动长板，对于新的木板：1.比原短板短，则新短板更短。2.与原短板相等或者比原短板长，则新短板不变。所以，向内移动长板，一定不能使新短板变长。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> j = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            res = height[i] &gt; height[j] ? Math.max(res,(j - i) * height[j--]) : Math.max(res, (j - i) * height[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h2><p>参考答案：<a href="https://leetcode-cn.com/problems/3sum/solution/3sumpai-xu-shuang-zhi-zhen-yi-dong-by-jyd/">https://leetcode-cn.com/problems/3sum/solution/3sumpai-xu-shuang-zhi-zhen-yi-dong-by-jyd/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">      Arrays.sort(nums);</span><br><span class="line">      List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">//固定 3 个指针中最左（最小）数字的指针 k，双指针 i，j 分设在数组索引 (k, len(nums)) 两端，通过双指针交替向中间移动，记录对于每个固定指针 k 的所有满足 nums[k] + nums[i] + nums[j] == 0 的 i,j 组合：</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;nums.length - <span class="number">2</span>;k++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(nums[k] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">//防止重复</span></span><br><span class="line">          <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">int</span> i = k + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">              <span class="keyword">int</span> sum = nums[i] + nums[k] + nums[j];</span><br><span class="line">              <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                  <span class="comment">//防止重复</span></span><br><span class="line">                  <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);</span><br><span class="line">              &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                  <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(nums[i],nums[j],nums[k])));</span><br><span class="line">                  <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);</span><br><span class="line">                  <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)</p>
<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h2><p>参考答案：官方解题</p>
<p>以排列 [4,5,2,6,3,1][4,5,2,6,3,1] 为例：</p>
<p>我们能找到的符合条件的一对「较小数」与「较大数」的组合为 22 与 33，满足「较小数」尽量靠右，而「较大数」尽可能小。</p>
<p>当我们完成交换后排列变为 [4,5,3,6,2,1][4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6][4,5,3,1,2,6]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//如果是倒序的数组 i的值为-1 直接reserve</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;   </span><br><span class="line">            swap(nums ,i ,j);</span><br><span class="line">        &#125;</span><br><span class="line">        reserve(nums, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i ,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reserve</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            swap(nums,i++,j--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><p>参考答案：官方解题</p>
<p>有序数组就考虑使用二分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">//如果左面是有序的</span></span><br><span class="line">            <span class="comment">//为什么是&lt;=:(l+r)/2是把小数部分都省去了的结果，因此当l=0,r=1时会出现l==(l+r)/2。nums[left]&lt;nums[mid]，虽然可以判断出mid左边是升序的，但当mid=0时，就会到了else中，而else中mid右边有序的，不可能成立，所以要在这个位置加个等号。</span></span><br><span class="line">            <span class="keyword">if</span>(nums[left] &lt;= nums[mid])&#123;</span><br><span class="line">                <span class="comment">//如果target在这个范围内</span></span><br><span class="line">                <span class="keyword">if</span>(nums[left] &lt;= target&amp;&amp;nums[mid] &gt;= target)&#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//如果右面是有序的</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt;= target &amp;&amp; nums[right] &gt;= target)&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right = mid -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><p>参考解题：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/</a></p>
<p>参考博客：<a href="https://www.zhihu.com/question/36132386/answer/712269942">https://www.zhihu.com/question/36132386/answer/712269942</a></p>
<p>​                   <a href="https://leetcode-cn.com/leetbook/read/learning-algorithms-with-leetcode/xs41qg/">https://leetcode-cn.com/leetbook/read/learning-algorithms-with-leetcode/xs41qg/</a></p>
<p>​                   <a href="https://blog.csdn.net/shaomingmin/article/details/105901635">https://blog.csdn.net/shaomingmin/article/details/105901635</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> firstPosition = FirstPosition(nums,target);</span><br><span class="line">        <span class="keyword">if</span>(firstPosition == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastPosition = LastPosition(nums,target);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;firstPosition,lastPosition&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">FirstPosition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//因为是闭区间且循环终止条件是 `&lt;` 所以nums[left]被漏掉 需要做一次特殊判断</span></span><br><span class="line">        <span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">LastPosition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt;target) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left-<span class="number">1</span>] == target ? left-<span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FindLastPosition方法中需要上取整的原因</p>
<p><img src="/2020/12/28/leetcode/log\source_posts\leetcode\image-20210104141114097.png" alt="image-20210104141114097"></p>
<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h2><p>参考解题：<a href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/</a></p>
<p>代码1：无剪枝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        dfs(candidates,target,<span class="number">0</span>,len,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> begin,<span class="keyword">int</span> len,Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin;i &lt; len;i++)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            <span class="comment">//数组元素可以重复使用所以begin还是i</span></span><br><span class="line">            dfs(candidates,target-candidates[i],i,len,path,res);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剪枝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//剪枝的前提是排序</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        dfs(candidates,target,<span class="number">0</span>,len,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> begin,<span class="keyword">int</span> len,Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="comment">//目标值比当前数组值小 则进行剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(target &lt; candidates[i])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            dfs(candidates,target-candidates[i],i,len,path,res);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a></h2><p>参考解题；<a href="https://leetcode-cn.com/problems/rotate-image/solution/ji-qiao-ti-zai-zeng-song-yi-wei-xing-shi-377z/">https://leetcode-cn.com/problems/rotate-image/solution/ji-qiao-ti-zai-zeng-song-yi-wei-xing-shi-377z/</a></p>
<p>答案中拓展了一维数组旋转的方法</p>
<p><img src="/2020/12/28/leetcode/log\source_posts\leetcode\image-20210106135604308.png" alt="image-20210106135604308"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; mid;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][n - <span class="number">1</span> - j];</span><br><span class="line">                matrix[i][n - <span class="number">1</span> - j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a></h2><p>参考答案：<a href="https://leetcode-cn.com/problems/maximum-subarray/solution/hua-jie-suan-fa-53-zui-da-zi-xu-he-by-guanpengchn/">https://leetcode-cn.com/problems/maximum-subarray/solution/hua-jie-suan-fa-53-zui-da-zi-xu-he-by-guanpengchn/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sum += num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum = num;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h2><p>参考解题：<a href="https://leetcode-cn.com/problems/jump-game/solution/55-by-ikaruga/">https://leetcode-cn.com/problems/jump-game/solution/55-by-ikaruga/</a></p>
<ol>
<li>如果某一个作为 <strong>起跳点</strong> 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 <strong>起跳点</strong>。</li>
<li>可以对每一个能作为 <strong>起跳点</strong> 的格子都尝试跳一次，把 <strong>能跳到最远的距离</strong> 不断更新。</li>
<li>如果可以一直跳到最后，就成功了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; i) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k = Math.max(k,nums[i] + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a></h2><p>tag:数组，排序</p>
<p>参考答案：<a href="https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/">https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        Arrays.sort(intervals,<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; merged = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = intervals[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(merged.size() == <span class="number">0</span> || merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] &lt; left)&#123;</span><br><span class="line">                merged.add(intervals[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(right,merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[merged.size()][]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h2><p>参考答案：<a href="https://leetcode-cn.com/problems/unique-paths/solution/dong-tai-gui-hua-by-powcai-2/">https://leetcode-cn.com/problems/unique-paths/solution/dong-tai-gui-hua-by-powcai-2/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(arr,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                arr[j] += arr[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h2><p>归并排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortInList</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用快慢指针把链表一分为二</span></span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newList = slow.next;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    ListNode left = sortInList(head);</span><br><span class="line">    ListNode right = sortInList(newList);</span><br><span class="line">    ListNode lhead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode res= lhead;</span><br><span class="line">    <span class="keyword">while</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left.val &lt; right.val)&#123;</span><br><span class="line">            lhead.next = left;</span><br><span class="line">            left = left.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            lhead.next = right;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        lhead = lhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    lhead.next = left != <span class="keyword">null</span>? left:right;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈和排序"><a href="#栈和排序" class="headerlink" title="栈和排序"></a>栈和排序</h2><p><img src="/2020/12/28/leetcode/log\source_posts\leetcode\image-20210304082245336.png" alt="image-20210304082245336"></p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210205/9980465_1612514040325/CD16117538EE2394B4BF8476B630C8D8" alt="图片说明"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] solve (<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">boolean</span> [] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">10</span>];</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; a.length;i++)&#123;     <span class="comment">//此处不能用n 循环内会改变n</span></span><br><span class="line">        stack.push(a[i]);</span><br><span class="line">        vis[a[i]] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span> &amp;&amp; vis[n]) n--;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; n &lt;= stack.peek())&#123;</span><br><span class="line">            res[index++] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        res[index++] = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大数"><a href="#最大数" class="headerlink" title="最大数"></a>最大数</h2><p><img src="/2020/12/28/leetcode/log\source_posts\leetcode\image-20210304083606985.png" alt="image-20210304083606985"></p>
<p><img src="https://uploadfiles.nowcoder.com/images/20201217/9980465_1608181272700/31F22EFF4011B9068F5C9D00BB183892" alt="图片说明"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        list.add(String.valueOf(num));</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (o2+o1).compareTo(o1+o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(list.get(<span class="number">0</span>).equals(<span class="string">&quot;0&quot;</span>)) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">        res.append(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a><a href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a></h2><p><img src="/2020/12/28/leetcode/log\source_posts\leetcode\image-20210314083637948.png" alt="image-20210314083637948"></p>
<p>动态规划+位运算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">int</span> hightBit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= num;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">            hightBit = i;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = res[i - hightBit] + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：0～3 是两位，分别是00，01，10，10，11，然后 4 到 7 是三位，分别是100，101，110，111，这不就是前面多了个 1 嘛！ 直接相加就可以了</p>
]]></content>
      <categories>
        <category>错题本</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql笔记</title>
    <url>/2021/02/02/mysql%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>常用命令</p>
<ul>
<li><p>显示数据库 show databases ; </p>
</li>
<li><p>显示表：1)show tables; 2) show table from test;</p>
</li>
<li><p>当前所在的库：select database();</p>
</li>
<li><p>查看表的属性 desc tableName;</p>
</li>
<li><p>查看mysql版本 1)select version(); 2)在cmd输入mysql –version</p>
</li>
<li><p>注释 # ，– (后面要加一个空格)，/* */</p>
</li>
</ul>
<p>起别名用<strong>AS</strong> 且AS可以省略</p>
<p>truncate 清空数据 :truncate table user</p>
<p>auto_increment要搭配key（主键 唯一 外键等）使用 且一个表中只能有一个标识列且类型是数字</p>
<p><strong>DISTINCT</strong>去重</p>
<p><strong>+号</strong>的作用</p>
<ul>
<li>select 100+90 做加法操作</li>
<li>select ‘12’ + 90 把字符串转换为整数做加法操作 如果转换失败字符串值为0</li>
<li>select null + 21 结果为null</li>
</ul>
<p><strong>逻辑运算符</strong>：and,or,not</p>
<p><strong>分页查询limit（m,n）m是初始索引 n是要显示的条目个数 limit放在查询语句的最后</strong></p>
<p>**安全等于&lt;=&gt;**：可以判断null和数值 </p>
<ul>
<li>select 2 &lt;=&gt; null 结果为 0</li>
<li>select 2 = null 结果为空</li>
<li>select null &lt;=&gt; null结果为1</li>
</ul>
<p><strong>ORDER BY</strong> 【asc | desc】默认是asc ：select * from user order by salary desc</p>
<p><strong>IFNULL</strong>：如果不是null显示第一个参数 是null显示第二个参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select ifnull(commission_pct,0),commission_pct from employees</span><br></pre></td></tr></table></figure>

<h1 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a><strong>模糊查询</strong></h1><p><strong>LIKE</strong>：% 匹配任意多个字符 包含0个字符，_ 匹配一个或一个以上字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询第三个字母为e第五个字母为a的员工名 不区分大小写</span><br><span class="line">select last_name from employees where last_name like &#39;__e_a%&#39;;</span><br><span class="line">#查询第二个字符为_的员工名</span><br><span class="line">select last_name from employees where last_name like &#39;_\_%&#39;;</span><br></pre></td></tr></table></figure>

<p><strong>BETWEEN</strong>：between a and b 包含临界值a和b</p>
<p><strong>IN</strong>：in列表中的值必须是互相兼容的且不能使用%</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select last_name,job_id from employees where job_id in(&#39;IT_PORT&#39;,&#39;AD_VP&#39;,&#39;AD_PRES&#39;)</span><br></pre></td></tr></table></figure>

<p><strong>IS NULL</strong>和<strong>IS NOT NULL</strong>：select * from user where id is null</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h2><h3 id="字母函数"><a href="#字母函数" class="headerlink" title="字母函数"></a>字母函数</h3><p>Length 获取参数值的字节个数 SELECT length(1232)</p>
<p>concat拼接字符串：select concat(id,’-‘,name) from user;</p>
<p>Upper ,Lowwer</p>
<p>substr:下标从1开始 包含开始位置和结束位置 一个汉字是一个符文为两个字节或三个字节</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select substr(&#39;today is a good day&#39;,7,2); #第三个参数可以省略</span><br></pre></td></tr></table></figure>

<p>insrt（A，B） : 返回子串B在主串A中第一次出现的起始索引 找不到返回0</p>
<p>trim , ltirm, rtirm 去掉空格 trim(x from b)去掉b首位出现的x</p>
<p>​           <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image006.png" alt="img"></p>
<p>lpad和rpad</p>
<p>​           <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image008.png" alt="img"></p>
<p>replace</p>
<p>​           <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image010.png" alt="img"></p>
<h3 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h3><p>round 四舍五入</p>
<p>​           <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612253586742.png" alt="img"></p>
<p>ceil向上取整 floor向下取整</p>
<p>truncate 截断：第二个参数是小数点后的位数</p>
<p>​           <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image004-1612253586743.png" alt="img"></p>
<p>mod取余 公式为：a-a/b*b</p>
<h2 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h2><p>IF：<code>select if(10 &gt; 5,true,false)</code></p>
<p>CASE</p>
<ul>
<li><pre><code class="mysql">select salary,department_id,
case department_id
when 30 then salary * 1.1
when 40 then salary * 1.2
when 50 then salary * 1.3
else salary 
end as newSalary
from employees
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* ```mysql</span><br><span class="line">  <span class="keyword">select</span> salary,</span><br><span class="line">  <span class="keyword">case</span></span><br><span class="line">  <span class="keyword">when</span> salary &gt; <span class="number">20000</span> <span class="keyword">then</span> <span class="comment">&#x27;a&#x27;</span></span><br><span class="line">  <span class="keyword">when</span> salary &gt; <span class="number">15000</span> <span class="keyword">then</span> <span class="comment">&#x27;b&#x27;</span></span><br><span class="line">  <span class="keyword">when</span> salary &gt; <span class="number">10000</span> <span class="keyword">then</span> <span class="comment">&#x27;c&#x27;</span></span><br><span class="line">  <span class="keyword">else</span> <span class="comment">&#x27;d&#x27;</span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">as</span> salaryLevel</span><br><span class="line">  <span class="keyword">from</span> employees</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>sum avg max min count 忽略null值 可以和distinct搭配 sum (distinct salary)</p>
<h1 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h1><p>查询列表必须是分组函数或group by后出现的字段</p>
<p>查询有奖金的每个领导手下的员工的最高工资 且最高工资大于12000</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select max(salary),manager_id from employees where commission_pct !&#x3D; null group by manager_id having max(salary) &gt; 12000 #having对分组后的结果进行筛选</span><br></pre></td></tr></table></figure>

<p>查询每个部门每个工种的员工的平均工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select avg(salary),departmeng_id,job_id from employees group by department_id,job_id;</span><br></pre></td></tr></table></figure>

<h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p>inner可以省略</p>
<p><strong>等值查询</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询名字中包含e的员工名和工种名 </span><br><span class="line">select last_name,job_title from employees e inner join jobs j on e.job_id &#x3D; j.job_id where e.last_name like &#39;%e%&#39;</span><br></pre></td></tr></table></figure>

<p><strong>非等值连接</strong></p>
<p><strong>自连接</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select e.last_name,m.last_name from employees e inner join employees m on e.manager_id &#x3D; m.manager_id</span><br></pre></td></tr></table></figure>

<h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a><strong>外连接</strong></h2><p>查询结果为主表的全部记录 左外连接中left左边的是主表</p>
<p><strong>左外连接</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select b.name,bo.* from beauty b left outer join boys bo on b.boyfrientd_id &#x3D; bo.id</span><br></pre></td></tr></table></figure>

<p><strong>右外连接</strong></p>
<p><strong>全外连接</strong>：全外连接=左表全部记录+右表全部记录+相关联结果=左外连接+右外连接-相关联结果（即去重复）</p>
<p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。</p>
<p>可以使用union操作符实现全外连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM emp e LEFT JOIN dept d ON e.deptno&#x3D;d.deptno</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM emp e RIGHT JOIN dept d ON e.deptno&#x3D;d.deptno;</span><br></pre></td></tr></table></figure>

<p><strong>内连接和外连接的区别</strong></p>
<p>内连接：取出两张表中匹配到的数据，匹配不到的不保留</p>
<p>外连接：取出连接表中匹配到的数据，匹配不到的也会保留，其值为NULL</p>
<h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>按子查询的位置可分为</p>
<ul>
<li>select后面：仅支持标量子查询</li>
<li>from后面：支持表子查询</li>
<li>where或having后面：标量子查询，列子查询，行子查询</li>
<li>exits后面：表子查询</li>
</ul>
<p>按结果集的行列数不同可分为</p>
<ul>
<li>标量子查询：结果集只有一行一列</li>
<li>行子查询：结果集中有一行多列</li>
<li>列子查询：结果集中有一列多行</li>
<li>表子查询：结果集中有多行多列</li>
</ul>
<p>where后面的标量子查询where后面的行子查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询员工编号最小并且工资最高的员工信息</span><br><span class="line">select * from employees where (employee_id,salary)&#x3D;(select MIN(employee_id),MAX(salary) from employees)</span><br></pre></td></tr></table></figure>

<p>where后面的列子查询：使用多行比较操作符 in,not in,any/some,all</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询location_id是1400或1700的部门编号</span><br><span class="line">select distinct department_id from departments where location_id in(1400,1700)</span><br><span class="line">#查询员工姓名，要求部门号是上面查询结果列表中的某一个</span><br><span class="line">select last_name from employees where department_id in(select distinct department_id from departments where location_id in(1400,1700))</span><br></pre></td></tr></table></figure>

<p>having后面的标量子查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询最低工资大于50号部门最低工资的部门id和其最低工资</span><br><span class="line">#先查询50号部门的最低工资</span><br><span class="line">select min(salary) from employees where department_id &#x3D; 50</span><br><span class="line">#再查询每个部门的最低工资</span><br><span class="line">select min(salary),department_id from employees group by department_id</span><br><span class="line">#总查询</span><br><span class="line">select min(salary),department_id from employees group by department_id having MIN(salary) &gt; (select MIN(salary) from employees where department_id &#x3D; 50)</span><br></pre></td></tr></table></figure>

<p>select后面的子查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询每个部门的员工个数</span><br><span class="line">select d.*,(select count(*) from employee e where e.department_id &#x3D; d.department_id ) as count from departments d</span><br></pre></td></tr></table></figure>

<p>from后面的子查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询每个部门的平均工资的工资等级</span><br><span class="line">select AVG(salary),department_id from employees group by department_id</span><br><span class="line">#连接上面的结果集和job_grades表 筛选条件平均工资 between lowest_sal and highest_sal</span><br><span class="line">select ag_dep.*,g.grade_level from(select AVG(salaru) ag.department_id from employees group by department_id) ag_dep inner join job_grades g on ag_dep.ag between lowest_sal and hisgest_sal</span><br></pre></td></tr></table></figure>

<p>exit后面的子查询：<code>select exists(select employee_id from employees where salary = 3000) #结果0或1</code></p>
<h1 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h1><p><strong>INSERT</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方法一</span><br><span class="line">insert into study(id,name,sex) values(12,&#39;bob&#39;,&#39;male&#39;)；</span><br><span class="line">insert into study values(12,&#39;bob&#39;,null);</span><br><span class="line">#方法二</span><br><span class="line">insert into study set id &#x3D; 1,name &#x3D; &#39;bob&#39;,sex &#x3D; &#39;male&#39;;</span><br><span class="line">#方法一支持同时插入多行和子查询</span><br></pre></td></tr></table></figure>

<p><strong>UPDATE</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#修改单表</span><br><span class="line">update user set name &#x3D; &#39;bob&#39; where name &#x3D; &#39;zhangsan&#39;</span><br><span class="line">#修改多表:修改bob的女朋友的手机号为114</span><br><span class="line">update boys bo inner join beauty b on bo.id &#x3D; b.boyfriend_id set b.phone &#x3D; 114 where bo.boyName &#x3D; &#39;bob&#39;</span><br></pre></td></tr></table></figure>

<p><strong>DELETE</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#单表删除</span><br><span class="line">delete from user where id &#x3D; 1;</span><br><span class="line">#多表删除：删除bob以及他女朋友的信息</span><br><span class="line">delete b,bo from beauty b inner join boys bo on b.boyfriend_id &#x3D; bo.id where bo.boyName &#x3D; &#39;bob&#39;</span><br></pre></td></tr></table></figure>

<p>delete和truncate的区别：如果表中有自增长的列 delete删除后自增长的列值从断点开始而truncate从0开始。truncate没有返回值不能回滚 delete有返回值能回滚</p>
<h1 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h1><p><strong>库的管理</strong></p>
<ul>
<li><p>创建数据库 Create databases (if not exists) mydata;</p>
</li>
<li><p>更改库的字符集 alter database mydata character set utf8</p>
</li>
<li><p>删除库 drop database (if exists) mydata;</p>
</li>
</ul>
<p><strong>表的管理</strong></p>
<p>表的创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table user(id int,name varchar(20),sex varchar(8));</span><br></pre></td></tr></table></figure>

<p>表的修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#修改列名，必须要带上类型</span><br><span class="line">alter table user change column id newId int;</span><br><span class="line">#修改列的类型或约束</span><br><span class="line">alter table user modify column name char;</span><br><span class="line">#添加新列</span><br><span class="line">alter table user add column hobby varchar(20);</span><br><span class="line">#删除列</span><br><span class="line">alter table user drop column hobby;</span><br><span class="line">#修改表名</span><br><span class="line">alter table user rename to users;</span><br><span class="line">#删除表</span><br><span class="line">drop table (if exists) user;</span><br></pre></td></tr></table></figure>

<p>表的复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#仅复制表的结构</span><br><span class="line">create table myCopy like user;</span><br><span class="line">#复制表的结构和数据</span><br><span class="line">create  table myCopy select * from user;</span><br><span class="line">#只复制一部分数据 全部结构</span><br><span class="line">create  table myCopy select id,name from user where name &#x3D; ‘bob’;</span><br><span class="line">#仅复制某些字段</span><br><span class="line">create  table myCopy select id,name from user where 0;</span><br></pre></td></tr></table></figure>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>整型：Tinyint(1字节)  Smallint（2字节） Mediumint（3字节） Int ，integer（四字节） Bigint（8字节）后面加unsigned表示无符号</p>
<p>小数</p>
<ul>
<li><p>浮点数 ：float(4byte) double（8byte）</p>
</li>
<li><p>定点数 ：DEC(M,D) 共M位 小数占D位 默认M=10 D=0</p>
</li>
</ul>
<p>较短的文本：varchar(M)和char(M)， M表示最多字符数 char可以省略M 默认为1 varchar长度可变</p>
<p>较长的文本: blob(较大的二进制)，text </p>
<p>保存较短的二进制 binary varbinary</p>
<p>set  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tab_char(c1 set(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;))</span><br><span class="line">#只能插入 1，2，3，a,b,c,A,B,C</span><br><span class="line">insert into tab_char values(&#39;a&#39;);</span><br><span class="line">insert into tab_char values(&#39;a,b&#39;);</span><br><span class="line">insert into tab_char values(&#39;b,c&#39;);</span><br></pre></td></tr></table></figure>

<p>enum    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tab_char(c1 enum(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;))</span><br><span class="line">#只能插入 1，2，3，a,b,c,A,B,C</span><br><span class="line">insert into tab_char values(&#39;a&#39;);</span><br></pre></td></tr></table></figure>

<p>字符型</p>
<ul>
<li><p>较短的文本：varchar(M)和char(M)， M表示最多字符数 char可以省略M 默认为1 varchar长度可变</p>
</li>
<li><p>较长的文本: blob(较大的二进制)，text </p>
</li>
<li><p>保存较短的二进制 binary varbinary</p>
</li>
</ul>
<p>日期型</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">字节</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">date</td>
<td align="center">4</td>
<td align="center">1000-01-01</td>
<td align="center">9999-12-31</td>
</tr>
<tr>
<td align="center">datatime</td>
<td align="center">8</td>
<td align="center">1000-01-01 00:00:00</td>
<td align="center">9999-12-31 23:59:59</td>
</tr>
<tr>
<td align="center">stamptime</td>
<td align="center">4</td>
<td align="center">19700101000001</td>
<td align="center">2038年的某个时刻</td>
</tr>
<tr>
<td align="center">time</td>
<td align="center">3</td>
<td align="center">-838:59:59</td>
<td align="center">838:59:59</td>
</tr>
<tr>
<td align="center">year</td>
<td align="center">1</td>
<td align="center">1901</td>
<td align="center">2155</td>
</tr>
</tbody></table>
<ul>
<li>timestamp会根据时区变化</li>
</ul>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p><strong>六大约束</strong></p>
<p><strong>NOT NULL</strong> ：非空约束，用于保证该字段的值不能为空 </p>
<p><strong>DEFAULT</strong> ：默认约束，用于保证该字段有默认值 </p>
<p><strong>PRIMARY KEY</strong> ：主键约束，用于保证该字段的值具有唯一性，并且非空 </p>
<p><strong>UNIQUE</strong> : 唯一约束，用于保证该字段的值具有唯一性，可以为空     </p>
<p><strong>CHECK</strong>：检查约束【mysql中不支持，sql语法支持，语法不报错，但是没效果】     比如年龄、性别，可以设置一个范围     </p>
<p><strong>FOREIGN KEY</strong> ：外键约束，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值</p>
<ul>
<li>PRIMARY KEY 和UNIQUE的区别：都可以保证唯一 主键不允许为空，unique允许 但是只能有一个null 主键只能有一个 unique可以多个 都支持组合列 </li>
<li>FOREIGN KEY ：从表的外键列类型和主表的关联列的类型要求一致或兼容，主表的关联列必须是一个key，插入数据时先插入主表，删除数据时先删除从表</li>
</ul>
<p>列级约束都支持但foreign key无效</p>
<p>表级约束除了default,not null都支持 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table stuinfo(</span><br><span class="line">	id int,</span><br><span class="line">    stuName varchar(20),</span><br><span class="line">    gender char(1),</span><br><span class="line">    seat int,</span><br><span class="line">    age int,</span><br><span class="line">    majorId int.</span><br><span class="line">    constraint pk primary key(id), #constarint 约束名 可以省略 </span><br><span class="line">    Unique(seat),</span><br><span class="line">    check(gender &#x3D; &#39;male&#39; or gender &#x3D; &#39;female&#39;).</span><br><span class="line">    foreign key(majorid) references major(id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>修改表示添加约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table stuinfo modify column stuname varchar(20) not null</span><br><span class="line">alter table stuinfo modify column id int primary key </span><br><span class="line">alter table stuinfo add primary key(id)</span><br><span class="line"> #constarin &lt;name&gt; 是为了删除方便</span><br><span class="line">alter table stuinfo add constarin fk_stuinfo_major foreign key(majorid) references user(id)</span><br></pre></td></tr></table></figure>

<p>修改表示删除约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#删除非空约束和默认约束</span><br><span class="line">alter talble stuinfo modify column stuname varchar(20) null #null可以省略</span><br><span class="line">#删除主键</span><br><span class="line">alter table stuinfo drop primary key</span><br><span class="line">#删除唯一</span><br><span class="line">alter table stuinfo drop index seat</span><br><span class="line">#删除外键</span><br><span class="line">alter table stuinfo drop foreign key fk_stuinfo_major</span><br></pre></td></tr></table></figure>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是由一组SQL语句组成的逻辑处理单元</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set autocommit &#x3D; 0 #关闭自动提交</span><br><span class="line">start transaction; #开始事务</span><br><span class="line">delete from user where name &#x3D; &#39;bob&#39;</span><br><span class="line">savepoint a; #设置回滚点</span><br><span class="line">delete from user where id &#x3D; 1;</span><br><span class="line">rollback to a;</span><br><span class="line">commit; #提交事务</span><br></pre></td></tr></table></figure>

<p><strong>ACID属性</strong></p>
<p>原子性(Atomicity)：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全不执行</p>
<p>一致性(Consistent)：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性;事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。 </p>
<p>隔离性：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</p>
<p>持久性：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持</p>
<p><strong>并发问题</strong>：对于同时运行的多个事务，当这些事务访问数据库中相同的数据时,如果没有采取必要的隔离机制,就会导致各种并发问题</p>
<ul>
<li><p>脏读：对于两个事务T1,T2,T1读取了已经被T2更新但还没有被提交的字段.之后,若T2回滚,T1读取的内容就是临时且无效的.</p>
</li>
<li><p>不可重复读:对于两个事务T1,T2,T1读取了一个字段,然后T2更新了该字段.之后,T1再次读取同一个字段,值就不同了.</p>
</li>
<li><p>幻读:对于两个事务T1,T2,T1从一个表中读取了一个字段,然后T2在该表中插入了一些新的行.之后,如果T1再次读取同一个表,就会多出几行.</p>
</li>
</ul>
<p><strong>事务隔离级别</strong></p>
<p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/image-20210204153156245.png" alt="image-20210204153156245"></p>
<p>mysql默认隔离级别为可重复读</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看当前隔离级别</span><br><span class="line">select @@tx_isolation</span><br><span class="line">#修改隔离级别</span><br><span class="line">set session transaction isolation level read uncommitted</span><br></pre></td></tr></table></figure>

<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图在使用时动态生成 只保存sql逻辑 不保存查询结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建视图</span><br><span class="line">create or replace view myview as </span><br><span class="line">select last_name,department_name,job_title from employees e join departments d on e.department_id &#x3D; d.department_id join jobs j on j.job_id &#x3D; e.job_id</span><br><span class="line">#使用视图</span><br><span class="line">select * from myview where last_name like &#39;%a%&#39;</span><br><span class="line">#修改视图</span><br><span class="line">alter vim myview as select * from employees</span><br><span class="line">#删除视图</span><br><span class="line">drop view name1,name2,name...</span><br><span class="line">#查看视图</span><br><span class="line">desc name1 或者 show create view name1</span><br><span class="line">#视图的更新 把视图当作一张表进行操（不建议更新）</span><br><span class="line">insert into myview values(‘zhangfei’)</span><br></pre></td></tr></table></figure>

<p>以下视图不能更新</p>
<ul>
<li><p>视图中包含 聚合函数。</p>
</li>
<li><p>视图中包含 UNION、UNION ALL、DISTINCT、 GROUP BY 和 HAVING 等关键字。</p>
</li>
<li><p>常量视图</p>
</li>
<li><p>视图中的select中包含子查询</p>
</li>
<li><p>由不可更新的视图导出的视图</p>
</li>
<li><p>创建视图时，ALGORITHM 为 TEMPTABLE 类型</p>
</li>
</ul>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h1 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h1><p>全局变量与会话变量的区别就在于，对全局变量的修改会影响到整个服务器，但是对会话变量的修改，只会影响到当前的会话</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>查看: show global variables like ‘%xxx%’ 如果不加模糊查询就是查询所有变量</p>
<p>查看具体的值 select @@global.&lt;系统变量名&gt;</p>
<p> 赋值：set global 系统变量名 = 值</p>
<p>作用域：服务器每次启动为所有的全局变量赋初始值 针对于所有会话有效 但不能跨重启</p>
<h3 id="会话变量"><a href="#会话变量" class="headerlink" title="会话变量"></a>会话变量</h3><p>查看：show 【session】 variables </p>
<p>查看具体值 select @@【session】变量名</p>
<p>赋值：set 【session】变量名=值</p>
<p>作用域：仅对于当前会话有效</p>
<p>注：以上的session可以省略</p>
<h2 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h2><h3 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h3><p>当前会话有效</p>
<p>初始化或赋值：set @变量名=值</p>
<p>赋值：select count(*) into @count from…</p>
<p>查看：select @用户变量名</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>仅仅在定义它的begin end中有效</p>
<p>声明：declare 变量名 类型 【default 值】</p>
<p>赋值：set 或select into 不用加@</p>
<p>查看 select 变量名</p>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>参数模式有输入in，输出out，输入兼输出inout</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure mypro(inout a int,inout b int)</span><br><span class="line">begin </span><br><span class="line">	set a &#x3D; a * 2;</span><br><span class="line">	set b &#x3D; b + a;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">set @a &#x3D; 1;</span><br><span class="line">set @b &#x3D; 2;</span><br><span class="line">#调用存储过程</span><br><span class="line">#如果时参数模式是in a和b的值不会被修改</span><br><span class="line">call mypro(@a,@b);</span><br><span class="line">#查看存储过程</span><br><span class="line">show create procedure mypro</span><br><span class="line">#删除存储过程</span><br><span class="line">drop procedure mypro</span><br></pre></td></tr></table></figure>

<h1 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#启用函数</span><br><span class="line">set global log_bin_trust_function_creators &#x3D; on</span><br><span class="line">#创建</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION genPerson(name varchar(20)) RETURNS varchar(50)</span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE str VARCHAR(50) DEFAULT &#39;&#39;;</span><br><span class="line">  SET @tableName&#x3D;name;</span><br><span class="line">  SET str&#x3D;CONCAT(&#39;create table &#39;, @tableName,&#39;(id int, name varchar(20));&#39;);</span><br><span class="line">  return str;</span><br><span class="line">end</span><br><span class="line">#执行函数</span><br><span class="line">select genPerson(&#39;student&#39;);</span><br><span class="line">#查看函数</span><br><span class="line">show create function genPerson()</span><br><span class="line">#删除函数</span><br><span class="line">drop function genPerson</span><br></pre></td></tr></table></figure>

<h1 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h1><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p>CASE</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure test_case(in score int)</span><br><span class="line">begin</span><br><span class="line">	case </span><br><span class="line">	when score &gt;&#x3D; 90 and score &lt;&#x3D; 100 then select &#39;A&#39;</span><br><span class="line">	when score &gt;&#x3D; 80 and then select &#39;B&#39;</span><br><span class="line">	when score &gt;&#x3D; 70 and then select &#39;C&#39;</span><br><span class="line">	else select &#39;D&#39;</span><br><span class="line">	end case;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>IF</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure test_case(in score int)</span><br><span class="line">begin</span><br><span class="line">	if score &gt;&#x3D; 90 and score &lt;&#x3D; 100 then return &#39;A&#39;;</span><br><span class="line">	elseif score &gt;&#x3D; 80 then return &#39;B&#39;</span><br><span class="line">	elseif score &gt;&#x3D; 70 then return &#39;C&#39;</span><br><span class="line">	else return &#39;D&#39;</span><br><span class="line">	end if</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>leave相当于break iterate相当于continue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#while</span><br><span class="line">while 循环条件 do</span><br><span class="line">	循环体</span><br><span class="line">end while 标签</span><br><span class="line">#loop</span><br><span class="line">loop </span><br><span class="line">	循环体</span><br><span class="line">end loop 标签 </span><br><span class="line">#repeat</span><br><span class="line">repeat </span><br><span class="line">	循环体</span><br><span class="line">until 结束循环的条件</span><br><span class="line">end repeat 标签</span><br><span class="line"></span><br><span class="line">#举例</span><br><span class="line">create procedure test_while(in insertCount int)</span><br><span class="line">begin</span><br><span class="line">	declare i int default 1;</span><br><span class="line">	a:while i&lt;&#x3D;insertCount Do</span><br><span class="line">		insert into admin(username,password) values (&#39;bob&#39;,&#39;123&#39;);</span><br><span class="line">		if i &gt;&#x3D; 20 then leave a;</span><br><span class="line">		end if;</span><br><span class="line">		set i &#x3D; i + 1;</span><br><span class="line">	end while a;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h1 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h1><p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612428706122.png" alt="img"></p>
<p>sql执行加载顺序 </p>
<p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612428715733.png" alt="img"></p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是帮助mysql高效获取数据的数据结构,一般是Btree 索引本身也很大 一般以索引文件的形式存储在磁盘上</p>
<p>优点：提高数据检索效率 降低数据库io成本 通过索引列对数据进行排序 降低数据排序的成本 降低了cpu的消耗 </p>
<p>缺点：降低更新表的速度<br><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612440213371.png" alt="img"></p>
<ul>
<li>非叶子节点不存储数据 只存储指引搜索方向的数据项</li>
</ul>
<p>索引分为以下几类</p>
<ul>
<li><p>单值索引：一个索引只包含单个列 </p>
</li>
<li><p>唯一索引：索引列的值必须唯一 但允许有空值 primary key ，unique</p>
</li>
<li><p>复合索引：一个索引包含多个列</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建索引</span><br><span class="line">CREATE [UNIQUE] INDEX indexName on tableName(columnName) #如果有unique是唯一索引 如果多个列是复合索引</span><br><span class="line">ALTER tableName ADD [UNIQUE] INDEX INDEXNAME on(columnName)</span><br><span class="line">#删除索引</span><br><span class="line">DROP INDEX indexName on tableName</span><br><span class="line">#查看索引</span><br><span class="line">SHOW INDEX FROM tableName</span><br></pre></td></tr></table></figure>

<p>需要创建索引的情况</p>
<ul>
<li><p>主键自动创建唯一索引</p>
</li>
<li><p>频繁作为查询条件的字段应该创建索引</p>
</li>
<li><p>查询中与其他表关联的字段，外键关系建立索引</p>
</li>
<li><p>频繁更新的字段不适合创建索引 因为更新不仅更新记录还会更新索引</p>
</li>
<li><p>where条件里用不到的字段不创建索引</p>
</li>
<li><p>单键/组合索引选择问题：高并发下倾向创建组合索引</p>
</li>
<li><p>查询中排序的字段 排序字段若通过索引去访问将大大提高查询速度</p>
</li>
<li><p>查询中统计或者分组字段</p>
</li>
</ul>
<p>不需要创建索引的情况</p>
<ul>
<li><p>表记录太少 </p>
</li>
<li><p>经常增删改的表</p>
</li>
<li><p>如果某个数据列包含许多重复的内容 为他建立索引没有太大实际效果</p>
</li>
</ul>
<h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><p>使用explain关键字可以模拟优化器执行sql查询的语句 从而知道mysql是如何处理你的sql语句的 分析你的查询语句或表结构的性能瓶颈</p>
<p>Explain各字段</p>
<ul>
<li><p>id：select查询的序列号 包含一组数字 表示查询中select或操作表的执行顺序如果id相同 执行顺序由上至下 id不同的话id大的优先级高 先执行</p>
</li>
<li><p>select_type：<a href="https://www.cnblogs.com/danhuangpai/p/8475458.html">https://www.cnblogs.com/danhuangpai/p/8475458.html</a></p>
</li>
<li><p>table：这行数据关于哪张表</p>
</li>
<li><p>type：查询使用的类型 性能从最好到最差 system-&gt;cosnt-&gt;eq_ref-&gt;ref-&gt;range-&gt;index-&gt;all 至少能达到range级别 最好到ref</p>
<ul>
<li>system：表中只有一条记录 等于系统表 是const类型的特例</li>
<li>const：表示通过索引一次就找到了 用于比较primary key 和 unique索引</li>
<li>eq_ref：唯一性索引扫描 用于联表查询的情况,按联表的主键或唯一键联合查询 表中只有一条记录与之匹配</li>
<li>ref：非唯一性索引扫描 返回匹配某个单独值 的所有行</li>
<li>range：检索给定范围的行 使用一个索引来选择行 key列显示了用哪个索引  </li>
<li>index：index和all都是全表扫描 但index从索引中读取</li>
<li>all：全表扫描</li>
</ul>
</li>
<li><p>possible_keys：显示可能应用在这张表上的索引，查询涉及到的字段上如果存在索引 该索引将被列出</p>
</li>
<li><p>key：实际使用的索引 如果为null则没用到索引 查询中如果用到覆盖索引 该索引只出现在key列表</p>
<ul>
<li><p>覆盖索引：查询的字段和建立索引的个数 顺序刚好一致 或是其子集</p>
<ul>
<li><pre><code class="mysql">create index ide_col1_col2 on mytalbe(col1,col2)
select col1,col2 from mytable;
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">* 覆盖索引中<span class="keyword">select</span>的数据列只用从索引中就能够取得 不必读取数据行，mysql可以利用索引返回<span class="keyword">select</span>列表中的字段 而不必根据索引再次读取数据文件 也就是说查询列要被所建的索引覆盖</span><br><span class="line">  </span><br><span class="line">* 如果要使用覆盖索引 一定要注意<span class="keyword">select</span>列表中只取出所需要的列 不可用<span class="keyword">select</span>*，因为如果将所有字段一起做索引会导致索引文件过大 查询新能下降</span><br><span class="line">  </span><br><span class="line">* key_len：表示索引中使用的字节数 显示的值为索引字段的最大可能长度 并非实际使用长度 这个值根据表定义计算得出 不是通过表内检索得出 在不失精度的前提下 长度越短越好</span><br><span class="line"></span><br><span class="line">* <span class="keyword">ref</span>：库.表.字段或const 显示索引的哪一列被使用了，有时候会是一个常量：表示哪些列或常量被用于查找索引列上的值 只有当<span class="keyword">type</span>为<span class="keyword">ref</span>和eq_ref的时候，<span class="keyword">ref</span>这列才会有值</span><br><span class="line"></span><br><span class="line">  * ![img](mysql笔记/clip_image002<span class="number">-1612446344425.</span>png)</span><br><span class="line"></span><br><span class="line">* <span class="keyword">rows</span>：查询所需要读取的行数</span><br><span class="line"></span><br><span class="line">* Extra：不适合在其他列中显示但十分重要的额外信息</span><br><span class="line"></span><br><span class="line">  * <span class="keyword">Using</span> fileSort：在使用<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">group</span> <span class="keyword">by</span>关键字的时候 没有使用索引的排序	</span><br><span class="line"></span><br><span class="line">    * ```mysql</span><br><span class="line">      <span class="keyword">create</span> <span class="keyword">index</span> idx_salary_name <span class="keyword">user</span>(salary,<span class="type">name</span>)</span><br><span class="line">      #建立索引的顺序是salary <span class="type">name</span> 使用时直接使用<span class="type">name</span> 不符合最左匹配原则 </span><br><span class="line">      <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="type">name</span>;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>using temporary：排序没有走索引、使用union、子查询连接查询、使用某些视图等原因，因此创建了一个内部临时表</p>
</li>
<li><p>using index：表示相应的select操作中使用了覆盖索引 如果同时出现using where 表示索引被用来执行索引键值的查找 如果没有using where 表明索引被用来执行读取数据而不是查找动作</p>
<ul>
<li><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612446539518.png" alt="img"></li>
</ul>
</li>
<li><p>using where：表明使用了where过滤 </p>
</li>
<li><p>using join buffer ：使用了连接缓存</p>
</li>
<li><p>impossible where：where子句的值总是false 不能用来获取任何元组</p>
</li>
</ul>
</li>
</ul>
<h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><p>​    最佳左前缀法则：如果索引了多列 查询从索引的最左前列开始并且不跳过索引中的列</p>
<p>​    在索引列上做任何操作（计算 函数 自动或手动转换）会使索引失效</p>
<p>​    范围条件右边的列索引失效</p>
<p>​    使用!= &lt;&gt;会使索引失效</p>
<p>​    like以通配符开头会使索引失效</p>
<p>​    字符串不加单引号使索引失效</p>
<p>​    用or连接会使索引失效</p>
<p>​    is null ，is not null 无法使用索引</p>
<p>​    尽量使用覆盖索引减少使用select*</p>
<p>​    order by中的字段要么全是升序排列 要么全是降序排列 否则会使索引失效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#首先创建复合索引c1 ~ c4</span><br><span class="line">#查询时用到了c1c2排序时用到了c3 没用到c4</span><br><span class="line">explain  select * from test where c1 &#x3D; &#39;a1&#39; and c2 &#x3D; &#39;a2&#39; and c4 &#x3D; &#39;c4&#39; order by c3</span><br><span class="line">#查询时用到了c1 c2 但不会出现fillSort因为 c2已经是常量了 所以排序时进行优化只用到了c3 </span><br><span class="line">explain  select * from test where c1 &#x3D; &#39;a1&#39; and c2 &#x3D; &#39;a2&#39; and c5 &#x3D; &#39;c5&#39; order by c3,c2</span><br><span class="line">#分组之前必排序：第二个sql没用到索引c2和c3 所以要建立临时表自己进行排序 第一个sql用c2和c3进行排序和分组</span><br><span class="line">explain  select * from test where c1 &#x3D; &#39;a1&#39; and c4 &#x3D; &#39;c4&#39; order by c2,c3</span><br><span class="line">explain  select * from test where c1 &#x3D; &#39;a1&#39; and c4 &#x3D; &#39;c4&#39; order by c3,c2</span><br></pre></td></tr></table></figure>

<h1 id="In和Exist"><a href="#In和Exist" class="headerlink" title="In和Exist"></a>In和Exist</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#当B表的数据集必须小于A表的数据集时，用in优于exists</span><br><span class="line">select * from A where id in (select id from B)</span><br><span class="line">等价于</span><br><span class="line">for select id from B</span><br><span class="line">for select * from A where A.id &#x3D; B.id</span><br><span class="line">#当A表的数据集必须小于B表的数据集时，用exists优于in</span><br><span class="line">#select 1也可以是 select * 因为exists结果返回bool值 实际执行会忽略select清单</span><br><span class="line">select * from A where exists (select 1 from B where B.id &#x3D; A.id)</span><br><span class="line">等价于</span><br><span class="line">for select * from A</span><br><span class="line">for select * from B Where B.id &#x3D; A.id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>select … from table where exists(subquery) 该语法可理解为：将主查询的数据放到子查询中做认证 根据验证结果(true,false)来决定著查询的数据是否得以保留</p>
<h1 id="FileSort"><a href="#FileSort" class="headerlink" title="FileSort"></a>FileSort</h1><p>mysql4.1之前是双路排序：从磁盘取排序字段 在buffer进行排序 在从磁盘取其他字段 两次io</p>
<p>单路排序：读出所有查询的列在buffer中进行排序 然后输出 一次io</p>
<p>在sort_buffer中，方法B比方法A要多占用很多空间，因为方法B是把所有字段都取出,所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并)，排完再取sort_buffer容量大小，再排……从而多次lO。本来想省一次lO操作，反而导致了大量的I/O操作，反而得不偿失。可以增大sort_buffer_size和max_length_for_sort_data进行优化</p>
<h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><p>慢查询日志用来记录在mysql中响应速度超过阈值的语句 具体指运行时间超过long_query_time值得sql 则会被记录到慢查询日志中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看是否开启</span><br><span class="line">show variables like &#39;%slow_query_log%&#39;</span><br><span class="line">#查看阈值 超过这个时间显示的sql语句被记录到日志中</span><br><span class="line">show variables like &#39;%slow_query_time%&#39;</span><br><span class="line">#开启慢查询</span><br><span class="line">set global general_log &#x3D; 1</span><br><span class="line">set global log_output &#x3D; &#39;table&#39;</span><br><span class="line">#被记录到mysql库中的general_log表中 可以用以下语句进行查看</span><br><span class="line">select * from mysql.general_log</span><br></pre></td></tr></table></figure>

<h1 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h1><p>​    优化顺序：慢查询-&gt;explain-&gt;show profile</p>
<p>​    showfile是mysql提供用来分析当前会话中语句执行的资源消耗情况 默认情况关闭 可以保存最近15次的运行结果</p>
<p>​    查看是否支持show variables like ‘profiling%’  开启:set profiling = on</p>
<p>​    查看语句的执行结果 show profiles  </p>
<p>​    诊断sql：show profile cpu,block io for query 9; 数字是要诊断的sql对应于show profiles列表中的id</p>
<p>​    showfile各字段</p>
<p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612450485937.png" alt="img"></p>
<p>出现以下几种情况很危险</p>
<ul>
<li>converting heap to myisam : 查询结果太大 内存不够用忘内存上搬</li>
<li>creating tmp table ：创建临时表，拷贝数据到临时表 用完再删除</li>
<li>copying to tmp  table on disk：把内存中临时表复制到磁盘</li>
</ul>
<h1 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h1><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>偏向myisam存储引擎 开销小 加锁块 无死锁 锁定粒度大 发生锁冲突的概率最高 并发程度低</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看表的上锁情况 </span><br><span class="line">show open tables;</span><br><span class="line">#解锁</span><br><span class="line">unlock tables;</span><br><span class="line">#读锁：上了读锁之后不能修改此表 不能访问别的表 其他用户可以读其他表和此表 但修改表时会阻塞 直到解锁</span><br><span class="line">lock table user read </span><br><span class="line">#写锁：上了读锁之后可以读写此表 不能读其他表  其他用户可以读其他表 读此表的时候阻塞 不能写此表</span><br><span class="line">lock table user write</span><br></pre></td></tr></table></figure>

<p>​     <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612450686998.png" alt="img"></p>
<p>​     <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image004-1612450686996.png" alt="img">    </p>
<p>​     <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image006-1612450686997.png" alt="img"></p>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>行锁：偏向InnoDb存储引擎 开销大 加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低 并发度也最高</p>
<p>如果使用针对InnoDB的表使用行锁，被锁定字段不是主键，也没有针对它建立索引的话。行锁锁定的也是整张表。锁整张表会造成程序的执行效率会很低。</p>
<p>索引失效会使行锁变表锁</p>
<p>事务未提交时 事务所涉及的行会自动锁住 其他行不会</p>
<p>​        <img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612450784685.png" alt="img"></p>
<p>解决不可重复读：在会话一中更新一条数据 在会话二中开启自动提交 再在会话一中提交 会话二中查询出的数据是更新后的数据</p>
<h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁;对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，</p>
<p>InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁_(Next-key锁）</p>
<p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/image-20210216134205633.png" alt="image-20210216134205633"></p>
<p>间隙锁的危害</p>
<ul>
<li>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。</li>
<li>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</li>
</ul>
<p>如何锁定一行</p>
<p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/clip_image002-1612450977750.png" alt="img"></p>
<p>如何分析行锁定</p>
<p>通过检查Innodb_row_lock状态变量来分析系统上的行锁的争夺情况</p>
<p>show status like ‘%innodb_row_lock%’</p>
<p>各个字段</p>
<p><img src="/2021/02/02/mysql%E7%AC%94%E8%AE%B0/image-20210204230741935.png" alt="image-20210204230741935"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>pig_note</title>
    <url>/2021/01/25/pig-note/</url>
    <content><![CDATA[<h1 id="getway"><a href="#getway" class="headerlink" title="getway"></a>getway</h1><h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><p>PigRequestGlobalFilter,对全部的微服务提供了安全过滤（这个后边会讲）和全局StripPrefix=1配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PigRequestGlobalFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 1. 清洗请求头中from 参数</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      因为部分内部feign调用 是没有token的,例如定时任务去调用upms的接口，所以需要在请求头中加了from in的标志</span></span><br><span class="line"><span class="comment">      ,upms看到这个from就放行了，但外部可能会人工恶意传入 所以网关要给清洗掉</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      ServerHttpRequest request = exchange.getRequest().mutate()</span><br><span class="line">            .headers(httpHeaders -&gt; httpHeaders.remove(SecurityConstants.FROM)).build();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 重写StripPrefix(截取前缀)=1 : 假如我们通过 Spring Cloud Gateway 访问/aaa/bbb/ccc/ddd的时候如果StripPrefix=2</span></span><br><span class="line">      <span class="comment">// 那么当网关服务向后转发请求时，会去掉/aaa/bbb 微服务收到的就是/ccc/ddd</span></span><br><span class="line">      <span class="comment">// 记录修改前的url</span></span><br><span class="line">      addOriginalRequestUrl(exchange, request.getURI());</span><br><span class="line">      String rawPath = request.getURI().getRawPath(); <span class="comment">// /auth/oauth/token</span></span><br><span class="line">      String newPath = <span class="string">&quot;/&quot;</span> + Arrays.stream(StringUtils.tokenizeToStringArray(rawPath, <span class="string">&quot;/&quot;</span>)).skip(<span class="number">1L</span>)</span><br><span class="line">            .collect(Collectors.joining(<span class="string">&quot;/&quot;</span>));  <span class="comment">// /oauth/token</span></span><br><span class="line">      ServerHttpRequest newRequest = request.mutate().path(newPath).build();</span><br><span class="line">      exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, newRequest.getURI());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> chain.filter(exchange.mutate().request(newRequest.mutate().build()).build());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网关降级"><a href="#网关降级" class="headerlink" title="网关降级"></a>网关降级</h2><p>以UMPS路由配置为例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">locator:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="comment">#UPMS 模块</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pig-upms</span>      <span class="comment"># 唯一的服务ID</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://pig-upms</span> <span class="comment"># 注册中心的服务名称，实现负载均衡</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/admin/**</span>  <span class="comment">#所有业务的请求前缀</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hystrix</span>           <span class="comment">#断路器降级策略</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">            <span class="attr">fallbackUri:</span> <span class="string">&#x27;forward:/fallback&#x27;</span> <span class="comment"># 降级接口的地址</span></span><br></pre></td></tr></table></figure>

<p>Spring Cloud Gateway 会自动寻找配置Hystrix的Filter，这个功能是内置的，然后回调我们提供的fallbackUr</p>
<p>降级入口。这里的意思类似于SpringMVC 定义一个 @GetMapping(“/fallback”) 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouterFunctionConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HystrixFallbackHandler hystrixFallbackHandler;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ImageCodeHandler imageCodeHandler;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RouterFunction <span class="title">routerFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RouterFunctions.route(</span><br><span class="line">      RequestPredicates.path(<span class="string">&quot;/fallback&quot;</span>)</span><br><span class="line">        .and(RequestPredicates.accept(MediaType.TEXT_PLAIN)), hystrixFallbackHandler)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="auth"><a href="#auth" class="headerlink" title="auth"></a>auth</h1><p>Spring Security Oauth2 以redis的方式存储Token</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>springCloud_mall</title>
    <url>/2020/12/13/springCloud-mall/</url>
    <content><![CDATA[<h1 id="集成Druid"><a href="#集成Druid" class="headerlink" title="集成Druid"></a>集成Druid</h1><p>project:springboot_druid</p>
<p>Druid阿里巴巴开源的一个java数据库连接池，是Java语言中最好的数据库连接池，Druid能够提供强大的监控和扩展功能；集成它能够方便我们对数据库连接进行监控和分析</p>
<p>application.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.52.131:3306/mall?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">Bbj0611..</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">initial-size:</span> <span class="number">5</span> <span class="comment">#连接池初始化大小</span></span><br><span class="line">      <span class="attr">min-idle:</span> <span class="number">10</span> <span class="comment">#最小空闲连接数</span></span><br><span class="line">      <span class="attr">max-active:</span> <span class="number">20</span> <span class="comment">#最大连接数</span></span><br><span class="line">      <span class="attr">web-stat-filter:</span></span><br><span class="line">        <span class="attr">exclusions:</span> <span class="string">&quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;</span> <span class="comment">#不统计这些请求数据</span></span><br><span class="line">      <span class="attr">stat-view-servlet:</span> <span class="comment">#访问监控网页的登录用户名和密码</span></span><br><span class="line">        <span class="attr">login-username:</span> <span class="string">druid</span></span><br><span class="line">        <span class="attr">login-password:</span> <span class="string">druid</span></span><br></pre></td></tr></table></figure>

<h1 id="集成admin"><a href="#集成admin" class="headerlink" title="集成admin"></a>集成admin</h1><p>参考博客：<a href="https://www.cnblogs.com/forezp/p/10242004.html">https://www.cnblogs.com/forezp/p/10242004.html</a></p>
<h1 id="MINIO"><a href="#MINIO" class="headerlink" title="MINIO"></a>MINIO</h1><p>安装</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget http:<span class="regexp">//</span>dl.minio.org.cn<span class="regexp">/server/mi</span>nio<span class="regexp">/release/</span>linux-amd64/minio</span><br><span class="line">chmod +x minio</span><br><span class="line">.<span class="regexp">/minio server /</span>data</span><br></pre></td></tr></table></figure>

<p>默认账号名和密码为:minioadmin</p>
<h1 id="nacos"><a href="#nacos" class="headerlink" title="nacos"></a>nacos</h1><p>下载地址:<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p>
<p>解压后 启动：<code>sh startup.sh -m standalone</code></p>
<p>启动失败解决方法：<a href="https://www.cnblogs.com/rookiemzl/p/13814919.html">https://www.cnblogs.com/rookiemzl/p/13814919.html</a></p>
<p>访问地址： <a href="http://192.168.52.131:8848/nacos/">http://192.168.52.131:8848/nacos/</a></p>
<p>默认账号和密码：nacos</p>
<p><strong>nacos可以作为配置中心</strong></p>
<p>项目：springcloud-learning-&gt;nacos-config-client</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/configInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个页面需要参数config.info 但是配置文件里没有</p>
<p>在nacos中创建一个配置</p>
<p><img src="/2020/12/13/springCloud-mall/image-20201214094003249.png" alt="image-20201214094003249"></p>
<p>并在bootstarp中配置获取路径</p>
<p><img src="/2020/12/13/springCloud-mall/image-20201214094027256.png" alt="image-20201214094027256"></p>
<h1 id="Gateway集成Oauth2-0"><a href="#Gateway集成Oauth2-0" class="headerlink" title="Gateway集成Oauth2.0"></a>Gateway集成Oauth2.0</h1><p><img src="https://pic4.zhimg.com/80/v2-93c28c22643361ecd5f265e33de6be03_1440w.png" alt="img"></p>
<p><strong>密码验证获取token</strong></p>
<p>使用postman根据密码授权模式获取token</p>
<p><img src="/2020/12/13/springCloud-mall/image-20210129210526873.png" alt="image-20210129210526873"></p>
<p>/mall-auth/oauth/token被设置在网关的白名单中 可以不用认证直接访问</p>
<p>访问服务的时候 在headers上加上token</p>
<p><img src="/2020/12/13/springCloud-mall/image-20210129210553051.png" alt="image-20210129210553051"></p>
<p>token在auth被密钥加密 在gateway中被公钥解密</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp/ip详解卷一:协议</title>
    <url>/2021/01/05/tcp-ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80-%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="互联网的地址"><a href="#互联网的地址" class="headerlink" title="互联网的地址"></a>互联网的地址</h2><p>五类ip地址</p>
<p><img src="/2021/01/05/tcp-ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80-%E5%8D%8F%E8%AE%AE/image-20210106201011718.png" alt="image-20210106201011718"></p>
<p>各类ip地址的范围</p>
<p><img src="/2021/01/05/tcp-ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80-%E5%8D%8F%E8%AE%AE/image-20210106201115334.png" alt="image-20210106201115334"></p>
<h2 id="客户-服务器模型"><a href="#客户-服务器模型" class="headerlink" title="客户-服务器模型"></a>客户-服务器模型</h2><p>大部分网络应用程序在编写时都假设一端是客户，另一端是服务器，其目的是为了让服务器为客户提供一些特定的服务。<br>可以将这种服务分为两种类型：重复型或并发型。重复型服务器通过以下步骤进行交互：</p>
<p>I1.等待一个客户请求的到来。<br>I2.处理客户请求。<br>I3.发送响应给发送请求的客户。<br>I4.返回I1步。</p>
<p>重复型服务器主要的问题发生在I2状态。在这个时候，它不能为其他客户机提供服务。相应地，并发型服务器采用以下步骤：<br>C1.等待一个客户请求的到来。<br>C2.启动一个新的服务器来处理这个客户的请求。在这期间可能生成一个新的进程、任务或线程，并依赖底层操作系统的支持。这个步骤如何进行取决于操作系统。生成的新服务器对客户的全部请求进行处理。处理结束后，终止这个新服务器。<br>C3.返回C1步。<br>并发服务器的优点在于它是利用生成其他服务器的方法来处理客户的请求。也就是说，每个客户都有它自己对应的服务器。如果操作系统允许多任务，那么就可以同时为多个客户服务。</p>
<p>一般来说，TCP服务器是并发的，而UDP服务器是重复的，但也存在一些例外</p>
<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><p><strong>以太网的帧格式</strong></p>
<p><img src="/2021/01/05/tcp-ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80-%E5%8D%8F%E8%AE%AE/image-20210107220050740.png" alt="image-20210107220050740"></p>
<ul>
<li>CRC字段用于帧内后续字节差错的循环冗余码检验</li>
</ul>
<h2 id="SLIP：串行线路IP"><a href="#SLIP：串行线路IP" class="headerlink" title="SLIP：串行线路IP"></a><strong>SLIP：串行线路IP</strong></h2><p>SLIP的全称是SerialLineIP。它是一种在串行线路上对IP数据报进行封装的简单形式</p>
<p>SLIP协议定义的帧格式：<br>1)IP数据报以一个称作END（0xc0）的特殊字符结束。同时，为了防止数据报到来之前的线路噪声被当成数据报内容，大多数实现在数据报的开始处也传一个END字符（如果有线路噪声，那么END字符将结束这份错误的报文。这样当前的报文得以正确地传输，而前一个错误报文交给上层后，会发现其内容毫无意义而被丢弃）。<br>2)如果IP报文中某个字符为END，那么就要连续传输两个字节0xdb和0xdc来取代它。0xdb这个特殊字符被称作SLIP的ESC字符，但是它的值与ASCII码的ESC字符（0x1b）不同。<br>3)如果IP报文中某个字符为SLIP的ESC字符，那么就要连续传输两个字节0xdb和0xdd来取代它。下图的例子就是含有一个END字符和一个ESC字符的IP报文。在这个例子中，在串行线路上传输的总字节数是原IP报文长度再加4个字节。</p>
<p><img src="/2021/01/05/tcp-ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80-%E5%8D%8F%E8%AE%AE/image-20210107230510162.png" alt="image-20210107230510162"></p>
<p>SLIP的缺陷：</p>
<p>1)每一端必须知道对方的IP地址。没有办法把本端的IP地址通知给另一端。</p>
<p>2)数据帧中没有类型字段（类似于以太网中的类型字段）。如果一条串行线路用于SLIP，那么它不能同时使用其他协议。</p>
<p>3)SLIP没有在数据帧中加上检验和（类似于以太网中的CRC字段）。如果SLIP传输的报文被线路噪声影响而发生错误，只能通过上层协议来发现（另一种方法是，新型的调制解调器可以检测并纠正错误报文）。这样，上层协议提供某种形式的CRC就显得很重要。</p>
<h2 id="压缩的SLIP：CompressSLIP"><a href="#压缩的SLIP：CompressSLIP" class="headerlink" title="压缩的SLIP：CompressSLIP"></a><strong>压缩的SLIP：CompressSLIP</strong></h2><p>由于串行线路的速率通常较低（19200b/s或更低），而且通信经常是交互式的（如Telnet和Rlogin，二者都使用TCP），因此在SLIP线路上有许多小的TCP分组进行交换。为了传送1个字节的数据需要20个字节的IP首部和20个字节的TCP首部，总数超过40个字节</p>
<p>CSLIP一般能把上面的40个字节压缩到3或5个字节。它能在CSLIP的每一端维持多达16个TCP连接，并且知道其中每个连接的首部中的某些字段一般不会发生变化。对于那些发生变化的字段，大多数只是一些小的数字和的改变。这些被压缩的首部大大地缩短了交互响应时间。</p>
<h2 id="PPP-点对点协议"><a href="#PPP-点对点协议" class="headerlink" title="PPP:点对点协议"></a><strong>PPP:点对点协议</strong></h2><p>PPP，点对点协议修改了SLIP协议中的所有缺陷。</p>
<p>PPP包括以下三个部分：<br>1)在串行链路上封装IP数据报的方法。PPP既支持数据为8位和无奇偶检验的异步模式（如大多数计算机上都普遍存在的串行接口），还支持面向比特的同步链接。<br>2)建立、配置及测试数据链路的链路控制协议（LCP：LinkControlProtocol）。它允许通信双方进行协商，以确定不同的选项。<br>3)针对不同网络层协议的网络控制协议（NCP：NetworkControlProtocol）体系。当前RFC定义的网络层有IP、OSI网络层、DECnet以及AppleTalk。例如，IPNCP允许双方商定是否对报文首部进行压缩，类似于CSLIP（缩写词NCP也可用在TCP的前面）。</p>
<h2 id="PPP数据帧的格式"><a href="#PPP数据帧的格式" class="headerlink" title="PPP数据帧的格式"></a><strong>PPP数据帧的格式</strong></h2><p>每一帧都以标志字符0x7e开始和结束。紧接着是一个地址字节，值始终是0xff，然后是一个值为0x03的控制字节。</p>
<p><img src="/2021/01/05/tcp-ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80-%E5%8D%8F%E8%AE%AE/image-20210107235728957.png" alt="image-20210107235728957"></p>
<p>由于标志字符的值是0x7e，因此当该字符出现在信息字段中时，PPP需要对它进行转义。在同步链路中，该过程是通过一种称作比特填充的硬件技术来完成的。在异步链路中，特殊字符0x7d用作转义字符。当它出现在PPP数据帧中时，那么紧接着的字符的第6个比特要取其补码，具体实现过程如下：<br>1)当遇到字符0x7e时，需连续传送两个字符：0x7d和0x5e，以实现标志字符的转义。<br>2)当遇到转义字符0x7d时，需连续传送两个字符：0x7d和0x5d，以实现转义字符的转义。<br>3)默认情况下，如果字符的值小于0x20（比如，一个ASCII控制字符），一般都要进行转义。例如，遇到字符0x01时需连续传送0x7d和0x21两个字符（这时，第6个比特取补码后变为1，而前面两种情况均把它变为0）。<br>这样做的原因是防止它们出现在双方主机的串行接口驱动程序或调制解调器中，因为有时它们会把这些控制字符解释成特殊的含义。另一种可能是用链路控制协议来指定是否需要对这32个字符中的某一些值进行转义。默认情况下是对所有的32个字符都进行转义。</p>
<p>与SLIP类似，由于PPP经常用于低速的串行链路，因此减少每一帧的字节数可以降低应用程序的交互时延。利用链路控制协议，大多数的产品通过协商可以省略标志符和地址字段，并且把协议字段由2个字节减少到1个字节。如果我们把PPP的帧格式与前面的SLIP的帧格式进行比较会发现，PPP只增加了3个额外的字节：1个字节留给协议字段，另2个给CRC字段使用。另外，使用IP网络控制协议，大多数的产品可以通过协商采用VanJacobson报文首部压缩方法（对应于CSLIP压缩），减小IP和TCP首部长度。总的来说，PPP比SLIP具有下面这些优点：(1)PPP支持在单根串行线路上运行多种协议，不只是IP协议；(2)每一帧都有循环冗余检验；(3)通信双方可以进行IP地址的动态协商(使用IP网络控制协议)；(4)与CSLIP类似，对TCP和IP报文首部进行压缩；(5)链路控制协议可以对多个数据链路选项进行设置。为这些优点付出的代价是在每一帧的首部增加3个字节，当建立链路时要发送几帧协商数据，以及更为复杂的实现。</p>
<p>PPP取代SLIP是大势所趋</p>
<h2 id="环回接口"><a href="#环回接口" class="headerlink" title="环回接口"></a>环回接口</h2><p>大多数的产品都支持环回接口（ Loopback Interface），以允许运行在同一台主机上的客户程序和服务器程序通过 T C P / I P进行通信。A类网络号1 2 7就是为环回接口预留的。根据惯例，大多数系统把I P地址1 2 7 . 0 . 0 . 1分配给这个接口，并命名为 l o c a l h o s t。一个传给环回接口的 I P数据报不能在任何网络上出现。我们想象，一旦传输层检测到目的端地址是环回地址时，应该可以省略部分传输层和所有网络层的逻辑操作。但是大多数的产品还是照样完成传输层和网络层的所有过程，只是当I P数据报离开网络层时把它返回给自己。</p>
<p>环回接口处理ip数据报的简单过程</p>
<p><img src="/2021/01/05/tcp-ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80-%E5%8D%8F%E8%AE%AE/image-20210109201930597.png" alt="image-20210109201930597"></p>
<p>图中需要指出的关键点是：</p>
<ol>
<li>传给环回地址（一般是1 2 7 . 0 . 0 . 1）的任何数据均作为I P输入。</li>
<li>传给广播地址或多播地址的数据报复制一份传给环回接口，然后送到以太网上。这是因为广播传送和多播传送的定义包含主机本身。<br>3 ) 任何传给该主机I P地址的数据均送到环回接口。</li>
</ol>
<h2 id="最大传输单元MTU"><a href="#最大传输单元MTU" class="headerlink" title="最大传输单元MTU"></a>最大传输单元MTU</h2><p>MTU：数据帧的最大长度</p>
<p>如果 I P层有一个数据报要传，而且数据的长度比链路层的 M T U还大，那么 I P层就需要进行分片</p>
<h2 id="路径MTU"><a href="#路径MTU" class="headerlink" title="路径MTU"></a>路径MTU</h2><p>当在同一个网络上的两台主机互相进行通信时，该网络的 M T U是非常重要的。但是如果两台主机之间的通信要通过多个网络，那么每个网络的链路层就可能有不同的 M T U。重要的不是两台主机所在网络的 M T U的值，重要的是两台通信主机路径中的最小 M T U。它被称作路径M T U。<br>两台主机之间的路径 M T U不一定是个常数。它取决于当时所选择的路由。而选路不一定是对称的（从A到B的路由可能与从B到A的路由不同），因此路径M T U在两个方向上不一定是一致的。</p>
<h1 id="IP-网际协议"><a href="#IP-网际协议" class="headerlink" title="IP:网际协议"></a>IP:网际协议</h1><p>IP提供不可靠、无连接的数据报传送服务</p>
<p>不可靠（u n r e l i a b l e）的意思是它不能保证 I P数据报能成功地到达目的地。 I P仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区， I P有一个简单的错误处理算法：丢弃该数据报，然后发送 I C M P消息报给信源端。任何要求的可靠性必须由上层来提供（如T C P）</p>
<p>无连接（c o n n e c t i o n l e s s）这个术语的意思是 I P并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。这也说明， I P数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是 A，然后是B），每个数据报都是独立地进行路由选择，可能选择不同的路线，因此 B可能在A到达之前先到达。</p>
<h2 id="ip首部"><a href="#ip首部" class="headerlink" title="ip首部"></a>ip首部</h2><p><img src="/2021/01/05/tcp-ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80-%E5%8D%8F%E8%AE%AE/image-20210110191848168.png" alt="image-20210110191848168"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper</title>
    <url>/2021/02/01/zookeeper/</url>
    <content><![CDATA[<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h1><ul>
<li>维护配置信息</li>
<li>分布式锁服务</li>
<li>集群管理</li>
<li>生成分布式唯一ID</li>
</ul>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h1><ul>
<li>高性能：zookeeper将全量数据存储在内存中，并直接用于客户端的所有非事务请求，尤其适用于以读为主的应用场景</li>
<li>高可用：zooKeeper一般以集群的方式对外提供服务，一般3~5台机器就可以组成一个可用的Zookeeper集群了，每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都相互保持着通信。只要集群中超过一半的机器都能够正常工作，那么整个集群就能够正常对外服务</li>
<li>严格顺序访问：对于来自客户端的每个更新请求，ZooKeeper都会分配一个全局唯一的递增编号，这个编号反映了所有事务操作的先后顺序</li>
</ul>
<h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a><strong>数据模型</strong></h1><p>zookeeper的数据节点可以视为树状结构（或者目录），树中的各节点被称为 znode（即zookeeper node），一个znode可以有多个子节点。zookeeper节点在结构 上表现为树状；使用路径path来定位某个znode，比如/ns1/itcast/mysql/schema1/table1。 znode，兼具文件和目录两种特点。既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分。</p>
<p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210201193107146.png" alt="image-20210201193107146"></p>
<p>一个znode大体上分为3各部分： 节点的数据：即znode data(节点path, 节点data)的关系就像是java map中(key, value)的关系 节点的子节点children 节点的状态stat：用来描述当前节点的创建、修改记录，包括cZxid、ctime等</p>
<p>在zookeeper shell中使用get命令查看指定路径节点的data、stat信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 7] get /ns-1/tenant</span><br><span class="line">cZxid = 0x6a0000000a</span><br><span class="line">ctime = Wed Mar 27 09:56:44 CST 2019</span><br><span class="line">mZxid = 0x6a0000000a</span><br><span class="line">mtime = Wed Mar 27 09:56:44 CST 2019</span><br><span class="line">pZxid = 0x6a0000000e</span><br><span class="line">cversion = 2</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 2</span><br></pre></td></tr></table></figure>

<p>属性说明： </p>
<ul>
<li>cZxid：数据节点创建时的事务 </li>
<li>ID ctime：数据节点创建时的时间 </li>
<li>mZxid：数据节点最后一次更新时的事务 ID</li>
<li>mtime：数据节点最后一次更新时的时间 </li>
<li>pZxid：数据节点的子节点最后一次被修改时的事务 ID </li>
<li>cversion：子节点的更改次数 </li>
<li>dataVersion：节点数据的更改次数 </li>
<li>aclVersion：节点的 ACL 的更改次数 </li>
<li>ephemeralOwner：如果节点是临时节点，则表示创建该节点的会话的 SessionID；如果节点是持久节点，则该属性值为 0 </li>
<li>dataLength：数据内容的长度 </li>
<li>numChildren：数据节点当前的子节点个数</li>
</ul>
<h1 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a><strong>节点类型</strong></h1><p>zookeeper中的节点有两种，分别为临时节点和永久节点。节点的类型在创建时即 被确定，并且不能改变。</p>
<ul>
<li>临时节点：该节点的生命周期依赖于创建它们的会话。一旦会话(Session)结束，临 时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的Znode都会绑定到 一个客户端会话，但他们对所有的客户端还是可见的。另外，ZooKeeper的临时节 点不允许拥有子节点。</li>
<li>持久化节点：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作 的时候，他们才能被删除</li>
</ul>
<h1 id="zookeeper单机安装"><a href="#zookeeper单机安装" class="headerlink" title="zookeeper单机安装"></a>zookeeper单机安装</h1><p>zookeeper-3.4.10.tar.gz，上传并解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 进入conf目录</span><br><span class="line">cd /home/zookeeper/zookeeper-3.4.10/conf</span><br><span class="line">// 复制配置文件</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line">// zookeeper根目录下新建data目录</span><br><span class="line">mkdir data</span><br><span class="line">// vi 修改配置文件中的dataDir</span><br><span class="line">// 此路径用于存储zookeeper中数据的内存快照、及事物日志文件</span><br><span class="line">dataDir=/home/zookeeper/zookeeper-3.4.10/data</span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 进入zookeeper的bin目录</span><br><span class="line">cd /home/zookeeper/zookeeper-3.4.10/bin</span><br><span class="line">// 启动zookeeper</span><br><span class="line">./zkServer.sh start</span><br><span class="line">//启动：zkServer.sh start</span><br><span class="line">//停止：zkServer.sh stop</span><br><span class="line">//查看状态：zkServer.sh status</span><br><span class="line">登录客户端：./zkCli.sh -server localhost:2181</span><br></pre></td></tr></table></figure>

<h1 id="常用shell命令"><a href="#常用shell命令" class="headerlink" title="常用shell命令"></a>常用shell命令</h1><p><strong>新增节点</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create [-s] [-e] path data #其中-s 为有序节点，-e 临时节点</span><br><span class="line"><span class="meta">#</span><span class="bash">创建持久化节点</span></span><br><span class="line">create /hadoop &quot;123&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">创建持久化有序节点</span></span><br><span class="line">create -s /a &quot;a&quot; </span><br><span class="line">	Created /a0000000001</span><br><span class="line">create -s /a &quot;b&quot;</span><br><span class="line">	Created /b0000000002</span><br><span class="line">create -s /a &quot;c&quot;</span><br><span class="line">	Created /c0000000003</span><br><span class="line"><span class="meta">#</span><span class="bash">创建临时节点 当当前会话过期后被删除[quit命令退出]</span></span><br><span class="line">create -e /tmp &quot;hhh&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">创建临时有序节点</span></span><br><span class="line">create -s -e /orderTmp &quot;ttt&quot;</span><br></pre></td></tr></table></figure>

<p><strong>更新节点</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set /hadoop &quot;345&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">也可以基于版本号进行更改，此时类似于乐观锁机制，当你传入的数据版本号(dataVersion) 和当前节点的数据版本号不符合时，会拒绝本次修改</span></span><br><span class="line">set /hadoop &quot;3456&quot; 1</span><br></pre></td></tr></table></figure>

<p><strong>删除节点</strong></p>
<p>与更新节点类似：delete path [version]</p>
<p><strong>查看节点</strong></p>
<p>get path</p>
<p><strong>查看节点状态</strong></p>
<p>state path:它的返回值和 get 命令类似，但不会返回 节点数据</p>
<p><strong>查看节点列表</strong></p>
<p>查看节点列表有 ls path 和 ls2 path 两个命令，后者是前者的增强，不仅可以查看指定路径下的所有节点，还可以查看当前节点的信息</p>
<p><strong>监听器</strong></p>
<p>get path [watch] ：注册的监听器能够在节点内容发生改变的时候，向客户端发出通知。需要注意的是 zookeeper 的触发器是一次性的 (One-time trigger)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] get /hadoop watch</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] set /hadoop 45678</span><br><span class="line">WATCHER::</span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDataChanged path:/hadoop #节点值改变</span><br></pre></td></tr></table></figure>

<p>ls\ls2 path [watch]：ls path [watch] 或 ls2 path [watch] 注册的监听器能够监听该节点下 所有子节点的增加和删除操作。也是一次性的</p>
<h1 id="ACL权限控制"><a href="#ACL权限控制" class="headerlink" title="ACL权限控制"></a>ACL权限控制</h1><p>zookeeper 类似文件系统，client 可以创建节点、更新节点、删除节点，那么 如何做到节点的权限的控制呢？zookeeper的access control list 访问控制列表可以做到 这一点。</p>
<p>acl 权限控制，使用scheme：id：permission 来标识，主要涵盖 3 个方面</p>
<ul>
<li>权限模式（scheme）：授权的策略</li>
<li>授权对象（id）：授权的对象</li>
<li>权限（permission）：授予的权限</li>
</ul>
<p>其特性如下</p>
<ul>
<li>zooKeeper的权限控制是基于每个znode节点的，需要对每个节点设置权限</li>
<li>每个znode支持设置多种权限控制方案和多个权限</li>
<li>子节点不会继承父节点的权限，客户端无权访问某节点，但可能可以访问它的子节点</li>
</ul>
<p><strong>权限模式</strong></p>
<p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210202170003037.png" alt="image-20210202170003037"></p>
<p><strong>授予的权限</strong></p>
<p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210202170113833.png" alt="image-20210202170113833"></p>
<p><strong>授权的相关命令</strong></p>
<p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210202170241887.png" alt="image-20210202170241887"></p>
<p>world授权模式 <code>setAcl /node1 world:anyone:cdrwa</code></p>
<p>IP授权模式 <code>setAcl /node2 ip:192.168.60.129:cdrwa</code></p>
<p>Auth授权模式 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">addauth digest itcast:123456</span><br><span class="line">setAcl /node3 auth:itcast:cdrwa</span><br></pre></td></tr></table></figure>

<p>Digest授权模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">通过以下命令计算密文</span></span><br><span class="line">echo -n &lt;user&gt;:&lt;password&gt; | openssl dgst -binary -sha1 | openssl base64</span><br><span class="line">echo -n bob:123465 | openssl dgst -binary -sha1 | openssl base64</span><br><span class="line"><span class="meta">#</span><span class="bash">使用算出的密文添加权限</span></span><br><span class="line">setAcl /node digest:bob:qlzQzCLKhBROghkooLvb+Mlwv4A=:cdrwa</span><br><span class="line"><span class="meta">#</span><span class="bash">添加认证用户后 才可以得到数据</span></span><br><span class="line">addauth digest bob:123456</span><br><span class="line">get /node</span><br></pre></td></tr></table></figure>

<p><strong>超级管理员</strong></p>
<p>首先为超管生成密文</p>
<p>比如<code>echo -n super:admin | openssl dgst -binary -sha1 | openssl base64</code></p>
<p>么打开zookeeper目录下的/bin/zkServer.sh服务器脚本文件，找到如下一行</p>
<p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210202171936529.png" alt="image-20210202171936529"></p>
<p>在后面添加</p>
<p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210202172025240.png" alt="image-20210202172025240"></p>
<h1 id="javaAPI"><a href="#javaAPI" class="headerlink" title="javaAPI"></a><strong>javaAPI</strong></h1><h2 id="连接到zookeeper"><a href="#连接到zookeeper" class="headerlink" title="连接到zookeeper"></a><strong>连接到zookeeper</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperConnection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 计数器对象</span></span><br><span class="line">            CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// arg1:服务器的ip和端口</span></span><br><span class="line">            <span class="comment">// arg2:客户端与服务器之间的会话超时时间 以毫秒为单位的</span></span><br><span class="line">            <span class="comment">// arg3:连接是异步的 需要实现“监视器”对象 zookeeper集合通过监视器对象返回连接状态</span></span><br><span class="line">            ZooKeeper zooKeeper=<span class="keyword">new</span> ZooKeeper(<span class="string">&quot;192.168.52.131:2181&quot;</span>,</span><br><span class="line">                    <span class="number">5000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(event.getState()==Event.KeeperState.SyncConnected)</span><br><span class="line">                    &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;连接创建成功!&quot;</span>);</span><br><span class="line">                        countDownLatch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 主线程阻塞等待连接对象的创建成功</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="comment">// 会话编号</span></span><br><span class="line">            System.out.println(zooKeeper.getSessionId());</span><br><span class="line">            zooKeeper.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a><strong>新增节点</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步方式</span></span><br><span class="line">create(String path, <span class="keyword">byte</span>[] data, List&lt;ACL&gt; acl, CreateMode createMode)</span><br><span class="line"><span class="comment">// 异步方式</span></span><br><span class="line">create(String path, <span class="keyword">byte</span>[] data, List&lt;ACL&gt; acl, CreateMode createMode，AsyncCallback.StringCallback callBack,Object ctx)</span><br></pre></td></tr></table></figure>

<ul>
<li>path - znode路径。例如/node1 </li>
<li>data - 要存储在指定znode路径中的数据</li>
<li>acl - 要创建的节点的访问控制列表。zookeeper API提供了一个静态接口 ZooDefs.Ids 来获取一些基本的acl列表。例如，ZooDefs.Ids.OPEN_ACL_UNSAFE 返回打开znode的acl列表。</li>
<li>createMode - 节点的类型,这是一个枚举。 </li>
<li>callBack-异步回调接口 </li>
<li>ctx-传递上下文参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKCreate</span> </span>&#123;</span><br><span class="line">    ZooKeeper zooKeeper ;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 计数器对象</span></span><br><span class="line">        CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// arg1:服务器的ip和端口</span></span><br><span class="line">        <span class="comment">// arg2:客户端与服务器之间的会话超时时间 以毫秒为单位的</span></span><br><span class="line">        <span class="comment">// arg3:连接是异步的 需要实现“监视器”对象 zookeeper集合通过监视器对象返回连接状态</span></span><br><span class="line">        zooKeeper=<span class="keyword">new</span> ZooKeeper(<span class="string">&quot;192.168.52.131:2181&quot;</span>,</span><br><span class="line">                <span class="number">5000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(event.getState()==Event.KeeperState.SyncConnected)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接创建成功!&quot;</span>);</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * Decrements the count of the latch, releasing all waiting threads if the count reaches zero.</span></span><br><span class="line"><span class="comment">                     * If the current count is greater than zero then it is decremented. If the new count is zero then all waiting threads are re-enabled for thread scheduling purposes.</span></span><br><span class="line"><span class="comment">                     * If the current count equals zero then nothing happens.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程阻塞等待连接对象的创建成功</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createSync</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * READ_ACL_UNSAFE:world:anyone:r 只读的</span></span><br><span class="line"><span class="comment">         * CREATOR_ALL_ACL:赋予了节点的创建者所有的权限，在创建者采用此ACL创建节点之前，已经被服务器所认证（例如，采用 “ digest”方案）。</span></span><br><span class="line"><span class="comment">         * OPEN_ACL_UNSAFE:world:anyone:cdrwa 任何应用程序在节点上可进行任何操作，能创建、列出和删除它的子节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node1&quot;</span>,<span class="string">&quot;i am node1&quot;</span>.getBytes(StandardCharsets.UTF_8), ZooDefs.Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAcl</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//自定义权限</span></span><br><span class="line">        <span class="comment">//world授权</span></span><br><span class="line">        List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//授权模式和授权对象</span></span><br><span class="line">        Id id = <span class="keyword">new</span> Id(<span class="string">&quot;world&quot;</span>,<span class="string">&quot;anyone&quot;</span>);</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.READ,id));</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.WRITE,id));</span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node2&quot;</span>,<span class="string">&quot;i am node2&quot;</span>.getBytes(StandardCharsets.UTF_8),acls,CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAcl2</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//ip授权</span></span><br><span class="line">        List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Id id = <span class="keyword">new</span> Id(<span class="string">&quot;ip&quot;</span>,<span class="string">&quot;192.168.52.131&quot;</span>);</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.ALL,id));</span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node2&quot;</span>,<span class="string">&quot;i am node2&quot;</span>.getBytes(StandardCharsets.UTF_8),acls,CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAcl3</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//auth授权</span></span><br><span class="line">        zooKeeper.addAuthInfo(<span class="string">&quot;digest&quot;</span>,<span class="string">&quot;admin:123456&quot;</span>.getBytes());</span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node2&quot;</span>,<span class="string">&quot;i am node2&quot;</span>.getBytes(StandardCharsets.UTF_8),ZooDefs.Ids.CREATOR_ALL_ACL,CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAcl4</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//auth授权</span></span><br><span class="line">        zooKeeper.addAuthInfo(<span class="string">&quot;digest&quot;</span>,<span class="string">&quot;admin:123456&quot;</span>.getBytes());</span><br><span class="line">        List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Id id = <span class="keyword">new</span> Id(<span class="string">&quot;auth&quot;</span>,<span class="string">&quot;bob&quot;</span>);</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.ALL,id));</span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node2&quot;</span>,<span class="string">&quot;i am node2&quot;</span>.getBytes(StandardCharsets.UTF_8),acls,CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAcl5</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//digest授权</span></span><br><span class="line">        List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Id id = <span class="keyword">new</span> Id(<span class="string">&quot;digest&quot;</span>,<span class="string">&quot;bob:qlzQzCLKhBROghkooLvb+Mlwv4A=&quot;</span>);</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.ALL,id));</span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node2&quot;</span>,<span class="string">&quot;i am node2&quot;</span>.getBytes(StandardCharsets.UTF_8),acls,CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPer</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建持久化顺序节点</span></span><br><span class="line">        String result = zooKeeper.create(<span class="string">&quot;/create/node1&quot;</span>,<span class="string">&quot;i am node1&quot;</span>.getBytes(StandardCharsets.UTF_8), ZooDefs.Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAsunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/create/node2&quot;</span>,<span class="string">&quot;i am node2&quot;</span>.getBytes(StandardCharsets.UTF_8),ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, <span class="keyword">new</span> AsyncCallback.StringCallback()&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> rc 0代表创建成功</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> path 节点路径</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> ctx  上下文参数</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> name 节点路径</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, String name)</span> </span>&#123;</span><br><span class="line">                System.out.println(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;i am ctx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        zooKeeper.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步方式</span></span><br><span class="line">set<span class="constructor">Data(String <span class="params">path</span>, <span class="params">byte</span>[] <span class="params">data</span>, <span class="params">int</span> <span class="params">version</span>)</span></span><br><span class="line"><span class="comment">// 异步方式:callback是异步回调接口 ctx传递上下文对象</span></span><br><span class="line">set<span class="constructor">Data(String <span class="params">path</span>, <span class="params">byte</span>[] <span class="params">data</span>,,<span class="params">int</span> <span class="params">version</span>,AsyncCallback.StatCallback <span class="params">callBack</span>,Object <span class="params">ctx</span>)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSyn</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Stat stat=zookeeper.setData(<span class="string">&quot;/set/node1&quot;</span>,<span class="string">&quot;node13&quot;</span>.getBytes(),<span class="number">2</span>);</span><br><span class="line">    System.out.println(stat.getVersion());</span><br><span class="line">    System.out.println(stat.getCtime());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsyn</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//版本号—1表示不参与更新 版本号一致才可以更新成功 每次更新版本号+1</span></span><br><span class="line">    zookeeper.setData(<span class="string">&quot;/set/node2&quot;</span>, <span class="string">&quot;node21&quot;</span>.getBytes(), -<span class="number">1</span>, <span class="keyword">new</span></span><br><span class="line">                      AsyncCallback.StatCallback() &#123;</span><br><span class="line">                          <span class="meta">@Override</span></span><br><span class="line">                          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, Stat stat)</span> </span>&#123;</span><br><span class="line">                              System.out.println(rc);</span><br><span class="line">                              System.out.println(path);</span><br><span class="line">                              System.out.println(ctx);</span><br><span class="line">                              System.out.println(stat.getVersion());</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;,<span class="string">&quot;I am Context&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 同步方式</span><br><span class="line"><span class="keyword">delete</span>(<span class="keyword">String</span> <span class="keyword">path</span>, <span class="built_in">int</span> <span class="keyword">version</span>)</span><br><span class="line">// 异步方式</span><br><span class="line"><span class="keyword">delete</span>(<span class="keyword">String</span> <span class="keyword">path</span>, <span class="built_in">int</span> <span class="keyword">version</span>, AsyncCallback.VoidCallback callBack,<span class="keyword">Object</span> ctx)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// arg2:数据版本信息 -1代表删除节点时不考虑版本信息</span></span><br><span class="line">    zooKeeper.delete(<span class="string">&quot;/delete/node1&quot;</span>,-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 异步使用方式</span></span><br><span class="line">    zooKeeper.delete(<span class="string">&quot;/delete/node2&quot;</span>, -<span class="number">1</span>, <span class="keyword">new</span></span><br><span class="line">                     AsyncCallback.VoidCallback() &#123;</span><br><span class="line">                         <span class="meta">@Override</span></span><br><span class="line">                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx)</span> </span>&#123;</span><br><span class="line">                             <span class="comment">// 0代表删除成功</span></span><br><span class="line">                             System.out.println(rc);</span><br><span class="line">                             System.out.println(path);</span><br><span class="line">                             System.out.println(ctx);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;,<span class="string">&quot;I am Context&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查看节点"><a href="#查看节点" class="headerlink" title="查看节点"></a>查看节点</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步方式</span></span><br><span class="line">get<span class="constructor">Data(String <span class="params">path</span>, <span class="params">boolean</span> <span class="params">b</span>, Stat <span class="params">stat</span>)</span></span><br><span class="line"><span class="comment">// 异步方式</span></span><br><span class="line">get<span class="constructor">Data(String <span class="params">path</span>, <span class="params">boolean</span> <span class="params">b</span>，AsyncCallback.DataCallback <span class="params">callBack</span>，Object <span class="params">ctx</span>)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// arg1:节点的路径</span></span><br><span class="line">    <span class="comment">// arg3:读取节点属性的对象</span></span><br><span class="line">    Stat stat=<span class="keyword">new</span> Stat();</span><br><span class="line">    <span class="keyword">byte</span> [] bys=zooKeeper.getData(<span class="string">&quot;/get/node1&quot;</span>,<span class="keyword">false</span>,stat);</span><br><span class="line">    <span class="comment">// 打印数据</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(bys));</span><br><span class="line">    <span class="comment">// 版本信息</span></span><br><span class="line">    System.out.println(stat.getVersion());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    zooKeeper.getData(<span class="string">&quot;/get/node1&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span></span><br><span class="line">            AsyncCallback.DataCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">byte</span>[] data, Stat stat)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 0代表读取成功</span></span><br><span class="line">                    System.out.println(rc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;I am Context&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查看子节点"><a href="#查看子节点" class="headerlink" title="查看子节点"></a>查看子节点</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步方式</span></span><br><span class="line">get<span class="constructor">Children(String <span class="params">path</span>, <span class="params">boolean</span> <span class="params">b</span>)</span></span><br><span class="line"><span class="comment">// 异步方式</span></span><br><span class="line">get<span class="constructor">Children(String <span class="params">path</span>, <span class="params">boolean</span> <span class="params">b</span>,AsyncCallback.ChildrenCallback <span class="params">callBack</span>,Object <span class="params">ctx</span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>b- 是否使用连接对象中注册的监视器。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//arg2:如果watch为true，并且调用成功（没有抛出异常），将在给定路径的节点上留下一个watch。</span></span><br><span class="line">    <span class="comment">//如果成功地删除给定路径的节点或在该节点下创建/删除一个子节点的操作将触发该监视。</span></span><br><span class="line">    List&lt;String&gt; list = zooKeeper.getChildren(<span class="string">&quot;/get&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    zooKeeper.getChildren(<span class="string">&quot;/get&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span></span><br><span class="line">                          AsyncCallback.ChildrenCallback() &#123;</span><br><span class="line">                              <span class="meta">@Override</span></span><br><span class="line">                              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        List&lt;String&gt; children)</span> </span>&#123;</span><br><span class="line">                                  <span class="comment">// 0代表读取成功</span></span><br><span class="line">                                  System.out.println(rc);</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;,<span class="string">&quot;I am Context&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查看节点是否存在"><a href="#查看节点是否存在" class="headerlink" title="查看节点是否存在"></a>查看节点是否存在</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步方法</span></span><br><span class="line"><span class="built_in">exists</span>(<span class="keyword">String</span> path, <span class="keyword">boolean</span> b)</span><br><span class="line"><span class="comment">// 异步方法</span></span><br><span class="line"><span class="built_in">exists</span>(<span class="keyword">String</span> path, <span class="keyword">boolean</span> b，AsyncCallback.StatCallback callBack,Object ctx)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exists1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Stat stat = zookeeper.exists(<span class="string">&quot;/exists1&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    System.out.println(stat.getVersion());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exists2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    zookeeper.exists(<span class="string">&quot;/exists1&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span></span><br><span class="line">            AsyncCallback.StatCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Stat stat)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 0 判断成功</span></span><br><span class="line">                    System.out.println(rc);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;I am Context&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h1><p>​    zookeeper提供了数据的发布/订阅功能，多个订阅者可同时监听某一特定主题对 象，当该主题对象的自身状态发生变化时(例如节点内容改变、节点下的子节点列表改变 等)，会实时、主动通知所有订阅者</p>
<p>​    zookeeper采用了Watcher机制实现数据的发布/订阅功能。该机制在被订阅对 象发生变化时会异步通知客户端，因此客户端不必在Watcher注册后轮询阻塞，从而减轻 了客户端压力</p>
<h2 id="watcher架构"><a href="#watcher架构" class="headerlink" title="watcher架构"></a>watcher架构</h2><p>watcher由三部分组成：zookeeper服务端，zookeeper客户端，客户端的ZKWatchManager对象</p>
<p>客户端首先将Watcher注册到服务端，同时将Watcher对象保存到客户端的Watch管理器中。当ZooKeeper服务端监听的数据状态发生变化时，服务端会主动通知客户端， 接着客户端的Watch管理器会触发相关Watcher来回调相应处理逻辑，从而完成整体的数据发布/订阅流程。</p>
<p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210215104851771.png" alt="image-20210215104851771"></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>一次性</td>
<td>watcher是一次性的，一旦被触发就会移除，再次使用时需要重新注册</td>
</tr>
<tr>
<td>客户端顺序回调</td>
<td>watcher回调是顺序串行化执行的，只有回调后客户端才能看到最新的数据状态。一个watcher回调逻辑不应该太多，以免影响别的watcher执行</td>
</tr>
<tr>
<td>轻量级</td>
<td>WatchEvent是最小的通信单元，结构上只包含通知状态、事件类型和节点路径，并不会告诉数据节点变化前后的具体内容</td>
</tr>
<tr>
<td>时效性</td>
<td>watcher只有在当前session彻底失效时才会无效，若在session有效期内快速重连成功，则watcher依然存在，仍可接收到通知</td>
</tr>
</tbody></table>
<h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>Watcher是一个接口，任何实现了Watcher接口的类就是一个新的Watcher。 Watcher内部包含了两个枚举类：KeeperState、EventType</p>
<p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210215105441596.png" alt="image-20210215105441596"></p>
<p>Watcher通知状态(KeeperState)：KeeperState是客户端与服务端连接状态发生变化时对应的通知类型。路径为 org.apache.zookeeper.Watcher.Event.KeeperState，是一个枚举类，其枚举属性 如下</p>
<table>
<thead>
<tr>
<th>枚举属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SyncConnected</td>
<td>客户端与服务器正常连接时</td>
</tr>
<tr>
<td>Disconnected</td>
<td>客户端与服务器断开连接时</td>
</tr>
<tr>
<td>Expired</td>
<td>会话session失效时</td>
</tr>
<tr>
<td>AuthFailed</td>
<td>身份认证失败时</td>
</tr>
</tbody></table>
<p>Watcher事件类型(EventType)：EventType是数据节点(znode)发生变化时对应的通知类型。EventType变化时 KeeperState永远处于SyncConnected通知状态下；当KeeperState发生变化时， EventType永远为None。其路径为org.apache.zookeeper.Watcher.Event.EventType，是一个枚举类，枚举属性如下</p>
<table>
<thead>
<tr>
<th>枚举属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>None</td>
<td>无</td>
</tr>
<tr>
<td>NodeCreated</td>
<td>Watcher监听的数据节点被创建时</td>
</tr>
<tr>
<td>NodeDeleted</td>
<td>Watcher监听的数据节点被删除时</td>
</tr>
<tr>
<td>NodeDataChanged</td>
<td>Watcher监听的数据节点内容发生变更时(无论内容数据 是否变化)</td>
</tr>
<tr>
<td>NodeChildrenChanged</td>
<td>Watcher监听的数据节点的子节点列表发生变更时</td>
</tr>
</tbody></table>
<h2 id="捕获相应的事件"><a href="#捕获相应的事件" class="headerlink" title="捕获相应的事件"></a>捕获相应的事件</h2><p>建立zookeeper的watcher监听</p>
<table>
<thead>
<tr>
<th>注册方式</th>
<th>Created</th>
<th>ChildChanged</th>
<th>Changed</th>
<th>Deleted</th>
</tr>
</thead>
<tbody><tr>
<td>zk.exists(“/nodex”,watcher)</td>
<td>可监控</td>
<td></td>
<td>可监控</td>
<td>可监控</td>
</tr>
<tr>
<td>zk.getData(“/nodex”,watcher)</td>
<td></td>
<td></td>
<td>可监控</td>
<td>可监控</td>
</tr>
<tr>
<td>zk.getChildren(“/nodex”,watcher)</td>
<td></td>
<td>可监控</td>
<td></td>
<td>可监控</td>
</tr>
</tbody></table>
<h2 id="注册watcher的方法"><a href="#注册watcher的方法" class="headerlink" title="注册watcher的方法"></a>注册watcher的方法</h2><h3 id="客户端与服务器的连接状态"><a href="#客户端与服务器的连接状态" class="headerlink" title="客户端与服务器的连接状态"></a>客户端与服务器的连接状态</h3><p>事件类型为none时 不同的通知状态的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.watcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKConnectionWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器对象</span></span><br><span class="line">    <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 连接对象</span></span><br><span class="line">    <span class="keyword">static</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 事件类型</span></span><br><span class="line">            <span class="keyword">if</span> (event.getType() == Event.EventType.None) &#123;</span><br><span class="line">                <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接创建成功!&quot;</span>);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == Event.KeeperState.Disconnected) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;断开连接！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == Event.KeeperState.Expired) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;会话超时!&quot;</span>);</span><br><span class="line">                    zooKeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;192.168.52.131:2181&quot;</span>, <span class="number">5000</span>, <span class="keyword">new</span> ZKConnectionWatcher());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == Event.KeeperState.AuthFailed) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;认证失败！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zooKeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;192.168.52.131:2181&quot;</span>, <span class="number">5000</span>, <span class="keyword">new</span> ZKConnectionWatcher());</span><br><span class="line">            <span class="comment">// 阻塞线程等待连接的创建</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="comment">// 会话id</span></span><br><span class="line">            System.out.println(zooKeeper.getSessionId());</span><br><span class="line">            <span class="comment">// 添加授权用户</span></span><br><span class="line">            zooKeeper.addAuthInfo(<span class="string">&quot;digest1&quot;</span>,<span class="string">&quot;itcast1:1234561&quot;</span>.getBytes());</span><br><span class="line">            <span class="keyword">byte</span> [] bs=zooKeeper.getData(<span class="string">&quot;/node1&quot;</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bs));</span><br><span class="line">            Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">            zooKeeper.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检查节点是否存在"><a href="#检查节点是否存在" class="headerlink" title="检查节点是否存在"></a>检查节点是否存在</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用连接对象的监视器</span></span><br><span class="line"><span class="function"><span class="title">exists</span><span class="params">(String path, boolean b)</span></span></span><br><span class="line"><span class="comment">// 自定义监视器</span></span><br><span class="line"><span class="function"><span class="title">exists</span><span class="params">(String path, Watcher w)</span></span></span><br><span class="line"></span><br><span class="line">path- znode路径。</span><br><span class="line">b- 是否使用连接对象中注册的监视器。</span><br><span class="line">w-监视器对象。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKWatcherExists</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String IP = <span class="string">&quot;192.168.52.131:2181&quot;</span>;</span><br><span class="line">    ZooKeeper zooKeeper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 连接zookeeper客户端</span></span><br><span class="line">        zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">6000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接对象的参数!&quot;</span>);</span><br><span class="line">                <span class="comment">// 连接成功</span></span><br><span class="line">                <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        zooKeeper.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherExists1</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// arg1:节点的路径</span></span><br><span class="line">        <span class="comment">// arg2:使用连接对象中的watcher</span></span><br><span class="line">        <span class="comment">//启动之后 再创建watcher1节点 控制台会显示出结果</span></span><br><span class="line">        zooKeeper.exists(<span class="string">&quot;/watcher1&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherExists2</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// arg1:节点的路径</span></span><br><span class="line">        <span class="comment">// arg2:自定义watcher对象</span></span><br><span class="line">        zooKeeper.exists(<span class="string">&quot;/watcher1&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;自定义watcher&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherExists3</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// watcher一次性</span></span><br><span class="line">        Watcher watcher = <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;自定义watcher&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    zooKeeper.exists(<span class="string">&quot;/watcher1&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        zooKeeper.exists(<span class="string">&quot;/watcher1&quot;</span>, watcher);</span><br><span class="line">        Thread.sleep(<span class="number">80000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherExists4</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 注册多个监听器对象</span></span><br><span class="line">        zooKeeper.exists(<span class="string">&quot;/watcher1&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        zooKeeper.exists(<span class="string">&quot;/watcher1&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(<span class="number">80000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看节点-1"><a href="#查看节点-1" class="headerlink" title="查看节点"></a>查看节点</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用连接对象的监视器</span></span><br><span class="line">get<span class="constructor">Data(String <span class="params">path</span>, <span class="params">boolean</span> <span class="params">b</span>, Stat <span class="params">stat</span>)</span></span><br><span class="line"><span class="comment">// 自定义监视器</span></span><br><span class="line">get<span class="constructor">Data(String <span class="params">path</span>, Watcher <span class="params">w</span>, Stat <span class="params">stat</span>)</span></span><br><span class="line"></span><br><span class="line">path- znode路径。</span><br><span class="line">b- 是否使用连接对象中注册的监视器。</span><br><span class="line">w-监视器对象。</span><br><span class="line">stat- 返回znode的元数据。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKWatcherGetData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String IP = <span class="string">&quot;192.168.60.130:2181&quot;</span>;</span><br><span class="line">    ZooKeeper zooKeeper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 连接zookeeper客户端</span></span><br><span class="line">        zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">6000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接对象的参数!&quot;</span>);</span><br><span class="line">                <span class="comment">// 连接成功</span></span><br><span class="line">                <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        zooKeeper.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetData1</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// arg1:节点的路径</span></span><br><span class="line">        <span class="comment">// arg2:使用连接对象中的watcher</span></span><br><span class="line">        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetData2</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// arg1:节点的路径</span></span><br><span class="line">        <span class="comment">// arg2:自定义watcher对象</span></span><br><span class="line">        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;自定义watcher&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">null</span>);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetData3</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 一次性</span></span><br><span class="line">        Watcher watcher = <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;自定义watcher&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    <span class="keyword">if</span>(event.getType()==Event.EventType.NodeDataChanged) &#123;</span><br><span class="line">                        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, watcher, <span class="keyword">null</span>);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetData4</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 注册多个监听器对象</span></span><br><span class="line">        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    <span class="keyword">if</span>(event.getType()==Event.EventType.NodeDataChanged) &#123;</span><br><span class="line">                        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">null</span>);</span><br><span class="line">        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    <span class="keyword">if</span>(event.getType()==Event.EventType.NodeDataChanged) &#123;</span><br><span class="line">                        zooKeeper.getData(<span class="string">&quot;/watcher2&quot;</span>, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">null</span>);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看子节点-1"><a href="#查看子节点-1" class="headerlink" title="查看子节点"></a>查看子节点</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">get<span class="constructor">Children(String <span class="params">path</span>, <span class="params">boolean</span> <span class="params">b</span>)</span></span><br><span class="line"></span><br><span class="line">get<span class="constructor">Children(String <span class="params">path</span>, Watcher <span class="params">w</span>)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKWatcherGetChild</span> </span>&#123;</span><br><span class="line">    String IP = <span class="string">&quot;192.168.60.130:2181&quot;</span>;</span><br><span class="line">    ZooKeeper zooKeeper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch connectedSemaphore = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 连接zookeeper客户端</span></span><br><span class="line">        zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">6000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接对象的参数!&quot;</span>);</span><br><span class="line">                <span class="comment">// 连接成功</span></span><br><span class="line">                <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                    connectedSemaphore.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        connectedSemaphore.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        zooKeeper.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetChild1</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// arg1:节点的路径</span></span><br><span class="line">        <span class="comment">// arg2:使用连接对象中的watcher</span></span><br><span class="line">        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetChild2</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// arg1:节点的路径</span></span><br><span class="line">        <span class="comment">// arg2:自定义watcher</span></span><br><span class="line">        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;自定义watcher&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetChild3</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 一次性</span></span><br><span class="line">        Watcher watcher = <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;自定义watcher&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    <span class="keyword">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">                        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, watcher);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watcherGetChild4</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 多个监视器对象</span></span><br><span class="line">        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    <span class="keyword">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">                        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;path=&quot;</span> + event.getPath());</span><br><span class="line">                    System.out.println(<span class="string">&quot;eventType=&quot;</span> + event.getType());</span><br><span class="line">                    <span class="keyword">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">                        zooKeeper.getChildren(<span class="string">&quot;/watcher3&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用zookeeper作为配置中心"><a href="#使用zookeeper作为配置中心" class="headerlink" title="使用zookeeper作为配置中心"></a>使用zookeeper作为配置中心</h2><p>设计思路： </p>
<ol>
<li>连接zookeeper服务器 </li>
<li>读取zookeeper中的配置信息，注册watcher监听器，存入本地变量 3</li>
<li>. 当zookeeper中的配置信息发生变化时，通过watcher的回调方法捕获数据变化事件 4. 重新获取配置信息</li>
</ol>
<p>首先要在zookeeper中创建相关的节点 存放配置信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfigCenter</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  zk的连接串</span></span><br><span class="line">    String IP = <span class="string">&quot;192.168.52.131:2181&quot;</span>;</span><br><span class="line">    <span class="comment">//  计数器对象</span></span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 连接对象</span></span><br><span class="line">    <span class="keyword">static</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于本地化存储配置信息</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 捕获事件状态</span></span><br><span class="line">            <span class="keyword">if</span> (event.getType() == EventType.None) &#123;</span><br><span class="line">                <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == Event.KeeperState.Disconnected) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接断开!&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == Event.KeeperState.Expired) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接超时!&quot;</span>);</span><br><span class="line">                    <span class="comment">// 超时后服务器端已经将连接释放，需要重新连接服务器端</span></span><br><span class="line">                    zooKeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;192.168.60.130:2181&quot;</span>, <span class="number">6000</span>,</span><br><span class="line">                            <span class="keyword">new</span> ZKConnectionWatcher());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == Event.KeeperState.AuthFailed) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;验证失败!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当配置信息发生变化时</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType() == EventType.NodeDataChanged) &#123;</span><br><span class="line">                initValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyConfigCenter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接zookeeper服务器，读取配置信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建连接对象</span></span><br><span class="line">            zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">5000</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 阻塞线程，等待连接的创建成功</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="comment">// 读取配置信息</span></span><br><span class="line">            <span class="keyword">this</span>.url = <span class="keyword">new</span> String(zooKeeper.getData(<span class="string">&quot;/config/url&quot;</span>, <span class="keyword">true</span>, <span class="keyword">null</span>));</span><br><span class="line">            <span class="keyword">this</span>.username = <span class="keyword">new</span> String(zooKeeper.getData(<span class="string">&quot;/config/username&quot;</span>, <span class="keyword">true</span>, <span class="keyword">null</span>));</span><br><span class="line">            <span class="keyword">this</span>.password = <span class="keyword">new</span> String(zooKeeper.getData(<span class="string">&quot;/config/password&quot;</span>, <span class="keyword">true</span>, <span class="keyword">null</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyConfigCenter myConfigCenter = <span class="keyword">new</span> MyConfigCenter();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;url:&quot;</span>+myConfigCenter.getUrl());</span><br><span class="line">                System.out.println(<span class="string">&quot;username:&quot;</span>+myConfigCenter.getUsername());</span><br><span class="line">                System.out.println(<span class="string">&quot;password:&quot;</span>+myConfigCenter.getPassword());</span><br><span class="line">                System.out.println(<span class="string">&quot;########################################&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成分布式唯一ID"><a href="#生成分布式唯一ID" class="headerlink" title="生成分布式唯一ID"></a>生成分布式唯一ID</h2><p>设计思路： </p>
<p>1.连接zookeeper服务器 </p>
<p>2.指定路径生成临时有序节点 </p>
<p>3.取序列号及为分布式环境下的唯一ID</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GloballyUniqueId</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  zk的连接串</span></span><br><span class="line">    String IP = <span class="string">&quot;192.168.52.131:2181&quot;</span>;</span><br><span class="line">    <span class="comment">//  计数器对象</span></span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//  用户生成序号的节点</span></span><br><span class="line">    String defaultPath = <span class="string">&quot;/uniqueId&quot;</span>;</span><br><span class="line">    <span class="comment">//  连接对象</span></span><br><span class="line">    ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 捕获事件状态</span></span><br><span class="line">            <span class="keyword">if</span> (event.getType() == Event.EventType.None) &#123;</span><br><span class="line">                <span class="keyword">if</span> (event.getState() == KeeperState.SyncConnected) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == KeeperState.Disconnected) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接断开!&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == KeeperState.Expired) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接超时!&quot;</span>);</span><br><span class="line">                    <span class="comment">// 超时后服务器端已经将连接释放，需要重新连接服务器端</span></span><br><span class="line">                    zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">6000</span>,</span><br><span class="line">                            <span class="keyword">new</span> ZKConnectionWatcher());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getState() == KeeperState.AuthFailed) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;验证失败!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GloballyUniqueId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//打开连接</span></span><br><span class="line">            zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">5000</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 阻塞线程，等待连接的创建成功</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成id的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUniqueId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String path = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建临时有序节点</span></span><br><span class="line">            path = zooKeeper.create(defaultPath, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// /uniqueId0000000001</span></span><br><span class="line">        <span class="keyword">return</span> path.substring(<span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GloballyUniqueId globallyUniqueId = <span class="keyword">new</span> GloballyUniqueId();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            String id = globallyUniqueId.getUniqueId();</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>设计思路：</p>
<p>1.每个客户端往/Locks下创建临时有序节点如/Locks/Lock_000000001 </p>
<p>2.客户端取得/Locks下子节点，并进行排序，判断排在最前面的是否为自己，如果自己的 锁节点在第一位，代表获取锁成功 </p>
<p>3.如果自己的锁节点不在第一位，则监听自己前一位的锁节点。例如，自己锁节点 Lock_000000001那么则监听锁几点Lock_000000002</p>
<p> 4.当前一位锁节点（Lock_000000001）对应的客户端完成执行完成，释放了锁，将会触发监听客户端（Lock_000000002）的逻辑</p>
<p> 5.监听客户端重新执行第2步逻辑，判断自己是否获得了锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  zk的连接串</span></span><br><span class="line">    String IP = <span class="string">&quot;192.168.60.130:2181&quot;</span>;</span><br><span class="line">    <span class="comment">//  计数器对象</span></span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//ZooKeeper配置信息</span></span><br><span class="line">    ZooKeeper zooKeeper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_ROOT_PATH = <span class="string">&quot;/Locks&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_NODE_NAME = <span class="string">&quot;Lock_&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String lockPath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开zookeeper连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">5000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getType() == Event.EventType.None) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;连接成功!&quot;</span>);</span><br><span class="line">                            countDownLatch.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建锁节点</span></span><br><span class="line">        createLock();</span><br><span class="line">        <span class="comment">//尝试获取锁</span></span><br><span class="line">        attemptLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建锁节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//判断Locks是否存在，不存在创建</span></span><br><span class="line">        Stat stat = zooKeeper.exists(LOCK_ROOT_PATH, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (stat == <span class="keyword">null</span>) &#123;</span><br><span class="line">            zooKeeper.create(LOCK_ROOT_PATH, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建临时有序节点</span></span><br><span class="line">        lockPath = zooKeeper.create(LOCK_ROOT_PATH + <span class="string">&quot;/&quot;</span> + LOCK_NODE_NAME, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        System.out.println(<span class="string">&quot;节点创建成功:&quot;</span> + lockPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监视器对象，监视上一个节点是否被删除</span></span><br><span class="line">    Watcher watcher = <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (event.getType() == Event.EventType.NodeDeleted) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attemptLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Locks节点下的所有子节点</span></span><br><span class="line">        List&lt;String&gt; list = zooKeeper.getChildren(LOCK_ROOT_PATH, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 对子节点进行排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="comment">// /Locks/Lock_000000001</span></span><br><span class="line">        <span class="keyword">int</span> index = list.indexOf(lockPath.substring(LOCK_ROOT_PATH.length() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取锁成功!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 上一个节点的路径</span></span><br><span class="line">            String path = list.get(index - <span class="number">1</span>);</span><br><span class="line">            Stat stat = zooKeeper.exists(LOCK_ROOT_PATH + <span class="string">&quot;/&quot;</span> + path, watcher);</span><br><span class="line">            <span class="keyword">if</span> (stat == <span class="keyword">null</span>) &#123;</span><br><span class="line">                attemptLock();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (watcher) &#123;</span><br><span class="line">                    watcher.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                attemptLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//删除临时有序节点</span></span><br><span class="line">            zooKeeper.delete(<span class="keyword">this</span>.lockPath,-<span class="number">1</span>);</span><br><span class="line">            zooKeeper.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;锁已经释放:&quot;</span>+<span class="keyword">this</span>.lockPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyLock myLock = <span class="keyword">new</span> MyLock();</span><br><span class="line">            myLock.createLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h1><p>事务需要跨多个分布式节点时，为了保证事务的ACID特性，需要选举出一个协调者来协调分布式各个节点的调度，基于这个思想衍生了多种一致性协议</p>
<h2 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h2><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210302193523354.png" alt="image-20210302193523354"></p>
<p>参与者提交后返回ack协调者再次提交 保证了一致性</p>
<p>中断事务：当有的参与者在任意阶段没有返回ack 参与者和协调者会回滚</p>
<p>二阶段提交存在的问题</p>
<ul>
<li>同步阻塞：二阶段提交过程中 所有参与事务的节点处于同步阻塞状态 无法进行其他操作</li>
<li>单点问题：一旦协调者出现单点故障 无法保证事务的一致性操作</li>
<li>脑裂导致数据不一致：如果分布式节点出现网络分区，某些参与者未收到commit提交命令或者选举了其他节点作为协调者。则出现部分参与者完成数据提交。未收到commit的命令的参与者则无法进行事务提交，整个分布式系统便出现了数据不一致性现象。</li>
</ul>
<h2 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h2><p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210302194659679.png" alt="image-20210302194659679"></p>
<p>阶段一：CanCommit</p>
<ol>
<li>事务询问</li>
<li>各参与者向协调者反馈事务询问的相应</li>
</ol>
<p>阶段二：PreCommit</p>
<p>根据阶段一的反馈结果分为两种情况</p>
<ol>
<li>执行事务预提交<ul>
<li>发送预提交请求：协调者向所有参与者发送preCommit请求，进入prepared阶段</li>
<li>事务预提交：各参与者节点接受到preCommit请求后，执行事务操作</li>
<li>各参与者节点向协调者反馈事务执行</li>
</ul>
</li>
<li>中断事务：任意一个参与者节点反馈给协调者响应No时，或者在等待超时后，协调者还未收到参与者的反馈，就中断事务，中断事务分为两步<ul>
<li>协调者向各个参与者节点发送abort请求</li>
<li>参与者收到abort请求，或者等待超时时间后，中断事务</li>
</ul>
</li>
</ol>
<p>阶段三：doCommit</p>
<ol>
<li>执行提交</li>
<li>中断事务</li>
</ol>
<p>三阶段中引入了超时时间解决了同步阻塞问题</p>
<p>当协调者故障的时候 参与者如果长时间接收不到参与者请求之后 会自动提交事务，解决了单点故障问题</p>
<p>无法解决脑裂问题</p>
<h2 id="paxos算法"><a href="#paxos算法" class="headerlink" title="paxos算法"></a>paxos算法</h2><p>paxos算法:基于消息传递且具有高度容错性的一种算法，是目前公认的解决分布式一致性问题最有效的算法</p>
<p>解决问题:在分布式系统中，如果产生容机或者网络异常情况，快速的正确的在集群内部对某个数据的值达成一致，并且不管发生任何异常，都不会破坏整个系统的一致性;</p>
<p>半数原则:少数服从多数</p>
<p>paxos中的四个角色</p>
<ul>
<li>client:系统外部角色，请求发起者，不参与决策</li>
<li>proposer:提案提议者</li>
<li>acceptor:提案的表决者，即是否accept该提案，只有超过半数以上的acceptor接受了提案，该提案才被认为被””选定”</li>
<li>learners:提案的学习者，当提案被选定后，其同步执行提案，不参与决策 </li>
</ul>
<p>两个阶段</p>
<ul>
<li>prepare阶段：<ul>
<li>proposer提出一个提案，编号为N,发送给所有的acceptor。</li>
<li>每个表决者都保存自己的accept的最大提案编号maxN，当表决者收到prepare(N)请求时，会比较N与maxN的值，若N小于maxN,则提案已过时，拒绝prepare(N)请求。若N大于等于maxN，则接受提案，并将该表决者曾经接受过的编号最大的提案Proposal(myid,maxN,value)反馈给提议者:其中myid表示表决者acceptor的标识id，maxN表示接受过的最大提案编号maxN,value表示提案内容。若当前表决者未曾accept任何提议，会将proposal(myid,null,null)反馈给提议者。</li>
</ul>
</li>
<li>accept阶段：<ul>
<li>提议者proposal发出prepare(N),若收到超过半数表决者acceptor的反馈，proposal将真正的提案内容proposal(N,value)发送给所有表决者。</li>
<li>表决者acceptor接受提议者发送的proposal(N,value)提案后，会将自己曾经accept过的最大提案编号maxN和反馈过的prepare的最大编号比较，若N大于这两个编号，则当前表决者accept该提案，并反馈给提议者。否则拒绝该提议。</li>
<li>若提议者没有收到半数以上的表决者accept反馈，则重新进入prepare阶段，递增提案编号，重新提出prepare请求。若收到半数以上的accept，则其他未向提议者反馈的表决者称为learner，主动同步提议者的提案。</li>
</ul>
</li>
</ul>
<p>正常流程</p>
<p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210302213055055.png" alt="image-20210302213055055"></p>
<p>单点故障，部分节点失败</p>
<p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210302213116146.png" alt="image-20210302213116146"></p>
<ul>
<li>虽然有一个acceptor挂掉 但是满足半数原则 仍可以继续执行</li>
</ul>
<p>proposer失败</p>
<p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210302213218757.png" alt="image-20210302213218757"></p>
<ul>
<li>会重新创建一个proposer 并且编号+1</li>
</ul>
<p>活锁问题</p>
<p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210302213549531.png" alt="image-20210302213549531"></p>
<p>当proposer1请求1的时候 proposer2请求2  当proposer1再请求的时候 编号小于2 重新执行第一阶段 请求3 这样两个proposer互相改变请求条件 谁都不能提交提议</p>
<p>解决方法： 执行时间错开</p>
<h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>由于paxos算法实现起来较难，存在活锁和全序问题（无法保证两次最终提交的顺序)，所以zookeeper并没有使用paxos作为一致性协议，而是使用了ZAB协议。</p>
<p>ZAB (zookeeper atomic broadcast) :是一种支持崩溃恢复的原子广播协议，基于Fast paxos实现</p>
<p>ZooKeeper使用单一主进程Leader用于处理客户端所有事务请求,，即写请求。当服务器数据发生变更好，集群采用ZAB原子广播协议，以事务提交proposal的形式广播到所有的副本进程，每一个事务分配一个全局的递增的事务编号xid。</p>
<p>若客户端提交的请求为读请求时，则接受请求的节点直接根据自己保存的数据响应。若是写请求，且当前节点不是leader，那么该节点就会将请求转发给leader，leader会以提案的方式广播此写请求，如果超过半数的节点同意写请求，则该写请求就会提交。leader会通知所有的订阅者同步数据。</p>
<p>zab协议 的全称是 Zookeeper Atomic Broadcast （zookeeper原子广播）。 zookeeper 是通过 zab协议来保证分布式事务的最终一致性</p>
<p>基于zab协议，zookeeper集群中的<strong>角色</strong>主要有以下三类，如下表所示：</p>
<p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210216193555107.png" alt="image-20210216193555107"></p>
<p>zab广播模式<strong>工作原理</strong>，通过类似两阶段提交协议的方式解决数据一致性：</p>
<p>一旦进入广播模式，集群中非leader节点接受到事务请求，首先会将事务请求转发给服务器，leader服务器为其生成对应的事务提案proposal,并发送给集群中其他节点，如果过半则事务提交;</p>
<p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210216194010598.png" alt="image-20210216194010598"></p>
<ol>
<li><p>leader接受到消息后，消息通过全局唯一的64位自增事务id，zxid标识</p>
</li>
<li><p>leader发送给follower的提案是有序的，leader会创建一个FIFO队列，将提案顺序写入队列中发送给follower</p>
</li>
<li><p>follower接受到提案后，会比较提案zxid和本地事务日志最大的zxid，若提案zxid比本地事务id大，将提案记录到本地日志中，反馈ack给leader，否则拒绝</p>
</li>
<li><p>leader接收到过半ack后，leader向所有的follower发送commit，通知每个follower执行本地事务</p>
</li>
</ol>
<p><strong>zookeeper两种模式</strong></p>
<ul>
<li>恢复模式<ul>
<li>当服务启动或领导崩溃后，zk进入恢复状态，选举leader，leader选出后，将完成leader和其他机器的数据同步，当大多数server完成和leader的同步后，恢复模式结束</li>
</ul>
</li>
<li>广播模式<ul>
<li>一旦Leader已经和多数的Follower进行了状态同步后，进入广播模式。进入广播模式后，如果有新加入的服务器，会自动从leader中同步数据。leader在接收客户端请求后，会生成事务提案广播给其他机器，有超过半数以上的follower同意该提议后，再提交事务。</li>
<li>再zab的二阶段提交中，移除了事务中断的逻辑，follower要么ack要么放弃，leader无需等待所有的follower的ack(因为有半数原则的支持)</li>
</ul>
</li>
</ul>
<p><strong>zxid</strong></p>
<p>zxid是64位长度的Long类型，其中高32位表示纪元epoch，低32位表示事务标识xid。即zxid由两部分构成: epoch和xid</p>
<p>每个leader都会具有不同的epoch值，表示一个纪元，每一个新的选举开启时都会生成一个新的epoch，新的leader产生，会更新所有的zkSeiezookeeper的leader选举</p>
<p><strong>服务器状态</strong></p>
<p>looking：寻找leader状态。当服务器处于该状态时，它会认为当前集群中没有 leader，因此需要进入leader选举状态。</p>
<p>leading： 领导者状态。表明当前服务器角色是leader。</p>
<p>following： 跟随者状态。表明当前服务器角色是follower。</p>
<p>observing：观察者状态。表明当前服务器角色是observer。</p>
<p><strong>服务器启动时期的leader选举</strong></p>
<p><img src="/2021/02/01/zookeeper/log\source_posts\zookeeper\image-20210303153439976.png" alt="image-20210303153439976"></p>
<p>如果leader挂掉，集群中其他follower会将状态改为looking重新进行选举</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>清除maven为下载成功的jar包</title>
    <url>/2021/01/12/%E6%B8%85%E9%99%A4maven%E4%B8%BA%E4%B8%8B%E8%BD%BD%E6%88%90%E5%8A%9F%E7%9A%84jar%E5%8C%85/</url>
    <content><![CDATA[<p>导入项目如果中途退出或者发生中断 刚下载一半的jar包会下载失败 需要手动清除</p>
<p>创建一个txt文件 把这段内容复制进入</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> REPOSITORY_PATH=D:\maven_repository</span><br><span class="line"><span class="comment">rem 正在搜索...</span></span><br><span class="line"><span class="keyword">for</span> /f &quot;delims=&quot; <span class="variable">%%i</span> <span class="keyword">in</span> (&#x27;<span class="built_in">dir</span> /b /s &quot;<span class="variable">%REPOSITORY_PATH%</span>\*lastUpdated*&quot;&#x27;) <span class="keyword">do</span> (</span><br><span class="line">    <span class="built_in">del</span> /s /q <span class="variable">%%i</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">rem 搜索完毕</span></span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<p>修改文件后缀为.bat 点击运行</p>
]]></content>
      <categories>
        <category>bug</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>解决chrome访问https网站出现您的连接不是私密的问题</title>
    <url>/2021/01/29/%E8%A7%A3%E5%86%B3chrome%E8%AE%BF%E9%97%AEhttps%E7%BD%91%E7%AB%99%E5%87%BA%E7%8E%B0%E6%82%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%98%AF%E7%A7%81%E5%AF%86%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天访问博客codebob111.github.io的时候chrome显示连接不是私密连接 无法访问</p>
<p><img src="%E8%A7%A3%E5%86%B3chrome%E8%AE%BF%E9%97%AEhttps%E7%BD%91%E7%AB%99%E5%87%BA%E7%8E%B0%E6%82%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%98%AF%E7%A7%81%E5%AF%86%E7%9A%84%E9%97%AE%E9%A2%98/image-20210129145042596.png" alt="image-20210129145042596"></p>
<p>在网上看了好多博客 最后终于找到了解决方法 开启使用安全dns并勾上第二个选项</p>
<p><img src="%E8%A7%A3%E5%86%B3chrome%E8%AE%BF%E9%97%AEhttps%E7%BD%91%E7%AB%99%E5%87%BA%E7%8E%B0%E6%82%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%98%AF%E7%A7%81%E5%AF%86%E7%9A%84%E9%97%AE%E9%A2%98/image-20210129145207994.png" alt="image-20210129145207994"></p>
]]></content>
      <categories>
        <category>bug</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch笔记</title>
    <url>/2020/11/14/elasticSearch%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="安装ik分词器"><a href="#安装ik分词器" class="headerlink" title="安装ik分词器"></a>安装ik分词器</h1><p>首先在docker中部署好es和kibana</p>
<p>在es中添加ik分词器插件:elasticsearch-plugin install <a href="https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.6.1/e">https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.6.1/e</a></p>
<p>重启es：docker restart id</p>
<h1 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h1><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">PUT <span class="regexp">/customer/</span>_doc/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET <span class="regexp">/customer/</span>_doc/<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="regexp">/customer/</span>_doc/<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>bulk操作</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">PUT /customer/_bulk</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:5&#125;&#125;  #action 可以是create update</span><br><span class="line">&#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:22&#125; #data</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:6&#125;&#125;</span><br><span class="line">&#123;&quot;delete&quot;:&#123;&quot;_index&quot;:&quot;customer&quot;,&quot;_id&quot;:1&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:22&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:7&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:29&#125;</span><br></pre></td></tr></table></figure>

<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p><strong>搜索所有字段并排序</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; </span><br><span class="line">  	&quot;match_all&quot;: &#123;&#125; </span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123; &quot;account_number&quot;: &quot;asc&quot; &#125;</span><br><span class="line">  ]</span><br><span class="line">  &quot;_source&quot;: &quot;[account_number]&quot; #指定返回的字段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>limit</strong>：下标从0开始</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123; &quot;account_number&quot;: &quot;asc&quot; &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;from&quot;: 10,</span><br><span class="line">  &quot;size&quot;: 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索指定字段： searches the <code>address</code> field to find customers whose addresses contain <code>mill</code> or <code>lane</code></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;mill lane&quot; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>搜索整个字段而不是词条</strong>：Only matches addresses that contain the phrase <code>mill lane</code></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;address&quot;: &quot;mill lane&quot; &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;address.keyword&quot;: &quot;mill lane&quot; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用bool条件查询</strong>：should,must,must not</p>
<p>For example, the following request searches the <code>bank</code> index for accounts that belong to customers who are 40 years old, but excludes anyone who lives in Idaho (ID)</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;age&quot;: &quot;40&quot; &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;state&quot;: &quot;ID&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>bool查询中也可以使用filter进行筛选</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">          &quot;balance&quot;: &#123;</span><br><span class="line">            &quot;gte&quot;: 20000,</span><br><span class="line">            &quot;lte&quot;: 30000</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>term:和match一样匹配某个属性的值 全文检索字段用match 其他字段匹配用term</p>
<h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><p>基本使用</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;group_by_state&quot;: &#123; #指定结果名称</span><br><span class="line">      &quot;terms&quot;: &#123; #指定聚合方法</span><br><span class="line">        &quot;field&quot;: &quot;state.keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子聚合</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;group_by_state&quot;: &#123; </span><br><span class="line">      &quot;terms&quot;: &#123; </span><br><span class="line">        &quot;field&quot;: &quot;state.keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;average_balance&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;balance&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在聚合中排序</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;group_by_state&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;state.keyword&quot;,</span><br><span class="line">        &quot;order&quot;: &#123;</span><br><span class="line">          &quot;average_balance&quot;: &quot;desc&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;average_balance&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;balance&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h1><p>创建映射</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">PUT /sutdent</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;properties&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;age&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span>&#125;,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>&#125;,</span><br><span class="line">      <span class="string">&quot;email&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加新的字段映射</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">PUT <span class="string">/student/_mapping</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;properties&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;gender&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">      <span class="string">&quot;index&quot;</span>: <span class="literal">false</span>, <span class="comment">#该字段不支持索引</span></span><br><span class="line">      <span class="string">&quot;doc_value&quot;</span>: <span class="literal">false</span> <span class="comment">#该字段不支持聚合</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不能修改索引 只能通过数据迁移的方式创建新的映射</p>
<p>迁移数据</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;index&quot;</span>:<span class="string">&quot;old&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;index&quot;</span>: <span class="string">&quot;new&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用分词器</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span>,</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;我是中国人&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;我是中国人&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Spring-Data-ElasticSearch"><a href="#Spring-Data-ElasticSearch" class="headerlink" title="Spring Data ElasticSearch"></a>Spring Data ElasticSearch</h1><p>导入jar包并修改版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.6.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>springboot 的版本2.x会报错</p>
<p>创建配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchClientConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">restHighLevelClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        <span class="keyword">new</span> HttpHost(<span class="string">&quot;192.168.52.131&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="狂神"><a href="#狂神" class="headerlink" title="狂神"></a>狂神</h2><h3 id="关于索引的API操作"><a href="#关于索引的API操作" class="headerlink" title="关于索引的API操作"></a>关于索引的API操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestHighLevelClient restHighLevelClient;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">creatIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//索引的创建</span></span><br><span class="line">    CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    restHighLevelClient.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    GetIndexRequest request = <span class="keyword">new</span> GetIndexRequest(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="keyword">boolean</span> exists = restHighLevelClient.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(exists);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DeleteIndexRequest request = <span class="keyword">new</span> DeleteIndexRequest(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    AcknowledgedResponse delete = restHighLevelClient.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(delete.isAcknowledged());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于文档的API操作"><a href="#关于文档的API操作" class="headerlink" title="关于文档的API操作"></a>关于文档的API操作</h3><p>创建一个pojo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Document(indexName = &quot;item&quot;,shards = 1, replicas = 0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Good</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String title; <span class="comment">//标题</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="keyword">private</span> String category;<span class="comment">// 分类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="keyword">private</span> String brand; <span class="comment">// 品牌</span></span><br><span class="line">	<span class="comment">//index默认为ture 如果不想索引该值可以设置为false</span></span><br><span class="line">    <span class="meta">@Field(index = false,type = FieldType.Double)</span></span><br><span class="line">    <span class="keyword">private</span> Double price; <span class="comment">// 价格</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="crud"><a href="#crud" class="headerlink" title="crud"></a>crud</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="built_in">public</span> <span class="type">void</span> addDocument() throws IOException &#123;</span><br><span class="line">    Good good = <span class="built_in">new</span> Good(<span class="number">1</span>L,&quot;测试商品&quot;,&quot;手机&quot;,&quot;apple&quot;,<span class="number">1000.0</span>);</span><br><span class="line">    IndexRequest request = <span class="built_in">new</span> IndexRequest(&quot;good&quot;);</span><br><span class="line">    request.id(&quot;1&quot;);</span><br><span class="line">    request.timeout(TimeValue.timeValueSeconds(<span class="number">1</span>));</span><br><span class="line">    request.timeout(&quot;1s&quot;);</span><br><span class="line">    //将我们的数据利用fastjson转换成<span class="type">json</span>并放入请求</span><br><span class="line">    request.source(<span class="type">JSON</span>.toJSONString(good), XContentType.JSON);</span><br><span class="line">    IndexResponse response = restHighLevelClient.<span class="keyword">index</span>(request, RequestOptions.<span class="keyword">DEFAULT</span>);</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(response.toString());</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line"><span class="built_in">public</span> <span class="type">void</span> getDocument() throws IOException &#123;</span><br><span class="line">    GetRequest request = <span class="built_in">new</span> GetRequest(&quot;good&quot;,&quot;1&quot;);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="keyword">exists</span> = restHighLevelClient.<span class="keyword">exists</span>(request, RequestOptions.<span class="keyword">DEFAULT</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">exists</span>)&#123;</span><br><span class="line">        GetResponse response = restHighLevelClient.<span class="keyword">get</span>(request, RequestOptions.<span class="keyword">DEFAULT</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(response.getSourceAsString());</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">exists</span>);</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line"><span class="built_in">public</span> <span class="type">void</span> deleteDocument() throws IOException &#123;</span><br><span class="line">    DeleteRequest request = <span class="built_in">new</span> DeleteRequest(&quot;good&quot;,&quot;1&quot;);</span><br><span class="line">    DeleteResponse response= restHighLevelClient.<span class="keyword">delete</span>(request, RequestOptions.<span class="keyword">DEFAULT</span>);</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(response.status());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="批量处理数据"><a href="#批量处理数据" class="headerlink" title="批量处理数据"></a>批量处理数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bulkRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BulkRequest request = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    request.timeout(<span class="string">&quot;10s&quot;</span>);</span><br><span class="line">    ArrayList&lt;Good&gt; goods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    goods.add(<span class="keyword">new</span> Good(<span class="number">1L</span>,<span class="string">&quot;测试商品&quot;</span>,<span class="string">&quot;手机&quot;</span>,<span class="string">&quot;apple&quot;</span>,<span class="number">1000.0</span>));</span><br><span class="line">    goods.add(<span class="keyword">new</span> Good(<span class="number">2L</span>,<span class="string">&quot;测试商品&quot;</span>,<span class="string">&quot;手机&quot;</span>,<span class="string">&quot;apple&quot;</span>,<span class="number">1000.0</span>));</span><br><span class="line">    goods.add(<span class="keyword">new</span> Good(<span class="number">3L</span>,<span class="string">&quot;测试商品&quot;</span>,<span class="string">&quot;手机&quot;</span>,<span class="string">&quot;apple&quot;</span>,<span class="number">1000.0</span>));</span><br><span class="line">    goods.add(<span class="keyword">new</span> Good(<span class="number">4L</span>,<span class="string">&quot;测试商品&quot;</span>,<span class="string">&quot;手机&quot;</span>,<span class="string">&quot;apple&quot;</span>,<span class="number">1000.0</span>));</span><br><span class="line">    goods.add(<span class="keyword">new</span> Good(<span class="number">5L</span>,<span class="string">&quot;测试商品&quot;</span>,<span class="string">&quot;手机&quot;</span>,<span class="string">&quot;apple&quot;</span>,<span class="number">1000.0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;goods.size();i++)&#123;</span><br><span class="line">        request.add(<span class="keyword">new</span> IndexRequest(<span class="string">&quot;good&quot;</span>).id(<span class="string">&quot;&quot;</span>+(i+<span class="number">1</span>)).source(JSON.toJSONString(goods.get(i)),XContentType.JSON));</span><br><span class="line">    &#125;</span><br><span class="line">    BulkResponse response = restHighLevelClient.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response.hasFailures());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">        <span class="comment">//构建搜索条件</span></span><br><span class="line">        SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;测试商品&quot;</span>);</span><br><span class="line"><span class="comment">//        MatchAllQueryBuilder matchAllQueryBuilder = QueryBuilders.matchAllQuery();</span></span><br><span class="line">        sourceBuilder.query(termQueryBuilder);</span><br><span class="line">        <span class="comment">//构建分页</span></span><br><span class="line">        request.source(sourceBuilder);</span><br><span class="line">        SearchResponse searchResponse = restHighLevelClient.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="keyword">for</span>(SearchHit documentFields:searchResponse.getHits().getHits())&#123;</span><br><span class="line">            System.out.println(documentFields.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="黑马"><a href="#黑马" class="headerlink" title="黑马"></a>黑马</h2><h3 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h3><h4 id="新增和更新"><a href="#新增和更新" class="headerlink" title="新增和更新"></a>新增和更新</h4><p>Spring Data 的强大之处，就在于你不用写任何DAO处理，自动根据方法名或类的信息进行CRUD操作。只要你定义一个接口，然后继承Repository提供的一些子接口，就能具备各种基本的CRUD功能。</p>
<p>我们只需要定义接口，然后继承它就OK了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GoodRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Good</span>,<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增和批量新增</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Good good = <span class="keyword">new</span> Good(<span class="number">10L</span>, <span class="string">&quot;小米手机7&quot;</span>, <span class="string">&quot; 手机&quot;</span>, <span class="string">&quot;小米&quot;</span>, <span class="number">3499.00</span>);</span><br><span class="line">    goodRepository.save(good);</span><br><span class="line">    List&lt;Good&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(good);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Good&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> Good(<span class="number">2L</span>, <span class="string">&quot;坚果手机R1&quot;</span>, <span class="string">&quot; 手机&quot;</span>, <span class="string">&quot;锤子&quot;</span>, <span class="number">3699.00</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Good(<span class="number">3L</span>, <span class="string">&quot;华为META10&quot;</span>, <span class="string">&quot; 手机&quot;</span>, <span class="string">&quot;华为&quot;</span>, <span class="number">4499.00</span>));</span><br><span class="line">    <span class="comment">// 接收对象集合，实现批量新增</span></span><br><span class="line">    goodRepository.saveAll(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findById</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Optional&lt;Good&gt; optional = goodRepository.findById(<span class="number">1l</span>);</span><br><span class="line">    System.out.println(optional.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 查询全部，并按照价格降序排序</span></span><br><span class="line">    Iterable&lt;Good&gt; items = goodRepository.findAll(Sort.by(Sort.Direction.DESC, <span class="string">&quot;price&quot;</span>));</span><br><span class="line">    items.forEach(good -&gt; System.out.println(good));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h4><p>Spring Data 的另一个强大功能，是根据方法名称自动实现功能。</p>
<p>比如：你的方法名叫做：findByTitle，那么它就知道你是根据title查询，然后自动帮你完成，无需写实现类。</p>
<p>当然，方法名称要符合一定的约定：</p>
<table>
<thead>
<tr>
<th>Keyword</th>
<th>Sample</th>
<th>Elasticsearch Query String</th>
</tr>
</thead>
<tbody><tr>
<td><code>And</code></td>
<td><code>findByNameAndPrice</code></td>
<td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : [ &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125;, &#123;&quot;field&quot; : &#123;&quot;price&quot; : &quot;?&quot;&#125;&#125; ]&#125;&#125;</code></td>
</tr>
<tr>
<td><code>Or</code></td>
<td><code>findByNameOrPrice</code></td>
<td><code>&#123;&quot;bool&quot; : &#123;&quot;should&quot; : [ &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125;, &#123;&quot;field&quot; : &#123;&quot;price&quot; : &quot;?&quot;&#125;&#125; ]&#125;&#125;</code></td>
</tr>
<tr>
<td><code>Is</code></td>
<td><code>findByName</code></td>
<td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125;&#125;&#125;</code></td>
</tr>
<tr>
<td><code>Not</code></td>
<td><code>findByNameNot</code></td>
<td><code>&#123;&quot;bool&quot; : &#123;&quot;must_not&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125;&#125;&#125;</code></td>
</tr>
<tr>
<td><code>Between</code></td>
<td><code>findByPriceBetween</code></td>
<td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;range&quot; : &#123;&quot;price&quot; : &#123;&quot;from&quot; : ?,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true&#125;&#125;&#125;&#125;&#125;</code></td>
</tr>
<tr>
<td><code>LessThanEqual</code></td>
<td><code>findByPriceLessThan</code></td>
<td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;range&quot; : &#123;&quot;price&quot; : &#123;&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true&#125;&#125;&#125;&#125;&#125;</code></td>
</tr>
<tr>
<td><code>GreaterThanEqual</code></td>
<td><code>findByPriceGreaterThan</code></td>
<td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;range&quot; : &#123;&quot;price&quot; : &#123;&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true&#125;&#125;&#125;&#125;&#125;</code></td>
</tr>
<tr>
<td><code>Before</code></td>
<td><code>findByPriceBefore</code></td>
<td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;range&quot; : &#123;&quot;price&quot; : &#123;&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true&#125;&#125;&#125;&#125;&#125;</code></td>
</tr>
<tr>
<td><code>After</code></td>
<td><code>findByPriceAfter</code></td>
<td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;range&quot; : &#123;&quot;price&quot; : &#123;&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true&#125;&#125;&#125;&#125;&#125;</code></td>
</tr>
<tr>
<td><code>Like</code></td>
<td><code>findByNameLike</code></td>
<td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &#123;&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true&#125;&#125;&#125;&#125;&#125;</code></td>
</tr>
<tr>
<td><code>StartingWith</code></td>
<td><code>findByNameStartingWith</code></td>
<td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &#123;&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true&#125;&#125;&#125;&#125;&#125;</code></td>
</tr>
<tr>
<td><code>EndingWith</code></td>
<td><code>findByNameEndingWith</code></td>
<td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &#123;&quot;query&quot; : &quot;*?&quot;,&quot;analyze_wildcard&quot; : true&#125;&#125;&#125;&#125;&#125;</code></td>
</tr>
<tr>
<td><code>Contains/Containing</code></td>
<td><code>findByNameContaining</code></td>
<td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &#123;&quot;query&quot; : &quot;**?**&quot;,&quot;analyze_wildcard&quot; : true&#125;&#125;&#125;&#125;&#125;</code></td>
</tr>
<tr>
<td><code>In</code></td>
<td><code>findByNameIn(Collection&lt;String&gt;names)</code></td>
<td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;bool&quot; : &#123;&quot;should&quot; : [ &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125;, &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125; ]&#125;&#125;&#125;&#125;</code></td>
</tr>
<tr>
<td><code>NotIn</code></td>
<td><code>findByNameNotIn(Collection&lt;String&gt;names)</code></td>
<td><code>&#123;&quot;bool&quot; : &#123;&quot;must_not&quot; : &#123;&quot;bool&quot; : &#123;&quot;should&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125;&#125;&#125;&#125;&#125;</code></td>
</tr>
<tr>
<td><code>Near</code></td>
<td><code>findByStoreNear</code></td>
<td><code>Not Supported Yet !</code></td>
</tr>
<tr>
<td><code>True</code></td>
<td><code>findByAvailableTrue</code></td>
<td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;available&quot; : true&#125;&#125;&#125;&#125;</code></td>
</tr>
<tr>
<td><code>False</code></td>
<td><code>findByAvailableFalse</code></td>
<td><code>&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;available&quot; : false&#125;&#125;&#125;&#125;</code></td>
</tr>
<tr>
<td><code>OrderBy</code></td>
<td><code>findByAvailableTrueOrderByNameDesc</code></td>
<td><code>&#123;&quot;sort&quot; : [&#123; &quot;name&quot; : &#123;&quot;order&quot; : &quot;desc&quot;&#125; &#125;],&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;available&quot; : true&#125;&#125;&#125;&#125;</code></td>
</tr>
</tbody></table>
<p>例如，我们来按照价格区间查询，定义这样的一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ItemRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Item</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据价格区间查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> price1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> price2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Item&gt; <span class="title">findByPriceBetween</span><span class="params">(<span class="keyword">double</span> price1, <span class="keyword">double</span> price2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后添加一些测试数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">indexList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Item&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> Item(<span class="number">1L</span>, <span class="string">&quot;小米手机7&quot;</span>, <span class="string">&quot;手机&quot;</span>, <span class="string">&quot;小米&quot;</span>, <span class="number">3299.00</span>, <span class="string">&quot;http://image.leyou.com/13123.jpg&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Item(<span class="number">2L</span>, <span class="string">&quot;坚果手机R1&quot;</span>, <span class="string">&quot;手机&quot;</span>, <span class="string">&quot;锤子&quot;</span>, <span class="number">3699.00</span>, <span class="string">&quot;http://image.leyou.com/13123.jpg&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Item(<span class="number">3L</span>, <span class="string">&quot;华为META10&quot;</span>, <span class="string">&quot;手机&quot;</span>, <span class="string">&quot;华为&quot;</span>, <span class="number">4499.00</span>, <span class="string">&quot;http://image.leyou.com/13123.jpg&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Item(<span class="number">4L</span>, <span class="string">&quot;小米Mix2S&quot;</span>, <span class="string">&quot;手机&quot;</span>, <span class="string">&quot;小米&quot;</span>, <span class="number">4299.00</span>, <span class="string">&quot;http://image.leyou.com/13123.jpg&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Item(<span class="number">5L</span>, <span class="string">&quot;荣耀V10&quot;</span>, <span class="string">&quot;手机&quot;</span>, <span class="string">&quot;华为&quot;</span>, <span class="number">2799.00</span>, <span class="string">&quot;http://image.leyou.com/13123.jpg&quot;</span>));</span><br><span class="line">    <span class="comment">// 接收对象集合，实现批量新增</span></span><br><span class="line">    itemRepository.saveAll(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>不需要写实现类，然后我们直接去运行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryByPriceBetween</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Item&gt; list = <span class="keyword">this</span>.itemRepository.findByPriceBetween(<span class="number">2000.00</span>, <span class="number">3500.00</span>);</span><br><span class="line">    <span class="keyword">for</span> (Item item : list) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;item = &quot;</span> + item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2020/11/14/elasticSearch%E7%AC%94%E8%AE%B0/log\source_posts\elasticSearch笔记\1531993518230.png" alt="1531993518230"></p>
<p>虽然基本查询和自定义方法已经很强大了，但是如果是复杂查询（模糊、通配符、词条查询等）就显得力不从心了。此时，我们只能使用原生查询。</p>
<h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><h4 id="基本查询-1"><a href="#基本查询-1" class="headerlink" title="基本查询"></a>基本查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 词条查询</span></span><br><span class="line">    MatchQueryBuilder queryBuilder = QueryBuilders.matchQuery(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;小米&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行查询</span></span><br><span class="line">    Iterable&lt;Good&gt; items = goodRepository.search(queryBuilder);</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>QueryBuilders提供了大量的静态方法，用于生成各种不同类型的查询对象，例如：词条、模糊、通配符等QueryBuilder对象。</p>
<h4 id="自定义查询"><a href="#自定义查询" class="headerlink" title="自定义查询"></a>自定义查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNativeQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构建查询条件</span></span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">// 添加基本的分词查询</span></span><br><span class="line">    queryBuilder.withQuery(QueryBuilders.matchQuery(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;小米&quot;</span>));</span><br><span class="line">    <span class="comment">// 执行搜索，获取结果</span></span><br><span class="line">    Page&lt;Good&gt; items = goodRepository.search(queryBuilder.build());</span><br><span class="line">    <span class="comment">// 打印总条数</span></span><br><span class="line">    System.out.println(items.getTotalElements());</span><br><span class="line">    <span class="comment">// 打印总页数</span></span><br><span class="line">    System.out.println(items.getTotalPages());</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NativeSearchQueryBuilder：Spring提供的一个查询条件构建器，帮助构建json格式的请求体</p>
<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNativeQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构建查询条件</span></span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">// 添加基本的分词查询</span></span><br><span class="line">    queryBuilder.withQuery(QueryBuilders.termQuery(<span class="string">&quot;category&quot;</span>, <span class="string">&quot;手机&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化分页参数</span></span><br><span class="line">    <span class="keyword">int</span> page = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 设置分页参数</span></span><br><span class="line">    queryBuilder.withPageable(PageRequest.of(page, size));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行搜索，获取结果</span></span><br><span class="line">    Page&lt;Item&gt; items = <span class="keyword">this</span>.itemRepository.search(queryBuilder.build());</span><br><span class="line">    <span class="comment">// 打印总条数</span></span><br><span class="line">    System.out.println(items.getTotalElements());</span><br><span class="line">    <span class="comment">// 打印总页数</span></span><br><span class="line">    System.out.println(items.getTotalPages());</span><br><span class="line">    <span class="comment">// 每页大小</span></span><br><span class="line">    System.out.println(items.getSize());</span><br><span class="line">    <span class="comment">// 当前页</span></span><br><span class="line">    System.out.println(items.getNumber());</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构建查询条件</span></span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">// 添加基本的分词查询</span></span><br><span class="line">    queryBuilder.withQuery(QueryBuilders.termQuery(<span class="string">&quot;category&quot;</span>, <span class="string">&quot;手机&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    queryBuilder.withSort(SortBuilders.fieldSort(<span class="string">&quot;price&quot;</span>).order(SortOrder.DESC));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行搜索，获取结果</span></span><br><span class="line">    Page&lt;Item&gt; items = <span class="keyword">this</span>.itemRepository.search(queryBuilder.build());</span><br><span class="line">    <span class="comment">// 打印总条数</span></span><br><span class="line">    System.out.println(items.getTotalElements());</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="聚合-1"><a href="#聚合-1" class="headerlink" title="聚合"></a>聚合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAgg</span><span class="params">()</span></span>&#123;</span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">// 不查询任何结果</span></span><br><span class="line">    queryBuilder.withSourceFilter(<span class="keyword">new</span> FetchSourceFilter(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;&quot;</span>&#125;, <span class="keyword">null</span>));</span><br><span class="line">    <span class="comment">// 1、添加一个新的聚合，聚合类型为terms，聚合名称为brands，聚合字段为brand</span></span><br><span class="line">    queryBuilder.addAggregation(</span><br><span class="line">        AggregationBuilders.terms(<span class="string">&quot;brands&quot;</span>).field(<span class="string">&quot;brand&quot;</span>));</span><br><span class="line">    <span class="comment">// 2、查询,需要把结果强转为AggregatedPage类型</span></span><br><span class="line">    AggregatedPage&lt;Item&gt; aggPage = (AggregatedPage&lt;Item&gt;) <span class="keyword">this</span>.itemRepository.search(queryBuilder.build());</span><br><span class="line">    <span class="comment">// 3、解析</span></span><br><span class="line">    <span class="comment">// 3.1、从结果中取出名为brands的那个聚合，</span></span><br><span class="line">    <span class="comment">// 因为是利用String类型字段来进行的term聚合，所以结果要强转为StringTerm类型</span></span><br><span class="line">    StringTerms agg = (StringTerms) aggPage.getAggregation(<span class="string">&quot;brands&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.2、获取桶</span></span><br><span class="line">    List&lt;StringTerms.Bucket&gt; buckets = agg.getBuckets();</span><br><span class="line">    <span class="comment">// 3.3、遍历</span></span><br><span class="line">    <span class="keyword">for</span> (StringTerms.Bucket bucket : buckets) &#123;</span><br><span class="line">        <span class="comment">// 3.4、获取桶中的key，即品牌名称</span></span><br><span class="line">        System.out.println(bucket.getKeyAsString());</span><br><span class="line">        <span class="comment">// 3.5、获取桶中的文档数量</span></span><br><span class="line">        System.out.println(bucket.getDocCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嵌套聚合求平均值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSubAgg</span><span class="params">()</span></span>&#123;</span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">// 不查询任何结果</span></span><br><span class="line">    queryBuilder.withSourceFilter(<span class="keyword">new</span> FetchSourceFilter(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;&quot;</span>&#125;, <span class="keyword">null</span>));</span><br><span class="line">    <span class="comment">// 1、添加一个新的聚合，聚合类型为terms，聚合名称为brands，聚合字段为brand</span></span><br><span class="line">    queryBuilder.addAggregation(</span><br><span class="line">        AggregationBuilders.terms(<span class="string">&quot;brands&quot;</span>).field(<span class="string">&quot;brand&quot;</span>)</span><br><span class="line">        .subAggregation(AggregationBuilders.avg(<span class="string">&quot;priceAvg&quot;</span>).field(<span class="string">&quot;price&quot;</span>)) <span class="comment">// 在品牌聚合桶内进行嵌套聚合，求平均值</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 2、查询,需要把结果强转为AggregatedPage类型</span></span><br><span class="line">    AggregatedPage&lt;Item&gt; aggPage = (AggregatedPage&lt;Item&gt;) <span class="keyword">this</span>.itemRepository.search(queryBuilder.build());</span><br><span class="line">    <span class="comment">// 3、解析</span></span><br><span class="line">    <span class="comment">// 3.1、从结果中取出名为brands的那个聚合，</span></span><br><span class="line">    <span class="comment">// 因为是利用String类型字段来进行的term聚合，所以结果要强转为StringTerm类型</span></span><br><span class="line">    StringTerms agg = (StringTerms) aggPage.getAggregation(<span class="string">&quot;brands&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.2、获取桶</span></span><br><span class="line">    List&lt;StringTerms.Bucket&gt; buckets = agg.getBuckets();</span><br><span class="line">    <span class="comment">// 3.3、遍历</span></span><br><span class="line">    <span class="keyword">for</span> (StringTerms.Bucket bucket : buckets) &#123;</span><br><span class="line">        <span class="comment">// 3.4、获取桶中的key，即品牌名称  3.5、获取桶中的文档数量</span></span><br><span class="line">        System.out.println(bucket.getKeyAsString() + <span class="string">&quot;，共&quot;</span> + bucket.getDocCount() + <span class="string">&quot;台&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.6.获取子聚合结果：</span></span><br><span class="line">        InternalAvg avg = (InternalAvg) bucket.getAggregations().asMap().get(<span class="string">&quot;priceAvg&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;平均售价：&quot;</span> + avg.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>python</title>
    <url>/2020/10/15/python/</url>
    <content><![CDATA[<h1 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h1><p>Python解释器作⽤：运⾏⽂件</p>
<p>Python解释器种类</p>
<ul>
<li>CPython，C语⾔开发的解释器[官⽅]，应⽤⼴泛的解释器。</li>
<li>IPython，基于CPython的⼀种交互式解释器。</li>
<li>其他解释器<ul>
<li>PyPy，基于Python语⾔开发的解释器</li>
<li>Jython，运⾏在Java平台的解释器，直接把Python代码编译成Java字节码执⾏。</li>
<li>IronPython，运⾏在微软.Net平台上的Python解释器，可以直接把Python代码编译 成.Net的字节码。</li>
</ul>
</li>
</ul>
<h1 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h1><p>用于开发python的idea</p>
<p><img src="/2020/10/15/python/image-20201017081925205.png" alt="image-20201017081925205"></p>
<p>python文件的后缀名为.py</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>单行注释</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注释内容</span></span><br></pre></td></tr></table></figure>

<p>多行注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line"> 第⼀⾏注释</span><br><span class="line"> 第⼆⾏注释</span><br><span class="line"> 第三⾏注释</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"> 注释1</span><br><span class="line"> 注释2</span><br><span class="line"> 注释3</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>标识符</p>
<p><img src="/2020/10/15/python/image-20201017084416324.png" alt="image-20201017084416324"></p>
<p>定义变量 ： 变量名 = 值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#结尾不用分号</span></span><br><span class="line">myName = <span class="string">&#x27;bob&#x27;</span></span><br><span class="line">print(myName)</span><br></pre></td></tr></table></figure>

<p>数据类型</p>
<p><img src="/2020/10/15/python/image-20201017085032072.png" alt="image-20201017085032072"></p>
<p>可以使用type()检测数据类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myName = <span class="string">&#x27;bob&#x27;</span></span><br><span class="line">print(type(myName))</span><br></pre></td></tr></table></figure>

<h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><p><img src="/2020/10/15/python/image-20201017085215273.png" alt="image-20201017085215273"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myName = <span class="string">&#x27;bob&#x27;</span></span><br><span class="line">print(<span class="string">&#x27;我的名字是%s&#x27;</span> % myName)</span><br></pre></td></tr></table></figure>

<p>转义字符： \n换行 \t 制表符</p>
<p>python中print()自带换行符 </p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>语法 : <code>input(提示信息)</code></p>
<p>输入的特点</p>
<ul>
<li>当程序执⾏到 input ，等待⽤户输⼊，输⼊完成之后才继续向下执⾏。</li>
<li>在Python中， input 接收⽤户输⼊后，⼀般存储到变量，⽅便使⽤。</li>
<li>在Python中， input 会把接收到的任意⽤户输⼊的数据都当做字符串处理</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">passWord = input(<span class="string">&quot;请输入密码&quot;</span>)</span><br><span class="line">print(<span class="string">&#x27;您输入的密码是%s&#x27;</span> % passWord)</span><br><span class="line">print(type(passWord))</span><br></pre></td></tr></table></figure>

<h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><p>数据类型转换的函数</p>
<p><img src="/2020/10/15/python/image-20201017090403401.png" alt="image-20201017090403401"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = input(<span class="string">&quot;请输入&quot;</span>)</span><br><span class="line">print(type(int(x)))</span><br></pre></td></tr></table></figure>

<p>元组tuple:(x1,x2,x3) 序列list:(x1,x2,x3)</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>算数运算符</p>
<p><img src="/2020/10/15/python/image-20201017091851957.png" alt="image-20201017091851957"></p>
<ul>
<li>混合运算符优先级顺序： () ⾼于 ** ⾼于 * / // % ⾼于 + -</li>
</ul>
<p>多个变量赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num1, float1, str1 = <span class="number">10</span>, <span class="number">0.5</span>, <span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure>

<p>复合赋值运算符</p>
<p><img src="/2020/10/15/python/image-20201017092209169.png" alt="image-20201017092209169"></p>
<p>比较运算符</p>
<p><img src="/2020/10/15/python/image-20201017092236556.png" alt="image-20201017092236556"></p>
<p>逻辑运算符</p>
<p><img src="/2020/10/15/python/image-20201017092254611.png" alt="image-20201017092254611"></p>
<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = int(input(<span class="string">&quot;请输入数字&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">70</span>:</span><br><span class="line">        print(<span class="string">&#x27;快要入土80&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> x &lt; <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">&quot;毛头小子&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;其他&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>三目运算符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>

<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>break 和 continue</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">5</span>:</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">3</span> : <span class="keyword">break</span>;</span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line">print(<span class="string">&#x27;任务结束&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&#x27;bob&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line"> print(i)</span><br></pre></td></tr></table></figure>

<h2 id="while…else"><a href="#while…else" class="headerlink" title="while…else"></a>while…else</h2><p> else 循环可以和else配合使⽤，else下⽅缩进的代码指的是当循环正常结束之后要执⾏的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">5</span>:</span><br><span class="line"> print(<span class="string">&#x27;老师，我错了&#x27;</span>)</span><br><span class="line"> i += <span class="number">1</span></span><br><span class="line">print(<span class="string">&#x27;老师原谅我了...&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>相似的还有for…else</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">name = <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="comment"># 三引号形式的字符串⽀持换⾏</span></span><br><span class="line">name = <span class="string">&quot;&quot;&quot;tom&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#创建字符串 i&#x27;m tom</span></span><br><span class="line">name = <span class="string">&quot;i&#x27;m tom&quot;</span></span><br><span class="line">name = <span class="string">&#x27;i\&#x27;m tom&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a><strong>下标</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&#x27;bob&#x27;</span></span><br><span class="line">print(str1[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a><strong>切片</strong></h2><p>切⽚是指对操作的对象截取其中⼀部分的操作。字符串、列表、元组都⽀持切⽚操作。</p>
<p>语法 <code>序列[开始位置下标:结束位置下标:步⻓]</code></p>
<ul>
<li>不包含结束位置下标对应的数据， 正负整数均可；</li>
<li>步⻓是选取间隔，正负整数均可，默认步⻓为1</li>
</ul>
<p><img src="/2020/10/15/python/image-20201017094414821.png" alt="image-20201017094414821"></p>
<h2 id="常用操作方法"><a href="#常用操作方法" class="headerlink" title="常用操作方法"></a><strong>常用操作方法</strong></h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>find()：检测某个⼦串是否包含在这个字符串中，如果在返回这个⼦串开始的位置下标，否则则返 回-1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">语法:字符串序列.find(⼦串, 开始位置下标, 结束位置下标)</span><br><span class="line">mystr = <span class="string">&quot;hello world and itcast and itheima and Python&quot;</span></span><br><span class="line">print(mystr.find(<span class="string">&#x27;and&#x27;</span>)) <span class="comment"># 12</span></span><br><span class="line">print(mystr.find(<span class="string">&#x27;and&#x27;</span>, <span class="number">15</span>, <span class="number">30</span>)) <span class="comment"># 23</span></span><br><span class="line">print(mystr.find(<span class="string">&#x27;ands&#x27;</span>)) <span class="comment"># -1</span></span><br><span class="line">注意：开始和结束位置下标可以省略，表示在整个字符串序列中查找。</span><br></pre></td></tr></table></figure>

<p>index()：检测某个⼦串是否包含在这个字符串中，如果在返回这个⼦串开始的位置下标，否则则 报异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串序列.index(⼦串, 开始位置下标, 结束位置下标)</span><br><span class="line">mystr = <span class="string">&quot;hello world and itcast and itheima and Python&quot;</span></span><br><span class="line">print(mystr.index(<span class="string">&#x27;and&#x27;</span>)) <span class="comment"># 12</span></span><br><span class="line">print(mystr.index(<span class="string">&#x27;and&#x27;</span>, <span class="number">15</span>, <span class="number">30</span>)) <span class="comment"># 23</span></span><br><span class="line">print(mystr.index(<span class="string">&#x27;ands&#x27;</span>)) <span class="comment"># 报错</span></span><br><span class="line">注意：开始和结束位置下标可以省略，表示在整个字符串序列中查找。</span><br></pre></td></tr></table></figure>

<p>rfind()： 和find()功能相同，但查找⽅向为右侧开始。</p>
<p>rindex()：和index()功能相同，但查找⽅向为右侧开始</p>
<p>count()：返回某个⼦串在字符串中出现的次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串序列.count(⼦串, 开始位置下标, 结束位置下标)</span><br><span class="line">mystr = <span class="string">&quot;hello world and itcast and itheima and Python&quot;</span></span><br><span class="line">print(mystr.count(<span class="string">&#x27;and&#x27;</span>)) <span class="comment"># 3</span></span><br><span class="line">print(mystr.count(<span class="string">&#x27;ands&#x27;</span>)) <span class="comment"># 0</span></span><br><span class="line">print(mystr.count(<span class="string">&#x27;and&#x27;</span>, <span class="number">0</span>, <span class="number">20</span>)) <span class="comment"># 1</span></span><br><span class="line">注意：开始和结束位置下标可以省略，表示在整个字符串序列中查找。</span><br></pre></td></tr></table></figure>

<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>replace()：替换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串序列.replace(旧⼦串, 新⼦串, 替换次数)</span><br><span class="line">mystr = <span class="string">&quot;hello world and itcast and itheima and Python&quot;</span></span><br><span class="line"><span class="comment"># 结果：hello world he itcast he itheima he Python</span></span><br><span class="line">print(mystr.replace(<span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;he&#x27;</span>))</span><br><span class="line"><span class="comment"># 结果：hello world he itcast he itheima he Python</span></span><br><span class="line">print(mystr.replace(<span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;he&#x27;</span>, <span class="number">10</span>))</span><br><span class="line"><span class="comment"># 结果：hello world and itcast and itheima and Python</span></span><br><span class="line">print(mystr)</span><br><span class="line">数据按照是否能直接修改分为可变类型和不可变类型两种。字符串类型的数据修改的时候</span><br><span class="line">不能改变原有字符串，属于不能直接修改数据的类型即是不可变类型</span><br></pre></td></tr></table></figure>

<p>split()：按照指定字符分割字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串序列.split(分割字符, num)</span><br><span class="line">num表示的是分割字符出现的次数，即将来返回数据个数为num+<span class="number">1</span>个。</span><br><span class="line">mystr = <span class="string">&quot;hello world and itcast and itheima and Python&quot;</span></span><br><span class="line"><span class="comment"># 结果：[&#x27;hello world &#x27;, &#x27; itcast &#x27;, &#x27; itheima &#x27;, &#x27; Python&#x27;]</span></span><br><span class="line">print(mystr.split(<span class="string">&#x27;and&#x27;</span>))</span><br><span class="line"><span class="comment"># 结果：[&#x27;hello world &#x27;, &#x27; itcast &#x27;, &#x27; itheima and Python&#x27;]</span></span><br><span class="line">print(mystr.split(<span class="string">&#x27;and&#x27;</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># 结果：[&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;and&#x27;, &#x27;itcast&#x27;, &#x27;and&#x27;, &#x27;itheima&#x27;, &#x27;and&#x27;, &#x27;Python&#x27;]</span></span><br><span class="line">print(mystr.split(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line"><span class="comment"># 结果：[&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;and itcast and itheima and Python&#x27;]</span></span><br><span class="line">print(mystr.split(<span class="string">&#x27; &#x27;</span>, <span class="number">2</span>))</span><br><span class="line">如果分割字符是原有字符串中的⼦串，分割后则丢失该⼦串。</span><br></pre></td></tr></table></figure>

<p>join()：⽤⼀个字符或⼦串合并字符串，即是将多个字符串合并为⼀个新的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符或⼦串.join(多字符串组成的序列)</span><br><span class="line">list1 = [<span class="string">&#x27;chuan&#x27;</span>, <span class="string">&#x27;zhi&#x27;</span>, <span class="string">&#x27;bo&#x27;</span>, <span class="string">&#x27;ke&#x27;</span>]</span><br><span class="line">t1 = (<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;ddd&#x27;</span>)</span><br><span class="line"><span class="comment"># 结果：chuan_zhi_bo_ke</span></span><br><span class="line">print(<span class="string">&#x27;_&#x27;</span>.join(list1))</span><br><span class="line"><span class="comment"># 结果：aa...b...cc...ddd</span></span><br><span class="line">print(<span class="string">&#x27;...&#x27;</span>.join(t1))</span><br></pre></td></tr></table></figure>

<p>capitalize()：将字符串第⼀个字符转换成⼤写。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr = <span class="string">&quot;hello world and itcast and itheima and Python&quot;</span></span><br><span class="line"><span class="comment"># 结果：Hello world and itcast and itheima and python</span></span><br><span class="line">print(mystr.capitalize())</span><br></pre></td></tr></table></figure>

<p>title()：将字符串每个单词⾸字⺟转换成⼤写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr = <span class="string">&quot;hello world and itcast and itheima and Python&quot;</span></span><br><span class="line"><span class="comment"># 结果：Hello World And Itcast And Itheima And Python</span></span><br><span class="line">print(mystr.title())</span><br></pre></td></tr></table></figure>

<p>lower()：将字符串中⼤写转⼩写。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr = <span class="string">&quot;hello world and itcast and itheima and Python&quot;</span></span><br><span class="line"><span class="comment"># 结果：hello world and itcast and itheima and python</span></span><br><span class="line">print(mystr.lower())</span><br></pre></td></tr></table></figure>

<p>upper()：将字符串中⼩写转⼤写。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr = <span class="string">&quot;hello world and itcast and itheima and Python&quot;</span></span><br><span class="line"><span class="comment"># 结果：HELLO WORLD AND ITCAST AND ITHEIMA AND PYTHON</span></span><br><span class="line">print(mystr.upper())</span><br></pre></td></tr></table></figure>

<p>lstrip()：删除字符串左侧空⽩字符。</p>
<p><img src="/2020/10/15/python/image-20201017145109999.png" alt="image-20201017145109999"></p>
<p>rstrip()：删除字符串右侧空⽩字符。</p>
<p><img src="/2020/10/15/python/image-20201017145118081.png" alt="image-20201017145118081"></p>
<p>strip()：删除字符串两侧空⽩字符。</p>
<p><img src="/2020/10/15/python/image-20201017145129970.png" alt="image-20201017145129970"></p>
<p>ljust()：返回⼀个原字符串左对⻬,并使⽤指定字符(默认空格)填充⾄对应⻓度 的新字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串序列.ljust(⻓度, 填充字符)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/15/python/image-20201017145428055.png" alt="image-20201017145428055"></p>
<p>rjust()：返回⼀个原字符串右对⻬,并使⽤指定字符(默认空格)填充⾄对应⻓度 的新字符串，语法和 ljust()相同。</p>
<p>center()：返回⼀个原字符串居中对⻬,并使⽤指定字符(默认空格)填充⾄对应⻓度 的新字符串，语 法和ljust()相同。</p>
<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p>startswith()：检查字符串是否是以指定⼦串开头，是则返回 True，否则返回 False。如果设置开 始和结束位置下标，则在指定范围内检查。</p>
<p>endswith()：：检查字符串是否是以指定⼦串结尾，是则返回 True，否则返回 False。如果设置开 始和结束位置下标，则在指定范围内检查。</p>
<p>isalpha()：如果字符串⾄少有⼀个字符并且所有字符都是字⺟则返回 True, 否则返回 False。</p>
<p>isdigit()：如果字符串只包含数字则返回 True 否则返回 False。</p>
<p>isalnum()：如果字符串⾄少有⼀个字符并且所有字符都是字⺟或数字则返 回 True,否则返回 False。</p>
<p>isspace()：如果字符串中只包含空⽩，则返回 True，否则返回 False。</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p><strong>下标</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">print(name_list[<span class="number">0</span>])</span><br><span class="line">print(name_list[<span class="number">1</span>])</span><br><span class="line">print(name_list[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p><strong>函数</strong></p>
<p>index()：返回指定数据所在位置的下标 。<code>列表序列.index(数据, 开始位置下标, 结束位置下标)</code></p>
<p>count()：统计指定数据在当前列表中出现的次数</p>
<p>len()：访问列表⻓度，即列表中数据的个数。</p>
<p><strong>判断是否存在</strong></p>
<p>in：判断指定数据在某个列表序列，如果在返回True，否则返回False</p>
<p>not in：判断指定数据不在某个列表序列，如果不在返回True，否则返回False</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line"><span class="comment"># 结果：True</span></span><br><span class="line">print(<span class="string">&#x27;Lily&#x27;</span> <span class="keyword">in</span> name_list)</span><br><span class="line"><span class="comment"># 结果：True</span></span><br><span class="line">print(<span class="string">&#x27;Lilys&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> name_list)</span><br></pre></td></tr></table></figure>

<p><strong>增加</strong></p>
<p>append()：列表结尾追加数据。</p>
<ul>
<li>列表追加数据的时候，直接在原列表⾥⾯追加了指定数据，即修改了原列表，故列表为可变类型 数据。</li>
</ul>
<p>extend()：列表结尾追加数据，如果数据是⼀个序列，则将这个序列的数据逐⼀添加到列表</p>
<p>insert()：指定位置新增数据。 <code>列表序列.insert(位置下标, 数据)</code></p>
<p><strong>删除</strong></p>
<p>del</p>
<ul>
<li><p>删除列表 <code>del name_list</code></p>
</li>
<li><p>删除指定数据 <code>del name_list[0]</code></p>
</li>
</ul>
<p>pop()：删除指定下标的数据(默认为最后⼀个)，并返回该数据。</p>
<p>remove()：移除列表中某个数据的第⼀个匹配项 <code>列表序列.remove(数据)</code></p>
<p>clear:清空列表<br><strong>修改</strong></p>
<p>修改指定下标数据     <code>name_list[0] = &#39;aaa&#39;</code></p>
<p>逆置：reverse()</p>
<p>排序：sort()</p>
<ul>
<li><code>列表序列.sort( key=None, reverse=False)</code></li>
<li>reverse表示排序规则，reverse = True 降序， reverse = False 升序（默认）</li>
</ul>
<p><strong>复制</strong></p>
<p>copy </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">name_li2 = name_list.copy()</span><br><span class="line"><span class="comment"># 结果：[&#x27;Tom&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;]</span></span><br><span class="line">print(name_li2)</span><br></pre></td></tr></table></figure>

<p><strong>循环</strong></p>
<p>while</p>
<p><img src="/2020/10/15/python/image-20201018104322871.png" alt="image-20201018104322871"></p>
<p>for</p>
<p><img src="/2020/10/15/python/image-20201018104330693.png" alt="image-20201018104330693"></p>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p><strong>⼀个元组可以存储多个数据，元组内的数据是不能修改的。</strong></p>
<p><strong>定义元组</strong></p>
<p>元组特点：定义元组使⽤⼩括号，且逗号隔开各个数据，数据可以是不同的数据类型。</p>
<ul>
<li>注意：如果定义的元组只有⼀个数据，那么这个数据后⾯也好添加逗号，否则数据类型为唯⼀的 这个数据的数据类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t2 = (<span class="number">10</span>,)</span><br><span class="line">print(type(t2)) <span class="comment"># tuple</span></span><br><span class="line">t3 = (<span class="number">20</span>)</span><br><span class="line">print(type(t3)) <span class="comment"># int</span></span><br><span class="line">t4 = (<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">print(type(t4)) <span class="comment"># str</span></span><br></pre></td></tr></table></figure>

<p><strong>元组常见操作</strong></p>
<p>按下标查找数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>)</span><br><span class="line">print(tuple1[<span class="number">0</span>]) <span class="comment"># aa</span></span><br></pre></td></tr></table></figure>

<p>index()：查找某个数据，如果数据存在返回对应的下标，否则报错，语法和列表、字符串的index ⽅法相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>)</span><br><span class="line">print(tuple1.index(<span class="string">&#x27;aa&#x27;</span>)) <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>

<p>count()：统计某个数据在当前元组出现的次数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>)</span><br><span class="line">print(tuple1.count(<span class="string">&#x27;bb&#x27;</span>)) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p>len()：统计元组中数据的个数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>)</span><br><span class="line">print(len(tuple1)) <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>

<p>元组内的直接数据如果修改则⽴即报错,但是如果元组⾥⾯有列表，修改列表⾥⾯的数据则是⽀持的，故⾃觉很重要。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple2 = (<span class="number">10</span>, <span class="number">20</span>, [<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>], <span class="number">50</span>, <span class="number">30</span>)</span><br><span class="line">print(tuple2[<span class="number">2</span>]) <span class="comment"># 访问到列表</span></span><br><span class="line"><span class="comment"># 结果：(10, 20, [&#x27;aaaaa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;], 50, 30)</span></span><br><span class="line">tuple2[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;aaaaa&#x27;</span></span><br><span class="line">print(tuple2)</span><br></pre></td></tr></table></figure>

<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>创建集合使⽤ {} 或 set() ， 但是如果要创建空集合只能使⽤ set() ，因为 {} ⽤来创建空字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line">print(s1)</span><br><span class="line">s2 = &#123;<span class="number">10</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">50</span>&#125;</span><br><span class="line">print(s2)</span><br><span class="line">s3 = set(<span class="string">&#x27;abcdefg&#x27;</span>)</span><br><span class="line">print(s3)</span><br><span class="line">s4 = set()</span><br><span class="line">print(type(s4)) <span class="comment"># set</span></span><br><span class="line">s5 = &#123;&#125;</span><br><span class="line">print(type(s5)) <span class="comment"># dict</span></span><br></pre></td></tr></table></figure>

<ul>
<li>集合可以去掉重复数据；</li>
<li>集合数据是⽆序的，故不⽀持下标</li>
</ul>
<p><strong>增加数据</strong></p>
<p>add</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">s1.add(<span class="number">100</span>)</span><br><span class="line">s1.add(<span class="number">10</span>)</span><br><span class="line">print(s1) <span class="comment"># &#123;100, 10, 20&#125;</span></span><br></pre></td></tr></table></figure>

<p>update(), 追加的数据是序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line"><span class="comment"># s1.update(100) # 报错</span></span><br><span class="line">s1.update([<span class="number">100</span>, <span class="number">200</span>])</span><br><span class="line">s1.update(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">print(s1)</span><br></pre></td></tr></table></figure>

<p><strong>删除数据</strong></p>
<p>remove()，删除集合中的指定数据，如果数据不存在则报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">s1.remove(<span class="number">10</span>)</span><br><span class="line">print(s1)</span><br><span class="line">s1.remove(<span class="number">10</span>) <span class="comment"># 报错</span></span><br><span class="line">print(s1)</span><br></pre></td></tr></table></figure>

<p>discard()，删除集合中的指定数据，如果数据不存在也不会报错。</p>
<p>pop()，随机删除集合中的某个数据，并返回这个数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line">del_num = s1.pop()</span><br><span class="line">print(del_num)</span><br><span class="line">print(s1)</span><br></pre></td></tr></table></figure>

<p><strong>查找数据</strong></p>
<p>in：判断数据在集合序列     not in：判断数据不在集合序列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line">print(<span class="number">10</span> <span class="keyword">in</span> s1)</span><br><span class="line">print(<span class="number">10</span> <span class="keyword">not</span> <span class="keyword">in</span> s1)</span><br></pre></td></tr></table></figure>

<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典⾥⾯的数据是以键值对形式出现，字典数据和数据顺序没有关系，即字典不⽀持下标， 后期⽆论数据如何变化，只需要按照对应的键的名字查找数据即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有数据字典</span></span><br><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 空字典</span></span><br><span class="line">dict2 = &#123;&#125;</span><br><span class="line">dict3 = dict()</span><br></pre></td></tr></table></figure>

<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><strong>增</strong></p>
<p>如果key存在则修改这个key对应的值；如果key不存在则新增此键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">dict1[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;Rose&#x27;</span></span><br><span class="line"><span class="comment"># 结果：&#123;&#x27;name&#x27;: &#x27;Rose&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span></span><br><span class="line">print(dict1)</span><br></pre></td></tr></table></figure>

<p><strong>删</strong></p>
<p> del：删除字典或删除字典中指定键值对。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">del</span> dict1[<span class="string">&#x27;gender&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>clear()：清空字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">dict1.clear()</span><br><span class="line">print(dict1) <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>查</strong></p>
<p>根据key查找</p>
<p>get方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">print(dict1.get(<span class="string">&#x27;name&#x27;</span>)) <span class="comment"># Tom</span></span><br></pre></td></tr></table></figure>

<p>keys</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">print(dict1.keys()) <span class="comment"># dict_keys([&#x27;name&#x27;, &#x27;age&#x27;, &#x27;gender&#x27;])</span></span><br></pre></td></tr></table></figure>

<p>values</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">print(dict1.values()) <span class="comment"># dict_values([&#x27;Tom&#x27;, 20, &#x27;男&#x27;])</span></span><br></pre></td></tr></table></figure>

<p>items</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">print(dict1.items()) <span class="comment"># dict_items([(&#x27;name&#x27;, &#x27;Tom&#x27;), (&#x27;age&#x27;, 20), (&#x27;gender&#x27;,&#x27;男&#x27;)])</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p> 遍历字典的key</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict1.keys():</span><br><span class="line"> print(key)</span><br></pre></td></tr></table></figure>

<p>遍历字典的value</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dict1.values():</span><br><span class="line"> print(value)</span><br></pre></td></tr></table></figure>

<p>遍历元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> dict1.items():</span><br><span class="line"> print(item)</span><br></pre></td></tr></table></figure>

<p>遍历键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> dict1.items():</span><br><span class="line"> print(<span class="string">f&#x27;<span class="subst">&#123;key&#125;</span> = <span class="subst">&#123;value&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="公共操作"><a href="#公共操作" class="headerlink" title="公共操作"></a>公共操作</h1><h2 id="运算符-1"><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h2><p><strong>+</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 字符串</span></span><br><span class="line">str1 = <span class="string">&#x27;aa&#x27;</span></span><br><span class="line">str2 = <span class="string">&#x27;bb&#x27;</span></span><br><span class="line">str3 = str1 + str2</span><br><span class="line">print(str3) <span class="comment"># aabb</span></span><br><span class="line"><span class="comment"># 2. 列表</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">list2 = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">list3 = list1 + list2</span><br><span class="line">print(list3) <span class="comment"># [1, 2, 10, 20]</span></span><br><span class="line"><span class="comment"># 3. 元组</span></span><br><span class="line">t1 = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">t2 = (<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">t3 = t1 + t2</span><br><span class="line">print(t3) <span class="comment"># (10, 20, 100, 200)</span></span><br></pre></td></tr></table></figure>

<p><strong>*</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 字符串</span></span><br><span class="line">print(<span class="string">&#x27;-&#x27;</span> * <span class="number">10</span>) <span class="comment"># ----------</span></span><br><span class="line"><span class="comment"># 2. 列表</span></span><br><span class="line">list1 = [<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line">print(list1 * <span class="number">4</span>) <span class="comment"># [&#x27;hello&#x27;, &#x27;hello&#x27;, &#x27;hello&#x27;, &#x27;hello&#x27;]</span></span><br><span class="line"><span class="comment"># 3. 元组</span></span><br><span class="line">t1 = (<span class="string">&#x27;world&#x27;</span>,)</span><br><span class="line">print(t1 * <span class="number">4</span>) <span class="comment"># (&#x27;world&#x27;, &#x27;world&#x27;, &#x27;world&#x27;, &#x27;world&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>in 或 not in</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 字符串</span></span><br><span class="line">print(<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;abcd&#x27;</span>) <span class="comment"># True</span></span><br><span class="line">print(<span class="string">&#x27;a&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abcd&#x27;</span>) <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 2. 列表</span></span><br><span class="line">list1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">print(<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> list1) <span class="comment"># True</span></span><br><span class="line">print(<span class="string">&#x27;a&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> list1) <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 3. 元组</span></span><br><span class="line">t1 = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;aa&#x27;</span> <span class="keyword">in</span> t1) <span class="comment"># False</span></span><br><span class="line">print(<span class="string">&#x27;aa&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> t1) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h2 id="公共方法"><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h2><p><img src="/2020/10/15/python/image-20201019191942901.png" alt="image-20201019191942901"></p>
<p><strong>len</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 字符串</span></span><br><span class="line">str1 = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line">print(len(str1)) <span class="comment"># 7</span></span><br><span class="line"><span class="comment"># 2. 列表</span></span><br><span class="line">list1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line">print(len(list1)) <span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 3. 元组</span></span><br><span class="line">t1 = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>)</span><br><span class="line">print(len(t1)) <span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 4. 集合</span></span><br><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">print(len(s1)) <span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 5. 字典</span></span><br><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Rose&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line">print(len(dict1)) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>del</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 字符串</span></span><br><span class="line">str1 = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="keyword">del</span> str1</span><br><span class="line">print(str1)</span><br><span class="line"><span class="comment"># 2. 列表</span></span><br><span class="line">list1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line"><span class="keyword">del</span>(list1[<span class="number">0</span>])</span><br><span class="line">print(list1) <span class="comment"># [20, 30, 40]</span></span><br></pre></td></tr></table></figure>

<p><strong>max</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 字符串</span></span><br><span class="line">str1 = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line">print(max(str1)) <span class="comment"># g</span></span><br><span class="line"><span class="comment"># 2. 列表</span></span><br><span class="line">list1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line">print(max(list1)) <span class="comment"># 40</span></span><br></pre></td></tr></table></figure>

<p><strong>min</strong></p>
<p><strong>range</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>):</span><br><span class="line"> print(i)</span><br><span class="line"><span class="comment"># 1 3 5 7 9</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>):</span><br><span class="line"> print(i)</span><br><span class="line"><span class="comment"># 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line"> print(i)</span><br></pre></td></tr></table></figure>

<p> <strong>enumerate</strong></p>
<p><img src="/2020/10/15/python/image-20201019192254243.png" alt="image-20201019192254243"></p>
<h2 id="容器类型转换"><a href="#容器类型转换" class="headerlink" title="容器类型转换"></a>容器类型转换</h2><p><strong>tuple()</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">将某个序列转换为元组</span><br><span class="line">list1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">20</span>]</span><br><span class="line">s1 = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>&#125;</span><br><span class="line">print(tuple(list1))</span><br><span class="line">print(tuple(s1))</span><br></pre></td></tr></table></figure>

<p> <strong>list()</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">将某个序列转换为元组</span><br><span class="line">t1 = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">s1 = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>&#125;</span><br><span class="line">print(list(t1))</span><br><span class="line">print(list(s1))</span><br></pre></td></tr></table></figure>

<p><strong>set()</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">将某个序列转换为集合</span><br><span class="line">list1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">20</span>]</span><br><span class="line">t1 = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">print(set(list1))</span><br><span class="line">print(set(t1))</span><br></pre></td></tr></table></figure>

<h1 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h1><p>作⽤：⽤⼀个表达式创建⼀个有规律的列表或控制⼀个有规律列表。</p>
<h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>用一个表达式创建⼀个有规律的列表或控制⼀个有规律列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="comment">#创建偶数列表</span></span><br><span class="line">list1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>)]</span><br><span class="line">list1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="comment">#创建[(1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]</span></span><br><span class="line">list1 = [(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h2><p>快速合并列表为字典或提取字典中⽬标数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建⼀个字典：字典key是1-5数字，value是这个数字的2次⽅。</span></span><br><span class="line">dict1 = &#123;i: i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>)&#125;</span><br><span class="line"><span class="comment">#将两个列表合并为⼀个字典</span></span><br><span class="line">list1 = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>]</span><br><span class="line">list2 = [<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;man&#x27;</span>]</span><br><span class="line">dict1 = &#123;list1[i]: list2[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(list1))&#125;</span><br><span class="line"><span class="comment">#提取字典中⽬标数据</span></span><br><span class="line">counts = &#123;<span class="string">&#x27;MBP&#x27;</span>: <span class="number">268</span>, <span class="string">&#x27;HP&#x27;</span>: <span class="number">125</span>, <span class="string">&#x27;DELL&#x27;</span>: <span class="number">201</span>, <span class="string">&#x27;Lenovo&#x27;</span>: <span class="number">199</span>, <span class="string">&#x27;acer&#x27;</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="comment">#需求：提取上述电脑数量⼤于等于200的字典数据</span></span><br><span class="line">count1 = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> counts.items() <span class="keyword">if</span> value &gt;= <span class="number">200</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h2><p>需求：创建⼀个集合，数据为下⽅列表的2次⽅。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">set1 = &#123;i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> list1&#125;</span><br><span class="line">print(set1) <span class="comment"># &#123;1, 4&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数必须先定义后使用</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">(参数)</span></span><span class="symbol">:</span></span><br><span class="line"> 代码<span class="number">1</span></span><br><span class="line"> 代码<span class="number">2</span></span><br><span class="line"> ......</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">函数名(参数)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a,b)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">x = sum(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h2 id="函数的说明文档"><a href="#函数的说明文档" class="headerlink" title="函数的说明文档"></a>函数的说明文档</h2><p><img src="/2020/10/15/python/image-20201019195341331.png" alt="image-20201019195341331"></p>
<p><img src="/2020/10/15/python/image-20201019195347466.png" alt="image-20201019195347466"></p>
<h2 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h2><p><img src="/2020/10/15/python/image-20201019195659583.png" alt="image-20201019195659583"></p>
<p><img src="/2020/10/15/python/image-20201019195710809.png" alt="image-20201019195710809"></p>
<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p><img src="/2020/10/15/python/image-20201019195851539.png" alt="image-20201019195851539"></p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>位置参数：调⽤函数时根据函数定义的参数位置来传递参数。</p>
<p><img src="/2020/10/15/python/image-20201019200104973.png" alt="image-20201019200104973"></p>
<p>关键词参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">函数调⽤，通过“键=值”形式加以指定。可以让函数更加清晰、容易使⽤，同时也清除了参数的顺序需 求。</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span>(<span class="params">name, age, gender</span>):</span></span><br><span class="line"> print(<span class="string">f&#x27;您的名字是<span class="subst">&#123;name&#125;</span>, 年龄是<span class="subst">&#123;age&#125;</span>, 性别是<span class="subst">&#123;gender&#125;</span>&#x27;</span>)</span><br><span class="line">user_info(<span class="string">&#x27;Rose&#x27;</span>, age=<span class="number">20</span>, gender=<span class="string">&#x27;⼥&#x27;</span>)</span><br><span class="line">函数调⽤时，如果有位置参数时，位置参数必须在关键字参数的前⾯，但关键字参数之间不存在</span><br><span class="line">先后顺序。</span><br></pre></td></tr></table></figure>

<p>缺省参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">缺省参数也叫默认参数，⽤于定义函数，为参数提供默认值，调⽤函数时可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调⽤</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span>(<span class="params">name, age, gender=<span class="string">&#x27;男&#x27;</span></span>):</span></span><br><span class="line"> print(<span class="string">f&#x27;您的名字是<span class="subst">&#123;name&#125;</span>, 年龄是<span class="subst">&#123;age&#125;</span>, 性别是<span class="subst">&#123;gender&#125;</span>&#x27;</span>)</span><br><span class="line">user_info(<span class="string">&#x27;TOM&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">user_info(<span class="string">&#x27;Rose&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;⼥&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>不定长参数</p>
<p>不定⻓参数也叫可变参数。⽤于不确定调⽤的时候会传递多少个参数(不传参也可以)的场景。此时，可 ⽤包裹(packing)位置参数，或者包裹关键字参数，来进⾏参数传递，会显得⾮常⽅便。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#包裹位置传递:传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为⼀个元组(tuple)，args是元组类型，这就是包裹位置传递。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span>(<span class="params">*args</span>):</span></span><br><span class="line"> print(args)</span><br><span class="line"><span class="comment"># (&#x27;TOM&#x27;,)</span></span><br><span class="line">user_info(<span class="string">&#x27;TOM&#x27;</span>)</span><br><span class="line"><span class="comment"># (&#x27;TOM&#x27;, 18)</span></span><br><span class="line">user_info(<span class="string">&#x27;TOM&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment">#包裹关键字传递</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line"> print(kwargs)</span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;TOM&#x27;, &#x27;age&#x27;: 18, &#x27;id&#x27;: 110&#125;</span></span><br><span class="line">user_info(name=<span class="string">&#x27;TOM&#x27;</span>, age=<span class="number">18</span>, id=<span class="number">110</span>)</span><br></pre></td></tr></table></figure>

<h2 id="拆包和交换变量组"><a href="#拆包和交换变量组" class="headerlink" title="拆包和交换变量组"></a>拆包和交换变量组</h2><p>拆包：元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_num</span>():</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">100</span>, <span class="number">200</span></span><br><span class="line">num1, num2 = return_num()</span><br><span class="line">print(num1) <span class="comment"># 100</span></span><br><span class="line">print(num2) <span class="comment"># 200</span></span><br></pre></td></tr></table></figure>

<p>拆包：字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;TOM&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line">a, b = dict1</span><br><span class="line"><span class="comment"># 对字典进⾏拆包，取出来的是字典的key</span></span><br><span class="line">print(a) <span class="comment"># name</span></span><br><span class="line">print(b) <span class="comment"># age</span></span><br><span class="line">print(dict1[a]) <span class="comment"># TOM</span></span><br><span class="line">print(dict1[b]) <span class="comment"># 18</span></span><br></pre></td></tr></table></figure>

<p>交换变量值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">a, b = b, a</span><br><span class="line">print(a) <span class="comment"># 2</span></span><br><span class="line">print(b) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>我们可以⽤ id() 来判断两个变量是否为同⼀个值的引⽤。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#列表</span></span><br><span class="line">aa = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">bb = aa</span><br><span class="line">print(id(aa)) <span class="comment"># 2325297783432</span></span><br><span class="line">print(id(bb)) <span class="comment"># 2325297783432</span></span><br><span class="line">aa.append(<span class="number">30</span>)</span><br><span class="line">print(bb) <span class="comment"># [10, 20, 30], 列表为可变类型</span></span><br><span class="line">print(id(aa)) <span class="comment"># 2325297783432</span></span><br><span class="line">print(id(bb)) <span class="comment"># 2325297783432</span></span><br><span class="line"><span class="comment">#int类型</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = a</span><br><span class="line">print(b) <span class="comment"># 1</span></span><br><span class="line">print(id(a)) <span class="comment"># 140708464157520</span></span><br><span class="line">print(id(b)) <span class="comment"># 140708464157520</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">print(b) <span class="comment"># 1,说明int类型为不可变类型</span></span><br><span class="line">print(id(a)) <span class="comment"># 140708464157552，此时得到是的数据2的内存地址</span></span><br><span class="line">print(id(b)) <span class="comment"># 140708464157520</span></span><br></pre></td></tr></table></figure>

<h2 id="可变类型和不可变类型"><a href="#可变类型和不可变类型" class="headerlink" title="可变类型和不可变类型"></a>可变类型和不可变类型</h2><p><img src="/2020/10/15/python/image-20201019223000046.png" alt="image-20201019223000046"></p>
<h1 id="函数加强"><a href="#函数加强" class="headerlink" title="函数加强"></a>函数加强</h1>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2020/12/01/redis/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><strong>redis-benchmark</strong>可以进行性能测试</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>-h</strong></td>
<td>指定服务器主机名</td>
<td>127.0.0.1</td>
</tr>
<tr>
<td>2</td>
<td><strong>-p</strong></td>
<td>指定服务器端口</td>
<td>6379</td>
</tr>
<tr>
<td>3</td>
<td><strong>-s</strong></td>
<td>指定服务器 socket</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td><strong>-c</strong></td>
<td>指定并发连接数</td>
<td>50</td>
</tr>
<tr>
<td>5</td>
<td><strong>-n</strong></td>
<td>指定请求数</td>
<td>10000</td>
</tr>
<tr>
<td>6</td>
<td><strong>-d</strong></td>
<td>以字节的形式指定 SET/GET 值的数据大小</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td><strong>-k</strong></td>
<td>1=keep alive 0=reconnect</td>
<td>1</td>
</tr>
<tr>
<td>8</td>
<td><strong>-r</strong></td>
<td>SET/GET/INCR 使用随机 key, SADD 使用随机值</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td><strong>-P</strong></td>
<td>通过管道传输 <numreq> 请求</numreq></td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td><strong>-q</strong></td>
<td>强制退出 redis。仅显示 query/sec 值</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td><strong>–csv</strong></td>
<td>以 CSV 格式输出</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td><strong>-l</strong></td>
<td>生成循环，永久执行测试</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td><strong>-t</strong></td>
<td>仅运行以逗号分隔的测试命令列表。</td>
<td></td>
</tr>
<tr>
<td>14</td>
<td><strong>-I</strong></td>
<td>Idle 模式。仅打开 N 个 idle 连接并等待。</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">redis-benchmark -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6379</span> -t <span class="keyword">set</span>,lpush -n <span class="number">10000</span> -q</span><br></pre></td></tr></table></figure>

<p>默认有16个数据库 可以使用select n 进行切换</p>
<p>清空当前数据库：flushdb</p>
<p>清空所有数据库：flushall</p>
<p>查看所有key：keys * </p>
<p>判断key是否存在：exists name</p>
<p>设置过期时间 单位秒：expire name n</p>
<p>查看key的剩余时间：ttl name</p>
<p>查看key的类型：type name</p>
<p>移动key到其他数据库：move name n</p>
<p>删除key：del name</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>数字和字符串都用String存储</p>
<p>set</p>
<p>get</p>
<p>append：追加字符串 没有的话新建一个</p>
<p>strlen：获取字符串长度</p>
<p>incr：自增 第二个参数可以指定步长 incr views 10</p>
<p>decr：自减 第二个参数可以指定步长</p>
<p>getrange：getrange name 0 3  如果最后一个参数是-1则获取整个字符串</p>
<p>setrange: setrange name 0 xx  =&gt; abcde-&gt;xxcde</p>
<p>setex：为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值。setex name 10 bob</p>
<p>setnx：如果不存在才创建 setnx name bob </p>
<p>mget：批量获取值 mget k1 k2</p>
<p>mset：批量设置值 mset k1 v1 k2 v2</p>
<p>msetnx：原子性的 要么批量成功要么批量失败</p>
<p>设置对象：</p>
<pre><code>1. set user:1 &#123;name:zhangdan,age:3&#125; 获取：get user:1
2. set user:1 &#123;name:zhangdan,age:3&#125;  获取：get user:1:name</code></pre>
<p>getset：返回旧值 设置新值 getset name bob</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>lpush(头插法)：从左端放入对应的是rpush(尾插法)</p>
<p>lrange：获取指定范围 如果最后一个参数是-1则获取全部</p>
<p>lpop：移除头部元素 对应的是rpop</p>
<p>lindex：获取下标对应的元素</p>
<p>llen：返回列表长度</p>
<p>lrem：移除指定的值 第二个参数是移除的数量 lrm list 1 one 从头部开始移除</p>
<p>ltrim： ltrim list 0 3 只留下 下标0-3的元素</p>
<p>rpoplpush：rpoplpush list mylist  把list最右边的元素移除并添加到mylist中</p>
<p>lset：lset list [index] [new_value] 将指定下标的值替换为另一个</p>
<p>linsert：linsert list after/before “two” “world” 往two后面/前面插入world</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>set中的值不能重复</p>
<p>sadd： 添加元素</p>
<p>srem：移除指定元素</p>
<p>spop：随机删除元素</p>
<p>srandmember：随机获取n个元素</p>
<p>smembers：查看集合中的元素</p>
<p>sismember：查看集合中是否有某个元素</p>
<p>scard：获取集合中的元素个数</p>
<p>smove set1 set2 value1将指定值移动到set2</p>
<p>sdiff set1 set2查看set1中哪些元素set2中没有</p>
<p>sinter：两个集合的交集</p>
<p>sunion：两个集合的并集</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>存放的key是一个map</p>
<p>hset和hget：设置 获取元素 也有hmset和hmget</p>
<p>hsetnx</p>
<p>hgetall：获取所有键值对</p>
<p>hdel：删除</p>
<p>hlen：获取键值对数量</p>
<p>hkeys：只获取所有key</p>
<p>hvals：只获取所有value</p>
<p>hincrby ：hincrby hash age 5 </p>
<h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><p>是set的有序版本</p>
<p>zset：zset myset 1 bob </p>
<p>zrange</p>
<p>zrangebyscore：第二个和第三个参数指定范围 降序是zrevrangebyscore</p>
<p>​    <img src="/2020/12/01/redis/image-20201202093438696.png" alt="image-20201202093438696"></p>
<p>zrem ：移除元素</p>
<p>zcard：获取有序集合中的个数</p>
<p>zcount：获取指定区间的成员数量</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>不保证原子性：Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<p>没有隔离级别的概念</p>
<p>开启事务：multi</p>
<p>执行事务：exec</p>
<p>​    <img src="/2020/12/01/redis/image-20201202100249565.png" alt="image-20201202100249565"></p>
<p>discard：取消事务 事务队列中的命令都不会被执行</p>
<p>​    <img src="/2020/12/01/redis/image-20201202100555522.png" alt="image-20201202100555522"></p>
<p>如果事务中出现编译型异常(代码有问题或者命令出错) 所有命令都不会执行 ，如果事务中出现运行时异常(get不存在的值) 其他命令可以正常执行</p>
<p><strong>redis实现乐观锁</strong></p>
<p>watch：监视一个元素 如果事务中有其他线程修改这个值 则事务执行失败 失败后可以使用unwatch取消监视 再次watch并开始事务</p>
<p>unwatch：取消所有的监视    </p>
<p>通过</p>
<h1 id="操作redis"><a href="#操作redis" class="headerlink" title="操作redis"></a>操作redis</h1><h2 id="通过jedis操作redis"><a href="#通过jedis操作redis" class="headerlink" title="通过jedis操作redis"></a>通过jedis操作redis</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.52.131&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//执行事务</span></span><br><span class="line">        Transaction multi = jedis.multi();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            multi.set(<span class="string">&quot;value1&quot;</span>,<span class="string">&quot;bob&quot;</span>);</span><br><span class="line">            multi.set(<span class="string">&quot;value2&quot;</span>,<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            multi.get(<span class="string">&quot;value1&quot;</span>);</span><br><span class="line"></span><br><span class="line">            multi.exec();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            multi.discard();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;value2&quot;</span>));</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringBoot整合redis"><a href="#SpringBoot整合redis" class="headerlink" title="SpringBoot整合redis"></a>SpringBoot整合redis</h2><p>引入依赖：spring-boot-starter-data-redis</p>
<p><img src="/2020/12/01/redis/image-20201202104116611.png" alt="image-20201202104116611"></p>
<p>源码分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RedisOperations.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RedisProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">      RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">      template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">      <span class="keyword">return</span> template;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">      StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">      template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">      <span class="keyword">return</span> template;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Database index used by the connection factory.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> database = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Connection URL. Overrides host, port, and password. User is ignored. Example:</span></span><br><span class="line"><span class="comment">    * redis://user:password@example.com:6379</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Redis server host.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> String host = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Login password of the redis server.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Redis server port.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> port = <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Whether to enable SSL support.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> ssl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Connection timeout.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> Duration timeout;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Client name to be set on connections with CLIENT SETNAME.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> String clientName;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Sentinel sentinel;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Cluster cluster;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">    connection.flushAll();</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;23&quot;</span>);</span><br><span class="line">    String name = (String)redisTemplate.opsForValue().get(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义RedisTemplate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class="line">        RedisTemplate&lt;String,Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//配置具体的序列化方式</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        <span class="comment">//String的序列化</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h1><p>daemonize yes ：以守护进程的方式运行 默认是no 需要自己开启</p>
<p>pidfile /var/run/redis_6379.pid：如果以后台方式运行 需要制定pid文件</p>
<p>save 120 1：表示如果120s内至少有一条数据改动 则进行持久化</p>
<p>stop-writes-on-bgsave-error yes：持久化失败后 是否继续工作</p>
<p>rdbcompression yes：是否压缩rdb文件，需要消耗一些cpu资源</p>
<p>rdbchechsum yes：保存rdb文件的时候 进行错误的校验</p>
<p>dir ./：文件的保存目录 </p>
<p>maxclients：设置能连接上redis的最大客户端数</p>
<p>maxmemory：配置最大的内存容量</p>
<p>aof配置</p>
<p>​    appendonly  no ：默认不开启</p>
<p>​    appendfilename：持久化的文件名</p>
<p>​    appendfsync everysec：每秒执行 一次 同步 这1s可能会丢失数据</p>
<h1 id="持久化之RDB操作"><a href="#持久化之RDB操作" class="headerlink" title="持久化之RDB操作"></a>持久化之RDB操作</h1><p>流程：</p>
<p><img src="/2020/12/01/redis/image-20201202233309973.png" alt="image-20201202233309973"></p>
<p>在指定时间间隔内将内存中的数据集快照写入磁盘，恢复时将快照文件直接读到内存中</p>
<p>Redis会单独创建 ( fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p>
<p>触发机制：默认生成dump.rdb文件</p>
<ul>
<li>save的规则 满足的情况下 会自动触发rdb规则</li>
<li>执行flushdb命令时 会触发</li>
<li>退出redis 也会触发</li>
</ul>
<p>只需要将rdb文件放入到redis启动目录就行 redis启动的时候自动检查dump.rdb并回复其中的数据</p>
<p>通过命令 config get dir查看启动目录</p>
<h1 id="持久化之AOF操作"><a href="#持久化之AOF操作" class="headerlink" title="持久化之AOF操作"></a>持久化之AOF操作</h1><p>流程：</p>
<p><img src="/2020/12/01/redis/image-20201202234131430.png" alt="image-20201202234131430"></p>
<p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<p>Aof保存的是appendonely.aof文件 </p>
<p>默认是不开启的 需要手动开启</p>
<p>如果aof文件被修改 就会启动失败 可以进行修复redis-check-aof –fix appendonly.aof</p>
<p>优点</p>
<ul>
<li>每一个修改都会同步，文件完整性会更好</li>
<li>每秒同步一次，可能会丢失一秒的数据</li>
</ul>
<p>缺点</p>
<ul>
<li>aof数据文件远大于rdb 修复数据较慢</li>
<li>aof运行速率较慢</li>
</ul>
<p>如果aof大小超过了默认配置，会fork一个新的线程来将我们的文件进行重写，这里重写是为了将aof文件变得更小，降低文件占用空间，以便更快的被redis加载</p>
<p><strong>同时开启两种持久化方式</strong></p>
<ul>
<li>·在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢?作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。</li>
</ul>
<p><strong>性能建议</strong></p>
<ul>
<li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 9001这条规则。</li>
<li>如果Enable AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite的最后将 rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</li>
<li>如果不Enable AOF，仅靠Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave 中的RDB文件，载入较新的那个，微博就是这种架构。</li>
</ul>
<h1 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h1><p><strong>流程</strong></p>
<p><img src="/2020/12/01/redis/image-20201203001310583.png" alt="image-20201203001310583"></p>
<p><strong>命令</strong></p>
<p><img src="/2020/12/01/redis/image-20201203001635483.png" alt="image-20201203001635483"></p>
<p><strong>测试</strong>：创建两个redis连接 一个订阅subscribe diantai 一个推送消息publish diantai hello </p>
<p><strong>底层实现</strong></p>
<p><img src="/2020/12/01/redis/image-20201203002602416.png" alt="image-20201203002602416"></p>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>数据的复制是单向的 只能从主机复制到从机 主节点可以有多个从节点 一个从节点只能由一个主节点</p>
<p>设置主人：slaveof ip port  (建议在配置文件中进行配置)  查看信息：info replication</p>
<p>从机不能写 只能读 主机中的信息和数据会自动保存到从机中</p>
<p><strong>复制原理</strong></p>
<p><img src="/2020/12/01/redis/image-20201203083755766.png" alt="image-20201203083755766"></p>
<p><strong>哨兵模式</strong></p>
<p>哨兵是一个独立的进程 ，作为进程 他会独立运行，其原理是哨兵通过发送命令，等待redis服务器响应，从而监控运行的多个redis实例</p>
<p><img src="/2020/12/01/redis/image-20201203084635501.png" alt="image-20201203084635501"></p>
<p>当哨兵监控到master宕机 会自动将slave切换成master 然后通过发布订阅通知通知其他从服务器 修改配置文件 让他们切换主机</p>
<p>一个哨兵可能会出现问题 使用多个哨兵进行监控</p>
<p><img src="/2020/12/01/redis/image-20201203084841536.png" alt="image-20201203084841536"></p>
<p>主观下线和客观下线</p>
<p><img src="/2020/12/01/redis/image-20201203090416317.png" alt="image-20201203090416317"></p>
<p>配置哨兵配置文件sentinel.conf</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sentinel monitor myredis<span class="built_in"> ip port </span>1 #最后一个参数 是否进行重新投票</span><br></pre></td></tr></table></figure>

<p>启动哨兵：redis-sentinel /config/sentinel.conf</p>
<p>当主机宕机的时候 会自动挑选一个从机作为主机 宕机的主机修复后成为从机</p>
<h1 id="缓存穿透和雪崩"><a href="#缓存穿透和雪崩" class="headerlink" title="缓存穿透和雪崩"></a>缓存穿透和雪崩</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h2><p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀!），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>
<p><strong>解决方法</strong></p>
<p><strong>布隆过滤器</strong>：是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合就舍弃，从而避免了对底层存储系统的查询压力</p>
<p><strong>缓存空对象</strong>：当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源</p>
<p><img src="/2020/12/01/redis/image-20201203094734020.png" alt="image-20201203094734020"></p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><strong>缓存击穿</strong></h2><p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>
<p>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p>
<p><strong>解决方案</strong></p>
<p>设置热点数据永不过期</p>
<p>加互斥锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h2><p>缓存雪崩是指在某一时间段，缓存集中过期失效，redis宕机</p>
<p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>
<p><strong>解决方案</strong></p>
<p>高可用：搭建集群</p>
<p>限流降级：缓存失效后，通过加锁或队列来控制数据库写缓存的线程数量</p>
<p>数据预热：数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="希尔排序是不是一种稳定的排序方法？"><a href="#希尔排序是不是一种稳定的排序方法？" class="headerlink" title="希尔排序是不是一种稳定的排序方法？"></a>希尔排序是不是一种稳定的排序方法？</h2><p>答：由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p>
<p><a href="https://www.cnblogs.com/chengxiao/p/6104371.html">图解算法之希尔排序</a></p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p><a href="https://baijiahao.baidu.com/s?id=1618548971082312617&wfr=spider&for=pc">关于IP地址、网络地址、子网掩码、广播地址的理解</a></p>
<p><a href="https://blog.csdn.net/u014465934/article/details/81146443">子网掩码、网络地址、广播地址的计算</a></p>
<p>RIP基础知识</p>
<ul>
<li><a href="https://cshihong.blog.csdn.net/article/details/80503512?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control">https://cshihong.blog.csdn.net/article/details/80503512?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control</a></li>
<li><a href="https://bingw.blog.csdn.net/article/details/53346473?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control">https://bingw.blog.csdn.net/article/details/53346473?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control</a></li>
</ul>
<p>CRC校验原理</p>
<ul>
<li><a href="https://blog.csdn.net/qiaobt/article/details/81661345">https://blog.csdn.net/qiaobt/article/details/81661345</a></li>
</ul>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BaseClass</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> 	&#123;</span><br><span class="line">		 System.out.println(<span class="string">&quot;I’m BaseClass class&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">	 <span class="keyword">static</span> &#123;</span><br><span class="line"> 	    System.out.println(<span class="string">&quot;static BaseClass&quot;</span>);</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> <span class="keyword">extends</span> <span class="title">BaseClass</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> 	&#123;</span><br><span class="line">		 System.out.println(<span class="string">&quot;I’m Base class&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">	 <span class="keyword">static</span> &#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;static Base&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">new</span> Base();</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>执行顺序为：父类静态代码块 -&gt;子类静态代码块 -&gt;父类非静态代码块 -&gt; 父类构造函数 -&gt; 子类非静态代码块 -&gt; 子类构造函数。</p>
<ol start="2">
<li><p>对象空间被收集掉之后，会执行该对象的finalize方法(×)：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法， 并且在<strong>下一次</strong>垃圾回收动作发生时，才会<strong>真正的</strong>回收对象占用的内存</p>
</li>
<li><p><strong>包的作用</strong></p>
</li>
</ol>
<ul>
<li>1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</li>
<li>2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li>
<li>3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li>
</ul>
<p>Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。</p>
<ol start="4">
<li>java中 %是取余运算最后的符号和第1个值相同</li>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201228162626849.png" alt="image-20201228162626849"></li>
</ol>
<p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210329085347474.png" alt="image-20210329085347474"></p>
<ol start="6">
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201228163509069.png" alt="image-20201228163509069"></li>
</ol>
<p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201228163617276.png" alt="image-20201228163617276"></p>
<p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201228163529004.png" alt="image-20201228163529004"></p>
<ol start="7">
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201228163800403.png" alt="image-20201228163800403"></li>
</ol>
<p>我们在执行URL u =new URL(“<a href="http://www.123.com/">http://www.123.com</a>“);这句话的时候确实要抛出异常，但是这个异常属于IOException，不管网址是否存在，最后都会返回该网址的一个连接，打印出来就是该网址。</p>
<ol start="8">
<li><a href="https://blog.csdn.net/liangyihuai/article/details/83106584">CyclicBarrier和CountDownLatch都可以让一组线程等待其他线程。前者是让一组线程相互等待到某一个状态再执行。后者是一个线程等待其他线程结束再执行。</a></li>
</ol>
<p><strong>Callable中的call比Runnable中的run厉害就厉害在有返回值和可以抛出异常。同时这个返回值和线程池一起用的时候可以返回一个异步对象Future。</strong></p>
<ol start="9">
<li><p>java8中，忽略内部接口的情况，不能用来修饰interface里的方法的修饰符有:private , protected</p>
</li>
<li><p>抽象方法只可以被public 和 protected修饰；</p>
</li>
</ol>
<ol start="14">
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201228164913519.png" alt="image-20201228164913519"></li>
</ol>
<p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201228164946718.png" alt="image-20201228164946718"></p>
<p>​    <a href="https://blog.csdn.net/Hacker_ZhiDian/article/details/82193100?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.baidujs">详解java内部类</a></p>
<ol start="15">
<li><p>java运算符优先级：<a href="http://c.biancheng.net/view/794.html">http://c.biancheng.net/view/794.html</a></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105170242902.png" alt="image-20210105170242902"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105170252150.png" alt="image-20210105170252150"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105171431976.png" alt="image-20210105171431976"></p>
<ol>
<li>final修饰的成员变量在赋值时可以有三种方式。1、在声明时直接赋值。2、在构造器中赋值。3、在初始代码块中进行赋值。</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105172515143.png" alt="image-20210105172515143"></p>
<ol>
<li>String split 这个方法默认返回一个数组，如果没有找到分隔符，会把整个字符串当成一个长度为1的字符串数组返回到结果</li>
</ol>
</li>
<li><p>接口中的属性默认是public static final</p>
</li>
<li><p>GBK编码字节流传唤到UTF-8编码字节流:<code>byte[] dst = new String(&quot;hello&quot;.getBytes(), &quot;GBK&quot;).getBytes();</code></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105173635738.png" alt="image-20210105173635738"></p>
<ol>
<li>数组元素在内存中是一个接着一个线性存放的，通过第一个元素就能访问随后的元素，避免了数据覆盖的可能性，和数据类型覆盖并没有关系。</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105173752455.png" alt="image-20210105173752455"></p>
<ol>
<li>这类多态问题中，无论向上或向下转型，都记住一句话就可以了。<strong>编译看左边，运行看右边。</strong>意思编译时候，看左边有没有该方法，运行的时候结果看 <strong>new</strong> 的对象是谁，就调用的谁。</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105174542394.png" alt="image-20210105174542394"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210105174601119.png" alt="image-20210105174601119"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106212423016.png" alt="image-20210106212423016"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106212429344.png" alt="image-20210106212429344"></li>
<li>A B D是并发编程的锁机制相关，Future是一个线程任务的返回结果的‘欠条’。</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106214233706.png" alt="image-20210106214233706"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210328092635893.png" alt="image-20210328092635893"></li>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106214330068.png" alt="image-20210106214330068"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106214433699.png" alt="image-20210106214433699"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106214444017.png" alt="image-20210106214444017"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106214547104.png" alt="image-20210106214547104"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210106214552994.png" alt="image-20210106214552994"></li>
</ol>
</li>
<li><p>面对对象的三个基本元素：多态，继承，封装</p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107172001632.png" alt="image-20210107172001632"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107172012758.png" alt="image-20210107172012758"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107175344971.png" alt="image-20210107175344971"></p>
<ol>
<li>接口方法默认是public abstract的，且实现该接口的类中对应的方法的可见性不能小于接口方法的可见性，因此也只能是public的。</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107180458042.png" alt="image-20210107180458042"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107180503469.png" alt="image-20210107180503469"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107180943624.png" alt="image-20210107180943624"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210328095842840.png" alt="image-20210328095842840"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107194106028.png" alt="image-20210107194106028"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210107194132761.png" alt="image-20210107194132761"></li>
</ol>
</li>
<li><p>局部内部类可以用哪些修饰符修饰？abstract，final</p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109180301821.png" alt="image-20210109180301821"></p>
<ol>
<li>子类可以不是abstract</li>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109180518044.png" alt="image-20210109180518044"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109181346678.png" alt="image-20210109181346678"></p>
<ol>
<li>读取路径是request做的</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109181704154.png" alt="image-20210109181704154"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109181727290.png" alt="image-20210109181727290"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109182209631.png" alt="image-20210109182209631"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109182215903.png" alt="image-20210109182215903"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109182834824.png" alt="image-20210109182834824"></p>
<ol>
<li>​    局部变量随着栈帧的创建而创建，而栈桢的创建就是在该方法被调用时创建的 所以C是正确的</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109183322635.png" alt="image-20210109183322635"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210109183337878.png" alt="image-20210109183337878"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210110185014750.png" alt="image-20210110185014750"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210110185023277.png" alt="image-20210110185023277"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210110185442964.png" alt="image-20210110185442964"></p>
<ol>
<li>java的赋值运算有返回值 赋什么值就返回什么值</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210110190014730.png" alt="image-20210110190014730"></p>
<ol>
<li>子类可以继承父类的全部数据域和方法，但是这里继承代表的是“拥有”，即：只是拥有父类的全部数据域和方法，但不具备对某些私有数据域或私有方法的使用权（调用）。</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210110191027017.png" alt="image-20210110191027017"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210110191154675.png" alt="image-20210110191154675"></p>
<ol>
<li><img src="https://uploadfiles.nowcoder.com/images/20180701/3807435_1530425536125_D49BCBCCF82CF58C566E12F1E3130070" alt="img"></li>
</ol>
</li>
<li><p>session中存储属性：session.setAttribute(“key”，”value”)</p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115170304923.png" alt="image-20210115170304923"></p>
<ol>
<li>因为String是被final修饰的类，所以本身的内容是不会改变的，相当于基本数据类型的值传递，在changge方法中给str赋值了“test”，相当于重新创建了一个string类型的变量</li>
<li>注意String str = “test”; 和 String str = new String(“test”);的区别</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115171538415.png" alt="image-20210115171538415"></p>
<ol>
<li><strong>如果try，finally语句里均有return，忽略try的return，而使用finally的return.</strong></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115172030479.png" alt="image-20210115172030479"></p>
<ol>
<li>java object默认的基本方法中没有copy()，含有如下方法：getClass(), hashCode(), equals(), clone(), toString(), notify(), notifyAll(), wait(), finalize()</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115172236655.png" alt="image-20210115172236655"></p>
<ol>
<li>导入java.util.*不能读取其子目录的类，因为如果java.util里面有个a类，java.util.regex里面也有个a类，我们若是要调用a类的方法或属性时，应该使用哪个a类呢。所以也应该选C</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115172352568.png" alt="image-20210115172352568"></p>
<ol>
<li><p>首先 super.getClass() 是父类的getClass（）方法，其父类是Date，它的getClass（）方法是继承自Object类而且没有重写，</p>
<p>所以就是调用<strong>object的getClass（）方法。而看一下getclass的方法解释如下图</strong></p>
<p><img src="https://uploadfiles.nowcoder.com/images/20160722/579609_1469158660593_072774B6B658B3603E1AA7198722775C"></p>
<p><strong>所以可以知道是返回当前运行时的类。</strong></p>
</li>
<li><p>在调用getName()方法而getName()是：包名+类名</p>
</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115172522217.png" alt="image-20210115172522217"></p>
<ol>
<li>web容器是一种服务程序，在服务器一个端口就有一个提供相应服务的程序，而这个程序就是处理从客户端发出的请求，如JAVA中的Tomcat容器，ASP的IIS或PWS都是这样的容器。一个服务器可以多个容器。</li>
<li>servlet是运行在服务器端的小应用程序，是接收网络服务的请求和产生响应的一种方式。servlet的功能：接受http请求，产生动态http响应。</li>
</ol>
</li>
<li><p>true flase null不是关键字</p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115172819184.png" alt="image-20210115172819184"></p>
<ol>
<li><p>Jsp只会在客户端第一次发请求的时候被编译，之后的请求不会再编译，同时tomcat能自动检测jsp变更与否，变更则再进行编译。</p>
<p>第一次编译并初始化时调用： init() ；销毁调用： destroy() 。在整个jsp生命周期中均只调用一次。 </p>
<p>service()方法是接收请求，返回响应的方法。每次请求都执行一次，该方法被HttpServlet封装为doGet和doPost方法</p>
</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115172950347.png" alt="image-20210115172950347"></p>
<ol>
<li>ab相同 cd相同</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115173104765.png" alt="image-20210115173104765"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210115173119227.png" alt="image-20210115173119227"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210116162408021.png" alt="image-20210116162408021"></p>
<ol>
<li>不能有两个public类 子类不能访问父类的私有变量</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210116162521133.png" alt="image-20210116162521133"></p>
<ol>
<li>EOFException：当输入过程中意外到达文件或流的末尾时，抛出此异常。</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210116163034404.png" alt="image-20210116163034404"></p>
<ol>
<li>枚举类有三个实例，故调用三次构造方法，打印三次It is a account type 再打印FIXED</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210116163256251.png" alt="image-20210116163256251"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210116163328489.png" alt="image-20210116163328489"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210117161309975.png" alt="image-20210117161309975"></li>
</ol>
</li>
<li><p>java语言的下面几种数组复制方法中，哪个效率最高?for,System.arrayCopy,Array.copyOf,clone</p>
<p><strong>（1）从速度上看：System.arraycopy &gt; clone &gt; Arrays.copyOf &gt; for</strong><br><strong>（2）for的速度之所以最慢是因为下标表示法每次都从起点开始寻位到指定下标处（现代编译器应该对其有进行优化，改为指针），另外就是它每一次循环都要判断一次是否达到数组最大长度和进行一次额外的记录下标值的加法运算。</strong> </p>
<p>（3）System.arraycopy():native方法+jvm手写函数 在jvm中预写好速度最快</p>
<p>（4）clone:native方法但并未手写 需要jni转换 速度其次</p>
<p><strong>（5）查看Arrays.copyOf的源码可以发现，它其实本质上是调用了System.arraycopy。之所以时间差距比较大，是因为很大一部分开销全花在了Math.min函数上了。</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                 <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>min(original.length, newLength));</span><br></pre></td></tr></table></figure>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210117161051627.png" alt="image-20210117161051627"></p>
<ol>
<li><strong>由于replaceAll方法的第一个参数是一个正则表达式，而”.”在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成”/“。如果想替换的只是”.”，那么久要写成”\.”</strong></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210117161540388.png" alt="image-20210117161540388"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210117161724389.png" alt="image-20210117161724389"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210117162000840.png" alt="image-20210117162000840"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210117162008056.png" alt="image-20210117162008056"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210117162150331.png" alt="image-20210117162150331"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210117162552290.png" alt="image-20210117162552290"></p>
<ol>
<li><p>主要考核了这几个知识点：</p>
<p>1.静态内部类才可以声明静态方法</p>
<p>2.静态方法不可以使用非静态变量</p>
<p>3.抽象方法不可以有函数体 </p>
</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122162446809.png" alt="image-20210122162446809"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122162647241.png" alt="image-20210122162647241"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122162653784.png" alt="image-20210122162653784"></li>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122162702612.png" alt="image-20210122162702612"></li>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122162709782.png" alt="image-20210122162709782"></li>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122162716157.png" alt="image-20210122162716157"></li>
<li>只有A可以指定字符集、</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122162912805.png" alt="image-20210122162912805"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122162922723.png" alt="image-20210122162922723"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122163014350.png" alt="image-20210122163014350"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122163035993.png" alt="image-20210122163035993"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122163405991.png" alt="image-20210122163405991"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122163427923.png" alt="image-20210122163427923"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122163758860.png" alt="image-20210122163758860"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122163810456.png" alt="image-20210122163810456"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210122164017658.png" alt="image-20210122164017658"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123125045033.png" alt="image-20210123125045033"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123125057445.png" alt="image-20210123125057445"></li>
</ol>
</li>
</ol>
<ol start="76">
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123125435657.png" alt="image-20210123125435657"></p>
<ol>
<li>length得到的是字符，不是字节。</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123125624618.png" alt="image-20210123125624618"></p>
<ol>
<li>request.getAttribute()方法返回request范围内存在的对象，而request.getParameter()方法是获取http提交过来的数据。</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123130033328.png" alt="image-20210123130033328"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123130135614.png" alt="image-20210123130135614"></li>
<li>java是自动管理内存的，通常情况下程序运行到稳定状态，内存大小也达到一个基本稳定的值，但是内存泄露导致Gc不能回收泄露的垃圾，内存不断变大.最终超出内存界限，抛出OutOfMemoryExpection</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123130334531.png" alt="image-20210123130334531"></p>
<ol>
<li>分母为0 为运行时异常，jvm帮我们捕获，无需代码里面显式捕获</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123130740493.png" alt="image-20210123130740493"></p>
<ol>
<li>A：方法抛出异常是throws B：throw用于抛出异常 C也是错的</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123130914569.png" alt="image-20210123130914569"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123131316466.png" alt="image-20210123131316466"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123131326280.png" alt="image-20210123131326280"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123131427089.png" alt="image-20210123131427089"></p>
<ol>
<li><p>字符流和字节流每次读入的字节数是不确定的 要看是什么编码，可能相同也可能不相同；字符流和字节流都有缓冲流</p>
<p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210123131506629.png" alt="image-20210123131506629"></p>
</li>
</ol>
</li>
<li><p>IO流关系图</p>
<ol>
<li><img src="http://uploadfiles.nowcoder.com/images/20150328/138512_1427527478646_1.png" alt="img"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210128185021408.png" alt="image-20210128185021408"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210128185249478.png" alt="image-20210128185249478"></p>
<ol>
<li>​    既然求最小整数，那肯定先想到负数，则最高位（符号位）一定为1，原码中肯定是1所在的位数越高，值越小，而补码是由原码取反加1得到的，则在补码中1所在的位数一定要越低，即补码为1000 0011；由补码求得原码：1111 1101=-(64+32+16+8+4+1)=-125;</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210128185532442.png" alt="image-20210128185532442"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210128185546647.png" alt="image-20210128185546647"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210128185714149.png" alt="image-20210128185714149"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210128185825903.png" alt="image-20210128185825903"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210128185832411.png" alt="image-20210128185832411"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210206110407500.png" alt="image-20210206110407500"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210206110416072.png" alt="image-20210206110416072"></li>
</ol>
</li>
<li><p>数组是对象</p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210206110725104.png" alt="image-20210206110725104"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210206110848262.png" alt="image-20210206110848262"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210206110858596.png" alt="image-20210206110858596"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210206111117394.png" alt="image-20210206111117394"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207114345964.png" alt="image-20210207114345964"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207114354402.png" alt="image-20210207114354402"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207114610909.png" alt="image-20210207114610909"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207114620000.png" alt="image-20210207114620000"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207114733921.png" alt="image-20210207114733921"></p>
</li>
<li><p>除了jvm不是用java编写 jdk中的开发工具包都是java编写的</p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207114904411.png" alt="image-20210207114904411"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207115000623.png" alt="image-20210207115000623"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207115038891.png" alt="image-20210207115038891"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207115138087.png" alt="image-20210207115138087"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207115148922.png" alt="image-20210207115148922"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210207115220995.png" alt="image-20210207115220995"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217183025112.png" alt="image-20210217183025112"></p>
<ol>
<li>构造方法是在对象创建时就被调用，用于初始化。</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217183435998.png" alt="image-20210217183435998"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217183442132.png" alt="image-20210217183442132"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217183617554.png" alt="image-20210217183617554"></p>
<ol>
<li>D选项反了</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217183642553.png" alt="image-20210217183642553"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217183739684.png" alt="image-20210217183739684"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217183802339.png" alt="image-20210217183802339"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217183855884.png" alt="image-20210217183855884"></p>
<ol>
<li>只要是被子类重写的方法，不被super调用都是调用子类方法</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210217184036777.png" alt="image-20210217184036777"></p>
<ol>
<li>join()有资格释放资源其实是通过调用wait()来实现的</li>
<li><strong>yield方法</strong>：暂停当前正在执行的线程对象。yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。yield()只能使同优先级或更高优先级的线程有执行的机会。</li>
</ol>
</li>
<li><p>java数组下标可以是整数或整型表达式</p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210301112032516.png" alt="image-20210301112032516"></p>
<ol>
<li>final修饰的变量必须初始化或者在构造函数中赋值</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210301112145677.png" alt="image-20210301112145677"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210301112203863.png" alt="image-20210301112203863"></p>
<ol>
<li>构造函数中可以调用其他函数</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210301112506533.png" alt="image-20210301112506533"></p>
<ol>
<li><p>包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱</p>
<p>包装类的equals()方法不处理数据转型</p>
</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210301112547079.png" alt="image-20210301112547079"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210301112611454.png" alt="image-20210301112611454"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210301130408089.png" alt="image-20210301130408089"></p>
<ol>
<li>JDK8以后的默认方法和静态方法可以有方法体，题目的方法应该是指普通方法</li>
<li>接口中不可以包含静态方法</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210301130624405.png" alt="image-20210301130624405"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210312192658784.png" alt="image-20210312192658784"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210312192800067.png" alt="image-20210312192800067"></p>
<ol>
<li>子类的权限不能比父类更低</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210312193141112.png" alt="image-20210312193141112"></p>
<ol>
<li>只有char变成 int 的时候才会变为对应的assic码</li>
</ol>
</li>
<li><ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210312193301891.png" alt="image-20210312193301891"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210312193333272.png" alt="image-20210312193333272"></p>
<ol>
<li>使用链地址法</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210315170210864.png" alt="image-20210315170210864"></p>
<ol>
<li>没有final修饰的变量相加后会被自动提升为int型，与目标类型byte不相容，需要强制转换（向下转型）。</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210315170532111.png" alt="image-20210315170532111"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210315170540791.png" alt="image-20210315170540791"></li>
</ol>
</li>
<li><p>当前线程创建了一个新的线程。  新创建的线程不会立刻抢占时间片，只有等当前线程把时间片用完，其他线程才有资格拿到时间片去执行。 </p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210320190525987.png" alt="image-20210320190525987"></p>
<ol>
<li>Float类和Double类都重写对于的equals方法，在比较之前都会判断是否同属于Float对象或Double对象，如果不是直接返回false</li>
</ol>
</li>
<li><p>bool值不可以与整数比较</p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210320190754308.png" alt="image-20210320190754308"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210320190810017.png" alt="image-20210320190810017"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210320191421404.png" alt="image-20210320191421404"></p>
<ol>
<li>int是4字节 char是2字节 </li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210320191558803.png" alt="image-20210320191558803"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210320191604741.png" alt="image-20210320191604741"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210325161708797.png" alt="image-20210325161708797"></p>
<ol>
<li>把内部类理解成类的成员，成员有4种访问权限吧，内部类也是！分别为private、protected、public以及默认的访问权限</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210325162505933.png" alt="image-20210325162505933"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210325162507944.png" alt="image-20210325162507944"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210325162627104.png" alt="image-20210325162627104"></p>
<ol>
<li>接口和抽象类都可以被声明使用</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210325162647002.png" alt="image-20210325162647002"></p>
<ol>
<li>throws出现在方法头，表示可能会出现异常；</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210325162814529.png" alt="image-20210325162814529"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210325162820159.png" alt="image-20210325162820159"></li>
</ol>
</li>
<li><p>编译 Java 源程序文件产生的字节码文件的扩展名为class</p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210330143151572.png" alt="image-20210330143151572"></p>
<ol>
<li>在java语言中虚函数指代的就是抽象方法，抽象方法中不能用private，static， synchronized，native等修饰词修饰。</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210330143409089.png" alt="image-20210330143409089"></p>
<ol>
<li><p>&lt;&lt;表示左移位</p>
<p>&gt;&gt;表示带符号右移位 左边补1</p>
<p>&gt;&gt;&gt;表示无符号右移</p>
<p>但是没有&lt;&lt;&lt;运算符 因为向左位移后边总是补0</p>
</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210330143622226.png" alt="image-20210330143622226"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210330143720349.png" alt="image-20210330143720349"></p>
<ol>
<li>f：整数默认是int类型，int类型不能转型为Double，最多通过自动装箱变为Integer但是Integer与Double没有继承关系，也没法进行转型。</li>
<li>d：’f’ 字符会自动装箱成包装类，就可以向上转型成Object了。</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210401091555591.png" alt="image-20210401091555591"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210401091740491.png" alt="image-20210401091740491"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210401091857089.png" alt="image-20210401091857089"></p>
<ol>
<li>Class在java.lang包下 </li>
<li>动态代理的原理就是反射</li>
<li>CGLIB实现了字节码修改，反射不行</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210402092736266.png" alt="image-20210402092736266"></p>
<ol>
<li>==优先级高于三目运算符</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210402092825297.png" alt="image-20210402092825297"></p>
<ol>
<li>占位符只对应一个值</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210402093116400.png" alt="image-20210402093116400"></p>
<ol>
<li>持久代一般存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。<br>  持久代想要溢出，与创建对象的，大量运行字符串没关系。只有操纵调用，类信息的东西才会影响到持久代。<br> 类信息对应的就是操纵动态生成类等等。</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210402093227944.png" alt="image-20210402093227944"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210402093238684.png" alt="image-20210402093238684"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210402093328503.png" alt="image-20210402093328503"></p>
<ol>
<li>二维数组第一个括号必须有值</li>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210402093354953.png" alt="image-20210402093354953"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210402093514609.png" alt="image-20210402093514609"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210402093523670.png" alt="image-20210402093523670"></li>
</ol>
</li>
<li><p>判断一块内存空间是否符合垃圾收集器收集的标准有哪些？</p>
<ol>
<li><p>在java语言中，判断一块内存空间是否符合垃圾收集器收集标准的标准只有两个：</p>
<p>1.给对象赋值为null，以下没有调用过。</p>
<p>2.给对象赋了新的值，重新分配了内存空间。</p>
</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210403105747762.png" alt="image-20210403105747762"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210403105759617.png" alt="image-20210403105759617"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210403105853700.png" alt="image-20210403105853700"></p>
<ol>
<li>选C多半是认为置为null，但是置为null不一定就不会使用了啊~那我初始化的时候还置为null呢况且，置为null只是被认为可以当垃圾回收了。不一定会马上回收</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210403110030025.png" alt="image-20210403110030025"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210403110035611.png" alt="image-20210403110035611"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210403110121310.png" alt="image-20210403110121310"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210403110127394.png" alt="image-20210403110127394"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210403110419268.png" alt="image-20210403110419268"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210403110437642.png" alt="image-20210403110437642"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210407143928721.png" alt="image-20210407143928721"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210407144034899.png" alt="image-20210407144034899"></p>
<ol>
<li>C:都需要加锁</li>
<li>D：只能保证可见性不能保证原子性</li>
</ol>
</li>
<li><p>Char类型在Java语言里面存储的是Unicode码 不仅可以存ascii还可以存储汉字</p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210408095133385.png" alt="image-20210408095133385"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210408095138649.png" alt="image-20210408095138649"></li>
</ol>
</li>
<li><p>“|”与”||”的区别：||会短路 |不会</p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210408095325211.png" alt="image-20210408095325211"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210408095336402.png" alt="image-20210408095336402"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210408095500834.png" alt="image-20210408095500834"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210408095513572.png" alt="image-20210408095513572"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210408100710547.png" alt="image-20210408100710547"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210408100716201.png" alt="image-20210408100716201"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210408100751286.png" alt="image-20210408100751286"></p>
<ol>
<li>D选项错误，调度算法未必是剥夺式的，而准备就绪但是还没有获得CPU，它的权限更高只能说明它获得CPU被执行的几率更大而已</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210408101359955.png" alt="image-20210408101359955"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210408101410660.png" alt="image-20210408101410660"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210408101504209.png" alt="image-20210408101504209"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210409085734043.png" alt="image-20210409085734043"></p>
<ol>
<li>编译器无法事先知道new String(“hello”)是什么 也不可能自动转换</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210409085917321.png" alt="image-20210409085917321"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210409090203574.png" alt="image-20210409090203574"></p>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210409090310148.png" alt="image-20210409090310148"></p>
<ol>
<li>序列化的是对象，不是类，类变量不会被序列化</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210409090446197.png" alt="image-20210409090446197"></p>
<ol>
<li>将一个数组转化为一个List对象，这个方*<strong>返回一个ArrayList类型的对象， 这个ArrayList类并非java.util.ArrayList类，</strong>而是Arrays类的静态内部类！**</li>
<li>DateTimeFormatter是线程安全额</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210409090737358.png" alt="image-20210409090737358"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210409090753884.png" alt="image-20210409090753884"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210410103153737.png" alt="image-20210410103153737"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210410103200772.png" alt="image-20210410103200772"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210410103303261.png" alt="image-20210410103303261"></p>
<ol>
<li>一般会增加代码量</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210410103408974.png" alt="image-20210410103408974"></p>
<ol>
<li>常用ASCII码值：空格为32；数字0为48；“A”为65；“a”值为97。</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210410103631533.png" alt="image-20210410103631533"></p>
<ol>
<li>知道两同两⼩⼀⼤原则，却不清楚如果⽅法的返回类型是void和基本数据类型，则返回值重写时不可修改。但是如果⽅法的返回值是引⽤类型，重写时是可以返回该引⽤类型的⼦类的。</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210410103822487.png" alt="image-20210410103822487"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210410103830117.png" alt="image-20210410103830117"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210410103952044.png" alt="image-20210410103952044"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210410103957687.png" alt="image-20210410103957687"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210410104250875.png" alt="image-20210410104250875"></p>
<ol>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210410104310314.png" alt="image-20210410104310314"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210410104425906.png" alt="image-20210410104425906"></p>
<ol>
<li>静态成员变量或静态代码块&gt;main方法&gt;非静态成员变量或非静态代码块&gt;构造方法</li>
<li><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210410104516208.png" alt="image-20210410104516208"></li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210410104551874.png" alt="image-20210410104551874"></p>
<ol>
<li>使用的不是引用计数而是可达性分析</li>
</ol>
</li>
<li><p><img src="/2020/11/23/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/log\source_posts\牛客网练习题笔记\image-20210410104805468.png" alt="image-20210410104805468"></p>
<ol>
<li>str += ‘a’  和 str +=”a”都是对的，但是如果a前面加一个空格，那么只能用双引号了。代表字符串</li>
</ol>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>错题本</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2020/10/11/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1185-一周中的第几天"><a href="#1185-一周中的第几天" class="headerlink" title="1185. 一周中的第几天"></a><a href="https://leetcode-cn.com/problems/day-of-the-week/">1185. 一周中的第几天</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">dayOfTheWeek</span><span class="params">(<span class="keyword">int</span> day, <span class="keyword">int</span> month, <span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        String[] s = </span><br><span class="line">                &#123;<span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>,<span class="string">&quot;Sunday&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(month==<span class="number">1</span>||month==<span class="number">2</span>) &#123;</span><br><span class="line">          month+=<span class="number">12</span>;</span><br><span class="line">            year--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> iWeek=(day+<span class="number">2</span>*month+<span class="number">3</span>*(month+<span class="number">1</span>)/<span class="number">5</span>+year+year/<span class="number">4</span>-year/<span class="number">100</span>+year/<span class="number">400</span>)%<span class="number">7</span>;</span><br><span class="line">  	    <span class="keyword">return</span> s[iWeek];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>计算星期几的公式</p>
<ul>
<li>蔡勒公式：<a href="https://www.cnblogs.com/faterazer/p/11393521.html">https://www.cnblogs.com/faterazer/p/11393521.html</a></li>
<li>基姆拉尔森计算公式：<a href="https://www.cnblogs.com/SeekHit/p/7498408.html">https://www.cnblogs.com/SeekHit/p/7498408.html</a></li>
</ul>
<h2 id="624-数组列表中的最大距离"><a href="#624-数组列表中的最大距离" class="headerlink" title="624. 数组列表中的最大距离"></a>624. 数组列表中的最大距离</h2><p>题目</p>
<p><img src="/2020/10/11/%E7%AE%97%E6%B3%95/image-20201011103046603.png" alt="image-20201011103046603"></p>
<p>解题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[][] arrays)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arrays.length;</span><br><span class="line">    <span class="keyword">int</span> min = arrays[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = arrays[<span class="number">0</span>][arrays[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">int</span> maxdis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        maxdis = Math.max(maxdis,Math.abs(arrays[i][<span class="number">0</span>]-max));</span><br><span class="line">        maxdis = Math.max(maxdis,Math.abs(arrays[i][arrays[i].length]-min));</span><br><span class="line">        min = Math.min(min,arrays[i][<span class="number">0</span>]);</span><br><span class="line">        max = Math.max(max,arrays[i][arrays[i].length]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxdis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1566-重复至少-K-次且长度为-M-的模式"><a href="#1566-重复至少-K-次且长度为-M-的模式" class="headerlink" title="1566. 重复至少 K 次且长度为 M 的模式"></a><a href="https://leetcode-cn.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/">1566. 重复至少 K 次且长度为 M 的模式</a></h2><p>枚举法：</p>
<p><img src="/2020/10/11/%E7%AE%97%E6%B3%95/image-20201013092445098.png" alt="image-20201013092445098"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsPattern</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=arr.length-m*k;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> offset;</span><br><span class="line">        <span class="keyword">for</span>(offset = <span class="number">0</span>;offset&lt;m*k;offset++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i + offset] != arr[i + offset % m]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(offset == m*k) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<ul>
<li>时间复杂度：外层循环取值个数为n-m*k内存循环取值个数为m * K 故时间复杂度O((n - m * k) * m * k) = O(n * m * k)</li>
<li>空间复杂度:O(1)</li>
</ul>
<h2 id="1089-复写零"><a href="#1089-复写零" class="headerlink" title="1089. 复写零"></a><a href="https://leetcode-cn.com/problems/duplicate-zeros/">1089. 复写零</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">duplicateZeros</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 统计需要复制的0的个数，复制count个0，则会挤出原数组count个值</span></span><br><span class="line">    <span class="comment">// i进行扫描，遇到0则count自增</span></span><br><span class="line">    <span class="comment">// 若i+count大于原数组长度，则停止扫描，后面的直接舍弃</span></span><br><span class="line">    <span class="keyword">while</span>(i + count &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i++] == <span class="number">0</span>) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为循环中i自增到了下一个值，此处i--返回到上一个结束值</span></span><br><span class="line">    i--;</span><br><span class="line">    <span class="keyword">int</span> j = len - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// i从结束值开始，j从数组末尾开始，从后往前扫描，开始复制</span></span><br><span class="line">    <span class="comment">// 特别需要注意的是：若最后一个数字是0，统计需要复制的0时统计了该数，但若复制一次，则数组可能越界</span></span><br><span class="line">    <span class="comment">// 比如[1 0 2 3 0 0 5 0]第二个零</span></span><br><span class="line">    <span class="comment">// 此处+1判断，如果越界，则只复制本身</span></span><br><span class="line">    <span class="keyword">if</span>(count + i + <span class="number">1</span> &gt; len) &#123;</span><br><span class="line">        arr[j--] = arr[i--];</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遇0则复制两次，非0则复制本身</span></span><br><span class="line">    <span class="comment">// count&lt;=0时，说明前面没有0了，保持不变就行</span></span><br><span class="line">    <span class="keyword">while</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        arr[j--] = arr[i];</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            arr[j--] = arr[i];</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n) 空间复杂度O(1)</p>
<h2 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h2><p>不能用除法 因为数组元素可能有0</p>
<p>用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案</p>
<p>初始化两个数组 L R分别存放i左侧和右侧的成绩 但是要求空间复杂度为常数 可以先把L作为输出数组来计算 然后动态构造R得到结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        answer[i] = nums[i-<span class="number">1</span>] * answer[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态构造R数组 使空间复杂度降低</span></span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        answer[i] *= R;</span><br><span class="line">        R *= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="665-非递减数列"><a href="#665-非递减数列" class="headerlink" title="665. 非递减数列"></a><a href="https://leetcode-cn.com/problems/non-decreasing-array/">665. 非递减数列</a></h2><p>这道题可以看做是找向下拐点的过程，如果向下拐点存在，那么你就需要作出改变数字的操作了</p>
<p>如果在拐点前一位元素＜拐点后一位元素时，选择向上移的方法就有可能存在拐点没有被消除的现象，而如果选择向下移，就可以完全避免这种情况</p>
<p><img src="/2020/10/11/%E7%AE%97%E6%B3%95/image-20201013091407278.png" alt="image-20201013091407278"></p>
<p>如果前一位元素≥后一位元素，就只能采用上移才能保证向下拐点消除：</p>
<p><img src="/2020/10/11/%E7%AE%97%E6%B3%95/image-20201013091419805.png" alt="image-20201013091419805"></p>
<p>操作一次计数器增加1，当出现第二个向下拐点时，就说明改变一次是不行的，返回false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPossibility</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i-<span class="number">1</span>] &gt; nums[i]) count++;</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">2</span>&amp;&amp;nums[i-<span class="number">2</span>]&gt;nums[i])</span><br><span class="line">                nums[i] = nums[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> nums[i-<span class="number">1</span>] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1208-尽可能使字符串相等"><a href="#1208-尽可能使字符串相等" class="headerlink" title="1208. 尽可能使字符串相等"></a><a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/">1208. 尽可能使字符串相等</a></h2><p>注意：这道题是返回最大长度 而不是从下标0开始的最大转换长度</p>
<p>使用滑动窗口解题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">equalSubstring</span><span class="params">(String s, String t, <span class="keyword">int</span> maxCost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>,sum = <span class="number">0</span>;right&lt;len;right++)&#123;</span><br><span class="line">        sum += Math.abs(s.charAt(right)-t.charAt(right));</span><br><span class="line">        <span class="keyword">if</span>(sum &lt;= maxCost)&#123;</span><br><span class="line">            res = Math.max(res,right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum -= Math.abs(s.charAt(left)-t.charAt(left));</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="滑动窗口其他题"><a href="#滑动窗口其他题" class="headerlink" title="滑动窗口其他题"></a>滑动窗口其他题</h3><h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="comment">//创建一个双端队列 维持队列递减</span></span><br><span class="line">    Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len - k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="comment">//如果队列里有比当前元素小的，就将其移除队列，以保证队列的递减</span></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.getLast()] &lt; nums[i])</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        deque.addLast(i);</span><br><span class="line">        <span class="comment">//当队列元素位置之差大于 k，就将队首元素移除。</span></span><br><span class="line">        <span class="keyword">if</span>(deque.getFirst() == i - k)&#123;</span><br><span class="line">            deque.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)&#123;</span><br><span class="line">            res[i - k + <span class="number">1</span>] = nums[deque.getFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建立一个256位大小的整型数组 freg ，用来建立字符和其出现位置之间的映射</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">int</span> len  = s.length();</span><br><span class="line">    <span class="comment">//初始窗口</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> r = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(r+<span class="number">1</span> &lt; len &amp;&amp; arr[s.charAt(r+<span class="number">1</span>)] == <span class="number">0</span>)&#123;</span><br><span class="line">            r++;</span><br><span class="line">            arr[s.charAt(r)]++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr[s.charAt(l)]--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res,r - l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219. 存在重复元素 II"></a><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/">219. 存在重复元素 II</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">//如果窗口内有重复元素 直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(set.contains(nums[i]))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        set.add(nums[i]);</span><br><span class="line">        <span class="comment">//相当于一个大小为k的窗口</span></span><br><span class="line">        <span class="keyword">if</span>(set.size() &gt; k)&#123;</span><br><span class="line">            set.remove(nums[i-k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h4><p>right不断向右移 知道满足条件之后 left右移 直到找到最优结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = nums.length + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(right+<span class="number">1</span> &lt; nums.length &amp;&amp; sum &lt; s)&#123;</span><br><span class="line">            right++;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= s)&#123;</span><br><span class="line">            res = Math.min(res,right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res == len + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1438-绝对差不超过限制的最长连续子数组"><a href="#1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1438. 绝对差不超过限制的最长连续子数组"></a><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a></h4><p>用单调队列维护当前窗口的最大值和最小值，保持最大值与最小值的差小于 limit 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; maxQ = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; minQ = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> end = <span class="number">0</span>;end &lt; nums.length;end++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!maxQ.isEmpty() &amp;&amp; nums[maxQ.peekLast()] &lt; nums[end])</span><br><span class="line">                maxQ.pollLast();</span><br><span class="line">            maxQ.add(end);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(!minQ.isEmpty() &amp;&amp; nums[minQ.peekLast()] &gt; nums[end])</span><br><span class="line">                minQ.pollLast();</span><br><span class="line">            minQ.add(end);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(!maxQ.isEmpty() &amp;&amp; !minQ.isEmpty() &amp;&amp; nums[maxQ.peek()] - nums[minQ.peek()] &gt; limit)&#123;</span><br><span class="line">                <span class="keyword">if</span>(maxQ.peek() &lt;= start) maxQ.poll();</span><br><span class="line">                <span class="keyword">if</span>(minQ.peek() &lt;= start) minQ.poll();</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,end - start + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1011-在-D-天内送达包裹的能力"><a href="#1011-在-D-天内送达包裹的能力" class="headerlink" title="1011. 在 D 天内送达包裹的能力"></a><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力</a></h2><p>二分查找解题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.最低运载能力必然大于等于序列中的最大值；结果落在[max(weights), sum(weights)]</span></span><br><span class="line">    <span class="comment">//2.要注意是在D天“内”完成，所以运载能力要尽量小，只要是在D天之内就可以</span></span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> len = weights.length;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//计算max(weights)和sum(weights)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        left = Math.max(left,weights[i]);</span><br><span class="line">        right += weights[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> day = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当到某个包裹大于运载能力，之前的包裹记为一天</span></span><br><span class="line">        <span class="comment">//这个包裹开始记为第二天</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            tmp += weights[i];</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; mid)&#123;</span><br><span class="line">                day++;</span><br><span class="line">                tmp = weights[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//剩下的包裹再记一天</span></span><br><span class="line">        day++;</span><br><span class="line">        <span class="keyword">if</span>(day&gt;D)</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//运载能力过剩</span></span><br><span class="line">            right = mid-<span class="number">1</span>;</span><br><span class="line">            res = Math.min(res,mid); <span class="comment">//取满足条件的运载能力最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(NlogN)</li>
<li>空间复杂度：<em>O</em>(1)</li>
</ul>
<p><a href="https://www.cnblogs.com/kyoner/p/11080078.html">深入了解二分查找</a>：这篇文章详细解释了二分查找的细节和用二分查找寻找左侧边界和右侧边界</p>
<p>当while循环中的条件是left &lt; right 当left == right的时候进入去循环 漏掉了left</p>
<h2 id="974-和可被-K-整除的子数组"><a href="#974-和可被-K-整除的子数组" class="headerlink" title="974. 和可被 K 整除的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/">974. 和可被 K 整除的子数组</a></h2><p><strong>通常，涉及连续子数组问题的时候，我们使用前缀和来解决</strong>。</p>
<p><a href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/solution/he-ke-bei-k-zheng-chu-de-zi-shu-zu-by-leetcode-sol/">利用同余定理解题</a></p>
<p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560. 和为K的子数组</a>与这道题相似</p>
<h2 id="1590-使数组和能被-P-整除"><a href="#1590-使数组和能被-P-整除" class="headerlink" title="1590. 使数组和能被 P 整除"></a><a href="https://leetcode-cn.com/problems/make-sum-divisible-by-p/">1590. 使数组和能被 P 整除</a></h2><p>与974类似</p>
<p><a href="https://leetcode-cn.com/problems/make-sum-divisible-by-p/solution/zuo-yi-ti-song-yi-ti-li-kou-shang-bu-shao-lei-si-t/">解题</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubarray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求出数组和的余数</span></span><br><span class="line">    <span class="keyword">long</span> mod = sum % p;</span><br><span class="line">    <span class="keyword">if</span> (mod == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min = n;</span><br><span class="line">    <span class="comment">//我们使用一个哈希表 table，来存储之前前缀和对 P 的余数和所在的索引。（key 为余数；value 为索引）</span></span><br><span class="line">    Map&lt;Long, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    hashMap.put(<span class="number">0L</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        sum += (<span class="keyword">long</span>)nums[i];</span><br><span class="line">        <span class="keyword">long</span> curMod = sum % p;</span><br><span class="line">        hashMap.put(curMod, i);</span><br><span class="line">        <span class="keyword">long</span> targetMod = curMod &gt;= mod ? curMod - mod : curMod - mod + p;</span><br><span class="line">        <span class="keyword">if</span> (hashMap.containsKey(targetMod)) &#123;</span><br><span class="line">            min = Math.min(min, i - hashMap.get(targetMod));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min == n ? -<span class="number">1</span> : min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h2><p>这道题想要达到O(log (m+n))时间复杂度 需要使用二分查找</p>
<p>查看这篇解题的三种解题方式：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/</a></p>
<h2 id="面试题-17-21-直方图的水量"><a href="#面试题-17-21-直方图的水量" class="headerlink" title="面试题 17.21. 直方图的水量"></a><a href="https://leetcode-cn.com/problems/volume-of-histogram-lcci/">面试题 17.21. 直方图的水量</a></h2><p>双指针：当左面最大值小于 右面做大值的时候 水一定能被接住 借助的容积就是 左面最大值 - 当前指针指向的值 反之亦然</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(height.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftMax = height[left], rightMax = height[right];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftMax &lt; rightMax)&#123;</span><br><span class="line">            res += leftMax - height[left++];</span><br><span class="line">            leftMax = Math.max(leftMax,height[left]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res += rightMax - height[right--];</span><br><span class="line">            rightMax = Math.max(rightMax,height[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-17-10-主要元素"><a href="#面试题-17-10-主要元素" class="headerlink" title="面试题 17.10. 主要元素"></a><a href="https://leetcode-cn.com/problems/find-majority-element-lcci/">面试题 17.10. 主要元素</a></h2><p>通过投票法 投出票数最多的元素 在遍历看这个元素的数量是否超过数组的一半</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> vote = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> main = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vote == <span class="number">0</span>)&#123;</span><br><span class="line">            main = num;</span><br><span class="line">            vote++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num == main) vote++;</span><br><span class="line">            <span class="keyword">else</span> vote--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> half = nums.length / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    vote = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == main) vote++;</span><br><span class="line">        <span class="keyword">if</span>(vote == half) <span class="keyword">return</span> main;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1535-找出数组游戏的赢家"><a href="#1535-找出数组游戏的赢家" class="headerlink" title="1535. 找出数组游戏的赢家"></a><a href="https://leetcode-cn.com/problems/find-the-winner-of-an-array-game/">1535. 找出数组游戏的赢家</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">int</span> prev = Math.max(arr[<span class="number">0</span>],arr[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//如果k == 1 前两个元素之间只有一轮游戏</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> prev;</span><br><span class="line">        <span class="comment">//比较len轮之后 还如果没有胜出的元素 则返回数组中的最大值</span></span><br><span class="line">        <span class="keyword">int</span> maxNum = prev;</span><br><span class="line">        <span class="comment">//记录连胜的次数</span></span><br><span class="line">        <span class="keyword">int</span> consecutive = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = arr[i];</span><br><span class="line">            <span class="keyword">if</span>(prev &gt; cur)&#123;</span><br><span class="line">                consecutive++;</span><br><span class="line">                <span class="keyword">if</span>(consecutive == k)&#123;</span><br><span class="line">                    <span class="keyword">return</span> prev;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev = cur;</span><br><span class="line">                consecutive = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxNum = Math.max(maxNum,cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1552-两球之间的磁力"><a href="#1552-两球之间的磁力" class="headerlink" title="1552. 两球之间的磁力"></a><a href="https://leetcode-cn.com/problems/magnetic-force-between-two-balls/">1552. 两球之间的磁力</a></h2><p>两球的最小距离的最小值，是1；最小距离的最大值是 (最后位置的球坐标 - 最前位置的球坐标) / (球数-1)，这里需要先对position数组排序，那么易得最小球间距离的最大值为 (position[position.length - 1] - position[0]) / (m-1)<br>有最小和最大，直觉想到二分法。 以二分的中间值，作为间距去摆放球。如果摆放的球数 &gt;=m, 可认为需要增加球间距 （同时保存中间值作为候选答案）； 否则需要减少球间距。<br>一点总结是， 当碰到求最大或最小值的时候，是否可转化为二分法。属于直觉和经验吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[] position, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(position);</span><br><span class="line">        <span class="keyword">int</span> right = (position[position.length-<span class="number">1</span>] - position[<span class="number">0</span>]) / (m - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(position,mid,m))&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] position,<span class="keyword">int</span> distance,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; position.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(position[j] - position[i] &gt;= distance)&#123;</span><br><span class="line">                i = j;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count == m)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>, index = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[left] * A[left] &gt; A[right] * A[right])&#123;</span><br><span class="line">                ans[index] = A[left] * A[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[index] = A[right] * A[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1588-所有奇数长度子数组的和"><a href="#1588-所有奇数长度子数组的和" class="headerlink" title="*1588. 所有奇数长度子数组的和"></a>*<a href="https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/">1588. 所有奇数长度子数组的和</a></h2><p>解题：<a href="https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/solution/cong-on3-dao-on-de-jie-fa-by-liuyubobobo/">https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/solution/cong-on3-dao-on-de-jie-fa-by-liuyubobobo/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOddLengthSubarrays</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left_even = i / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right_even = (len - i - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> left_odd = (i + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> right_odd = (len - i) / <span class="number">2</span>;</span><br><span class="line">            ans += arr[i] * (left_even * right_even + left_odd * right_odd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="628-三个数的最大乘积"><a href="#628-三个数的最大乘积" class="headerlink" title="628. 三个数的最大乘积"></a><a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/">628. 三个数的最大乘积</a></h2><p>先把数组排序 如果没有负数的话 最大值为后三个数的乘积 有负数的话为前两个负数和最后一个元素相乘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[nums.length - <span class="number">1</span>], nums[nums.length - <span class="number">1</span>] * nums[nums.length - <span class="number">2</span>] * nums[nums.length - <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以不排序数组 找出最小的两个值 和最大的三个值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &lt;= min1) &#123;</span><br><span class="line">                min2 = min1;</span><br><span class="line">                min1 = n;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= min2) &#123;     <span class="comment">// n lies between min1 and min2</span></span><br><span class="line">                min2 = n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n &gt;= max1) &#123;            <span class="comment">// n is greater than max1, max2 and max3</span></span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = max1;</span><br><span class="line">                max1 = n;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= max2) &#123;     <span class="comment">// n lies betweeen max1 and max2</span></span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = n;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= max3) &#123;     <span class="comment">// n lies betwen max2 and max3</span></span><br><span class="line">                max3 = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(min1 * min2 * max1, max1 * max2 * max3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="381-O-1-时间插入、删除和获取随机元素-允许重复"><a href="#381-O-1-时间插入、删除和获取随机元素-允许重复" class="headerlink" title="381. O(1) 时间插入、删除和获取随机元素 - 允许重复"></a><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/">381. O(1) 时间插入、删除和获取随机元素 - 允许重复</a></h2><p><img src="/2020/10/11/%E7%AE%97%E6%B3%95/image-20201022090842197.png" alt="image-20201022090842197"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,Set&lt;Integer&gt;&gt; map;</span><br><span class="line">    java.util.Random random = <span class="keyword">new</span> java.util.Random();</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;Integer, Set&lt;Integer&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(val)) </span><br><span class="line">            map.put(val,<span class="keyword">new</span> LinkedHashSet&lt;Integer&gt;());</span><br><span class="line">        map.get(val).add(list.size());</span><br><span class="line">        list.add(val);</span><br><span class="line">        <span class="keyword">return</span> map.get(val).size() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the collection. Returns true if the collection contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(val) || map.get(val).size() == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> remove_index = map.get(val).iterator().next();</span><br><span class="line">        <span class="keyword">int</span> last = list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">        map.get(val).remove(remove_index);</span><br><span class="line">        list.set(remove_index,last);</span><br><span class="line">        map.get(last).add(remove_index);</span><br><span class="line">        map.get(last).remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the collection. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(random.nextInt(list.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="228-汇总区间"><a href="#228-汇总区间" class="headerlink" title="228. 汇总区间"></a><a href="https://leetcode-cn.com/problems/summary-ranges/">228. 汇总区间</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">summaryRanges</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; summary = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; nums.length; ++j) &#123;</span><br><span class="line">            <span class="comment">// check if j + 1 extends the range [nums[i], nums[j]]</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; nums.length &amp;&amp; nums[j + <span class="number">1</span>] == nums[j] + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// put the range [nums[i], nums[j]] into the list</span></span><br><span class="line">            <span class="keyword">if</span> (i == j)</span><br><span class="line">                summary.add(nums[i] + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                summary.add(nums[i] + <span class="string">&quot;-&gt;&quot;</span> + nums[j]);</span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> summary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>错题本</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题总结</title>
    <url>/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h2 id="final-finally-finalize区别"><a href="#final-finally-finalize区别" class="headerlink" title="final finally finalize区别"></a>final finally finalize区别</h2><p>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。<br>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。<br>finalize是一个方法，属于Object类的一个方法，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，判断一个对象是否可回收</p>
<h2 id="泛型类型擦除"><a href="#泛型类型擦除" class="headerlink" title="泛型类型擦除"></a><a href="https://www.cnblogs.com/wuqinglong/p/9456193.html">泛型类型擦除</a></h2><h2 id="为什么重写equals时必须重写hashcode方法"><a href="#为什么重写equals时必须重写hashcode方法" class="headerlink" title="为什么重写equals时必须重写hashcode方法"></a>为什么重写equals时必须重写hashcode方法</h2><p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</p>
<h2 id="为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？"><a href="#为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？" class="headerlink" title="为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？"></a><strong>为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</strong></h2><p>因为 <code>hashCode()</code> 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞</p>
<h2 id="自动拆箱与自动装箱"><a href="#自动拆箱与自动装箱" class="headerlink" title="自动拆箱与自动装箱"></a><a href="https://www.cnblogs.com/dolphin0520/p/3780005.html">自动拆箱与自动装箱</a></h2><h2 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h2><table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类（或者父类和子类之间）</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><p><strong>例一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">a</span> = <span class="number">20</span></span><br><span class="line"><span class="attr">b</span> = <span class="number">10</span></span><br><span class="line"><span class="attr">num1</span> = <span class="number">10</span></span><br><span class="line"><span class="attr">num2</span> = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210318090517177.png" alt="image-20210318090517177"></p>
<p><strong>例二</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    change(arr);</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210318090553874.png" alt="image-20210318090553874"></p>
<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>
<p><strong>例三</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        Test.swap(s1, s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;s1:&quot;</span> + s1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;s2:&quot;</span> + s2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Student x, Student y)</span> </span>&#123;</span><br><span class="line">        Student temp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">        System.out.println(<span class="string">&quot;x:&quot;</span> + x.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;y:&quot;</span> + y.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">x:</span>小李</span><br><span class="line"><span class="symbol">y:</span>小张</span><br><span class="line"><span class="symbol">s1:</span>小张</span><br><span class="line"><span class="symbol">s2:</span>小李</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210318090707050.png" alt="image-20210318090707050"></p>
<p> <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p>
<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><ol>
<li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li>
<li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>
</ol>
<h2 id="在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>在 Java 中定义一个不做事且没有参数的构造方法的作用</h2><p>Java 程序在执行子类的构造方法之前，如果没有用 <code>super()</code>来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 <code>super()</code>来调用父类中特定的构造方法，则编译时将发生错误</p>
<h2 id="对象的相等与指向他们的引用相等-两者有什么不同"><a href="#对象的相等与指向他们的引用相等-两者有什么不同" class="headerlink" title="对象的相等与指向他们的引用相等,两者有什么不同?"></a>对象的相等与指向他们的引用相等,两者有什么不同?</h2><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p>
<h2 id="在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的?"></a>在一个静态方法内调用一个非静态成员为什么是非法的?</h2><p>静态方法可以不通过对象进行调用</p>
<h2 id="String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?"></a>String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h2><p><code>String</code> 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以<code>String</code> 对象是不可变的。</p>
<p>而 <code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 <code>final</code> 关键字修饰，所以这两种对象都是可变的。</p>
<p><code>StringBuffer</code> 对方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但  却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h2 id="Arrays-asList-使用指南"><a href="#Arrays-asList-使用指南" class="headerlink" title="Arrays.asList()使用指南"></a>Arrays.asList()使用指南</h2><p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个List集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] myArray = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line"><span class="comment">//上面两个语句等价于下面一条语句</span></span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>JDK 源码对于这个方法的说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，</span></span><br><span class="line"><span class="comment">  * 与 Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><code>Arrays.asList()</code>将数组转换为集合后,底层其实还是数组，《阿里巴巴Java 开发手册》对于这个方法有如下描述：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B-Arrays.asList()%E6%96%B9%E6%B3%95.png" alt="阿里巴巴Java开发手-Arrays.asList()方法"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List myList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(myList.getClass());<span class="comment">//class java.util.Arrays$ArrayList</span></span><br></pre></td></tr></table></figure>

<h3 id="使用时的注意事项总结"><a href="#使用时的注意事项总结" class="headerlink" title="使用时的注意事项总结"></a><strong>使用时的注意事项总结</strong></h3><p><strong>传递的数组必须是对象数组，而不是基本类型。</strong></p>
<p><code>Arrays.asList()</code>是泛型方法，传入的对象必须是对象数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] myArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List myList = Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="keyword">int</span>[] array = (<span class="keyword">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。</p>
<p>我们使用包装类型数组就可以解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] myArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>下图是<code>java.util.Arrays$ArrayList</code>的简易源码，我们可以看到这个类重写的方法有哪些。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再看一下<code>java.util.AbstractList</code>的<code>remove()</code>方法，这样我们就明白为啥会抛出<code>UnsupportedOperationException</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何正确的将数组转换为ArrayList"><a href="#如何正确的将数组转换为ArrayList" class="headerlink" title="如何正确的将数组转换为ArrayList"></a>如何正确的将数组转换为ArrayList</h3><p>1.自己动手实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK1.5+</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">arrayToList</span><span class="params">(<span class="keyword">final</span> T[] array)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> List&lt;T&gt; l = <span class="keyword">new</span> ArrayList&lt;T&gt;(array.length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> T s : array) &#123;</span><br><span class="line">    l.add(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line">Integer [] myArray = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(arrayToList(myArray).getClass());<span class="comment">//class java.util.ArrayList</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 最简便的方法(推荐)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>3. 使用 Java8 的Stream(推荐)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="keyword">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p><strong>4. 使用 Guava(推荐)</strong></p>
<p>对于不可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java"><code>ImmutableList</code></a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101"><code>of()</code></a>与<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225"><code>copyOf()</code></a>工厂方法：（参数不能为空）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; il = ImmutableList.of(<span class="string">&quot;string&quot;</span>, <span class="string">&quot;elements&quot;</span>);  <span class="comment">// from varargs</span></span><br><span class="line">List&lt;String&gt; il = ImmutableList.copyOf(aStringArray);      <span class="comment">// from arrayCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>对于可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java"><code>Lists</code></a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87"><code>newArrayList()</code></a>工厂方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l1 = Lists.newArrayList(anotherListOrCollection);    <span class="comment">// from collection</span></span><br><span class="line">List&lt;String&gt; l2 = Lists.newArrayList(aStringArray);               <span class="comment">// from array</span></span><br><span class="line">List&lt;String&gt; l3 = Lists.newArrayList(<span class="string">&quot;or&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;elements&quot;</span>); <span class="comment">// from varargs</span></span><br></pre></td></tr></table></figure>

<p><strong>5. 使用 Apache Commons Collections</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">CollectionUtils.addAll(list, str);</span><br></pre></td></tr></table></figure>

<p><strong>6. 使用 Java9 的 <code>List.of()</code>方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br><span class="line">System.out.println(list); <span class="comment">/* [1, 2, 3] */</span></span><br><span class="line"><span class="comment">/* 不支持基本数据类型 */</span></span><br></pre></td></tr></table></figure>

<h2 id="Collection-toArray-方法使用的坑-amp-如何反转数组"><a href="#Collection-toArray-方法使用的坑-amp-如何反转数组" class="headerlink" title="Collection.toArray()方法使用的坑&amp;如何反转数组"></a>Collection.toArray()方法使用的坑&amp;如何反转数组</h2><p>该方法是一个泛型方法：<code>&lt;T&gt; T[] toArray(T[] a);</code> 如果<code>toArray</code>方法中没有传递任何参数的话返回的是<code>Object</code>类型数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> String[]&#123;</span><br><span class="line">    <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;over&quot;</span>, <span class="string">&quot;jumps&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">s=list.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);<span class="comment">//没有指定类型的话会报错</span></span><br></pre></td></tr></table></figure>

<p>由于JVM优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。</p>
<h2 id="不要在-foreach-循环里进行元素的-remove-add-操作"><a href="#不要在-foreach-循环里进行元素的-remove-add-操作" class="headerlink" title="不要在 foreach 循环里进行元素的 remove/add 操作"></a>不要在 foreach 循环里进行元素的 remove/add 操作</h2><p>如果要进行<code>remove</code>操作，可以调用迭代器的 <code>remove </code>方法而不是集合类的 remove 方法。因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身<code>remove/add</code>方法，迭代器都将抛出一个<code>ConcurrentModificationException</code>,这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</p>
<blockquote>
<p><strong>fail-fast 机制</strong> ：多个线程对 fail-fast 集合进行修改的时，可能会抛出ConcurrentModificationException，单线程下也会出现这种情况，上面已经提到过。</p>
</blockquote>
<p>Java8开始，可以使用<code>Collection#removeIf()</code>方法删除满足特定条件的元素,如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">list.removeIf(filter -&gt; filter % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">/* 删除list中的所有偶数 */</span></span><br><span class="line">System.out.println(list); <span class="comment">/* [1, 3, 5, 7, 9] */</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><code>java.util</code>包下面的所有的集合类都是fail-fast的，而<code>java.util.concurrent</code>包下面的所有的类都是fail-safe的。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/foreach-remove:add.png" alt="不要在 foreach 循环里进行元素的 remove/add 操作"></p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3?id=_31-jdk-%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86%e6%9c%ba%e5%88%b6">https://snailclimb.gitee.io/javaguide/#/docs/java/basis/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3?id=_31-jdk-%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86%e6%9c%ba%e5%88%b6</a></p>
<p><a href="https://blog.csdn.net/zhang6622056/article/details/87286498?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">关于cglib</a></p>
<p><a href="https://blog.csdn.net/doujinlong1/article/details/80680149?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">cglib和jdk动态代理的区别</a></p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210319101500088.png" alt="image-20210319101500088"></p>
<p>set</p>
<ul>
<li><code>HashSet</code>（无序，唯一）: 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>
<li><code>LinkedHashSet</code>：<code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>
<li><code>TreeSet</code>（有序，唯一）： 红黑树(自平衡的排序二叉树)</li>
</ul>
<p>map</p>
<ul>
<li><code>HashMap</code>：无序</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树），是有序的</li>
</ul>
<h2 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h2><ol>
<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>
<li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li>
<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ol>
<h2 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a>ArrayList扩容机制</h2><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90">通过源码一步一步分析 ArrayList 扩容机制</a></p>
<p><strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong>当添加到第十一个元素的时候 扩容为1.5倍</p>
<h2 id="HashMap的容量为什么是2的幂次方"><a href="#HashMap的容量为什么是2的幂次方" class="headerlink" title="HashMap的容量为什么是2的幂次方"></a>HashMap的容量为什么是2的幂次方</h2><p>当n为2的幂次方时，（n-1）&amp; hash 的值是均匀分布的，我们假设n=16，hash从0开始递增：</p>
<table>
<thead>
<tr>
<th>hash</th>
<th>（n-1）&amp; hash</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1111 &amp; 0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1111 &amp; 1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1111 &amp; 10</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>1111 &amp; 11</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>1111 &amp; 100</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>1111 &amp; 101</td>
<td>5</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
<tr>
<td>16</td>
<td>1111 &amp; 10000</td>
<td>0</td>
</tr>
<tr>
<td>17</td>
<td>1111 &amp; 10001</td>
<td>1</td>
</tr>
<tr>
<td>18</td>
<td>1111 &amp; 10010</td>
<td>2</td>
</tr>
</tbody></table>
<p>当n不为2的幂次方时，（n-1）&amp; hash 的值不是是均匀分布的，我们假设n=15，hash从0开始递增：</p>
<table>
<thead>
<tr>
<th>hash</th>
<th>（n-1）&amp; hash</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1110 &amp; 0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1110 &amp; 1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>1110 &amp; 10</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>1110 &amp; 11</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>1110 &amp; 100</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>1110 &amp; 101</td>
<td>4</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
<tr>
<td>16</td>
<td>1110 &amp; 10000</td>
<td>0</td>
</tr>
<tr>
<td>17</td>
<td>1110 &amp; 10001</td>
<td>0</td>
</tr>
<tr>
<td>18</td>
<td>1110 &amp; 10010</td>
<td>2</td>
</tr>
</tbody></table>
<p>由上面可以看出，当我们根据key的hash确定其在数组的位置时，如果n为2的幂次方，可以保证数据的均匀插入，如果n不是2的幂次方，可能数组的一些位置永远不会插入数据，浪费数组的空间，加大hash冲突。<br>另一方面，一般我们可能会想通过 % 求余来确定位置，这样也可以，只不过性能不如 &amp; 运算。而且当n是2的幂次方时：hash &amp; (length - 1) == hash % length</p>
<p>因此，HashMap 容量为2次幂的原因，就是为了数据的的均匀分布，减少hash冲突，毕竟hash冲突越大，代表数组中一个链的长度越大，这样的话会降低hashmap的性能。</p>
<p><a href="https://blog.csdn.net/woyingle8866/article/details/108368857">https://blog.csdn.net/woyingle8866/article/details/108368857</a></p>
<h2 id="HashMap的7中遍历方式"><a href="#HashMap的7中遍历方式" class="headerlink" title="HashMap的7中遍历方式"></a>HashMap的7中遍历方式</h2><p><a href="https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow">https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow</a></p>
<h2 id="HashMap的死循环"><a href="#HashMap的死循环" class="headerlink" title="HashMap的死循环"></a>HashMap的死循环</h2><p><a href="https://coolshell.cn/articles/9606.html">https://coolshell.cn/articles/9606.html</a></p>
<h2 id="HashMap-ConcurrentHahsMap源码"><a href="#HashMap-ConcurrentHahsMap源码" class="headerlink" title="HashMap,ConcurrentHahsMap源码"></a>HashMap,ConcurrentHahsMap源码</h2><p>阅读笔记：HashMap源码分析</p>
<h2 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构?"></a>HashMap的数据结构?</h2><p>哈希表结构(链表散列:数组+链表)实现,结合数组和链表的优点。当链表长度超过<code>8</code>时,链表转换为红黑树。</p>
<h2 id="你知道hash的实现吗-为什么要这样实现"><a href="#你知道hash的实现吗-为什么要这样实现" class="headerlink" title="你知道hash的实现吗?为什么要这样实现?"></a>你知道hash的实现吗?为什么要这样实现?</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当n即数组长度很小，假设是16的话，那么n - 1即为1111 ，这样的值和hashCode直接做按位与操作，实际上只使用了哈希值的后4位。如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成哈希冲突了，所以这里把高低位都利用起来，从而解决了这个问题。</p>
<p><strong>为什么要用异或运算符？</strong></p>
<p>保证了对象的<code>hashCode</code>的32位值只要有一位发生改变,整个<code>hash()</code>返回值就会改变。尽可能的减少碰撞。</p>
<h2 id="拉链法导致的链表过深问为什么不用二叉查找树代替-而选择红黑树-为什么不一直使用红黑树"><a href="#拉链法导致的链表过深问为什么不用二叉查找树代替-而选择红黑树-为什么不一直使用红黑树" class="headerlink" title="拉链法导致的链表过深问为什么不用二叉查找树代替,而选择红黑树?为什么不一直使用红黑树?"></a>拉链法导致的链表过深问为什么不用二叉查找树代替,而选择红黑树?为什么不一直使用红黑树?</h2><p>之所以选择红黑树是为了解决二叉查找树的缺陷,二叉查找树在特殊情况下会变成一条线性结构(这就跟原来使用链表结构一样了,造成很深的问题),遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋,右旋、变色这些操作来保持平衡,引入红黑树就是为了查找数据快,解决链表查询深度的问题,我们知道红黑树属于平衡二叉树,但是为了保持”平衡”是需要付出代价的,但是该代价所损耗的资源要比遍历线性链表要少,所以当长度大于8的时候,会使用红黑树,如果链表长度很短的话,根本不需要引入红黑树,引入反而会慢。</p>
<h2 id="ConcurrentHashMap在JDK1-8中-为什么要使用内置锁synchronized来代替重入锁ReentrantLock"><a href="#ConcurrentHashMap在JDK1-8中-为什么要使用内置锁synchronized来代替重入锁ReentrantLock" class="headerlink" title="ConcurrentHashMap在JDK1.8中,为什么要使用内置锁synchronized来代替重入锁ReentrantLock?"></a>ConcurrentHashMap在JDK1.8中,为什么要使用内置锁synchronized来代替重入锁ReentrantLock?</h2><ul>
<li>①、粒度降低了;</li>
<li>②、<code>JVM</code>开发团队没有放弃<code>synchronized</code>,而且基于<code>JVM</code>的<code>synchronized</code>优化空间更大,更加自然。</li>
<li>③、在大量的数据操作下,对于<code>JVM</code>的内存压力,基于<code>API</code>的<code>ReentrantLock</code>会开销更多的内存。</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210320134109503.png" alt="image-20210320134109503"></p>
<p>Error：是程序中无法处理的错误，表示运行应用程序中出现了严重的错误。此类错误一般表示代码运行时JVM出现问题。通常有Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如说当jvm耗完可用内存时，将出现OutOfMemoryError。此类错误发生时，JVM将终止线程。非代码性错误。因此，当此类错误发生时，应用不应该去处理此类错误。</p>
<p>Exception：程序本身可以捕获并且可以处理的异常。</p>
<p>运行时异常(不受检异常)：RuntimeException类极其子类表示JVM在运行期间可能出现的错误。编译器不会检查此类异常，并且不要求处理异常，比如用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）。此类异常属于不可查异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。</p>
<p>非运行时异常(受检异常)：Exception中除RuntimeException极其子类之外的异常。编译器会检查此类异常，如果程序中出现此类异常，比如说IOException，必须对该异常进行处理，要么使用try-catch捕获，要么使用throws语句抛出，否则编译不通过。</p>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p><a href="https://blog.csdn.net/nightcurtis/article/details/51324105?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujs">博客</a></p>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210320140134147.png" alt="image-20210320140134147"></p>
<h2 id="父类的静态方法能否被子类重写"><a href="#父类的静态方法能否被子类重写" class="headerlink" title="父类的静态方法能否被子类重写?"></a>父类的静态方法能否被子类重写?</h2><p>不能.重写只适用于实例方法,不能用于静态方法,而子类当中含有和父类相同签名的静态方法,我们一般称之为覆盖.</p>
<h2 id="什么是不可变对象-好处是什么-原理？"><a href="#什么是不可变对象-好处是什么-原理？" class="headerlink" title="什么是不可变对象?好处是什么?原理？"></a>什么是不可变对象?好处是什么?原理？</h2><p>不可变对象指对象一旦被创建,状态就不能再改变,任何修改都会创建一个新的对象,如 String、Integer及其它包装类.不可变对象最大的好处是线程安全.</p>
<p>Final 变量在并发当中，原理是通过禁止cpu的指令集重排序，保证了对象的内存可见性， final 域能确保初始化过程的安全性， 防止对象引用在对象被完全构造完成前被其他线程拿到并使用（ fianl 可以保证正在创建中的对象不能被其他线程访问到）</p>
<h2 id="静态变量和实例变量的区别"><a href="#静态变量和实例变量的区别" class="headerlink" title="静态变量和实例变量的区别?"></a>静态变量和实例变量的区别?</h2><p>静态变量存储在方法区,属于类所有.实例变量存储在堆当中,其引用存在当前线程栈</p>
<h2 id="java-创建对象的几种方式"><a href="#java-创建对象的几种方式" class="headerlink" title="java 创建对象的几种方式"></a>java 创建对象的几种方式</h2><p>java中提供了以下四种创建对象的方式:</p>
<ul>
<li>new创建新对象</li>
<li>通过反射机制</li>
<li>采用clone机制</li>
<li>通过序列化机制</li>
</ul>
<h2 id="String-s-new-String-quot-abc-quot-创建了几个String对象"><a href="#String-s-new-String-quot-abc-quot-创建了几个String对象" class="headerlink" title="String s = new String(&quot;abc&quot;)创建了几个String对象?"></a><code>String s = new String(&quot;abc&quot;)</code>创建了几个String对象?</h2><p>2个.一个是字符串字面常数,在字符串常量池中;另一个是new出来的字符串对象,在堆中.</p>
<h2 id="请问s1-s3是true还是false，s1-s4是false还是true-s1-s5呢？"><a href="#请问s1-s3是true还是false，s1-s4是false还是true-s1-s5呢？" class="headerlink" title="请问s1==s3是true还是false，s1==s4是false还是true?s1==s5呢？"></a>请问s1<code>==</code>s3是true还是false，s1<code>==</code>s4是false还是true?s1<code>==</code>s5呢？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">String s3 = s2 + <span class="string">&quot;bc&quot;</span>;</span><br><span class="line">String s4 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;bc&quot;</span>;</span><br><span class="line">String s5 = s3.intern();</span><br></pre></td></tr></table></figure>

<p>s1==s3返回false,s1==s4返回true,s1==s5返回true.</p>
<p>“abc”这个字符串常量值会直接方法字符串常量池中,s1是对其的引用.由于s2是个变量,编译器在编译期间无法确定该变量后续会不会改,因此无法直接将s3的值在编译器计算出来,因此s3是堆中”abc”的引用.因此s1!=s3.对于s4而言,其赋值号右边是常量表达式,因此可以在编译阶段直接被优化为”abc”,由于”abc”已经在字符串常量池中存在,因此s4是对其的引用,此时也就意味s1和s4引用了常量池中的同一个”abc”.所以s1==s4.String中的intern()会首先从字符串常量池中检索是否已经存在字面值为”abc”的对象,如果不存在则先将其添加到字符串常量池中,否则直接返回已存在字符串常量的引用.此处由于”abc”已经存在字符串常量池中了,因此s5和s1引用的是同一个字符串常量.</p>
<h2 id="try-catch-finally-中哪个部分可以省略？"><a href="#try-catch-finally-中哪个部分可以省略？" class="headerlink" title="try-catch-finally 中哪个部分可以省略？"></a>try-catch-finally 中哪个部分可以省略？</h2><p>catch和finally可以省略其中一个</p>
<h2 id="try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h2><p>会执行，在 return 前执行。</p>
<p>在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰</p>
<h2 id="throw-和-throws-的区别是什么"><a href="#throw-和-throws-的区别是什么" class="headerlink" title="throw 和 throws 的区别是什么"></a>throw 和 throws 的区别是什么</h2><p>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。<br>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</p>
<h2 id="类-ExampleA-继承-Exception，类-ExampleB-继承ExampleA"><a href="#类-ExampleA-继承-Exception，类-ExampleB-继承ExampleA" class="headerlink" title="类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA"></a>类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA</h2><p>有如下代码片断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> ExampleB(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>（ExampleA e）&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;ExampleA&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>（Exception e）&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问执行此段代码的输出是什么？ExampleA。</p>
<h2 id="Java集合的快速失败机制-“fail-fast”？"><a href="#Java集合的快速失败机制-“fail-fast”？" class="headerlink" title="Java集合的快速失败机制 “fail-fast”？"></a>Java集合的快速失败机制 “fail-fast”？</h2><p>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</p>
<p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<p>解决办法：</p>
<ul>
<li><p>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</p>
</li>
<li><p>使用CopyOnWriteArrayList来替换ArrayList(<a href>关于CopyOnWriteArrayList</a>)</p>
</li>
</ul>
<h2 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h2><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p>
<h2 id="Iterator的特点"><a href="#Iterator的特点" class="headerlink" title="Iterator的特点"></a>Iterator的特点</h2><p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>
<p>可以使用Iterator的remove方法边遍历集合边移除元素</p>
<h2 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h2><p>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。<br>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。<br>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置</p>
<h2 id="遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List-遍历的最佳实践是什么？"><a href="#遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List-遍历的最佳实践是什么？" class="headerlink" title="遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？"></a>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</h2><p>遍历方式有以下几种：</p>
<p>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</p>
<p>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</p>
<p>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</p>
<p>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</p>
<p>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。<br>如果没有实现该接口，表示不支持 Random Access，如LinkedList。<br>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</p>
<h2 id="多线程场景下如何使用-ArrayList？"><a href="#多线程场景下如何使用-ArrayList？" class="headerlink" title="多线程场景下如何使用 ArrayList？"></a>多线程场景下如何使用 ArrayList？</h2><p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。</p>
<h2 id="为什么HashMap中String、Integer这样的包装类适合作为Key？"><a href="#为什么HashMap中String、Integer这样的包装类适合作为Key？" class="headerlink" title="为什么HashMap中String、Integer这样的包装类适合作为Key？"></a>为什么HashMap中String、Integer这样的包装类适合作为Key？</h2><p>答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p>
<p>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况<br>内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</p>
<h2 id="如果使用Object作为HashMap的Key，应该怎么办呢？"><a href="#如果使用Object作为HashMap的Key，应该怎么办呢？" class="headerlink" title="如果使用Object作为HashMap的Key，应该怎么办呢？"></a>如果使用Object作为HashMap的Key，应该怎么办呢？</h2><p>答：重写hashCode()和equals()方法</p>
<p>重写hashCode()是因为需要计算数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；<br>重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性；</p>
<h2 id="如何决定使用-HashMap-还是-TreeMap？"><a href="#如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是 TreeMap？"></a>如何决定使用 HashMap 还是 TreeMap？</h2><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。</p>
<h2 id="Comparator和Comparable的区别？"><a href="#Comparator和Comparable的区别？" class="headerlink" title="Comparator和Comparable的区别？"></a>Comparator和Comparable的区别？</h2><p>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序<br>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序<br>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p>
<p>参考博客：<a href="https://www.cnblogs.com/sunflower627/p/3158042.html">https://www.cnblogs.com/sunflower627/p/3158042.html</a></p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="七层协议-五层协议-四层协议"><a href="#七层协议-五层协议-四层协议" class="headerlink" title="七层协议 五层协议 四层协议"></a><strong>七层协议 五层协议 四层协议</strong></h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210330145311415.png" alt="image-20210330145311415"> </p>
<p>应用层：通过应用进程之间的交互完成特定的网络应用</p>
<p><strong>运输层</strong>：为两台计算机之间进程的通信提供通用的数据传输服务</p>
<p>网络层：计算机网络中进行通讯的两个计算机之间的有很多数据链路和通讯子网，网络层负责找到合适的网间路由和链路节点，确保数据及时传输    </p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210123145701309.png"></p>
<p><strong>为什么需要三次握手</strong></p>
<p>三次握手的最主要目的是保证连接是双工的。为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次握手。</p>
<p><strong>第2次握手传回了ACK，为什么还要传回SYN？</strong></p>
<p>接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信</p>
<p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。 ACK(Acknowledgement)是应答消息</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭</p>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210123150815077.png" alt="image-20210123150815077"></p>
<p><strong>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</strong></p>
<p>这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK 和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了，但是你还可以给对方发送数据，也有这么种可能，你还有一些数据在传给对方的途中，所以你不能立马关闭连接，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的。</p>
<p><strong>为什么 TIME_WAIT 状态还需要等 2MSL（Maximum Segment Lifetime）后才能返回到 CLOSED 状态？</strong></p>
<p>因为我们必须要假想网络是不可靠的，你无法保证你最后发送的 ACK 报文会一定被对方收到，因此对方处于 LAST_ACK 状态下的 SOCKET 可能会因为超时未收到 ACK 报文，而重发 FIN 报文，所以这个 TIME_WAIT 状态的作用就是用来重发可能丢失的 ACK 报文</p>
<p><strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong></p>
<p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h2 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a>tcp和udp的区别</h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210124134700276.png" alt="image-20210124134700276"></p>
<h2 id="tcp协议如何保证可靠传输"><a href="#tcp协议如何保证可靠传输" class="headerlink" title="tcp协议如何保证可靠传输"></a>tcp协议如何保证可靠传输</h2><ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块并为每一个包进行编号，接收方对数据包进行排序，丢弃重复的数据，把有序数据传送给应用层。</li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP发送端不允许发送超过接收端缓冲区大小的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 利用滑动窗口实现流量控制。</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h2 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h2><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p>
<h3 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h3><ul>
<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</li>
<li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li>
</ul>
<p><strong>优点：</strong> 简单</p>
<p><strong>缺点：</strong> 信道利用率低，等待时间长</p>
<p><strong>确认丢失和确认迟到</strong></p>
<ul>
<li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>
<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li>
</ul>
<h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p>
<p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a><a href="https://blog.csdn.net/qq_41431406/article/details/97926927">拥塞控制</a></h2><h2 id="从输入url到页面加载完成发生了什么"><a href="#从输入url到页面加载完成发生了什么" class="headerlink" title="从输入url到页面加载完成发生了什么"></a><a href="https://www.cnblogs.com/liutianzeng/p/10456865.html">从输入url到页面加载完成发生了什么</a></h2><h2 id="dns域名解析过程"><a href="#dns域名解析过程" class="headerlink" title="dns域名解析过程"></a><a href="https://blog.csdn.net/baidu_37964071/article/details/80500825?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&dist_request_id=1331974.5978.16185553650719277&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">dns域名解析过程</a></h2><h2 id="同源策略和跨域"><a href="#同源策略和跨域" class="headerlink" title="同源策略和跨域"></a>同源策略和跨域</h2><p>同源策略：如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的<strong>源</strong></p>
<p>同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源</p>
<p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p>
<p>跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制。</p>
<p>跨域解决方法</p>
<p>例如<a href="http://www.123.com/index.html%E9%9C%80%E8%A6%81%E8%B0%83%E7%94%A8www.456.com/server.php%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%86%99%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3www.123.com/server.php%EF%BC%8C%E7%94%B1%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%E5%9C%A8%E5%90%8E%E7%AB%AF%E5%8E%BB%E8%B0%83%E7%94%A8www.456.com/server.php%E5%B9%B6%E6%8B%BF%E5%88%B0%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E8%BF%94%E5%9B%9E%E7%BB%99index.html%EF%BC%8C%E8%BF%99%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%90%86%E7%9A%84%E6%A8%A1%E5%BC%8F%E3%80%82%E7%9B%B8%E5%BD%93%E4%BA%8E%E7%BB%95%E8%BF%87%E4%BA%86%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%EF%BC%8C%E8%87%AA%E7%84%B6%E5%B0%B1%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E3%80%82">www.123.com/index.html需要调用www.456.com/server.php，可以写一个接口www.123.com/server.php，由这个接口在后端去调用www.456.com/server.php并拿到返回值，然后再返回给index.html，这就是一个代理的模式。相当于绕过了浏览器端，自然就不存在跨域问题。</a></p>
<h2 id="长连接和短链接"><a href="#长连接和短链接" class="headerlink" title="长连接和短链接"></a>长连接和短链接</h2><p>所谓，短连接说的就是 server 端 与 client 端建⽴连接之后，读写完成之后就关闭掉连接，如果下⼀次再要互相发送消息，就要重新连接。短连接的优点很明显，就是管理和实现都比较简单，缺点也很明显，每⼀次的读写都要建⽴连接必然会带来⼤量⽹络资源的消耗，并且连接的建⽴也需要耗费时间。<br>⻓连接说的就是 client 向 server 双⽅建⽴连接之后，即使 client 与 server 完成⼀次读写，它们之间的连接并不会主动关闭，后续的读写操作会继续使⽤这个连接。⻓连接的可以省去较多的 TCP 建⽴和关闭的操作，降低对⽹络资源的依赖，节约时间。对于频繁请求资源的客户来说，⾮常适⽤⻓连接。</p>
<h2 id="Cookie机制"><a href="#Cookie机制" class="headerlink" title="Cookie机制"></a>Cookie机制</h2><p>当用户第一次访问并登陆一个网站的时候，cookie的设置以及发送会经历以下4个步骤：</p>
<p><strong>客户端发送一个请求到服务器</strong> –》 <strong>服务器发送一个HttpResponse响应到客户端，其中包含Set-Cookie的头部</strong> –》 <strong>客户端保存cookie，之后向服务器发送请求时，HttpRequest请求中会包含一个Cookie的头部</strong> –》<strong>服务器返回响应数据</strong></p>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/log\source_posts\面试题总结\image-20210507153716780.png" alt="image-20210507153716780"></p>
<h2 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a><a href="https://blog.csdn.net/qq_28296925/article/details/80921585">Session和Cookie</a></h2><h2 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h2><p>URI是：协议+主机（不含端口）+具体路径（不一定含文件）；URL是：协议+主机（默认是80，或是别的端口）+具体文件路径（还必须是对应到路径下面的具体文件名称）。所以URI是粗框架，URL是详细定位。。。比如URI：<a href="http://www.123.com/123/%EF%BC%8C%E8%AF%A5%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%8F%AF%E8%83%BD%E6%9C%89index.html%E5%92%8Cindex.htm%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%89">http://www.123.com/123/，该目录下可能有index.html和index.htm（两个文件）</a></p>
<p>、比如URL:<a href="http://www.123.com/123/index.html%EF%BC%88%E5%94%AF%E4%B8%80%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%89">http://www.123.com/123/index.html（唯一的文件）</a></p>
<h2 id="Http和Https的区别"><a href="#Http和Https的区别" class="headerlink" title="Http和Https的区别"></a>Http和Https的区别</h2><ol>
<li><p><strong>端口</strong> ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p>
</li>
<li><p>安全性和资源消耗：</p>
<p>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。</p>
<p>HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p>
<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li>
</ul>
</li>
</ol>
<h2 id="带宽和吞吐量"><a href="#带宽和吞吐量" class="headerlink" title="带宽和吞吐量"></a>带宽和吞吐量</h2><p>两者的单位都是Mbps.当我们讨论通信链路的带宽时，一般是指链路上每秒所能传送的<a href="http://baike.baidu.com/view/3021024.htm">比特数</a>，它取决于链路时钟速率和信道编码在计算机网络中又称为线速。我们可以说<a href="http://baike.baidu.com/view/848.htm">以太网</a>的带宽是10Mbps。但是，我们需要区分链路上的可用带宽（带宽）与实际链路中每秒所能传送的比特数（吞吐量）。我们倾向于用“吞吐量”一次来表示一个系统的测试性能。这样，因为实现受各种低效率因素的影响，所以由一段带宽为10Mbps的链路连接的一对节点可能只达到2Mbps的吞吐量。这样就意味着，一个主机上的应用能够以2Mbps的速度向另外的一个主机发送数据。</p>
<h2 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h2><p>A类地址(1~126)：网络号占前8位，以0开头，主机号占后24位。</p>
<p>B类地址(128~191)：网络号占前16位，以10开头，主机号占后16位。</p>
<p>C类地址(192~223)：网络号占前24位，以110开头，主机号占后8位。</p>
<p>D类地址(224~239)：以1110开头，保留位多播地址。</p>
<p>E类地址(240~255)：以1111开头，保留位今后使用。</p>
<h2 id="客户端不断进行请求链接会怎样-DDos-Distributed-Denial-of-Service-攻击？"><a href="#客户端不断进行请求链接会怎样-DDos-Distributed-Denial-of-Service-攻击？" class="headerlink" title="客户端不断进行请求链接会怎样 DDos(Distributed Denial of Service)攻击？"></a>客户端不断进行请求链接会怎样 DDos(Distributed Denial of Service)攻击？</h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210126124355659.png" alt="image-20210126124355659"></p>
<h2 id="Get与POST的区别"><a href="#Get与POST的区别" class="headerlink" title="Get与POST的区别"></a>Get与POST的区别</h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210126124446349.png" alt="image-20210126124446349"></p>
<h2 id="网络层的ARP协议工作原理"><a href="#网络层的ARP协议工作原理" class="headerlink" title="网络层的ARP协议工作原理"></a>网络层的ARP协议工作原理</h2><p>网络层的ARP协议完成了IP地址与物理地址的映射。首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p>
<h2 id="物理层的三个基本问题"><a href="#物理层的三个基本问题" class="headerlink" title="物理层的三个基本问题"></a>物理层的三个基本问题</h2><p><strong>封装成帧</strong>：在一段数据前后添加首部和尾部，其中包含控制信息 还起到帧定界的功能</p>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210127140125472.png" alt="image-20210127140125472"></p>
<ul>
<li>mtu：最大传送单元</li>
</ul>
<p><strong>透明传输</strong>：如果数据中出现像SOH，EOT这样的帧定界控制字符，使用转义符进行转义，接收端收到数据后再去掉转义符</p>
<p><strong>差错检测</strong>：<strong>使用循环冗余检测传输过程中是否有差错</strong></p>
<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="BIO和NIO"><a href="#BIO和NIO" class="headerlink" title="BIO和NIO"></a>BIO和NIO</h2><p>BIO(同步阻塞IO模式):服务器实现模式为 一个连接对应一个线程，即客户端有连接请求时服务端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销</p>
<p>NIO(同步非阻塞IO模式):服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接时如果有IO请求就进行处理</p>
<h2 id="netty是什么"><a href="#netty是什么" class="headerlink" title="netty是什么"></a>netty是什么</h2><ol>
<li>Netty 是⼀个 基于 NIO 的 client-server(客户端服务器)框架，使⽤它可以快速简单地开发⽹络应⽤程序。</li>
<li>它极⼤地简化并优化了 TCP 和 UDP 套接字服务等⽹络编程,并且性能以及安全性等很多⽅⾯甚⾄都要更好。</li>
<li>⽀持多种协议 如 FTP，SMTP，HTTP 以及各种⼆进制和基于⽂本的传统协议。</li>
</ol>
<h2 id="netty应用场景"><a href="#netty应用场景" class="headerlink" title="netty应用场景"></a>netty应用场景</h2><p>Netty 主要⽤来做⽹络通信 :</p>
<ol>
<li>作为 RPC 框架的⽹络通信⼯具 ： 我们在分布式系统中，不同服务节点之间经常需要相互调⽤，这个时候就需要 RPC 框架了。⽐如我调⽤另外⼀个节点的⽅法的话，⾄少是要让对⽅知道我调⽤的是哪个类中的哪个⽅法以及相关参数</li>
<li>实现⼀个⾃⼰的 HTTP 服务器 ：作为 Java 后端开发，我们⼀般使⽤ Tomcat 比较 多。⼀个最基本的 HTTP 服务器可要以处理常⻅的 HTTP Method 的请求，⽐如 POST 请求、GET<br>请求等等。</li>
<li>实现⼀个即时通讯系统</li>
<li><strong>实现消息推送系统</strong></li>
</ol>
<h2 id="netty的核心组件"><a href="#netty的核心组件" class="headerlink" title="netty的核心组件"></a>netty的核心组件</h2><p>Channel：Netty 网络操作抽象类，它除了包括基本的 I/O 操作，如 bind、connect、read、write 等。</p>
<p>EventLoop：主要是配合 Channel 处理 I/O 操作，用来处理连接的生命周期中所发生的事情。</p>
<p>ChannelFuture：Netty 框架中所有的 I/O 操作都为异步的，因此我们需要 ChannelFuture 的 addListener()注册ChannelFutureListener 监听事件，当操作执行成功或者失败时，监听就会自动触发返回结果。</p>
<p>ChannelHandler：充当了所有处理入站和出站数据的逻辑容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。</p>
<p>ChannelPipeline：为 ChannelHandler 链提供了容器，当 channel 创建时，就会被自动分配到它专属的 ChannelPipeline，这个关联是永久性的。</p>
<h2 id="Netty-的零拷贝实现？"><a href="#Netty-的零拷贝实现？" class="headerlink" title="Netty 的零拷贝实现？"></a>Netty 的零拷贝实现？</h2><p>Netty 的零拷贝主要包含三个方面：</p>
<p>Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p>
<p>Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。</p>
<p>Netty 的文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroCopyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="number">7001</span>);</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        ServerSocket socket = serverSocketChannel.socket();</span><br><span class="line">        socket.bind(inetSocketAddress);</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            <span class="keyword">int</span> readCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(-<span class="number">1</span> != readCount)&#123;</span><br><span class="line">                socketChannel.read(byteBuffer);</span><br><span class="line">                <span class="comment">//倒带:position = 0 清除mark</span></span><br><span class="line">                byteBuffer.rewind();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroCopyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>,<span class="number">7001</span>));</span><br><span class="line">        String filename = <span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(filename).getChannel();</span><br><span class="line">        <span class="comment">//linux:一次transferTo方法就可以完成传输</span></span><br><span class="line">        <span class="comment">//windows: 一次transferTo只能传输8m</span></span><br><span class="line">        <span class="keyword">long</span> count = fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br><span class="line">        fileChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="netty心跳机制"><a href="#netty心跳机制" class="headerlink" title="netty心跳机制"></a>netty心跳机制</h2><p>⼼跳机制的⼯作原理是: 在 client 与 server 之间在⼀定时间内没有数据交互时, 即处于 idle 状态时, 客户端或服务器就会发送⼀个特殊的数据包给对⽅, 当接收⽅收到这个数据报⽂后, 也⽴即发送⼀个特殊的数据报⽂, 回应发送⽅, 此即⼀个 PING-PONG 交互。所以, 当某⼀端收到⼼跳消息后, 就知道了对⽅仍然在线, 这就确保 TCP 连接的有效性.</p>
<p>TCP 实际上⾃带的就有⻓连接选项，本身是也有⼼跳包机制，也就是 TCP 的选项： SO_KEEPALIVE 。但是，TCP 协议层⾯的⻓连接灵活性不够。所以，⼀般情况下我们都是在应⽤层协议上实现⾃定义⼼跳机制的，也就是在 Netty 层⾯通过编码实现。通过 Netty 实现⼼跳机制的话，核⼼类是IdleStateHandler 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IdleStateHandler是netty提供的处理空闲状态的处理器</span></span><br><span class="line"><span class="comment">//readerIdleTime表示多长时间没读 会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">//writerIdleTime</span></span><br><span class="line"><span class="comment">//allIdleTime</span></span><br><span class="line"><span class="comment">//当IdleStatement触发后 就会传递给管道的下一个handler 通过userEventTriggered处理</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>, TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure>

<h2 id="TCP-粘包-拆包的原因及解决方法？"><a href="#TCP-粘包-拆包的原因及解决方法？" class="headerlink" title="TCP 粘包/拆包的原因及解决方法？"></a><strong>TCP 粘包/拆包的原因及解决方法？</strong></h2><ul>
<li>TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</li>
<li>TCP粘包/分包的原因：<ul>
<li>应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；</li>
<li>进行MSS大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包</li>
<li>以太网帧的payload（净荷）大于MTU（1500字节）进行ip分片。</li>
</ul>
</li>
<li>解决方法<ul>
<li>消息定长：FixedLengthFrameDecoder类</li>
<li>包尾增加特殊字符分割：行分隔符类：LineBasedFrameDecoder或自定义分隔符类 ：DelimiterBasedFrameDecoder</li>
<li>将消息分为消息头和消息体，消息头中带有长度信息：LengthFieldBasedFrameDecoder类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</li>
</ul>
</li>
</ul>
<h2 id="Netty的线程模型？"><a href="#Netty的线程模型？" class="headerlink" title="Netty的线程模型？"></a><strong>Netty的线程模型？</strong></h2><p>Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件，由对应的Handler处理。</p>
<h2 id="同步与异步、阻塞与非阻塞的区别？"><a href="#同步与异步、阻塞与非阻塞的区别？" class="headerlink" title="同步与异步、阻塞与非阻塞的区别？"></a>同步与异步、阻塞与非阻塞的区别？</h2><p>同步和异步关注的是<strong>消息通信机制</strong>.阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong></p>
<p>同步：发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。例如普通B/S模式（同步）：提交请求-&gt;等待服务器处理-&gt;处理完毕返回 这个期间客户端浏览器不能干任何事。</p>
<p>异步：当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。例如 ajax请求（异步）: 请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕</p>
<p>阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回,它还会抢占cpu去执行其他逻辑，也会主动检测io是否准备好。</p>
<p>非阻塞：指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>
<h2 id="select、poll、epoll之间的区别"><a href="#select、poll、epoll之间的区别" class="headerlink" title="select、poll、epoll之间的区别"></a>select、poll、epoll之间的区别</h2><p>(1)select==&gt;时间复杂度O(n)</p>
<p>它仅仅知道了，有I/O事件发生了，却并不知道是哪几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</p>
<p>(2)poll==&gt;时间复杂度O(n)</p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，原因是它是基于链表来存储的.</p>
<p>(3)epoll==&gt;时间复杂度O(1)</p>
<p><strong>epoll可以理解为event poll</strong>，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。<strong>（复杂度降低到了O(1)）</strong></p>
<p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。<strong>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。 </p>
<h2 id="netty执行流程"><a href="#netty执行流程" class="headerlink" title="netty执行流程"></a>netty执行流程</h2><ol>
<li>创建ServerBootStrap实例</li>
<li>设置并绑定Reactor线程池：EventLoopGroup，EventLoop就是处理所有注册到本线程的Selector上面的Channel</li>
<li>设置并绑定服务端的channel</li>
<li>创建处理网络事件的ChannelPipeline和handler，网络事件以流的形式在其中流转，handler完成多数的功能定制：比如编解码 SSl安全认证</li>
<li>绑定并启动监听端口</li>
<li>当轮询到准备就绪的channel后，由Reactor线程：NioEventLoop执行pipline中的方法，最终调度并执行channelHandler</li>
</ol>
<h2 id="为什么要用Netty-呢"><a href="#为什么要用Netty-呢" class="headerlink" title="为什么要用Netty 呢"></a>为什么要用Netty 呢</h2><p>因为 Netty 具有下⾯这些优点，并且相⽐于直接使⽤ JDK ⾃带的 NIO 相关的 API 来说更加易⽤。</p>
<ul>
<li>统⼀的 API，⽀持多种传输类型，阻塞和⾮阻塞的。</li>
<li>简单⽽强⼤的线程模型。</li>
<li>⾃带编解码器解决 TCP 粘包/拆包问题。</li>
<li>⾃带各种协议栈。</li>
<li>真正的⽆连接数据包套接字⽀持。</li>
<li>⽐直接使⽤ Java 核⼼ API 有更⾼的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制。</li>
<li>安全性不错，有完整的 SSL/TLS 以及 StartTLS ⽀持。</li>
<li>成熟稳定，经历了⼤型项⽬的使⽤和考验，⽽且很多开源项⽬都使⽤到了 Netty， ⽐如我们经常接触的 Dubbo、RocketMQ 等等。</li>
</ul>
<h2 id="Bootstrap-和-ServerBootstrap-了解么？"><a href="#Bootstrap-和-ServerBootstrap-了解么？" class="headerlink" title="Bootstrap 和 ServerBootstrap 了解么？"></a>Bootstrap 和 ServerBootstrap 了解么？</h2><ol>
<li>Bootstrap 通常使⽤ connet() ⽅法连接到远程的主机和端⼝，作为⼀个 Netty TCP 协议通信中的客户端。另外， Bootstrap 也可以通过 bind() ⽅法绑定本地的⼀个端⼝，作为UDP 协议通信中的⼀端。</li>
<li>ServerBootstrap 通常使⽤ bind() ⽅法绑定本地的端⼝上，然后等待客户端的连接。</li>
<li>Bootstrap 只需要配置⼀个线程组— EventLoopGroup ,⽽ ServerBootstrap 需要配置两个线程组— EventLoopGroup ，⼀个⽤于接收连接，⼀个⽤于具体的事件处理。</li>
</ol>
<h2 id="Netty-服务端和客户端的启动过程"><a href="#Netty-服务端和客户端的启动过程" class="headerlink" title="Netty 服务端和客户端的启动过程"></a><strong>Netty 服务端和客户端的启动过程</strong></h2><p><strong>服务端</strong></p>
<ul>
<li>创建两个NioEventLoopGroup对象实例：一个处理连接请求 一个处理读写操作</li>
<li>创建一个服务端启动引导类/辅助类</li>
<li>通过group方法给引导类配置两大线程组，确定了线程模型</li>
<li>通过channel方法给引导类指定IO模型为NIO(NIOSeverSocketChannel)</li>
</ul>
<p><strong>客户端</strong></p>
<ul>
<li>创建一个NioEventLoopGroup对象实例</li>
<li>创建服务端启动的引导类</li>
<li>通过group方法给引导类配置线程组</li>
<li>通过channel方法给引导类指定IO模型为NIO(NIOSocketChannel)</li>
<li>通过childHandler()给引导类创建一个ChannelInitializer然后指定了客户端消息的业务处理逻辑对象</li>
<li>调用BootStrap的Connect方法进行连接</li>
</ul>
<h2 id="Netty-和-Tomcat-的区别？"><a href="#Netty-和-Tomcat-的区别？" class="headerlink" title="Netty 和 Tomcat 的区别？"></a>Netty 和 Tomcat 的区别？</h2><p>作用不同：Tomcat 是 Servlet 容器，可以视为 Web 服务器，而 Netty 是异步事件驱动的网络应用程序框架和工具 用于简化网络编程，例如TCP和UDP套接字服务器。</p>
<p>协议不同：Tomcat 是基于 http 协议的 Web 服务器，而 Netty 能通过编程自定义各种协议，因为 Netty 本身自己能编码/解码字节流，所以 Netty 可以实现HTTP 服务器、FTP 服务器、UDP 服务器、RPC 服务器、WebSocket 服务器、<a href="https://cloud.tencent.com/product/crs?from=10680">Redis</a> 的 Proxy 服务器、<a href="https://cloud.tencent.com/product/cdb?from=10680">MySQL</a> 的 Proxy 服务器等等。</p>
<h2 id="Netty-高性能表现在哪些方面？"><a href="#Netty-高性能表现在哪些方面？" class="headerlink" title="Netty 高性能表现在哪些方面？"></a>Netty 高性能表现在哪些方面？</h2><p>IO 线程模型：同步非阻塞，用最少的资源做更多的事。</p>
<p>内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输。</p>
<p>内存池设计：申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。</p>
<p>串形化处理读写：避免使用锁带来的性能开销。</p>
<p>高性能序列化协议：支持 protobuf 等高性能序列化协议。</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><ol>
<li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong></li>
<li><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> </li>
<li><strong>操作系统的核心部分是内核（Kernel），它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li>
</ol>
<h2 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h2><p>在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成</p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。 </li>
</ul>
<h2 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h2><p>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p>
<p>资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p>
<p>影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃可能导致整个进程都死掉。所以多进程要比多线程健壮。</p>
<p>执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p>
<h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><p><a href="https://www.jianshu.com/p/c1015f5ffa74">https://www.jianshu.com/p/c1015f5ffa74</a></p>
<h2 id="管道-消息队列-共享内存的优缺点"><a href="#管道-消息队列-共享内存的优缺点" class="headerlink" title="管道 消息队列 共享内存的优缺点"></a>管道 消息队列 共享内存的优缺点</h2><p><a href="https://blog.csdn.net/Helloo_jerry/article/details/77508180">https://blog.csdn.net/Helloo_jerry/article/details/77508180</a></p>
<h2 id="线程间同步方式"><a href="#线程间同步方式" class="headerlink" title="线程间同步方式"></a>线程间同步方式</h2><ol>
<li>**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>
<li><strong>信号量(Semphares)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li>
<li><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</li>
<li>事件对象： 通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作</li>
</ol>
<h2 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h2><ul>
<li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
<li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
<li><strong>最高响应比优先</strong>：响应比 = （等待时间+要求服务时间）/ 要求服务时间。响应比高的算法会先执行</li>
</ul>
<h2 id="内存管理主要是做什么？"><a href="#内存管理主要是做什么？" class="headerlink" title="内存管理主要是做什么？"></a><strong>内存管理主要是做什么？</strong></h2><p>负责内存的分配与回收与地址转换也就是将逻辑地址转换成相应的物理地址</p>
<h2 id="操作系统的内存管理机制了解吗？内存管理有哪几种方式"><a href="#操作系统的内存管理机制了解吗？内存管理有哪几种方式" class="headerlink" title="操作系统的内存管理机制了解吗？内存管理有哪几种方式?"></a><strong>操作系统的内存管理机制了解吗？内存管理有哪几种方式?</strong></h2><p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 <strong>块式管理</strong> 。同样地，非连续分配管理方式允许一个程序使用的内存是离散的，常见的如<strong>页式管理</strong> 和 <strong>段式管理</strong>。</p>
<ol>
<li><strong>块式管理</strong> ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</li>
<li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li>
<li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li>
<li><strong>段页式管理机制</strong>：结合了段式管理和页式管理的优点。段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说段与段之间以及段的内部的内存都是离散的。</li>
</ol>
<h2 id="介绍下页表管理机制中的快表和多级页表"><a href="#介绍下页表管理机制中的快表和多级页表" class="headerlink" title="介绍下页表管理机制中的快表和多级页表"></a>介绍下页表管理机制中的快表和多级页表</h2><p>在分页内存管理中，很重要的两点是：</p>
<ol>
<li>虚拟地址到物理地址的转换要快。</li>
<li>解决虚拟地址空间大，页表也会很大的问题。</li>
</ol>
<p><strong>块表</strong></p>
<p>为了解决虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>
<p>使用快表之后的地址转换流程是这样的：</p>
<ol>
<li>根据虚拟地址中的页号查快表；</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址；</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>
</ol>
<p>看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。</p>
<p><strong>多级页表</strong></p>
<p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，具体可以查看下面这篇文章</p>
<ul>
<li>多级页表如何节约内存：<a href="https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html">https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html</a></li>
</ul>
<h2 id="分页机制和分段机制有哪些共同点和区别"><a href="#分页机制和分段机制有哪些共同点和区别" class="headerlink" title="分页机制和分段机制有哪些共同点和区别"></a><strong>分页机制和分段机制有哪些共同点和区别</strong></h2><ol>
<li>共同点<ul>
<li>分页机制和分段机制都是为了提高内存利用率，较少内存碎片。</li>
<li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>
</ul>
</li>
<li>区别<ul>
<li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li>
<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>
</ul>
</li>
</ol>
<h2 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a><strong>逻辑地址和物理地址</strong></h2><p>我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中的地址，更具体一点来说就是内存地址寄存器中的地址。</p>
<h2 id="CPU-寻址了解吗"><a href="#CPU-寻址了解吗" class="headerlink" title="CPU 寻址了解吗?"></a>CPU 寻址了解吗?</h2><p>现代处理器使用的是一种称为 <strong>虚拟寻址(Virtual Addressing)</strong> 的寻址方式。虚拟寻址就是CPU 利用他的内存管理单元将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</p>
<h2 id="为什么需要虚拟地址空间"><a href="#为什么需要虚拟地址空间" class="headerlink" title="为什么需要虚拟地址空间?"></a>为什么需要虚拟地址空间?</h2><p>没有虚拟地址空间的时候，<strong>程序直接访问和操作的是物理内存</strong> 。但是这样有什么问题呢？</p>
<ol>
<li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。</li>
<li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li>
</ol>
<p>通过虚拟地址访问内存有以下优势：</p>
<ul>
<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的内存缓冲区。</li>
<li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li>
<li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>
</ul>
<h2 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a><strong>什么是虚拟内存</strong></h2><p>定义：具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存之和和外存之和决定。</p>
<p> <strong>虚拟内存</strong> 可以让程序拥有超过系统物理内存大小的可用内存空间。另外，<strong>为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</strong>。这样会更加有效地管理内存并减少出错。</p>
<p>与传统存储器比较虚拟存储器有以下三个主要特征：</p>
<ul>
<li>多次性，是指无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行。</li>
<li>对换性，是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出。</li>
<li>虚拟性，是指从逻辑上扩充内存的容量，使用户所看到的内存容量，远大于实际的内存容量。</li>
</ul>
<h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。</p>
<p>局部性原理表现在以下两个方面：</p>
<ol>
<li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
<li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ol>
<p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p>
<h2 id="虚拟内存技术的实现"><a href="#虚拟内存技术的实现" class="headerlink" title="虚拟内存技术的实现"></a><strong>虚拟内存技术的实现</strong></h2><p><strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</strong> 虚拟内存的实现有以下三种方式：</p>
<ol>
<li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分页即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>
<li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li>
<li><strong>请求段页式存储管理</strong>：先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名</li>
</ol>
<h2 id="页面置换算法的作用-常见的页面置换算法有哪些"><a href="#页面置换算法的作用-常见的页面置换算法有哪些" class="headerlink" title="页面置换算法的作用?常见的页面置换算法有哪些?"></a><strong>页面置换算法的作用?常见的页面置换算法有哪些?</strong></h2><p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。</p>
<p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法</p>
<ul>
<li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li>
<li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li>
<li><strong>LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li>
<li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</li>
</ul>
<h2 id="中断和轮询的特点"><a href="#中断和轮询的特点" class="headerlink" title="中断和轮询的特点"></a>中断和轮询的特点</h2><p>​    对I/O设备的程序轮询的方式，是早期的计算机系统对I/O设备的一种管理方式。它定时对各种设备轮流询问一遍有无处理要求。轮流询问之后，有要求的就加以处理。在处理I/O设备的要求之后，处理机返回继续工作。尽管轮询需要时间，但轮询要比I/O设备的速度要快得多，所以一般不会发生不能及时处理的问题。当然，再快的处理机，能处理的输入输出设备的数量也是有一定限度的。而且，程序轮询毕竟占据了CPU相当一部分处理时间，因此程序轮询是一种效率较低的方式，现代计算机系统中已很少应用。</p>
<p>​    　程序中断通常简称中断，是指CPU在正常运行程序的过程中，由于预先安排或发生了各种随机的内部或外部事件，使CPU中断正在运行的程序，而转到为响应的服务程序去处理。</p>
<p>　　轮询效率低，等待时间很长，CPU利用率不高；中断容易遗漏一些问题，CPU利用率高。</p>
<h2 id="什么是临界区、如何解决冲突"><a href="#什么是临界区、如何解决冲突" class="headerlink" title="什么是临界区、如何解决冲突"></a>什么是临界区、如何解决冲突</h2><p>​    每个进程中访问临界资源的那段程序称为临界区，每次只准许一个进程进入临界区。如已有进程进入自己的临界区，则其他试图进入临界区的进程必须等待。进入临界区的进程要在有限时间内退出，以便其他进程能及时进入自己的临界区。如果不能进入自己的临界区，就应该让出CPU，避免进程出现忙等等现象。</p>
<h2 id="为什么进程上下文切换比线程上下文切换代价高？"><a href="#为什么进程上下文切换比线程上下文切换代价高？" class="headerlink" title="为什么进程上下文切换比线程上下文切换代价高？"></a><strong>为什么进程上下文切换比线程上下文切换代价高？</strong></h2><p>进程切换分两步：</p>
<p>1.切换页目录以使用新的地址空间</p>
<p>2.切换内核栈和硬件上下文</p>
<p>对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。</p>
<p>切换的性能消耗：</p>
<p>1、线程上下文切换和进程上下问切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。</p>
<p>2、另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor’s Translation Lookaside Buffer (TLB)）</p>
<h2 id="用户态和核心态-内核态）之间的区别是什么呢？"><a href="#用户态和核心态-内核态）之间的区别是什么呢？" class="headerlink" title="用户态和核心态(内核态）之间的区别是什么呢？"></a><strong>用户态和核心态(内核态）之间的区别是什么呢？</strong></h2><p>​    <strong>权限不一样。</strong></p>
<ul>
<li><strong>用户态的进程能存取它们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据）</strong>。</li>
<li><strong>核心态下的进程能够存取内核和用户地址的指令和数据，某些机器指令是特权指令，在用户态下执行特权指令会引起错误</strong></li>
</ul>
<h2 id="守护、僵尸、孤儿进程的概念"><a href="#守护、僵尸、孤儿进程的概念" class="headerlink" title="守护、僵尸、孤儿进程的概念"></a>守护、僵尸、孤儿进程的概念</h2><ul>
<li><strong>守护进程</strong>：运行在后台的一种特殊进程，<strong>独立于控制终端并周期性地执行某些任务</strong>。</li>
<li><strong>僵尸进程</strong>：一个进程 fork 子进程，子进程退出，而父进程没有wait/waitpid子进程，那么<strong>子进程的进程描述符仍保存在系统中</strong>，这样的进程称为僵尸进程。</li>
<li><strong>孤儿进程</strong>：一个<strong>父进程退出，而它的一个或多个子进程还在运行</strong>，这些子进程称为孤儿进程。（孤儿进程将由 init 进程收养并对它们完成状态收集工作）</li>
</ul>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="数据库三大范式是什么"><a href="#数据库三大范式是什么" class="headerlink" title="数据库三大范式是什么"></a>数据库三大范式是什么</h2><p>第一范式：每个列都不可以再拆分。</p>
<p>第二范式：在第一范式的基础上，属性完全依赖于主键。要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主键</p>
<p>第三范式：在第二范式的基础上，属性不依赖于其它非主属性   属性直接依赖于主键</p>
<ul>
<li><p>数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a–&gt;b–&gt;c  属性之间含有这样的关系，是不符合第三范式的。</p>
<p>比如Student表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）</p>
<p>这样一个表结构，就存在上述关系。 学号–&gt; 所在院校 –&gt; (院校地址，院校电话)</p>
<p>这样的表结构，我们应该拆开来，如下。</p>
<p>  （学号，姓名，年龄，性别，所在院校）–（所在院校，院校地址，院校电话）</p>
</li>
</ul>
<p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p>
<h2 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h2><ol>
<li><strong>是否支持行级锁</strong> : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li>
<li><strong>是否支持事务和崩溃后的安全恢复： MyISAM</strong> 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是<strong>InnoDB</strong> 提供事务支持，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li>
<li><strong>是否支持外键：</strong> MyISAM不支持，而InnoDB支持。</li>
<li><strong>是否支持MVCC</strong> ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;MVCC可以使用乐观(optimistic)锁和悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。推荐阅读：<a href="https://www.jianshu.com/p/8845ddca3b23">MySQL-InnoDB-MVCC多版本并发控制</a></li>
</ol>
<h2 id="大表优化策略"><a href="#大表优化策略" class="headerlink" title="大表优化策略"></a>大表优化策略</h2><h3 id="1-限定数据的范围"><a href="#1-限定数据的范围" class="headerlink" title="1. 限定数据的范围"></a>1. 限定数据的范围</h3><p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</p>
<h3 id="2-读-写分离"><a href="#2-读-写分离" class="headerlink" title="2. 读/写分离"></a>2. 读/写分离</h3><p>经典的数据库拆分方案，主库负责写，从库负责读；</p>
<h3 id="3-垂直分区"><a href="#3-垂直分区" class="headerlink" title="3. 垂直分区"></a>3. 垂直分区</h3><p><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。 <img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9E%82%E7%9B%B4%E5%88%86%E5%8C%BA.png" alt="数据库垂直分区"></p>
<ul>
<li><strong>垂直拆分的优点：</strong>使列数据变小，在查询时减少读取的Block数，减少I/O次数，简化表的结构，易于维护。</li>
<li><strong>垂直拆分的缺点：</strong> 主键会出现冗余，并会引起Join操作，会让事务变得更加复杂；</li>
</ul>
<h3 id="4-水平分区"><a href="#4-水平分区" class="headerlink" title="4. 水平分区"></a>4. 水平分区</h3><p><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p>
<p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86.png" alt="数据库水平拆分"></p>
<p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</p>
<p>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p>
<p><strong>下面补充一下数据库分片的两种常见方案：</strong></p>
<ul>
<li><strong>客户端代理：</strong> <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li>
<li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>
</ul>
<p>参考文章：<a href="https://segmentfault.com/a/1190000006158186">mysql大表优化方案</a></p>
<h2 id="一条SQL语句在MySQL中如何执行的"><a href="#一条SQL语句在MySQL中如何执行的" class="headerlink" title="一条SQL语句在MySQL中如何执行的"></a><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd">一条SQL语句在MySQL中如何执行的</a></h2><h2 id="MySQL的binlog有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有几种录入格式？分别有什么区别？"></a>MySQL的binlog有几种录入格式？分别有什么区别？</h2><p>binlog原理：<a href="https://blog.csdn.net/lzhcoder/article/details/88814364">https://blog.csdn.net/lzhcoder/article/details/88814364</a></p>
<p>有三种格式，statement，row和mixed。</p>
<ul>
<li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li>
</ul>
<ul>
<li>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li>
<li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li>
</ul>
<p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p>
<h2 id="mysql有哪些数据类型"><a href="#mysql有哪些数据类型" class="headerlink" title="mysql有哪些数据类型"></a>mysql有哪些数据类型</h2><table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>类型名称</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>整数类型</strong></td>
<td>tinyInt</td>
<td>很小的整数(8位二进制)</td>
</tr>
<tr>
<td></td>
<td>smallint</td>
<td>小的整数(16位二进制)</td>
</tr>
<tr>
<td></td>
<td>mediumint</td>
<td>中等大小的整数(24位二进制)</td>
</tr>
<tr>
<td></td>
<td>int(integer)</td>
<td>普通大小的整数(32位二进制)</td>
</tr>
<tr>
<td><strong>小数类型</strong></td>
<td>float</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td></td>
<td>double</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td></td>
<td>decimal(m,d)</td>
<td>压缩严格的定点数</td>
</tr>
<tr>
<td><strong>日期类型</strong></td>
<td>year</td>
<td>YYYY 1901~2155</td>
</tr>
<tr>
<td></td>
<td>time</td>
<td>HH:MM:SS -838:59:59~838:59:59</td>
</tr>
<tr>
<td></td>
<td>date</td>
<td>YYYY-MM-DD 1000-01-01~9999-12-3</td>
</tr>
<tr>
<td></td>
<td>datetime</td>
<td>YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59</td>
</tr>
<tr>
<td></td>
<td>timestamp</td>
<td>YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC</td>
</tr>
<tr>
<td><strong>文本、二进制类型</strong></td>
<td>CHAR(M)</td>
<td>M为0~255之间的整数</td>
</tr>
<tr>
<td></td>
<td>VARCHAR(M)</td>
<td>M为0~65535之间的整数</td>
</tr>
<tr>
<td></td>
<td>TINYBLOB</td>
<td>允许长度0~255字节</td>
</tr>
<tr>
<td></td>
<td>BLOB</td>
<td>允许长度0~65535字节</td>
</tr>
<tr>
<td></td>
<td>MEDIUMBLOB</td>
<td>允许长度0~167772150字节</td>
</tr>
<tr>
<td></td>
<td>LONGBLOB</td>
<td>允许长度0~4294967295字节</td>
</tr>
<tr>
<td></td>
<td>TINYTEXT</td>
<td>允许长度0~255字节</td>
</tr>
<tr>
<td></td>
<td>TEXT</td>
<td>允许长度0~65535字节</td>
</tr>
<tr>
<td></td>
<td>MEDIUMTEXT</td>
<td>允许长度0~167772150字节</td>
</tr>
<tr>
<td></td>
<td>LONGTEXT</td>
<td>允许长度0~4294967295字节</td>
</tr>
<tr>
<td></td>
<td>VARBINARY(M)</td>
<td>允许长度0~M个字节的变长字节字符串</td>
</tr>
<tr>
<td></td>
<td>BINARY(M)</td>
<td>允许长度0~M个字节的定长字节字符串</td>
</tr>
</tbody></table>
<p>还有set和enum</p>
<h2 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h2><p>MyISAM引擎也使用B+树作为索引结果，不过叶节点的data域存放的是数据记录的地址</p>
<ul>
<li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li>
<li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li>
<li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li>
</ul>
<h2 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a>索引有哪些优缺点？</h2><p>索引的优点</p>
<ul>
<li>创建索引可以大大加快数据的检索速度</li>
<li>通过使用索引，提高查询性能</li>
</ul>
<p>索引的缺点</p>
<ul>
<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li>
<li>空间方面：索引需要占物理空间</li>
</ul>
<h2 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a>索引有哪几种类型？</h2><p><strong>主键索引:</strong> 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p>
<p><strong>唯一索引:</strong> 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p>
<ul>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column);</code> 创建唯一索引</li>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column1,column2);</code> 创建唯一组合索引</li>
</ul>
<p><strong>普通索引:</strong> 基本的索引类型，没有唯一性的限制，允许为NULL值。</p>
<ul>
<li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name (column);</code>创建普通索引</li>
<li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);</code>创建组合索引</li>
</ul>
<p><strong>全文索引：</strong> 是目前搜索引擎使用的一种关键技术。</p>
<ul>
<li>可以通过<code>ALTER TABLE table_name ADD FULLTEXT (column);</code>创建全文索引</li>
</ul>
<h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><p>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有<strong>Hash索引</strong>，<strong>B+树索引</strong>等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>
<p>1）B树索引</p>
<p>mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzI0LzE2NjBjMGYxNGRhY2Y2ZjU?x-oss-process=image/format,png" alt="img"></p>
<p>查询方式：</p>
<p>主键索引区:PI(关联保存的时数据的地址)按主键查询,</p>
<p>普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快</p>
<ul>
<li>主键索引的叶子结点存放了整行记录，普通索引的叶子结点存放了主键ID和其他建立索引的字段，查询的时候需要做一次回表查询<br>一定要回表查询么？<br>不一定，当查询的字段刚好是索引的字段或者索引的一部分，就可以不用回表，这也是索引覆盖的原理</li>
</ul>
<p>B+tree性质：</p>
<p>1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</p>
<p>2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p>
<p>3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</p>
<p>4.）B+树中，数据对象的插入和删除仅在叶节点上进行。</p>
<p>5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p>
<p>2）哈希索引</p>
<p>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzI0LzE2NjBjMGYxNThhNzZmOTQ?x-oss-process=image/format,png" alt="img"></p>
<h2 id="创建索引的原则（重中之重）"><a href="#创建索引的原则（重中之重）" class="headerlink" title="创建索引的原则（重中之重）"></a>创建索引的原则（重中之重）</h2><p>索引虽好，但也不是无限制的使用，最好符合一下几个原则</p>
<p>1） 根据最左前缀匹配原则创建和使用组合索引</p>
<p>2）较频繁作为查询条件的字段才去创建索引，更新频繁字段不适合创建索引</p>
<p>3）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p>
<p>4）定义有外键的数据列一定要建立索引。</p>
<p>5）基数较小的类，索引效果较差，没有必要在此列建立索引</p>
<p>6）对于定义为text、image和bit的数据类型的列不要建立索引。</p>
<p>7）适合索引的列是出现在where，join,order by 子句中的列</p>
<p>8）使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</p>
<p>9）不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</p>
<h2 id="创建索引的三种方式，删除索引"><a href="#创建索引的三种方式，删除索引" class="headerlink" title="创建索引的三种方式，删除索引"></a>创建索引的三种方式，删除索引</h2><p>一种方式：在执行CREATE TABLE时创建索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(字段名 数据类型 [完整性约束条件],</span><br><span class="line">                  [<span class="keyword">UNIQUE</span> | FULLTEXT | SPATIAL] <span class="keyword">INDEX</span> | <span class="keyword">KEY</span></span><br><span class="line">                  [索引名](字段名<span class="number">1</span> [(长度)] [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>])</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_index2 (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span> auto_increment PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">	first_name <span class="built_in">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">	last_name <span class="built_in">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">	id_card <span class="built_in">VARCHAR</span> (<span class="number">18</span>),</span><br><span class="line">	information <span class="built_in">text</span>,</span><br><span class="line">	<span class="keyword">KEY</span> <span class="keyword">name</span> (first_name, last_name),</span><br><span class="line">	FULLTEXT <span class="keyword">KEY</span> (information),</span><br><span class="line">	<span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (id_card)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>UNIQUE：可选。表示索引为唯一性索引。</li>
<li>FULLTEXT；可选。表示索引为全文索引。</li>
<li>SPATIAL：可选。表示索引为空间索引。</li>
<li>INDEX和KEY：用于指定字段为索引，两者选择其中之一就可以了，作用是一样的。</li>
<li>索引名：可选。给创建的索引取一个新名称。</li>
<li>字段名1：指定索引对应的字段的名称，该字段必须是前面定义好的字段。</li>
<li>长度：可选。指索引的长度，必须是字符串类型才可以使用。</li>
<li>ASC：可选。表示升序排列。</li>
<li>DESC：可选。表示降序排列。</li>
</ul>
<p>第二种方式：使用ALTER TABLE命令去增加索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name (column_list);</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p>
<p>第三种方式：使用CREATE INDEX命令创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name (column_list);</span><br></pre></td></tr></table></figure>

<p>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p>
<p>删除索引</p>
<p>根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code></p>
<h2 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h2><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p>
<ol>
<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>
<li>然后删除其中无用数据（此过程需要不到两分钟）</li>
<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
</ol>
<h2 id="Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢?"></a>Hash索引和B+树所有有什么区别或者说优劣呢?</h2><p>首先要知道Hash索引和B+树索引的底层实现原理：</p>
<p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</p>
<p>那么可以看出他们有以下的不同：</p>
<ul>
<li><p>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p>
</li>
<li><p>hash索引不支持使用索引进行排序，原理同上。</p>
</li>
<li><p>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。</p>
</li>
<li><p>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</p>
</li>
<li><p>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</p>
</li>
</ul>
<h2 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h2><ul>
<li><p>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</p>
</li>
<li><p>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzIxLzE2NWZiNjgyZTc1OWNmMTI?x-oss-process=image/format,png" alt="img"></p>
</li>
</ul>
<h2 id="数据库为什么使用B-树而不是B树"><a href="#数据库为什么使用B-树而不是B树" class="headerlink" title="数据库为什么使用B+树而不是B树"></a>数据库为什么使用B+树而不是B树</h2><ul>
<li>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</li>
<li>B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</li>
<li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li>
<li>解决元素遍历的效率高问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</li>
<li>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</li>
</ul>
<ul>
<li>B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据。在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</li>
</ul>
<h2 id="事务的四大特性ACID"><a href="#事务的四大特性ACID" class="headerlink" title="事务的四大特性ACID"></a>事务的四大特性ACID</h2><ol>
<li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h2 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h2><ul>
<li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li>
<li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li>
<li>幻读(Phantom Read):在一个事务的两次查询中数据数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的</li>
</ul>
<h2 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h2><p>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h2 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h2><p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p>
<p>在Read Committed级别下，一个事务只能看见已经提交事务所做的改变</p>
<p>在Repeatable Read级别下，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。</p>
<p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别<strong>锁定整个范围的键</strong>，并一直持有锁，直到事务完成。</p>
<h2 id="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"><a href="#按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法" class="headerlink" title="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"></a>按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</h2><p>在关系型数据库中，可以<strong>按照锁的粒度把数据库锁分</strong>为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p>
<p><strong>MyISAM和InnoDB存储引擎使用的锁：</strong></p>
<ul>
<li>MyISAM采用表级锁(table-level locking)。</li>
<li>InnoDB支持行级锁(row-level locking)和表级锁 页级锁，默认为行级锁</li>
</ul>
<p>行级锁，表级锁和页级锁对比</p>
<p><strong>行级锁</strong> 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p>
<p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
<p><strong>表级锁</strong> 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p>
<p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p>
<p><strong>页级锁</strong> 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p>
<p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
<h2 id="从锁的类别上分MySQL都有哪些锁呢？"><a href="#从锁的类别上分MySQL都有哪些锁呢？" class="headerlink" title="从锁的类别上分MySQL都有哪些锁呢？"></a>从锁的类别上分MySQL都有哪些锁呢？</h2><p><strong>从锁的类别上来讲</strong>，有共享锁和排他锁。</p>
<p>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p>
<p>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p>
<h2 id="数据库的乐观锁和悲观锁是什么？怎么实现的？"><a href="#数据库的乐观锁和悲观锁是什么？怎么实现的？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？怎么实现的？"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h2><p>乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p>
<p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：一般会使用版本号机制或CAS算法实现。</p>
<p><strong>两种锁的使用场景</strong></p>
<p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p>
<p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p>
<h2 id="视图有哪些特点？"><a href="#视图有哪些特点？" class="headerlink" title="视图有哪些特点？"></a>视图有哪些特点？</h2><p>视图的特点如下:</p>
<ul>
<li>视图是由基本表(实表)产生的表(虚表)。</li>
</ul>
<ul>
<li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。当视图来自多个基本表时，不允许添加和删除数据。</li>
<li>视图的建立和删除不影响基本表 更新影响基本表。</li>
</ul>
<h2 id="视图的使用场景有哪些？"><a href="#视图的使用场景有哪些？" class="headerlink" title="视图的使用场景有哪些？"></a>视图的使用场景有哪些？</h2><p>视图根本用途：简化sql查询，提高开发效率。兼容老的表结构。</p>
<p>下面是视图的常见使用场景：</p>
<ul>
<li>简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</li>
<li>使用表的部分组成部分而不是整个表；</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<h2 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h2><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p>
<p><strong>优点</strong></p>
<p>1）存储过程是预编译过的，执行效率高。</p>
<p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p>
<p>3）安全性高，执行存储过程需要有一定权限的用户。</p>
<p>4）存储过程可以重复使用，减少数据库开发人员的工作量。</p>
<p><strong>缺点</strong></p>
<p>1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</p>
<p>2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p>
<p>3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p>
<p>4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p>
<h2 id="什么是触发器？触发器的使用场景有哪些？"><a href="#什么是触发器？触发器的使用场景有哪些？" class="headerlink" title="什么是触发器？触发器的使用场景有哪些？"></a>什么是触发器？触发器的使用场景有哪些？</h2><p>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</p>
<p>使用场景</p>
<ul>
<li>可以通过数据库中的相关表实现级联更改。</li>
<li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li>
</ul>
<p>六种触发器</p>
<ul>
<li>Before Insert</li>
<li>After Insert</li>
<li>Before Update</li>
<li>After Update</li>
<li>Before Delete</li>
<li>After Delete</li>
</ul>
<h2 id="SQL语句主要分为哪几类"><a href="#SQL语句主要分为哪几类" class="headerlink" title="SQL语句主要分为哪几类"></a>SQL语句主要分为哪几类</h2><p>数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER</p>
<p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p>
<p>数据查询语言DQL（Data Query Language）SELECT</p>
<p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p>
<p>数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE</p>
<p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p>
<p>数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p>
<p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p>
<h2 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a>超键、候选键、主键、外键分别是什么？</h2><ul>
<li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li>
<li>候选键：是最小超键，即没有冗余元素的超键。</li>
<li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li>
<li>外键：在一个表中存在的另一个表的主键称此表的外键。</li>
</ul>
<h2 id="六大约束"><a href="#六大约束" class="headerlink" title="六大约束"></a>六大约束</h2><ul>
<li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li>
<li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li>
<li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li>
<li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li>
<li>CHECK: 用于控制字段的值范围。</li>
<li>DEFAULT:默认值</li>
</ul>
<h2 id="mysql中-in-和-exists-区别"><a href="#mysql中-in-和-exists-区别" class="headerlink" title="mysql中 in 和 exists 区别"></a>mysql中 in 和 exists 区别</h2><p>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，再对内表进行查询</p>
<ol>
<li>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。 </li>
<li>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</li>
</ol>
<h2 id="char和varchar"><a href="#char和varchar" class="headerlink" title="char和varchar"></a>char和varchar</h2><p><strong>char的特点</strong></p>
<ul>
<li>char表示定长字符串，长度是固定的；</li>
<li>如果插入数据的长度小于char的固定长度时，则用空格填充；</li>
<li>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</li>
<li>对于char来说，最多能存放的字符个数为255，和编码无关</li>
</ul>
<p><strong>varchar的特点</strong></p>
<ul>
<li>varchar表示可变长字符串，长度是可变的；</li>
<li>插入的数据是多长，就按照多长来存储；</li>
<li>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li>
<li>对于varchar来说，最多能存放的字符个数为65532</li>
</ul>
<p>总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。</p>
<h2 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h2><table>
<thead>
<tr>
<th></th>
<th>Delete</th>
<th>Truncate</th>
<th>Drop</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>属于DML</td>
<td>属于DDL</td>
<td>属于DDL</td>
</tr>
<tr>
<td>回滚</td>
<td>可回滚</td>
<td>不可回滚</td>
<td>不可回滚</td>
</tr>
<tr>
<td>删除内容</td>
<td>表结构还在，删除表的全部或者一部分数据行</td>
<td>表结构还在，删除表中的所有数据</td>
<td>从数据库中删除表，所有的数据行，索引和权限也会被删除</td>
</tr>
<tr>
<td>删除速度</td>
<td>删除速度慢，需要逐行删除</td>
<td>删除速度快</td>
<td>删除速度最快</td>
</tr>
</tbody></table>
<h2 id="对慢查询怎么优化"><a href="#对慢查询怎么优化" class="headerlink" title="对慢查询怎么优化"></a>对慢查询怎么优化</h2><ul>
<li>首先分析语句，看看是否加载了额外的数据。可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li>
<li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li>
<li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li>
</ul>
<h2 id="为什么要尽量设定一个主键？"><a href="#为什么要尽量设定一个主键？" class="headerlink" title="为什么要尽量设定一个主键？"></a>为什么要尽量设定一个主键？</h2><p>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p>
<h2 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a>主键使用自增ID还是UUID？</h2><p>推荐使用自增ID，不要使用UUID。</p>
<p>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成性能的下降。</p>
<h2 id="字段为什么要求定义为not-null？"><a href="#字段为什么要求定义为not-null？" class="headerlink" title="字段为什么要求定义为not null？"></a>字段为什么要求定义为not null？</h2><p>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</p>
<h2 id="如果要存储用户的密码散列，应该使用什么字段进行存储？"><a href="#如果要存储用户的密码散列，应该使用什么字段进行存储？" class="headerlink" title="如果要存储用户的密码散列，应该使用什么字段进行存储？"></a>如果要存储用户的密码散列，应该使用什么字段进行存储？</h2><p>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</p>
<h2 id="优化WHERE子句"><a href="#优化WHERE子句" class="headerlink" title="优化WHERE子句"></a>优化WHERE子句</h2><ul>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>
<li>应尽量避免在 where 子句中对字段进行范围查询，范围查询后的索引失效</li>
<li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line"><span class="comment">-- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</li>
<li>应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">or</span> <span class="keyword">num</span>=<span class="number">20</span></span><br><span class="line"><span class="comment">-- 可以这样查询：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure>

<ul>
<li>in 和 not in 也要慎用，否则会导致全表扫描，如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line"><span class="comment">-- 对于连续的数值，能用 between 就不要用 in 了：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</li>
<li>如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span></span><br><span class="line"><span class="comment">-- 可以改为强制查询使用索引：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">with</span>(<span class="keyword">index</span>(索引名)) <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span></span><br></pre></td></tr></table></figure>

<ul>
<li>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>/<span class="number">2</span>=<span class="number">100</span></span><br><span class="line"><span class="comment">-- 应改为:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">100</span>*<span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>应尽量避免在where子句中对字段进行函数操作， 这将导致引擎放弃使用索引而进行全表扫描。如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">1</span>,<span class="number">3</span>)=’abc’</span><br><span class="line"><span class="comment">-- name以abc开头的id应改为:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> ‘abc%’</span><br></pre></td></tr></table></figure>

<h2 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h2><p>当 cpu 飙升到 500%时，先用操作系统命令 top 观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</p>
<p>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</p>
<p>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</p>
<p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</p>
<h2 id="MySQL的主从复制原理以及流程"><a href="#MySQL的主从复制原理以及流程" class="headerlink" title="MySQL的主从复制原理以及流程"></a>MySQL的主从复制原理以及流程</h2><p>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p>
<p><strong>主从复制的作用</strong></p>
<ol>
<li>主数据库出现问题，可以切换到从数据库。</li>
<li>可以进行数据库层面的读写分离。</li>
<li>可以在从数据库上进行日常备份。</li>
</ol>
<p><strong>MySQL主从复制解决了的问题</strong></p>
<ul>
<li>数据分布：在不同地理位置分布数据备份</li>
<li>负载均衡：降低单个服务器的压力</li>
<li>高可用和故障切换：帮助应用程序避免单点失败</li>
<li>升级测试：可以用更高版本的MySQL作为从库</li>
</ul>
<p><strong>MySQL主从复制工作原理</strong></p>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210221154803247.png" alt="image-20210221154803247"></p>
<p>Binary log：主数据库的二进制日志</p>
<p>Relay log：从服务器的中继日志</p>
<p>第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</p>
<p>第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。</p>
<p>第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</p>
<h2 id="MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年-怎么优化？"><a href="#MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年-怎么优化？" class="headerlink" title="MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？"></a>MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？</h2><p>a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。<br>b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。<br>c.  mysql库主从读写分离。<br>d. 找规律分表，减少单表中的数据量提高查询速度。<br>e. 添加缓存机制，比如memcached，apc等。<br>f. 不经常改动的页面，生成静态页面。<br>g. 书写高效率的SQL。</p>
<h2 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h2><p>MVCC叫做多版本并发控制，实际上就是保存了数据在某个时间节点的快照。</p>
<p>表中每行实际上隐藏了两列，创建时间版本号，过期(删除)时间版本号，每开始一个新的事务，版本号都会自动递增。</p>
<p>推荐阅读：<a href="https://blog.csdn.net/qq_27469549/article/details/99639880">https://blog.csdn.net/qq_27469549/article/details/99639880</a></p>
<h2 id="分表后的ID怎么保证唯一性的呢？"><a href="#分表后的ID怎么保证唯一性的呢？" class="headerlink" title="分表后的ID怎么保证唯一性的呢？"></a>分表后的ID怎么保证唯一性的呢？</h2><p>因为我们主键默认都是自增的，那么分表之后的主键在不同表就肯定会有冲突了。有几个办法考虑：</p>
<ol>
<li>设定步长，比如1-1024张表我们分别设定1-1024的基础步长，这样主键落到不同的表就不会冲突了。</li>
<li>分布式ID，自己实现一套分布式ID生成算法或者使用开源的比如雪花算法这种。</li>
<li>分表后不使用主键作为查询依据，而是每张表单独新增一个字段作为唯一主键使用，比如订单表订单号是唯一的，不管最终落在哪张表都基于订单号作为查询依据，更新也一样</li>
</ol>
<h2 id="事务是如何通过日志来实现的，说得越深入越好。"><a href="#事务是如何通过日志来实现的，说得越深入越好。" class="headerlink" title="事务是如何通过日志来实现的，说得越深入越好。"></a>事务是如何通过日志来实现的，说得越深入越好。</h2><p>InnoDB的日志分为redo log和undo log，redo恢复提交事务修改的页操作，而undo回滚记录到某个特定的版本。所以，<strong>redo通常是物理日志</strong>，记录的是页的物理修改操作；<strong>undo是逻辑日志</strong>，根据每行记录进行记录。</p>
<p>推荐阅读：<a href="https://blog.csdn.net/No_Game_No_Life_/article/details/106718599">https://blog.csdn.net/No_Game_No_Life_/article/details/106718599</a></p>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h2><p>程序计数器主要有下面两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>答：程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<h2 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h2><ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<h2 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a>一句话简单了解堆和方法区</h2><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h2 id="为什么要使用并发编程"><a href="#为什么要使用并发编程" class="headerlink" title="为什么要使用并发编程"></a>为什么要使用并发编程</h2><ol>
<li><p>可以将多核CPU的计算能力发挥到极致，提升性能</p>
</li>
<li><p>方便进行业务拆分，提升系统并发能力和性能：多线程并发编程是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。</p>
</li>
</ol>
<h2 id="并发编程有什么缺点"><a href="#并发编程有什么缺点" class="headerlink" title="并发编程有什么缺点"></a>并发编程有什么缺点</h2><p>可能会有内存泄漏、上下文切换、线程安全、死锁等问题。</p>
<h2 id="并发编程三要素是什么？"><a href="#并发编程三要素是什么？" class="headerlink" title="并发编程三要素是什么？"></a>并发编程三要素是什么？</h2><p>并发编程三要素（线程的安全性问题体现在）：</p>
<p>原子性：一个或多个操作要么全部执行成功要么全部执行失败。</p>
<p>可见性：一个线程对共享变量的修改,另一个线程能够立刻看到。（synchronized,volatile）</p>
<p>有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）</p>
<h2 id="在-Java-程序中怎么保证多线程的运行安全？"><a href="#在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="在 Java 程序中怎么保证多线程的运行安全？"></a>在 Java 程序中怎么保证多线程的运行安全？</h2><p>出现线程安全问题的原因：</p>
<ul>
<li>线程切换带来的原子性问题</li>
<li>缓存导致的可见性问题</li>
<li>编译优化带来的有序性问题</li>
</ul>
<p>解决办法：</p>
<ul>
<li>JDK Atomic开头的原子类、synchronized、LOCK可以解决原子性问题</li>
<li>synchronized、volatile、LOCK可以解决可见性问题</li>
<li>Happens-Before 规则可以解决有序性问题</li>
</ul>
<h2 id="并行-并发和串行有什么区别？"><a href="#并行-并发和串行有什么区别？" class="headerlink" title="并行 并发和串行有什么区别？"></a>并行 并发和串行有什么区别？</h2><ul>
<li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</li>
<li>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”。</li>
<li>串行：有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行所以不存在线程不安全情况，也就不存在临界区的问题。</li>
</ul>
<h2 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h2><p>一个任务切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>以下原因导致上下文切换</p>
<ul>
<li>线程的时间片用完</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行</li>
<li>线程自己调用了sleep,yield,wait,join,park,synchronized,lock等方法</li>
</ul>
<h2 id="守护线程和用户线程有什么区别呢？"><a href="#守护线程和用户线程有什么区别呢？" class="headerlink" title="守护线程和用户线程有什么区别呢？"></a>守护线程和用户线程有什么区别呢？</h2><p>守护线程和用户线程</p>
<ul>
<li><strong>用户 (User) 线程</strong>：运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</li>
<li><strong>守护 (Daemon) 线程</strong>：运行在后台，为其他前台线程服务。也可以说守护线程是 JVM 中非守护线程的 <strong>“佣人”</strong>。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</li>
</ul>
<p>main 函数所在的线程就是一个用户线程啊，main 函数启动的同时在 JVM 内部同时还启动了好多守护线程，比如垃圾回收线程。</p>
<p>比较明显的区别之一是用户线程结束，JVM 退出，不管这个时候有没有守护线程运行。而守护线程不会影响 JVM 的退出。</p>
<p><strong>注意事项：</strong></p>
<ol>
<li><code>setDaemon(true)</code>必须在<code>start()</code>方法前执行，否则会抛出 <code>IllegalThreadStateException</code> 异常</li>
<li>在守护线程中产生的新线程也是守护线程</li>
<li>不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑</li>
<li>守护 (Daemon) 线程中不能依靠 finally 块的内容来确保执行关闭或清理资源的逻辑。因为我们上面也说过了一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作，所以守护 (Daemon) 线程中的 finally 语句块可能无法被执行。</li>
</ol>
<h2 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h2><p>死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p>
<h2 id="形成死锁的四个必要条件是什么"><a href="#形成死锁的四个必要条件是什么" class="headerlink" title="形成死锁的四个必要条件是什么"></a>形成死锁的四个必要条件是什么</h2><ol>
<li>互斥条件：一个资源只能被一个线程(进程)占用，直到被该线程(进程)释放</li>
<li>请求与保持条件：一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</li>
<li>非抢占条件：线程(进程)已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件：当发生死锁时，所等待的线程(进程)必定会形成一个环路（类似于死循环），造成永久阻塞</li>
</ol>
<h2 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁"></a>如何避免线程死锁</h2><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p>
<p><strong>破坏互斥条件</strong></p>
<p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p>
<p><strong>破坏请求与保持条件</strong></p>
<p>一次性申请所有的资源。</p>
<p><strong>破坏非抢占条件</strong></p>
<p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p>
<p><strong>破坏循环等待条件</strong></p>
<p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>
<h2 id="创建线程有哪几种方式？"><a href="#创建线程有哪几种方式？" class="headerlink" title="创建线程有哪几种方式？"></a>创建线程有哪几种方式？</h2><p>创建线程有四种方式：</p>
<ul>
<li><p>继承 Thread 类；</p>
<ul>
<li><pre><code class="java">public class MyThread extends Thread &#123;

    @Override
    public void run() &#123;
        System.out.println(Thread.currentThread().getName() + &quot; run()方法正在执行...&quot;);
    &#125;

&#125;

public class TheadTest &#123;
    public static void main(String[] args) &#123;
        MyThread myThread = new MyThread();     
        myThread.start();
        System.out.println(Thread.currentThread().getName() + &quot; main()方法执行结束&quot;);
    &#125;
&#125;
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 实现 Runnable 接口；</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public <span class="keyword">class</span> MyRunnable implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run<span class="literal">()</span> &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot; run()方法执行中...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">class</span> RunnableTest &#123;</span><br><span class="line">        public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">            MyRunnable myRunnable = <span class="keyword">new</span> <span class="constructor">MyRunnable()</span>;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">myRunnable</span>)</span>;</span><br><span class="line">            thread.start<span class="literal">()</span>;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot; main()方法执行完成&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>实现 Callable 接口；</p>
<ul>
<li><pre><code class="java">public class MyCallable implements Callable&lt;Integer&gt; &#123;

    @Override
    public Integer call() &#123;
        System.out.println(Thread.currentThread().getName() + &quot; call()方法执行中...&quot;);
        return 1;
    &#125;

&#125;

public class CallableTest &#123;

    public static void main(String[] args) &#123;
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new MyCallable());
        Thread thread = new Thread(futureTask);
        thread.start();

        try &#123;
            Thread.sleep(1000);
            System.out.println(&quot;返回结果 &quot; + futureTask.get());
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; catch (ExecutionException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(Thread.currentThread().getName() + &quot; main()方法执行完成&quot;);
    &#125;

&#125;

<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 使用 Executors 工具类创建线程池</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(Thread.currentThread().getName() + <span class="string">&quot; run()方法执行中...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadExecutorTest</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">            ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">            MyRunnable runnableTest = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                executorService.execute(runnableTest);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;线程任务开始执行&quot;</span>);</span><br><span class="line">            executorService.<span class="built_in">shutdown</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="runnable-和-callable-有什么区别"><a href="#runnable-和-callable-有什么区别" class="headerlink" title="runnable 和 callable 有什么区别"></a>runnable 和 callable 有什么区别</h2><p>相同点</p>
<ul>
<li>都是接口</li>
<li>都可以编写多线程程序</li>
<li>都采用Thread.start()启动线程</li>
</ul>
<p>主要区别</p>
<ul>
<li>Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果<ul>
<li>Future 接口表示异步任务，是一个可能还没有完成的异步任务的结果。所以说 Callable用于产生结果，Future 用于获取结果。</li>
<li>FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。</li>
</ul>
</li>
<li>Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法可以抛出异常，也可以获取异常信息</li>
</ul>
<p><strong>注</strong>：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。.</p>
<h2 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h2><p>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</p>
<p>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p>
<h2 id="线程的五种状态"><a href="#线程的五种状态" class="headerlink" title="线程的五种状态"></a>线程的五种状态</h2><p>新建，就绪，运行，阻塞，死亡</p>
<h2 id="Java-中用到的线程调度算法是什么？"><a href="#Java-中用到的线程调度算法是什么？" class="headerlink" title="Java 中用到的线程调度算法是什么？"></a>Java 中用到的线程调度算法是什么？</h2><p>有两种调度模型：分时调度模型和抢占式调度模型。</p>
<p>分时调度模型是指平均分配每个线程占用的 CPU 的时间片，让所有的线程轮流获得 cpu 的使用权</p>
<p>Java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。</p>
<h2 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a>sleep() 和 wait() 有什么区别？</h2><p>两者都可以暂停线程的执行</p>
<ul>
<li>类的不同：sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。</li>
<li>是否释放锁：sleep() 不释放锁；wait() 释放锁。</li>
<li>用途不同：Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。</li>
<li>用法不同：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。</li>
</ul>
<h2 id="为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？"><a href="#为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？" class="headerlink" title="为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？"></a>为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</h2><p>Java中，任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。</p>
<p>有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。</p>
<h2 id="为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？"></a>为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</h2><p>当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</p>
<h2 id="Thread-类中的-yield-方法有什么作用？"><a href="#Thread-类中的-yield-方法有什么作用？" class="headerlink" title="Thread 类中的 yield 方法有什么作用？"></a>Thread 类中的 yield 方法有什么作用？</h2><p>使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。</p>
<p>当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。</p>
<h2 id="线程的-sleep-方法和-yield-方法有什么区别？"><a href="#线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="线程的 sleep()方法和 yield()方法有什么区别？"></a>线程的 sleep()方法和 yield()方法有什么区别？</h2><p>（1） sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</p>
<p>（2） 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；</p>
<p>（3）sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；</p>
<p>（4）sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。</p>
<h2 id="Java-中-interrupted-和-isInterrupted-方法的区别？"><a href="#Java-中-interrupted-和-isInterrupted-方法的区别？" class="headerlink" title="Java 中 interrupted 和 isInterrupted 方法的区别？"></a>Java 中 interrupted 和 isInterrupted 方法的区别？</h2><p>interrupt：用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。</p>
<p>注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p>
<p>interrupted：是静态方法，查看当前中断信号是true还是false并且清除中断信号。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了。</p>
<p>isInterrupted：查看当前中断信号是true还是false</p>
<h2 id="阻塞-非阻塞-同步-异步的区别"><a href="#阻塞-非阻塞-同步-异步的区别" class="headerlink" title="阻塞 非阻塞 同步 异步的区别"></a>阻塞 非阻塞 同步 异步的区别</h2><p>同步与异步是对应于调用者与被调用者，它们是线程之间的关系，两个线程之间要么是同步的，要么是异步的     </p>
<ul>
<li>同步操作时，调用者需要等待被调用者返回结果，才会进行下一步操作     </li>
<li>而异步则相反，调用者不需要等待被调用者返回调用，即可进行下一步操作，被调用者通常依靠事件、回调等机制来通知调用者结果</li>
</ul>
<p>阻塞与非阻塞是对同一个线程来说的，在某个时刻，线程要么处于阻塞，要么处于非阻塞  </p>
<p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态：     </p>
<ul>
<li><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。 </p>
</li>
<li><p>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
</li>
</ul>
<h2 id="如何在两个线程间共享数据？"><a href="#如何在两个线程间共享数据？" class="headerlink" title="如何在两个线程间共享数据？"></a>如何在两个线程间共享数据？</h2><p>在两个线程间共享变量即可实现共享。</p>
<p>一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。</p>
<h2 id="同步方法和同步块，哪个是更好的选择？"><a href="#同步方法和同步块，哪个是更好的选择？" class="headerlink" title="同步方法和同步块，哪个是更好的选择？"></a>同步方法和同步块，哪个是更好的选择？</h2><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p>
<p>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</p>
<h2 id="Java-如何实现多线程之间的通讯和协作？"><a href="#Java-如何实现多线程之间的通讯和协作？" class="headerlink" title="Java 如何实现多线程之间的通讯和协作？"></a>Java 如何实现多线程之间的通讯和协作？</h2><p>可以通过中断 和 共享变量的方式实现线程间的通讯和协作</p>
<p>Java中线程通信协作的最常见的两种方式：</p>
<p>一.syncrhoized加锁的线程的<strong>Object类</strong>的wait()/notify()/notifyAll()</p>
<p>二.ReentrantLock类加锁的线程的<strong>Condition类的</strong>await()/signal()/signalAll()</p>
<p>线程间直接的数据交换：</p>
<p>三.通过管道进行线程间通信：1）字节流；2）字符流</p>
<h2 id="什么是线程同步和线程互斥？有什么区别"><a href="#什么是线程同步和线程互斥？有什么区别" class="headerlink" title="什么是线程同步和线程互斥？有什么区别"></a>什么是线程同步和线程互斥？有什么区别</h2><p>线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作并处于等待状态，直到该线程完成操作</p>
<p>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</p>
<p>区别：</p>
<ol>
<li>互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</li>
<li>同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。</li>
<li>同步其实已经实现了互斥，所以同步是一种更为复杂的互斥。</li>
<li>互斥是一种特殊的同步。</li>
</ol>
<h2 id="在监视器-Monitor-内部，是如何做线程同步的？"><a href="#在监视器-Monitor-内部，是如何做线程同步的？" class="headerlink" title="在监视器(Monitor)内部，是如何做线程同步的？"></a>在监视器(Monitor)内部，是如何做线程同步的？</h2><p>在 java 虚拟机中,每个监视器和一个对象引用相关联，为了实现监视器的互斥功能，每个对象都关联着一把锁。</p>
<p>一旦方法或者代码块被 <strong>synchronized</strong> 修饰，那么这个部分就放入了监视器的监视区域，<strong>确保一次只能有一个线程执行该部分的代码</strong>，线程在获取锁之前不允许执行该部分的代码</p>
<h2 id="线程类的构造方法、静态块是被哪个线程调用的"><a href="#线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="线程类的构造方法、静态块是被哪个线程调用的"></a>线程类的构造方法、静态块是被哪个线程调用的</h2><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被 new这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用的。</p>
<h2 id="Java-线程数过多会造成什么异常？"><a href="#Java-线程数过多会造成什么异常？" class="headerlink" title="Java 线程数过多会造成什么异常？"></a>Java 线程数过多会造成什么异常？</h2><ul>
<li><p>线程的生命周期开销非常高，消耗过多的 CPU资源，如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU资源时还将产生其他性能的开销。</p>
</li>
<li><p>降低JVM稳定性：在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError 异常。</p>
</li>
</ul>
<h2 id="synchronized-的作用？"><a href="#synchronized-的作用？" class="headerlink" title="synchronized 的作用？"></a>synchronized 的作用？</h2><p>在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 可以修饰类、方法、静态方法，代码块。</p>
<h2 id="说说自己是怎么使用-synchronized-关键字，在项目中用到了吗"><a href="#说说自己是怎么使用-synchronized-关键字，在项目中用到了吗" class="headerlink" title="说说自己是怎么使用 synchronized 关键字，在项目中用到了吗"></a>说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</h2><p>​    关键字最主要的三种使用方式</p>
<ul>
<li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li>
<li><strong>修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例</li>
<li><strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li>
</ul>
<p><strong>总结：</strong> synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！</p>
<p>下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。</p>
<p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p>
<p><strong>双重校验锁实现对象单例（线程安全）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。</p>
<p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h2 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h2><h2 id="当一个线程进入一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B？"><a href="#当一个线程进入一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B？" class="headerlink" title="当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？"></a>当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？</h2><p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁</p>
<h2 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h2><ul>
<li>首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类；</li>
<li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li>
<li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁 可以知道有没有成功获取锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li>
</ul>
<h2 id="synchronized-和-ReentrantLock-区别是什么？"><a href="#synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="synchronized 和 ReentrantLock 区别是什么？"></a>synchronized 和 ReentrantLock 区别是什么？</h2><p>synchronized 是关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量</p>
<p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p>
<p>相同点：两者都是可重入锁</p>
<p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
<p>主要区别如下</p>
<ul>
<li>ReentrantLock使用起来比较灵活 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li>
<li>ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。</li>
<li>二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的park 方法加锁，synchronized 操作的是对象头中 mark word</li>
</ul>
<h2 id="Java-中能创建-volatile-数组吗？"><a href="#Java-中能创建-volatile-数组吗？" class="headerlink" title="Java 中能创建 volatile 数组吗？"></a>Java 中能创建 volatile 数组吗？</h2><p>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。</p>
<h2 id="synchronized-和-volatile-的区别是什么？"><a href="#synchronized-和-volatile-的区别是什么？" class="headerlink" title="synchronized 和 volatile 的区别是什么？"></a>synchronized 和 volatile 的区别是什么？</h2><p>synchronized 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。</p>
<p>volatile 表示变量在 CPU 的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性；禁止指令重排序。</p>
<p><strong>区别</strong></p>
<ul>
<li>volatile 是变量修饰符；synchronized 可以修饰类、方法</li>
<li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li>
<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>
<li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li>
<li><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong></li>
</ul>
<h2 id="不可变对象，对写并发应用有什么帮助？"><a href="#不可变对象，对写并发应用有什么帮助？" class="headerlink" title="不可变对象，对写并发应用有什么帮助？"></a>不可变对象，对写并发应用有什么帮助？</h2><p>不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p>
<h2 id="Lock接口是什么？对比同步它有什么优势？"><a href="#Lock接口是什么？对比同步它有什么优势？" class="headerlink" title="Lock接口是什么？对比同步它有什么优势？"></a>Lock接口是什么？对比同步它有什么优势？</h2><p>Lock 接口用来实现锁功能，比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p>
<p>它的优势有：</p>
<p>（1）可以使锁更公平</p>
<p>（2）可以使线程在等待锁的时候响应中断</p>
<p>（3）可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</p>
<p>（4）可以在不同的范围，以不同的顺序获取和释放锁</p>
<h2 id="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><a href="#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？" class="headerlink" title="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"></a>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h2><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。</p>
<p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p>
<h2 id="什么是-CAS"><a href="#什么是-CAS" class="headerlink" title="什么是 CAS"></a>什么是 CAS</h2><p>cas 是一种基于锁的操作，而且是乐观锁。</p>
<p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。CAS是通过无限循环来获取数据的，如果在第一轮循环中，a 线程获取地址里面的值被b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。</p>
<h2 id="CAS-的会产生什么问题？"><a href="#CAS-的会产生什么问题？" class="headerlink" title="CAS 的会产生什么问题？"></a>CAS 的会产生什么问题？</h2><p>1、ABA 问题：</p>
<p>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。</p>
<p>2、循环时间长开销大：</p>
<p>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。</p>
<p>3、只能保证一个共享变量的原子操作：</p>
<p>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。</p>
<h2 id="AQS-原理"><a href="#AQS-原理" class="headerlink" title="AQS 原理"></a>AQS 原理</h2><p><strong>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p>
<blockquote>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p>
</blockquote>
<p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p>
<h2 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h2><ul>
<li>Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
<li><strong>Share</strong>（共享）：多个线程可同时执行，如Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock </li>
</ul>
<h2 id="什么是ConcurrentHashMap？"><a href="#什么是ConcurrentHashMap？" class="headerlink" title="什么是ConcurrentHashMap？"></a>什么是ConcurrentHashMap？</h2><p>ConcurrentHashMap是Java中的一个<strong>线程安全且高效的HashMap实现</strong></p>
<p>JDK1.8后，ConcurrentHashMap抛弃了原有的<strong>Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性</strong>。</p>
<h2 id="CopyOnWriteArrayList-是什么，可以用于什么应用场景？有哪些优缺点？"><a href="#CopyOnWriteArrayList-是什么，可以用于什么应用场景？有哪些优缺点？" class="headerlink" title="CopyOnWriteArrayList 是什么，可以用于什么应用场景？有哪些优缺点？"></a>CopyOnWriteArrayList 是什么，可以用于什么应用场景？有哪些优缺点？</h2><p>查看源码</p>
<p>CopyOnWriteArrayList 是一个并发容器。有很多人称它是线程安全的，我认为这句话不严谨，缺少一个前提条件，那就是非复合场景下操作它是线程安全的。</p>
<p>CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出 ConcurrentModificationException。在CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。</p>
<p>CopyOnWriteArrayList 的使用场景</p>
<p>通过源码分析，我们看出它的优缺点比较明显，所以使用场景也就比较明显。就是合适读多写少的场景。</p>
<p>CopyOnWriteArrayList 的缺点</p>
<ol>
<li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。</li>
<li>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的，虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。</li>
<li>由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次 add/set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。</li>
</ol>
<p>CopyOnWriteArrayList 的设计思想</p>
<ol>
<li>读写分离，读和写分开</li>
<li>最终一致性</li>
<li>使用另外开辟空间的思路，来解决并发冲突</li>
</ol>
<p>其他并发容器：ConcurrentLinkedQueue，ArrayBlockingQueue，LinkedBlockingQueue</p>
<h2 id="ThreadLocal-是什么？"><a href="#ThreadLocal-是什么？" class="headerlink" title="ThreadLocal 是什么？"></a>ThreadLocal 是什么？</h2><p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
<h2 id="ThreadLocal内存泄漏分析与解决方案"><a href="#ThreadLocal内存泄漏分析与解决方案" class="headerlink" title="ThreadLocal内存泄漏分析与解决方案"></a>ThreadLocal内存泄漏分析与解决方案</h2><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<h2 id="什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"><a href="#什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？" class="headerlink" title="什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"></a>什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。</p>
<p>这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p>JDK7 提供了 7 个阻塞队列。分别是：</p>
<p>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</p>
<p>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</p>
<p>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</p>
<p>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</p>
<p>SynchronousQueue：一个不存储元素的阻塞队列。</p>
<p>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</p>
<p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>
<h2 id="什么是线程池？有哪几种创建方式？"><a href="#什么是线程池？有哪几种创建方式？" class="headerlink" title="什么是线程池？有哪几种创建方式？"></a>什么是线程池？有哪几种创建方式？</h2><p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：</p>
<p>（1）newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
<p>（2）newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。如果希望在服务器上使用线程池，建议使用 newFixedThreadPool方法来创建线程池，这样能获得更好的性能。</p>
<p>（3） newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。</p>
<p>（4）newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<h2 id="线程池有什么优点？"><a href="#线程池有什么优点？" class="headerlink" title="线程池有什么优点？"></a>线程池有什么优点？</h2><ul>
<li>降低资源消耗：重用存在的线程，减少对象创建销毁的开销。</li>
<li>提高响应速度。可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
<li>附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。</li>
</ul>
<p>综上所述使用线程池框架 Executor 能更好的管理线程、提供系统资源使用率。</p>
<h2 id="线程池都有哪些状态？"><a href="#线程池都有哪些状态？" class="headerlink" title="线程池都有哪些状态？"></a>线程池都有哪些状态？</h2><ul>
<li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li>
<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</li>
<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li>
<li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li>
<li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li>
</ul>
<h2 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit() 和 execute() 方法有什么区别？"></a>线程池中 submit() 和 execute() 方法有什么区别？</h2><p>接收参数：execute()只能执行 Runnable 类型的任务。submit()可以执行 Runnable 和 Callable 类型的任务。</p>
<p>返回值：submit()方法可以返回持有计算结果的 Future 对象，而execute()没有</p>
<p>异常处理：submit()方便Exception处理</p>
<h2 id="你知道怎么创建线程池吗？"><a href="#你知道怎么创建线程池吗？" class="headerlink" title="你知道怎么创建线程池吗？"></a>你知道怎么创建线程池吗？</h2><p>创建线程池的方式有多种，这里你只需要答 ThreadPoolExecutor 即可。</p>
<p>ThreadPoolExecutor() 是最原始的线程池创建，也是阿里巴巴 Java 开发手册中明确规范的创建线程池的方式。</p>
<p>ThreadPoolExecutor构造函数重要参数分析</p>
<p><strong><code>ThreadPoolExecutor</code></strong> <strong>3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code></strong> ：核心线程数，线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code></strong> ：线程池中允许存在的工作线程的最大数量</li>
<li>**<code>workQueue</code>**：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数:</p>
<ol>
<li>**<code>keepAliveTime</code>**：线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> ：<code>keepAliveTime</code> 参数的时间单位。</li>
<li>**<code>threadFactory</code>**：为线程池提供创建新线程的线程工厂</li>
<li><strong><code>handler</code></strong> ：线程池任务队列超过 maxinumPoolSize 之后的拒绝策略</li>
</ol>
<h2 id="什么是原子操作？"><a href="#什么是原子操作？" class="headerlink" title="什么是原子操作？"></a>什么是原子操作？</h2><p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。</p>
<p>int++并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程有可能会读到之前的值，这就会引发错误。</p>
<h2 id="Atomic原理"><a href="#Atomic原理" class="headerlink" title="Atomic原理"></a>Atomic原理</h2><p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。</p>
<p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<h2 id="在-Java-中-CycliBarriar-和-CountdownLatch-有什么区别？"><a href="#在-Java-中-CycliBarriar-和-CountdownLatch-有什么区别？" class="headerlink" title="在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？"></a>在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？</h2><p>CountDownLatch与CyclicBarrier都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：</p>
<ul>
<li>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；CountDownLatch强调一个线程等多个线程完成某件事情。CyclicBarrier是多个线程互等，等大家都完成，再携手共进。</li>
<li>调用CountDownLatch的countDown方法后，当前线程并不会阻塞，会继续往下执行；而调用CyclicBarrier的await方法，会阻塞当前线程，直到CyclicBarrier指定的线程全部都到达了指定点的时候，才能继续往下执行；</li>
<li>CountDownLatch方法比较少，操作比较简单，而CyclicBarrier提供的方法更多，比如能够通过getNumberWaiting()，isBroken()这些方法获取当前多个线程的状态，并且CyclicBarrier的构造方法可以传入barrierAction，指定当所有线程都到达时执行的业务功能；</li>
<li>CountDownLatch是不能复用的，而CycliBarria是可以复用的。</li>
</ul>
<h2 id="Semaphore-有什么作用"><a href="#Semaphore-有什么作用" class="headerlink" title="Semaphore 有什么作用"></a>Semaphore 有什么作用</h2><p>Semaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n=1，相当于变成了一个 synchronized 了。</p>
<h2 id="什么是线程间交换数据的工具Exchanger"><a href="#什么是线程间交换数据的工具Exchanger" class="headerlink" title="什么是线程间交换数据的工具Exchanger"></a>什么是线程间交换数据的工具Exchanger</h2><p>Exchanger是一个用于线程间协作的工具类，用于两个线程间交换数据。它提供了一个交换的同步点，在这个同步点两个线程能够交换数据。交换数据是通过exchange方法来实现的，如果一个线程先执行exchange方法，那么它会同步等待另一个线程也执行exchange方法，这个时候两个线程就都达到了同步点，两个线程就可以交换数据。</p>
<h2 id="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？"><a href="#现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？" class="headerlink" title="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？"></a>现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</h2><p>这个线程问题通常会在第一轮或电话面试阶段被问到，目的是检测你对”join”方法是否熟悉。这个多线程问题比较简单，可以用join方法实现。</p>
<p>notify&amp;wait方法</p>
<h2 id="什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？"><a href="#什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？" class="headerlink" title="什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？"></a>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？</h2><p>线程调度器是一个操作系统服务，它负责为<em>Runnable</em>状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的<em>Runnable</em>线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</p>
<h2 id="你如何确保main-方法所在的线程是Java程序最后结束的线程？"><a href="#你如何确保main-方法所在的线程是Java程序最后结束的线程？" class="headerlink" title="你如何确保main()方法所在的线程是Java程序最后结束的线程？"></a>你如何确保main()方法所在的线程是Java程序最后结束的线程？</h2><p>我们可以使用Thread类的joint()方法来确保所有程序创建的线程在main()方法退出前结束</p>
<h2 id="为什么Thread类的sleep-和yield-方法是静态的？"><a href="#为什么Thread类的sleep-和yield-方法是静态的？" class="headerlink" title="为什么Thread类的sleep()和yield()方法是静态的？"></a>为什么Thread类的sleep()和yield()方法是静态的？</h2><p>Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。</p>
<h2 id="什么是Java-Timer类？如何创建一个有特定时间间隔的任务？"><a href="#什么是Java-Timer类？如何创建一个有特定时间间隔的任务？" class="headerlink" title="什么是Java Timer类？如何创建一个有特定时间间隔的任务？"></a>什么是Java Timer类？如何创建一个有特定时间间隔的任务？</h2><p>java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。</p>
<p>java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。</p>
<h2 id="synchronized锁的优化了解吗"><a href="#synchronized锁的优化了解吗" class="headerlink" title="synchronized锁的优化了解吗"></a><strong>synchronized锁的优化了解吗</strong></h2><ul>
<li>synchronized在JDK1.6进行了锁的优化，也就是当一个线程多次访问一个同步代码块的时候，此时会记录该线程的ThreadId也就是，当你再来访问的时候，我就只需判断threadId就行了，效率高，这属于偏向锁。</li>
<li>当有多个线程来的时候，那么这个锁就会升级为轻量级锁，也就是通过CAS，来进行尝试获取锁，是一种自旋锁的状态。如果在短时间内可以获得锁，不会堵塞，而且节约了CPU上下文切换的时间。</li>
<li>如果长时间没有获取到锁，在那一直死循环，会消耗CUP的资源，经过一个时间段后会升级为重量级锁，会发生阻塞。其中锁升级是不可逆的。</li>
</ul>
<h2 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h2><p><strong>成员变量和静态变量是否线程安全</strong></p>
<ul>
<li>如果它们被共享了，根据它们的状态是否能够改变，分两种情况<ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<p><strong>局部变量是否线程安全</strong></p>
<ul>
<li>局部变量是线程安全的</li>
<li>但局部变量引用的对象则未必<ul>
<li>如果该对象没有逃离方法的作用访问，它是线程安全的</li>
<li>如果该对象逃离方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
</ul>
<p><strong>局部变量的暴露引用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadSafe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUMBER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOOP_NUMBER = <span class="number">200</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadSafeSubClass test = <span class="keyword">new</span> ThreadSafeSubClass();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                test.method1(LOOP_NUMBER);</span><br><span class="line">            &#125;, <span class="string">&quot;Thread&quot;</span> + (i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title">ThreadSafe</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>method1中的list对象逃离了该方法的作用范围 主线程创建了两个新的线程执行method3 他们对list共享从而引发线程安全问题 </li>
</ul>
<h2 id="为什么无锁效率高"><a href="#为什么无锁效率高" class="headerlink" title="为什么无锁效率高"></a>为什么无锁效率高</h2><ul>
<li>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。</li>
<li>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持</li>
</ul>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="简单介绍一下redis"><a href="#简单介绍一下redis" class="headerlink" title="简单介绍一下redis"></a>简单介绍一下redis</h2><p>简单来说 <strong>Redis 就是一个使用 C 语言开发的数据库</strong>，不过与传统数据库不同的是 <strong>Redis 的数据是存在内存中的</strong> ，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。</p>
<p>另外，<strong>Redis 除了做缓存之外，Redis 也经常用来做分布式锁，甚至是消息队列。</strong></p>
<p><strong>Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。</strong></p>
<p>Redis用作分布式缓存：分布式缓存主要解决的是单机缓存的容量受服务器限制并且无法保存通用的信息。因为，本地缓存只在当前服务里有效，比如如果你部署了两个相同的服务，他们两者之间的缓存数据是无法共通的。</p>
<h2 id="为什么要用缓存"><a href="#为什么要用缓存" class="headerlink" title="为什么要用缓存"></a>为什么要用缓存</h2><p><strong>高性能</strong> ：操作缓存就是直接操作内存，所以速度相当快。不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><strong>高并发</strong></p>
<h2 id="既然是单线程，那怎么监听大量的客户端连接呢？"><a href="#既然是单线程，那怎么监听大量的客户端连接呢？" class="headerlink" title="既然是单线程，那怎么监听大量的客户端连接呢？"></a><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></h2><p>Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发生。</p>
<p>这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p>
<h2 id="Redis-没有使用多线程？为什么不使用多线程？"><a href="#Redis-没有使用多线程？为什么不使用多线程？" class="headerlink" title="Redis 没有使用多线程？为什么不使用多线程？"></a>Redis 没有使用多线程？为什么不使用多线程？</h2><p><strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong></p>
<p>大体上来说，<strong>Redis 6.0 之前主要还是单线程处理。</strong></p>
<p><strong>那，Redis6.0 之前 为什么不使用多线程？</strong></p>
<p>我觉得主要原因有下面 3 个：</p>
<ol>
<li>单线程编程简单并且更容易维护；</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ol>
<p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈</p>
<p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了， 执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p>
<h2 id="Redis-给缓存数据设置过期时间有啥用？"><a href="#Redis-给缓存数据设置过期时间有啥用？" class="headerlink" title="Redis 给缓存数据设置过期时间有啥用？"></a>Redis 给缓存数据设置过期时间有啥用？</h2><p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，会导致Out of memory。</p>
<p>并且很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在1分钟内有效，用户登录的 token 可能只在 1 天内有效。</p>
<h2 id="Redis是如何判断数据是否过期的呢？"><a href="#Redis是如何判断数据是否过期的呢？" class="headerlink" title="Redis是如何判断数据是否过期的呢？"></a>Redis是如何判断数据是否过期的呢？</h2><p>Redis 通过一个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是一个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。</p>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210221190028319.png" alt="image-20210221190028319"></p>
<h2 id="过期的数据的删除策略了解么？"><a href="#过期的数据的删除策略了解么？" class="headerlink" title="过期的数据的删除策略了解么？"></a>过期的数据的删除策略了解么？</h2><p>果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p>
<p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p>
<ol>
<li><strong>惰性删除</strong> ：只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期key操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>
</ol>
<p>定期删除对内存更加友好，惰性删除对CPU更加友好。两者各有千秋，所以Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p>
<p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就Out of memory了。</p>
<p>怎么解决这个问题呢？答案就是： <strong>Redis 内存淘汰机制。</strong></p>
<h2 id="Redis-内存淘汰机制"><a href="#Redis-内存淘汰机制" class="headerlink" title="Redis 内存淘汰机制"></a><strong>Redis 内存淘汰机制</strong></h2><p>Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ol>
<h2 id="Redis-持久化机制-怎么保证-Redis-挂掉之后再重启数据可以进行恢复"><a href="#Redis-持久化机制-怎么保证-Redis-挂掉之后再重启数据可以进行恢复" class="headerlink" title="Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)"></a>Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)</h2><p><strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。</p>
<p><strong>快照</strong></p>
<p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p>快照持久化是 Redis 默认采用的持久化方式</p>
<p><strong>追加文件</strong></p>
<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<p><strong>Redis 4.0 对于持久化机制的优化</strong></p>
<p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>Redis 可以通过 <strong>MULTI，EXEC，DISCARD 和 WATCH</strong> 等命令来实现事务(transaction)功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line">&gt; INCR bar</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>使用 <a href="https://redis.io/commands/multi">MULTI</a>命令后可以输入多个命令。Redis不会立即执行这些命令，而是将它们放到队列，当调用了<a href="https://redis.io/commands/exec">EXEC</a>命令将执行所有命令。</p>
<p><strong>Redis 是不支持 roll back 的，因而不满足ACID中的原子性的（而且不满足持久性）。</strong></p>
<h2 id="什么是缓存穿透？解决办法？"><a href="#什么是缓存穿透？解决办法？" class="headerlink" title="什么是缓存穿透？解决办法？"></a>什么是缓存穿透？解决办法？</h2><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层</p>
<p><strong>缓存无效 key</strong></p>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p><strong>布隆过滤器</strong></p>
<p>把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210221191234025.png" alt="image-20210221191234025"></p>
<p>布隆过滤器可能误判 来看看他的原理</p>
<p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>
<p>关于布隆过滤器：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md">https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md</a></p>
<h2 id="什么是缓存雪崩？解决方法？"><a href="#什么是缓存雪崩？解决方法？" class="headerlink" title="什么是缓存雪崩？解决方法？"></a>什么是缓存雪崩？解决方法？</h2><p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>
<p>还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong></p>
<p><strong>解决方法</strong></p>
<p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
</ol>
<h2 id="如何保证缓存和数据库数据的一致性？"><a href="#如何保证缓存和数据库数据的一致性？" class="headerlink" title="如何保证缓存和数据库数据的一致性？"></a>如何保证缓存和数据库数据的一致性？</h2><p>下面单独对 <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</p>
<p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>
<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加cache更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>
</ol>
<h2 id="缓存常用的3种读写策略"><a href="#缓存常用的3种读写策略" class="headerlink" title="缓存常用的3种读写策略"></a><strong>缓存常用的3种读写策略</strong></h2><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/3%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5">https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/3%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5</a></p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="RestController-vs-Controller"><a href="#RestController-vs-Controller" class="headerlink" title="@RestController vs @Controller"></a>@RestController vs @Controller</h2><p>单独使用 <code>@Controller</code> 不加 <code>@ResponseBody</code>的话一般使用在要返回一个视图的情况，这种情况属于比较传统的Spring MVC 的应用，对应于前后端不分离的情况。</p>
<p><code>@RestController</code>只返回对象，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Controller</span> + <span class="variable">@ResponseBody</span> = <span class="variable">@RestController</span></span><br></pre></td></tr></table></figure>

<h2 id="谈谈自己对于-Spring-IoC-和-AOP-的理解"><a href="#谈谈自己对于-Spring-IoC-和-AOP-的理解" class="headerlink" title="谈谈自己对于 Spring IoC 和 AOP 的理解"></a>谈谈自己对于 Spring IoC 和 AOP 的理解</h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p><strong>控制反转（Inversion of Control）</strong> 就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的<strong>依赖注入（Dependency Injection）</strong></p>
<p><strong>所谓依赖注入，就是把底层类作为参数传入上层类，实现上层类对下层类的“控制</strong>”。</p>
<p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong></p>
<p><strong>IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p>
<p><strong>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的</strong></p>
<p>推荐阅读：<a href="https://www.zhihu.com/question/23277575/answer/169698662">https://www.zhihu.com/question/23277575/answer/169698662</a></p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却被业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>,在需要用到的地方直接使用即可,便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<h2 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h2><p>了解一下aop原理</p>
<p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>
<h2 id="Spring-中的-bean-的作用域有哪些"><a href="#Spring-中的-bean-的作用域有哪些" class="headerlink" title="Spring 中的 bean 的作用域有哪些?"></a>Spring 中的 bean 的作用域有哪些?</h2><ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
<h2 id="Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="Spring 中的单例 bean 的线程安全问题了解吗？"></a>Spring 中的单例 bean 的线程安全问题了解吗？</h2><p>的确是存在安全问题的。因为，当多个线程操作同一个对象的时候，对这个对象的成员变量的写操作会存在线程安全问题。</p>
<p>但是，一般情况下，我们常用的 <code>Controller</code>、<code>Service</code>、<code>Dao</code> 这些 Bean 是无状态的。无状态的 Bean 不能保存数据，因此是线程安全的。</p>
<p>常见的有 2 种解决办法：</p>
<ol>
<li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li>
<li>改变 Bean 的作用域为 “prototype”：每次请求都会创建一个新的 bean 实例，自然不会存在线程安全问题。</li>
</ol>
<h2 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h2><ol>
<li>作用对象不同: <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了Spring这是某个类的示例，当我需要用它的时候还给我。</li>
<li><code>@Bean</code> 注解比 <code>Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li>
</ol>
<h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a><a href="https://www.cnblogs.com/javazhiyin/p/10905294.html">bean的生命周期</a></h2><h2 id="spring框架中用到了哪些设计模式"><a href="#spring框架中用到了哪些设计模式" class="headerlink" title="spring框架中用到了哪些设计模式"></a>spring框架中用到了哪些设计模式</h2><p>关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN#rd">《面试官:“谈谈Spring中都用到了那些设计模式?”。》</a> 。</p>
<ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
</ul>
<h2 id="管理事务的方式有几种"><a href="#管理事务的方式有几种" class="headerlink" title="管理事务的方式有几种"></a>管理事务的方式有几种</h2><ol>
<li><p><strong>Spring 有几种实现事务的方式？</strong></p>
<p>答：Spring 实现事务有两种方式：编程式事务和声明式事务。</p>
<p>编程式事务，使用 TransactionTemplate 或 PlatformTransactionManager 实现，示例代码如下：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// Spring编码式事务，回调机制</span></span><br><span class="line">    transactionTemplate.execute(<span class="keyword">new</span> TransactionCallback&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function">Object <span class="title">doInTransaction</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                userMapper.insertSelective(user);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 异常，设置为回滚</span></span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有异常，调用 status.setRollbackOnly() 回滚事务，否则正常执行 doInTransaction() 方法，正常提交事务。<br>如果事务控制的方法不需要返回值，就可以使用 TransactionCallbackWithoutResult（TransactionCallback 接口的抽象实现类）示例代码如下：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Spring编码式事务，回调机制</span></span><br><span class="line">    transactionTemplate.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                userMapper.insertSelective(user);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 异常，设置为回滚</span></span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>声明式事务，底层是建立在 Spring AOP 的基础上，在方式执行前后进行拦截，并在目标方法开始执行前创建新事务或加入一个已存在事务，最后在目标方法执行完后根据情况提交或者回滚事务。<br>声明式事务的优点：不需要编程，减少了代码的耦合，在配置文件中配置并在目标方法上添加 @Transactional 注解来实现，示例代码如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Transactional</span><br><span class="line"><span class="built_in">public</span> <span class="type">void</span> save() &#123;</span><br><span class="line">    <span class="keyword">User</span> <span class="keyword">user</span> = <span class="built_in">new</span> <span class="keyword">User</span>(&quot;laowang&quot;);</span><br><span class="line">    userMapper.insertSelective(<span class="keyword">user</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        throw <span class="built_in">new</span> RuntimeException(&quot;异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>抛出异常，事务会自动回滚，如果方法正常执行，则会自动提交事务。</p>
</li>
</ol>
<h2 id="你更倾向用那种事务管理类型？"><a href="#你更倾向用那种事务管理类型？" class="headerlink" title="你更倾向用那种事务管理类型？"></a>你更倾向用那种事务管理类型？</h2><p>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p>
<h2 id="spring事务的隔离级别有哪几种"><a href="#spring事务的隔离级别有哪几种" class="headerlink" title="spring事务的隔离级别有哪几种"></a>spring事务的隔离级别有哪几种</h2><p><strong>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</strong></p>
<ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong> 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h2 id="Spring-中有哪几种事务传播行为"><a href="#Spring-中有哪几种事务传播行为" class="headerlink" title="Spring 中有哪几种事务传播行为?"></a>Spring 中有哪几种事务传播行为?</h2><p><strong>支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<p><strong>不支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><strong>其他情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h2 id="Transactional-rollbackFor-Exception-class-注解了解吗？"><a href="#Transactional-rollbackFor-Exception-class-注解了解吗？" class="headerlink" title="@Transactional(rollbackFor = Exception.class)注解了解吗？"></a>@Transactional(rollbackFor = Exception.class)注解了解吗？</h2><p>当<code>@Transactional</code>注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</p>
<h2 id="如何使用JPA在数据库中非持久化一个字段？"><a href="#如何使用JPA在数据库中非持久化一个字段？" class="headerlink" title="如何使用JPA在数据库中非持久化一个字段？"></a>如何使用JPA在数据库中非持久化一个字段？</h2><p>假如我们有有下面一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Entity(name=<span class="string">&quot;USER&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(name=&quot;USER_NAME&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(name=&quot;PASSWORD&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String secrect;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想让<code>secrect</code> 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String transient1; <span class="comment">// not persistent because of static</span></span><br><span class="line"><span class="keyword">final</span> String transient2 = “Satish”; <span class="comment">// not persistent because of final</span></span><br><span class="line"><span class="keyword">transient</span> String transient3; <span class="comment">// not persistent because of transient</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line">String transient4; <span class="comment">// not persistent because of @TransientCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>一般使用后面两种方式比较多，我个人使用注解的方式比较多。</p>
<h2 id="Spring-IoC-的实现机制"><a href="#Spring-IoC-的实现机制" class="headerlink" title="Spring IoC 的实现机制"></a>Spring IoC 的实现机制</h2><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</p>
<p>可以把IOC容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言的的反射编程，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。</p>
<h2 id="BeanFactory-和-ApplicationContext有什么区别？"><a href="#BeanFactory-和-ApplicationContext有什么区别？" class="headerlink" title="BeanFactory 和 ApplicationContext有什么区别？"></a>BeanFactory 和 ApplicationContext有什么区别？</h2><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p>
<p>依赖关系</p>
<p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p>
<p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p>
<ul>
<li>继承MessageSource，因此支持国际化。</li>
<li>统一的资源文件访问方式。</li>
<li>提供在监听器中注册bean的事件。</li>
<li>同时加载多个配置文件。</li>
<li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li>
</ul>
<p><strong>加载方式</strong></p>
<p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p>
<p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>
<p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<p><strong>创建方式</strong></p>
<p>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p>
<p><strong>注册方式</strong></p>
<p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>
<h2 id="ApplicationContext通常的实现是什么？"><a href="#ApplicationContext通常的实现是什么？" class="headerlink" title="ApplicationContext通常的实现是什么？"></a>ApplicationContext通常的实现是什么？</h2><p><strong>FileSystemXmlApplicationContext</strong> ：此容器从一个XML文件中加载beans的定义，必须把XML Bean配置文件的全路径名提供给它的构造函数。</p>
<p><strong>ClassPathXmlApplicationContext</strong>：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</p>
<p><strong>WebXmlApplicationContext</strong>：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</p>
<h2 id="怎么理解-Spring-中的依赖注入？"><a href="#怎么理解-Spring-中的依赖注入？" class="headerlink" title="怎么理解 Spring 中的依赖注入？"></a><strong>怎么理解 Spring 中的依赖注入？</strong></h2><p>答：依赖注入是指组件之间的依赖关系由容器在运行期决定，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是<strong>为了提升组件重用的频率</strong>，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<h2 id="有哪些不同类型的依赖注入实现方式？"><a href="#有哪些不同类型的依赖注入实现方式？" class="headerlink" title="有哪些不同类型的依赖注入实现方式？"></a>有哪些不同类型的依赖注入实现方式？</h2><p>依赖注入是时下最流行的IoC实现方式，依赖注入分为接口注入（Interface Injection），Setter方法注入（Setter Injection）和构造器注入（Constructor Injection）三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。</p>
<p><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p>
<p><strong>Setter方法注入</strong>：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&lt;bean <span class="keyword">class</span>=&quot;top.bigking.bean.Book&quot; id=&quot;book&quot;&gt;</span><br><span class="line">          &lt;constructor-arg <span class="keyword">index</span>=&quot;0&quot; <span class="keyword">value</span>=&quot;1&quot;/&gt;</span><br><span class="line">          &lt;constructor-arg <span class="keyword">index</span>=&quot;1&quot; <span class="keyword">value</span>=&quot;哈利波特&quot;/&gt;</span><br><span class="line">          &lt;constructor-arg <span class="keyword">index</span>=&quot;2&quot; <span class="keyword">value</span>=&quot;18.8&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean <span class="keyword">class</span>=&quot;top.bigking.bean.Book&quot; id=&quot;book&quot;&gt;</span><br><span class="line">		 &lt;property <span class="type">name</span>=&quot;id&quot; <span class="keyword">value</span>=&quot;1&quot;/&gt;</span><br><span class="line">         &lt;property <span class="type">name</span>=&quot;bookname&quot; <span class="keyword">value</span>=&quot;哈利波特&quot; /&gt;</span><br><span class="line">         &lt;property <span class="type">name</span>=&quot;price&quot; <span class="keyword">value</span>=&quot;18.8&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h2 id="构造器依赖注入和-Setter方法注入的区别"><a href="#构造器依赖注入和-Setter方法注入的区别" class="headerlink" title="构造器依赖注入和 Setter方法注入的区别"></a>构造器依赖注入和 Setter方法注入的区别</h2><table>
<thead>
<tr>
<th><strong>构造函数注入</strong></th>
<th><strong>setter</strong> <strong>注入</strong></th>
</tr>
</thead>
<tbody><tr>
<td>没有部分注入</td>
<td>有部分注入</td>
</tr>
<tr>
<td>不会覆盖 setter 属性</td>
<td>会覆盖 setter 属性</td>
</tr>
<tr>
<td>任意修改都会创建一个新实例</td>
<td>任意修改不会创建一个新实例</td>
</tr>
<tr>
<td>适用于设置很多属性</td>
<td>适用于设置少量属性</td>
</tr>
</tbody></table>
<h2 id="使用-Autowired注解自动装配的过程是怎样的？"><a href="#使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="使用@Autowired注解自动装配的过程是怎样的？"></a>使用@Autowired注解自动装配的过程是怎样的？</h2><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。</p>
<p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。</p>
<ul>
<li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li>
<li>如果查询的结果不止一个，那么@Autowired会根据名称进行匹配；</li>
<li>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。</li>
</ul>
<h2 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h2><p>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</p>
<p>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</p>
<p>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</p>
<p>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p>
<h2 id="Autowired和-Resource之间的区别"><a href="#Autowired和-Resource之间的区别" class="headerlink" title="@Autowired和@Resource之间的区别"></a>@Autowired和@Resource之间的区别</h2><p>@Autowired可用于：构造函数、成员变量、Setter方法</p>
<p>@Autowired和@Resource之间的区别</p>
<ul>
<li>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</li>
<li>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</li>
</ul>
<h2 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h2><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：</p>
<ul>
<li>类级别：映射请求的 URL</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法</li>
</ul>
<h2 id="解释一下Spring-AOP里面的几个名词"><a href="#解释一下Spring-AOP里面的几个名词" class="headerlink" title="解释一下Spring AOP里面的几个名词"></a>解释一下Spring AOP里面的几个名词</h2><ul>
<li>通知（Advice）: AOP 框架中的增强处理。通知描述了切面何时执行以及如何执行增强处理。</li>
<li>连接点（join point）: 连接点表示应用执行过程中能够插入切面的一个点，这个点可以是方法的调用、异常的抛出。在 Spring AOP 中，连接点总是方法的调用。</li>
<li>切点（PointCut）: 可以插入增强处理的连接点。</li>
<li>切面（Aspect）: 切面是通知和切点的结合。</li>
<li>引入（Introduction）：引入允许我们向现有的类添加新的方法或者属性。</li>
<li>织入（Weaving）: 将增强处理添加到目标对象中，并创建一个被增强的对象，这个过程就是织入。</li>
</ul>
<p>连接点和切点的区别</p>
<ul>
<li><p>连接点：连接点是一个虚拟的概念，可以理解为所有满足切点扫描条件的所有的时机。</p>
</li>
<li><p>具体举个例子：比如开车经过一条高速公路，这条高速公路上有很多个出口（连接点），但是我们不会每个出口都会出去，只会选择我们需要的那个出口（切点）开出去。</p>
</li>
</ul>
<h2 id="Spring通知有哪些类型？"><a href="#Spring通知有哪些类型？" class="headerlink" title="Spring通知有哪些类型？"></a>Spring通知有哪些类型？</h2><p>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p>
<p>Spring切面可以应用5种类型的通知：</p>
<ol>
<li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li>
<li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li>
<li>返回通知（After-returning ）：在目标方法成功执行之后调用通知；</li>
<li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li>
<li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li>
</ol>
<p>同一个aspect，不同advice的执行顺序：</p>
<p>①没有异常情况下的执行顺序：</p>
<p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterReturning</p>
<p>②有异常情况下的执行顺序：异常通知会出现在返回通知后面</p>
<p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterThrowing:异常发生<br>java.lang.RuntimeException: 异常发生</p>
<h2 id="Value-注解的作用是什么？"><a href="#Value-注解的作用是什么？" class="headerlink" title="@Value 注解的作用是什么？"></a><strong>@Value 注解的作用是什么？</strong></h2><p>答：基于 @Value 的注解可以读取 properties 配置文件</p>
<h2 id="Spring-的-JdbcTemplate-对象和-JDBC-有什么区别？"><a href="#Spring-的-JdbcTemplate-对象和-JDBC-有什么区别？" class="headerlink" title="Spring 的 JdbcTemplate 对象和 JDBC 有什么区别？"></a><strong>Spring 的 JdbcTemplate 对象和 JDBC 有什么区别？</strong></h2><p>答：Spring 的 JdbcTemplate 是对 JDBC API 的封装，提供更多的功能和更便利的操作，比如 JdbcTemplate 拥有：</p>
<ul>
<li>线程安全</li>
<li>实例化操作比较简单，仅需要传递 DataSource；</li>
<li>自动完成资源的创建和释放工作；</li>
<li>创建一次 JdbcTemplate，到处可用，避免重复开发。</li>
</ul>
<h2 id="关于MVC"><a href="#关于MVC" class="headerlink" title="关于MVC"></a>关于MVC</h2><p>MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。</p>
<h2 id="MVC工作原理"><a href="#MVC工作原理" class="headerlink" title="MVC工作原理"></a>MVC工作原理</h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210224151018792.png" alt="image-20210224151018792"></p>
<p>上图的一个笔误的小问题：Spring MVC 的入口函数也就是前端控制器 <code>DispatcherServlet</code> 的作用是接收请求，响应结果。</p>
<p><strong>流程说明（重要）：</strong></p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li>
<li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li>
<li><code>HandlerAdapter</code> 会根据 <code>Handler </code>来调用真正的处理器来处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><h2 id="为什么不从页面使用js给es发送请求-这样就不用后端了？"><a href="#为什么不从页面使用js给es发送请求-这样就不用后端了？" class="headerlink" title="为什么不从页面使用js给es发送请求 这样就不用后端了？"></a>为什么不从页面使用js给es发送请求 这样就不用后端了？</h2><ol>
<li>ES属于后端集群服务器 端口一般不对外暴漏 防止出现安全隐患</li>
<li>js支持率低</li>
</ol>
<h2 id="shard和replica机制"><a href="#shard和replica机制" class="headerlink" title="shard和replica机制"></a>shard和replica机制</h2><p>每个shard都是一个最小工作单元，承载部分数据，lucene实例，完整的建立索引和处理请求的能力.</p>
<p>replica shard是primary shard的副本，负责容错以及读请求负载均衡</p>
<p>primary shard的数量在创建索引的时候就固定了，replica shard的数量可以随时修改.</p>
<p>每个document肯定只存在于某一个primary shard以及其对应的replica shard中，不可能存在于多个primary shard上.</p>
<p>primary shard不能和自己的replica shard放在同一个节点上（否则节点宕机，primary shard和副本都丢失，起不到容错的作用），但是可以和其他primary shard的replica shard放在同一个节点上.</p>
<h2 id="ES路由算法"><a href="#ES路由算法" class="headerlink" title="ES路由算法"></a>ES路由算法</h2><p>document创建的时候路由就需要决定放在哪个shard  一个document只能存在于一个primary shard上</p>
<p>路由算法：shard = hash(routing) % number_of_primary_shards</p>
<p>举例</p>
<p>一个index有3个primary shard，P0，P1，P2<br>每次增删改查一个document的时候，都会带过来一个routing number（默认就是这个document的_id（可能是手动指定，也可能是自动生成））<br>routing = _id，假设_id=1</p>
<p>会将这个routing值，传入一个hash函数中，产出一个routing值的hash值，hash(routing) = 21<br>然后将hash函数产出的值对这个index的primary shard的数量求余数，21 % 3 = 0<br>就决定了，这个document就放在P0上。</p>
<h2 id="ES写过程"><a href="#ES写过程" class="headerlink" title="ES写过程"></a>ES写过程</h2><ul>
<li>客户端选择一个 node作为 <code>coordinating node</code>（协调节点）发送请求</li>
<li><code>coordinating node</code> 对 document 进行路由，将请求转发给对应的 node</li>
<li>实际的 node 上的 <code>primary shard</code> 处理请求，然后将数据同步到相应node上的<code>replica shard</code>。</li>
<li><code>coordinating node</code> 如果发现 <code>primary shard</code> 和所有 <code>replica shard</code> 都搞定之后，就返回响应结果给客户端。</li>
</ul>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210302130227926.png" alt="image-20210302130227926"></p>
<p>底层原理：</p>
<ol>
<li>在到达primary shard的时候 ，数据先写入内存buffer ，此时在buffer里的数据是不会被搜索到的。同时生成一个translog日志文件 ， 将数据写入translog里</li>
<li>如果内存buffer空间快满了，就会将数据refresh到一个新的segment file文件中，而且es里每隔1s就会将buffer里的数据写入到一个新的segment file中，这个segment file就存储最最近1s中buffer写入的数据，如果buffer里面没有数据，就不会执行refresh操作，当建立segment file文件的时候，就同时建立好了倒排索引库。</li>
<li>在buffer refresh到segment之前 ，会先进入到一个叫os cache中，只要被执行了refresh操作，就代表这个数据可以被搜索到了。数据被输入os cache中，buffer就会被清空了，所以为什么叫es是准实时的？NRT，near real-time，准实时。默认是每隔1秒refresh一次的，所以es是准实时的，因为写入的数据1秒之后才能被看到。还可以通过es的restful api或者java api，手动执行一次refresh操作，就是手动将buffer中的数据刷入os cache中，让数据立马就可以被搜索到。</li>
<li>就这样新的数据不断进入buffer和translog，不断将buffer数据写入一个又一个新的segment file中去，每次refresh完buffer清空，translog保留。随着这个过程推进，translog会变得越来越大。当translog达到一定长度的时候，就会触发commit操作。translog也是先进入os cache中，然后每隔5s持久化到translog到磁盘中，</li>
<li>commit操作，第一步，就是将buffer中现有数据refresh到os cache中去，清空buffer 每隔30分钟flush</li>
<li>es也有可能会数据丢失 ，有5s的数据停留在buffer、translog os cache, segment file os cache中，如果此时宕机，这5s的数据就会丢失，如果项目要求比较高，不能丢失数据，就可以设置参数，每次写入一条数据写入buffer，同时写入translog磁盘文件中，但这样做会使es的性能降低。</li>
<li>如果是删除操作，commit操作的时候就会生成一个.del文件，将这个document标识为deleted状态，在搜索的搜索的时候就不会被搜索到了。</li>
<li>如果是更新操作，就是将原来的document标识为deleted状态，然后新写入一条数据</li>
<li>buffer每次refresh一次，就会产生一个segment file，所以默认情况下是1秒钟一个segment file，segment file会越来越多，当躲到一定程度的时候，es就会自动触发merge(合并)造作，将所有segment file文件 merge成一个segment file，并同时物理删除掉标识为deleted的doc</li>
</ol>
<h2 id="es-搜索数据过程"><a href="#es-搜索数据过程" class="headerlink" title="es 搜索数据过程"></a>es 搜索数据过程</h2><p>是指search，search和普通doc id get的背后逻辑不一样</p>
<p>es 最强大的是做全文检索，就是比如你有三条数据：</p>
<ul>
<li><code>java真好玩儿啊</code></li>
<li><code>java好难学啊</code></li>
<li><code>j2ee特别牛</code></li>
</ul>
<p>你根据 <code>java</code> 关键词来搜索，将包含 <code>java</code>的 <code>document</code> 给搜索出来。es 就会给你返回：java真好玩儿啊，java好难学啊。</p>
<ul>
<li><p>搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch；</p>
</li>
<li><p>在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。PS：在搜索的时候是会查询Filesystem Cache的，但是有部分数据还在Memory Buffer，所以搜索是近实时的。</p>
</li>
<li><p>每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，协调节点合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</p>
</li>
<li><p>接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并 丰富 文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。</p>
</li>
</ul>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>倒排索引，就是建立词语与文档的对应关系（词语在什么文档出现，出现了多少次，在什么位置出现）</p>
<p>搜索的时候，根据搜索关键词，直接在索引中找到对应关系，搜索速度快。</p>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210302131654376.png" alt="image-20210302131654376"></p>
<p>doc:表示哪个文档，frep：表示出现的频率，pos：表示出现的位置</p>
<h2 id="为什么要使用Elasticsearch"><a href="#为什么要使用Elasticsearch" class="headerlink" title="为什么要使用Elasticsearch?"></a>为什么要使用Elasticsearch?</h2><p> 　　因为在我们商城中的数据，将来会非常多，所以采用以往的模糊查询，模糊查询前置配置，会放弃索引，导致商品查询是全表扫面，在百万级别的数据库中，效率非常低下，而我们使用ES做一个全文索引，我们将经常查询的商品的某些字段，比如说商品名，描述、价格还有id这些字段我们放入我们索引库里，可以提高查询速度。</p>
<h2 id="ES选举机制"><a href="#ES选举机制" class="headerlink" title="ES选举机制"></a><a href="https://www.cnblogs.com/zziawanblog/p/6577383.html">ES选举机制</a></h2><p>​    对所有可以成为master的节点（node.master: true）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。<br>​    如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。</p>
<h2 id="Elasticsearch是如何避免脑裂现象的"><a href="#Elasticsearch是如何避免脑裂现象的" class="headerlink" title="Elasticsearch是如何避免脑裂现象的"></a>Elasticsearch是如何避免脑裂现象的</h2><p>为了避免出现脑裂情况，我们可以查看的第一个参数是<strong>Discovery.zen.minimum_master_nodes</strong>。此参数确定要选举一个主机需要通信的节点数。默认值为1。经验法则是应将其设置为N / 2 + 1，其中N是群集中节点的数量。例如，在3节点群集的情况下，minimum_master_nodes应该设置为3/2 + 1 = 2（向下舍入为最接近的整数）。</p>
<p>让我们想象一下，如果我们将<strong>Discovery.zen.minimum_master_nodes</strong>设置为2（2/2 + 1），在上述情况下会发生什么。当两个节点之间的通信丢失时，节点1将失去其主控状态，而节点2将永远不会被选举为主节点。没有一个节点会接受索引或搜索请求，这使所有客户端的问题立即显而易见。此外，所有分片都不会处于不一致状态。</p>
<p>您可以调整的另一个参数是<strong>Discovery.zen.ping.timeout</strong>。默认值为3秒，它确定节点在假定节点发生故障之前将等待集群中其他节点响应的时间。在网络速度较慢的情况下，稍微增加默认值绝对是个好主意。此参数不仅可以满足更高的网络延迟，而且在节点由于过载而响应较慢的情况下也很有用。</p>
<p>当候选数量为两个时，只能修改为唯一的一个master候选，其他作为data节点，避免脑裂问题。   </p>
<h2 id="在并发情况下，Elasticsearch如果保证读写一致？"><a href="#在并发情况下，Elasticsearch如果保证读写一致？" class="headerlink" title="在并发情况下，Elasticsearch如果保证读写一致？"></a>在并发情况下，Elasticsearch如果保证读写一致？</h2><ul>
<li>可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；</li>
<li>另外对于写操作，一致性级别支持quorum/one/all，默认为quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</li>
<li>对于读操作，可以设置replication为sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置replication为async时，也可以通过设置搜索请求参数_preference为primary来查询主分片，确保文档是最新版本。</li>
</ul>
<h2 id="es-在数据量很大的情况下（数十亿级别）如何提高查询效率"><a href="#es-在数据量很大的情况下（数十亿级别）如何提高查询效率" class="headerlink" title="es 在数据量很大的情况下（数十亿级别）如何提高查询效率"></a><a href="https://www.jianshu.com/p/fa510352ce1a">es 在数据量很大的情况下（数十亿级别）如何提高查询效率</a></h2><h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><h2 id="什么是dubbo"><a href="#什么是dubbo" class="headerlink" title="什么是dubbo"></a>什么是dubbo</h2><p>是一款高性能、轻量级的开源Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
<h2 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC?"></a>什么是 RPC?</h2><p>RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求当然可以，但是可能会比较麻烦。 RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。</p>
<h2 id="既有-HTTP-为啥用-RPC-进行服务调用"><a href="#既有-HTTP-为啥用-RPC-进行服务调用" class="headerlink" title="既有 HTTP ,为啥用 RPC 进行服务调用?"></a>既有 HTTP ,为啥用 RPC 进行服务调用?</h2><p>RPC 只是一种概念、一种设计，就是为了解决 <strong>不同服务之间的调用问题</strong>, 它一般会包含有 <strong>传输协议</strong> 和 <strong>序列化协议</strong> 这两个。</p>
<p>但是，HTTP 是一种协议，RPC框架可以使用 HTTP协议作为传输协议或者直接使用TCP作为传输协议，使用不同的协议一般也是为了适应不同的场景。</p>
<h2 id="RPC原理是什么"><a href="#RPC原理是什么" class="headerlink" title="RPC原理是什么?"></a>RPC原理是什么?</h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210304142357573.png" alt="image-20210304142357573"></p>
<ol>
<li>服务消费方（client）调用以本地调用方式调用服务；</li>
<li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li>
<li>client stub找到服务地址，并将消息发送到服务端；</li>
<li>server stub收到消息后进行解码；</li>
<li>server stub根据解码结果调用本地的服务；</li>
<li>本地服务执行并将结果返回给server stub；</li>
<li>server stub将返回结果打包成消息并发送至消费方；</li>
<li>client stub接收到消息，并进行解码；</li>
<li>服务消费方得到最终结果。</li>
</ol>
<h2 id="为什么要用dubbo"><a href="#为什么要用dubbo" class="headerlink" title="为什么要用dubbo"></a>为什么要用dubbo</h2><ol>
<li><strong>负载均衡</strong>——同一个服务部署在不同的机器时该调用哪一台机器上的服务。</li>
<li><strong>服务调用链路生成</strong>——随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。</li>
<li><strong>服务访问压力以及时长统计、资源调度和治理</strong>——基于访问压力实时管理集群容量，提高集群利用率。</li>
<li><strong>服务降级</strong>——某个服务挂掉之后调用备用服务。</li>
</ol>
<p>另外，Dubbo 除了能够应用在分布式系统中，也可以应用在现在比较火的微服务系统中。不过，由于 Spring Cloud 在微服务中应用更加广泛，所以，我觉得一般我们提 Dubbo 的话，大部分是分布式系统的情况。</p>
<h2 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h2><p>分布式重要的就是面向服务，说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上。</p>
<h2 id="为什么要分布式"><a href="#为什么要分布式" class="headerlink" title="为什么要分布式"></a>为什么要分布式</h2><p>每个团队可以负责一个服务的开发，这样提升了开发效率。另外，代码根据业务拆分之后更加便于维护和扩展。</p>
<p>另外，我觉得将系统拆分成分布式之后不光便于系统扩展和维护，更能提高整个系统的性能。</p>
<h2 id="dubbo架构"><a href="#dubbo架构" class="headerlink" title="dubbo架构"></a>dubbo架构</h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210304142742968.png" alt="image-20210304142742968"></p>
<p><strong>调用关系说明：</strong></p>
<ol>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ol>
<p><strong>重要知识点总结：</strong></p>
<ul>
<li><strong>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小</strong></li>
<li><strong>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示</strong></li>
<li><strong>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外</strong></li>
<li><strong>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</strong></li>
<li><strong>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表</strong></li>
<li><strong>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者</strong></li>
<li><strong>服务提供者无状态，任意一台宕掉后，不影响使用</strong></li>
<li><strong>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</strong></li>
</ul>
<h2 id="dubbo的负载均衡策略"><a href="#dubbo的负载均衡策略" class="headerlink" title="dubbo的负载均衡策略"></a>dubbo的负载均衡策略</h2><p><strong>Random LoadBalance(默认，基于权重的随机负载均衡机制)</strong></p>
<ul>
<li><strong>随机，按权重设置随机概率。</strong></li>
<li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li>
</ul>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-7/77722327.jpg" alt="基于权重的随机负载均衡机制"></p>
<p><strong>RoundRobin LoadBalance(不推荐，基于权重的轮询负载均衡机制)</strong></p>
<ul>
<li>轮循，按公约后的权重设置轮循比率。</li>
<li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>
</ul>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-7/97933247.jpg" alt="基于权重的轮询负载均衡机制"></p>
<p><strong>LeastActive LoadBalance</strong></p>
<ul>
<li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</li>
<li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li>
</ul>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210304143246234.png" alt="image-20210304143246234"></p>
<p><strong>ConsistentHash LoadBalance</strong></p>
<ul>
<li><strong>一致性 Hash，相同参数的请求总是发到同一提供者。(如果你需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性hash策略。)</strong></li>
<li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。<img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210304143304760.png" alt="image-20210304143304760"></li>
</ul>
<p><strong>xml 配置方式</strong></p>
<p>服务端服务级别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:service <span class="class"><span class="keyword">interface</span></span>=<span class="string">&quot;...&quot;</span> loadbalance=<span class="string">&quot;roundrobin&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>客户端服务级别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:reference <span class="class"><span class="keyword">interface</span></span>=<span class="string">&quot;...&quot;</span> loadbalance=<span class="string">&quot;roundrobin&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>服务端方法级别</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:service <span class="class"><span class="keyword">interface</span></span>=<span class="string">&quot;...&quot;</span>&gt;</span><br><span class="line">    &lt;dubbo:method name=<span class="string">&quot;...&quot;</span> loadbalance=<span class="string">&quot;roundrobin&quot;</span>/&gt;</span><br><span class="line">&lt;/dubbo:service&gt;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>客户端方法级别</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:reference <span class="class"><span class="keyword">interface</span></span>=<span class="string">&quot;...&quot;</span>&gt;</span><br><span class="line">    &lt;dubbo:method name=<span class="string">&quot;...&quot;</span> loadbalance=<span class="string">&quot;roundrobin&quot;</span>/&gt;</span><br><span class="line">&lt;/dubbo:reference&gt;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>注解配置方式：</strong></p>
<p>消费方基于基于注解的服务级别配置方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Reference(loadbalance = &quot;roundrobin&quot;)</span></span><br><span class="line">HelloService helloService;</span><br></pre></td></tr></table></figure>

<h2 id="zookeeper宕机与dubbo直连的情况"><a href="#zookeeper宕机与dubbo直连的情况" class="headerlink" title="zookeeper宕机与dubbo直连的情况"></a>zookeeper宕机与dubbo直连的情况</h2><p>在实际生产中，假如zookeeper注册中心宕掉，一段时间内服务消费方还是能够调用提供方的服务的，实际上它使用的本地缓存进行通讯，这只是dubbo健壮性的一种体现。</p>
<p><strong>dubbo的健壮性表现：</strong></p>
<ol>
<li>监控中心宕掉不影响使用，只是丢失部分采样数据</li>
<li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li>
<li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li>
<li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</li>
<li>服务提供者无状态，任意一台宕掉后，不影响使用</li>
<li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li>
</ol>
<p><strong>xml配置方式：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.zang.gmall.service.UserService&quot;</span> <span class="attr">url</span>=<span class="string">&quot;dubbo://localhost:20880&quot;</span> /&gt;</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>注解方式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Reference(url = &quot;127.0.0.1:20880&quot;)</span>   </span><br><span class="line">HelloService helloService;</span><br></pre></td></tr></table></figure>

<h2 id="Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？"><a href="#Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？" class="headerlink" title="Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？"></a>Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？</h2><p><strong>答</strong>：可以通信的，启动dubbo时，消费者会从zk拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用；</p>
<h2 id="Dubbo在安全机制方面是如何解决的"><a href="#Dubbo在安全机制方面是如何解决的" class="headerlink" title="Dubbo在安全机制方面是如何解决的"></a>Dubbo在安全机制方面是如何解决的</h2><p><strong>答：</strong> Dubbo通过Token令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo还提供服务黑白名单，来控制服务所允许的调用方。</p>
<h2 id="dubbo通信协议dubbo协议为什么要消费者比提供者个数多"><a href="#dubbo通信协议dubbo协议为什么要消费者比提供者个数多" class="headerlink" title="dubbo通信协议dubbo协议为什么要消费者比提供者个数多"></a>dubbo通信协议dubbo协议为什么要消费者比提供者个数多</h2><p>答： 因dubbo协议采用单一长连接，假设网络为千兆网卡(1024Mbit=128MByte)，<br>根据测试经验数据每条连接最多只能压满7MByte(不同的环境可能不一样，供参考)，理论上1个服务提供者需要20个服务消费者才能压满网卡。</p>
<h2 id="dubbo通信协议dubbo协议为什么采用异步单一长连接"><a href="#dubbo通信协议dubbo协议为什么采用异步单一长连接" class="headerlink" title="dubbo通信协议dubbo协议为什么采用异步单一长连接"></a>dubbo通信协议dubbo协议为什么采用异步单一长连接</h2><p>答： 因为服务的现状大都是服务提供者少，通常只有几台机器，而服务的消费者多，可能整个网站都在访问该服务，如果采用常规的hessian服务，服务提供者很容易就被压跨，通过单一连接，保证单一消费者不会压死提供者，长连接，减少连接握手验证等，并使用异步IO，复用线程池，防止C10K问题。</p>
<h1 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h1><h2 id="ZooKeeper-是什么？"><a href="#ZooKeeper-是什么？" class="headerlink" title="ZooKeeper 是什么？"></a>ZooKeeper 是什么？</h2><p>ZooKeeper 是一个开源的分布式协调服务。它是一个为分布式应用提供一致性服务的软件，分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。</p>
<p>Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据</p>
<h2 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h2><p>client端会对某个znode建立一个watcher事件，当该znode发生变化时，这些client会收到zk的通知，然后client可以根据znode变化来做出业务上的改变等。</p>
<h2 id="Zookeeper-怎么保证主从节点的状态同步？"><a href="#Zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="Zookeeper 怎么保证主从节点的状态同步？"></a>Zookeeper 怎么保证主从节点的状态同步？</h2><p>Zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。</p>
<p>恢复模式<br>当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p>
<p>广播模式<br>一旦 leader 已经和多数的 follower 进行了状态同步后，它就可以开始广播消息了，即进入广播状态。这时候当一个 server 加入 ZooKeeper 服务中，它会在恢复模式下启动，发现 leader，并和 leader 进行状态同步。待到同步结束，它也参与消息广播。ZooKeeper 服务一直维持在 Broadcast 状态，直到 leader 崩溃了或者 leader 失去了大部分的 followers 支持。</p>
<h2 id="四种类型的数据节点-Znode"><a href="#四种类型的数据节点-Znode" class="headerlink" title="四种类型的数据节点 Znode"></a>四种类型的数据节点 Znode</h2><p>（1）PERSISTENT-持久节点</p>
<p>（2）EPHEMERAL-临时节点</p>
<p>（3）PERSISTENT_SEQUENTIAL-持久顺序节点</p>
<p>（4）EPHEMERAL_SEQUENTIAL-临时顺序节点</p>
<h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><table>
<thead>
<tr>
<th>注册方式</th>
<th>Created</th>
<th>ChildChanged</th>
<th>Changed</th>
<th>Deleted</th>
</tr>
</thead>
<tbody><tr>
<td>zk.exists(“/nodex”,watcher)</td>
<td>可监控</td>
<td></td>
<td>可监控</td>
<td>可监控</td>
</tr>
<tr>
<td>zk.getData(“/nodex”,watcher)</td>
<td></td>
<td></td>
<td>可监控</td>
<td>可监控</td>
</tr>
<tr>
<td>zk.getChildren(“/nodex”,watcher)</td>
<td></td>
<td>可监控</td>
<td></td>
<td>可监控</td>
</tr>
</tbody></table>
<h2 id="Watcher-机制-–-数据变更通知"><a href="#Watcher-机制-–-数据变更通知" class="headerlink" title="Watcher 机制 – 数据变更通知"></a>Watcher 机制 – 数据变更通知</h2><p>Zookeeper 允许客户端向服务端的某个 Znode 注册一个 Watcher 监听，当服务端的一些指定事件触发了这个 Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据 Watcher 通知状态和事件类型做出业务上的改变。</p>
<p>工作机制：</p>
<p>（1）客户端注册 watcher</p>
<p>（2）服务端处理 watcher</p>
<p>（3）客户端回调 watcher</p>
<h2 id="服务器角色"><a href="#服务器角色" class="headerlink" title="服务器角色"></a>服务器角色</h2><p>Leader</p>
<p>（1）事务请求的唯一调度和处理者，保证集群事务处理的顺序性</p>
<p>（2）集群内部各服务的调度者</p>
<p>Follower</p>
<p>（1）处理客户端的非事务请求，转发事务请求给 Leader 服务器</p>
<p>（2）参与事务请求 Proposal 的投票</p>
<p>（3）参与 Leader 选举投票</p>
<p>Observer</p>
<p>（1）3.0 版本以后引入的一个服务器角色，在不影响集群事务处理能力的基础上提升集群的非事务处理能力</p>
<p>（2）处理客户端的非事务请求，转发事务请求给 Leader 服务器</p>
<p>（3）不参与任何形式的投票</p>
<h2 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h2><p>（1）LOOKING：寻 找 Leader 状态。当服务器处于该状态时，它会认为当前集群中没有 Leader，因此需要进入 Leader 选举状态。</p>
<p>（2）FOLLOWING：跟随者状态。表明当前服务器角色是 Follower。</p>
<p>（3）LEADING：领导者状态。表明当前服务器角色是 Leader。</p>
<p>（4）OBSERVING：观察者状态。表明当前服务器角色是 Observer。</p>
<h2 id="zookeeper-是如何保证事务的顺序一致性的？"><a href="#zookeeper-是如何保证事务的顺序一致性的？" class="headerlink" title="zookeeper 是如何保证事务的顺序一致性的？"></a>zookeeper 是如何保证事务的顺序一致性的？</h2><p>zookeeper 采用了全局递增的事务id来标识，所有的 proposal（提议）都在被提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（ 时期; 纪元; 世; 新时代）用来标识 leader 周期，如果有新的 leader 产生出来，epoch会自增，低 32 位用来递增计数。当新产生 proposal 的时候，会依据数据库的两阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。</p>
<h2 id="分布式集群中为什么会有-Master主节点？"><a href="#分布式集群中为什么会有-Master主节点？" class="headerlink" title="分布式集群中为什么会有 Master主节点？"></a>分布式集群中为什么会有 Master主节点？</h2><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行 leader 选举。</p>
<h2 id="zk节点宕机如何处理？"><a href="#zk节点宕机如何处理？" class="headerlink" title="zk节点宕机如何处理？"></a>zk节点宕机如何处理？</h2><p>Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保证当一个节点宕机时，其他节点会继续提供服务。</p>
<p>如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数据是有多个副本的，数据并不会丢失；</p>
<p>如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。</p>
<p>ZK 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZK节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。</p>
<h2 id="集群最少要几台机器，集群规则是怎样的？集群中有-3-台服务器，其中一个节点宕机，这个时候-Zookeeper-还可以使用吗？"><a href="#集群最少要几台机器，集群规则是怎样的？集群中有-3-台服务器，其中一个节点宕机，这个时候-Zookeeper-还可以使用吗？" class="headerlink" title="集群最少要几台机器，集群规则是怎样的？集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗？"></a>集群最少要几台机器，集群规则是怎样的？集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗？</h2><p>集群规则为 2N+1 台，N&gt;0，即 3 台。可以继续使用，单数服务器只要没超过一半的服务器宕机就可以</p>
<h2 id="Zookeeper-对节点的-watch-监听通知是永久的吗？为什么不是永久的"><a href="#Zookeeper-对节点的-watch-监听通知是永久的吗？为什么不是永久的" class="headerlink" title="Zookeeper 对节点的 watch 监听通知是永久的吗？为什么不是永久的?"></a>Zookeeper 对节点的 watch 监听通知是永久的吗？为什么不是永久的?</h2><p>不是。官方声明：一个 Watch 事件是一个一次性的触发器，当被设置了 Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端，以便通知它们。</p>
<p>为什么不是永久的，举个例子，如果服务端变动频繁，而监听的客户端很多情况下，每次变动都要通知到所有的客户端，给网络和服务器造成很大压力。</p>
<h2 id="获取分布式锁"><a href="#获取分布式锁" class="headerlink" title="获取分布式锁"></a>获取分布式锁</h2><p>在获取分布式锁的时候在locker节点下创建临时顺序节点，释放锁的时候删除该临时节点。客户端调用createNode方法在locker下创建临时顺序节点，然后调用getChildren(“locker”)来获取locker下面的所有子节点，注意此时不用设置任何Watcher。客户端获取到所有的子节点path之后，如果发现自己创建的节点在所有创建的子节点序号最小，那么就认为该客户端获取到了锁。如果发现自己创建的节点并非locker所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到*<strong>比自己小的那个节点*</strong>，然后对其调用*<strong>exist()*</strong>方法，同时对其注册事件监听器。之后，当这个被关注的节点删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是locker子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。当前这个过程中还需要许多的逻辑判断。</p>
<h2 id="队列管理"><a href="#队列管理" class="headerlink" title="队列管理"></a>队列管理</h2><p>两种类型的队列：<br>1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。<br>2、队列按照 FIFO 方式进行入队和出队操作。<br>第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。<br>第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建<strong>PERSISTENT_SEQUENTIAL</strong>节点，创建成功时<strong>Watcher</strong>通知等待的队列，队列删除序列号最小的节点用以消费。此场景下Zookeeper的znode用于消息存储，znode存储的数据就是消息队列中的消息内容，SEQUENTIAL序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以不必担心队列消息的丢失问题</p>
<h2 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h2><p>Zookeeper作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。数据复制的好处： 1、容错：一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作； 2、提高系统的扩展能力 ：把负载分布到多个节点上，或者增加节点来提高系统的负载能力； 3、提高性能：让客户端本地访问就近的节点，提高用户访问速度。 </p>
<p>从客户端读写访问的透明度来看，数据复制集群系统分下面两种：</p>
<p> 1、写主(WriteMaster) ：对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离； </p>
<p>2、写任意(Write Any)：对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。</p>
<p> 对zookeeper来说，它采用的方式是写任意。通过增加机器，读的吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立observer的原因），而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。</p>
<h2 id="选举leader"><a href="#选举leader" class="headerlink" title="选举leader"></a>选举leader</h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210307130548201.png" alt="image-20210307130548201"></p>
<h2 id="一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗？"><a href="#一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗？" class="headerlink" title="一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗？"></a>一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗？</h2><p>ZooKeeper不能确保任何客户端能够获取（即Read Request）到一样的数据，除非客户端自己要求，方法是客户端在获取数据之前调用sync方法进行同步。 </p>
<h2 id="能否为临时节点创建子节点？"><a href="#能否为临时节点创建子节点？" class="headerlink" title="能否为临时节点创建子节点？"></a>能否为临时节点创建子节点？</h2><p>ZooKeeper中不能为临时节点创建子节点，如果需要创建子节点，应该将要创建子节点的节点创建为永久性节点。</p>
<h2 id="创建的临时节点什么时候会被删除，是连接一断就删除吗？"><a href="#创建的临时节点什么时候会被删除，是连接一断就删除吗？" class="headerlink" title="创建的临时节点什么时候会被删除，是连接一断就删除吗？"></a>创建的临时节点什么时候会被删除，是连接一断就删除吗？</h2><p>连接断了之后，ZK不会马上移除临时数据，只有当SESSIONEXPIRED之后，才会把这个会话建立的临时数据移除。</p>
<h2 id="ZooKeeper集群中服务器之间是怎样通信的？"><a href="#ZooKeeper集群中服务器之间是怎样通信的？" class="headerlink" title="ZooKeeper集群中服务器之间是怎样通信的？"></a>ZooKeeper集群中服务器之间是怎样通信的？</h2><p>Leader服务器会和每一个Follower/Observer服务器都建立TCP连接，同时为每个F/O都创建一个叫做LearnerHandler的实体。LearnerHandler主要负责Leader和F/O之间的网络通讯，包括数据同步，请求转发和Proposal提议的投票等。Leader服务器保存了所有F/O的LearnerHandler。</p>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h2><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p>
<p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p>
<ul>
<li><code>@Configuration</code>：允许在上下文中注册额外的 bean 或导入其他配置类</li>
</ul>
<p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</p>
<p>@ComponentScan：扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。如下图所示，容器中将排除<code>TypeExcludeFilter</code>和<code>AutoConfigurationExcludeFilter</code>。</p>
<h2 id="Spring-Boot-自动配置原理是什么？"><a href="#Spring-Boot-自动配置原理是什么？" class="headerlink" title="Spring Boot 自动配置原理是什么？"></a>Spring Boot 自动配置原理是什么？</h2><p><strong>@EnableAutoConfiguration:实现自动装配的核心注解</strong></p>
<p><code>EnableAutoConfiguration</code> 只是一个简单地注解，自动装配核心功能的实现实际是通过 <code>AutoConfigurationImportSelector</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span> <span class="comment">//作用：将main包下的所欲组件注册到容器中</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class="comment">//加载自动装配类 xxxAutoconfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AutoConfigurationImportSelector</code>类的继承体系如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeferredImportSelector</span> <span class="keyword">extends</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    String[] selectImports(AnnotationMetadata var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AutoConfigurationImportSelector</code> 类实现了 <code>ImportSelector</code>接口，也就实现了这个接口中的 <code>selectImports</code>方法，该方法主要用于<strong>获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</strong>。</p>
<p>这里我们需要重点关注一下<code>getAutoConfigurationEntry()</code>方法，这个方法主要负责加载自动配置类的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AutoConfigurationEntry EMPTY_ENTRY = <span class="keyword">new</span> AutoConfigurationEntry();</span><br><span class="line"></span><br><span class="line"><span class="function">AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//&lt;1&gt;.判断自动装配开关是否打开。默认spring.boot.enableautoconfiguration=true，可在 application.properties 或 application.yml 中设置</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//&lt;2&gt;.</span></span><br><span class="line">        AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">        <span class="comment">//&lt;3&gt;.拿到配置 这个方法调用loadFactoryNames()方法，获取资源，并且完成资源文件spring-factories的读取，也就是说通过类加载器classLoader，去加载META-INF下的spring-factories文件</span></span><br><span class="line">        List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">        <span class="comment">//&lt;4&gt;.</span></span><br><span class="line">        configurations = <span class="keyword">this</span>.removeDuplicates(configurations);</span><br><span class="line">        Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">        <span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations = <span class="keyword">this</span>.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">        <span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">                                                                         getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class="line">                    + <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在spring-factories中配置了自动装配类，所有 Spring Boot Starter 下的<code>META-INF/spring.factories</code>都会被读取到内存中，但是只有<code>@ConditionalOnXXX</code> 中的所有条件都满足，该类才会被加载。</p>
<p>比如</p>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/log\source_posts\面试题总结\image-20210410134448545.png" alt="image-20210410134448545"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;DruidDataSource.class&#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(&#123;DataSourceAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;DruidStatProperties.class, DataSourceProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123;DruidSpringAopConfiguration.class, DruidStatViewServletConfiguration.class, DruidWebStatFilterConfiguration.class, DruidFilterConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidDataSourceAutoConfigure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(DruidDataSourceAutoConfigure.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DruidDataSourceAutoConfigure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(</span></span><br><span class="line"><span class="meta">        initMethod = &quot;init&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;Init DruidDataSource&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSourceWrapper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@EnableConfigurationProperties，作用是把配置文件中，前缀是Spring.datasource.druid的，注入到该对象。最后，框架拿到数据库的连接信息（账号密码等四要素），才能帮我们创建出Datasource。</p>
<p>推荐阅读：<a href="https://www.cnblogs.com/javaguide/p/springboot-auto-config.html">https://www.cnblogs.com/javaguide/p/springboot-auto-config.html</a>    </p>
<p>​                   <a href="https://blog.csdn.net/weixin_45764765/article/details/110250531">https://blog.csdn.net/weixin_45764765/article/details/110250531</a></p>
<h2 id="你如何理解-Spring-Boot-配置加载顺序？"><a href="#你如何理解-Spring-Boot-配置加载顺序？" class="headerlink" title="你如何理解 Spring Boot 配置加载顺序？"></a>你如何理解 Spring Boot 配置加载顺序？</h2><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p>
<p>1）properties文件；</p>
<p>2）YAML文件；</p>
<p>3）系统环境变量；</p>
<p>4）命令行参数；</p>
<h2 id="spring-boot-核心配置文件bootstrap-properties-和-application-properties-有何区别"><a href="#spring-boot-核心配置文件bootstrap-properties-和-application-properties-有何区别" class="headerlink" title="spring boot 核心配置文件bootstrap.properties 和 application.properties 有何区别 ?"></a>spring boot 核心配置文件bootstrap.properties 和 application.properties 有何区别 ?</h2><p>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；<br>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</p>
<h2 id="比较一下-Spring-Security-和-Shiro-各自的优缺点"><a href="#比较一下-Spring-Security-和-Shiro-各自的优缺点" class="headerlink" title="比较一下 Spring Security 和 Shiro 各自的优缺点 ?"></a>比较一下 Spring Security 和 Shiro 各自的优缺点 ?</h2><p>Shiro 和 Spring Security 相比，主要有如下一些特点：</p>
<p>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架<br>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单<br>Spring Security 功能强大；Shiro 功能简单</p>
<h2 id="Spring-Boot-中如何解决跨域问题"><a href="#Spring-Boot-中如何解决跨域问题" class="headerlink" title="Spring Boot 中如何解决跨域问题 ?"></a>Spring Boot 中如何解决跨域问题 ?</h2><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>项目中前后端分离部署，所以需要解决跨域的问题。<br>我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。<br>当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。<br>我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(urlBasedCorsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是csrf攻击"><a href="#什么是csrf攻击" class="headerlink" title="什么是csrf攻击"></a>什么是csrf攻击</h2><p>CSRF 攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。</p>
<h2 id="Spring-Boot-中的-starter-到底是什么"><a href="#Spring-Boot-中的-starter-到底是什么" class="headerlink" title="Spring Boot 中的 starter 到底是什么 ?"></a>Spring Boot 中的 starter 到底是什么 ?</h2><p>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter</p>
<h2 id="spring-boot-starter-parent-有什么用"><a href="#spring-boot-starter-parent-有什么用" class="headerlink" title="spring-boot-starter-parent 有什么用 ?"></a>spring-boot-starter-parent 有什么用 ?</h2><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p>
<p>定义了 Java 编译版本为 1.8 。<br>使用 UTF-8 格式编码。<br>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。<br>执行打包操作的配置。<br>自动化的资源过滤。<br>自动化的插件配置。<br>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</p>
<h2 id="Spring-Boot工厂模式的加载"><a href="#Spring-Boot工厂模式的加载" class="headerlink" title="Spring Boot工厂模式的加载"></a>Spring Boot工厂模式的加载</h2><p>Spring Framework内部使用一种工厂加载机制(Factory Loading Mechanism)。这种机制使用SpringFactoriesLoader完成，SpringFactoriesLoader使用loadFactories方法加载并实例化从META-INF目录里的spring.factories文件出来的工厂，这些spring.factories文件都是从classpath里的jar包里找出来的。</p>
<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h2><ul>
<li><code>$&#123;&#125;</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为<code>com.mysql.jdbc.Driver</code>。</li>
<li><code>#&#123;&#125;</code>是 sql 的参数占位符，MyBatis 会将 sql 中的<code>#&#123;&#125;</code>替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue)，<code>#&#123;item.name&#125;</code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 <code>param.getItem().getName()</code>。</li>
</ul>
<h2 id="最佳实践中，通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#最佳实践中，通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"></a>最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h2><p>答：Dao 接口，就是人们常说的 <code>Mapper</code>接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中<code>MappedStatement</code>的 id 值，接口方法内的参数，就是传递给 sql 的参数。<code>Mapper</code>接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个<code>MappedStatement</code>，在 MyBatis 中，每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，都会被解析为一个<code>MappedStatement</code>对象。</p>
<p>Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p>
<p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行<code>MappedStatement</code>所代表的 sql，然后将 sql 执行结果返回。</p>
<h2 id="Mybatis是如何进行分页的，分页插件的原理是什么"><a href="#Mybatis是如何进行分页的，分页插件的原理是什么" class="headerlink" title="Mybatis是如何进行分页的，分页插件的原理是什么"></a>Mybatis是如何进行分页的，分页插件的原理是什么</h2><p>答：MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页，可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
<p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<p>举例：<code>select _ from student</code>，拦截 sql 后重写为：<code>select t._ from （select \* from student）t limit 0，10</code></p>
<p>关于RowBounds：<a href="https://blog.csdn.net/qq924862077/article/details/52611848">https://blog.csdn.net/qq924862077/article/details/52611848</a>    </p>
<h2 id="MyBatis-的插件运行原理，以及如何编写一个插件"><a href="#MyBatis-的插件运行原理，以及如何编写一个插件" class="headerlink" title="MyBatis 的插件运行原理，以及如何编写一个插件"></a>MyBatis 的插件运行原理，以及如何编写一个插件</h2><p>答：MyBatis 仅可以编写针对 <code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>StatementHandler</code>、<code>Executor</code> 这 4 种接口的插件，MyBatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 <code>InvocationHandler</code> 的 <code>invoke()</code>方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<p>实现 MyBatis 的 Interceptor 接口并复写<code> intercept()</code>方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>
<p>推荐阅读：<a href="https://www.cnblogs.com/felordcn/p/13473844.html">https://www.cnblogs.com/felordcn/p/13473844.html</a></p>
<h2 id="MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？"><a href="#MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？" class="headerlink" title="MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？"></a>MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</h2><p>MyBatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，MyBatis 提供了 9 种动态 sql 标签 <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>。</p>
<p>其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p>
<h2 id="MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h2><p>第一种是使用<code>&lt;resultMap&gt;</code>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，MyBatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，MyBatis 一样可以正常工作。</p>
<p>有了列名与属性名的映射关系后，MyBatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h2 id="MyBatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别"><a href="#MyBatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别" class="headerlink" title="MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别"></a>MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别</h2><p>能，MyBatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 <code>selectOne()</code>修改为 <code>selectList()</code>即可；多对多查询，其实就是一对多查询，只需要把 <code>selectOne()</code>修改为 <code>selectList()</code>即可。</p>
<p>关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。</p>
<ul>
<li>关联查询<ul>
<li><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/log\source_posts\面试题总结\image-20210412135736398.png" alt="image-20210412135736398"></li>
</ul>
</li>
<li>嵌套查询<ul>
<li><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/log\source_posts\面试题总结\image-20210412135812558.png" alt="image-20210412135812558"></li>
</ul>
</li>
</ul>
<p>那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是<code>&lt;resultMap&gt;</code>标签内的<code>&lt;id&gt;</code>子标签，指定了唯一确定一条记录的 id 列，MyBatis 根据列值来完成 100 条记录的去重复功能，<code>&lt;id&gt;</code>可以有多个，代表了联合主键的语意。</p>
<p>同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。</p>
<p>举例：下面 join 查询出来 6 条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列，MyBatis 去重复处理后，结果为 1 个老师 6 个学生，而不是 6 个老师 6 个学生。</p>
<p>t_id t_name s_id</p>
<p>| 1 | teacher | 38 | | 1 | teacher | 39 | | 1 | teacher | 40 | | 1 | teacher | 41 | | 1 | teacher | 42 | | 1 | teacher | 43 |</p>
<h2 id="mybatis支持延迟加载吗？原理是什么"><a href="#mybatis支持延迟加载吗？原理是什么" class="headerlink" title="mybatis支持延迟加载吗？原理是什么"></a>mybatis支持延迟加载吗？原理是什么</h2><p>MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false。</code></p>
<p>它的原理是，使用<code> CGLIB</code> 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 <code>a.getB().getName()</code>，拦截器 <code>invoke()</code>方法发现 <code>a.getB()</code>是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 <code>a.getB().getName()</code>方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是 MyBatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的</p>
<h2 id="MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h2><p>MyBatis 有三种基本的 Executor 执行器，**<code>SimpleExecutor</code>、<code>ReuseExecutor</code>、<code>BatchExecutor</code>。**</p>
<p><strong><code>SimpleExecutor</code>：</strong>每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。</p>
<p><strong>ReuseExecutor：</strong>执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</p>
<p><strong><code>BatchExecutor</code>：</strong>执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</p>
<p>作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。</p>
<p>推荐阅读：<a href="https://blog.csdn.net/HUDCHSDI/article/details/108071789?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/HUDCHSDI/article/details/108071789?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242</a></p>
<h2 id="模糊查询like语句"><a href="#模糊查询like语句" class="headerlink" title="模糊查询like语句"></a>模糊查询like语句</h2><p>在Java代码中添加sql通配符</p>
<pre><code>string wildcardname = “%smi%”; 
list&lt;name&gt; names = mapper.selectlike(wildcardname);

&lt;select id=”selectlike”&gt; 
 select * from foo where bar like #&#123;value&#125; 
&lt;/select&gt;</code></pre>
<p>在sql语句中拼接通配符，会引起sql注入</p>
<pre><code>string wildcardname = “smi”; 
list&lt;name&gt; names = mapper.selectlike(wildcardname);

&lt;select id=”selectlike”&gt; 
 select * from foo where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;
&lt;/select&gt;</code></pre>
<h2 id="如何批量插入"><a href="#如何批量插入" class="headerlink" title="如何批量插入"></a>如何批量插入</h2><p>首先创建一个简单的insert语句: </p>
<pre><code>&lt;insert id=”insertname”&gt; 
 insert into names (name) values (#&#123;value&#125;) 
&lt;/insert&gt;</code></pre>
<p>然后在java代码中像下面这样执行批处理插入: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list&lt;string&gt; names = <span class="keyword">new</span> arraylist(); </span><br><span class="line">names.add(“fred”); </span><br><span class="line">names.add(“barney”); </span><br><span class="line">names.add(“betty”); </span><br><span class="line">names.add(“wilma”); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里 executortype.batch </span></span><br><span class="line">sqlsession sqlsession = sqlsessionfactory.opensession(executortype.batch); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> namemapper mapper = sqlsession.getmapper(namemapper.class); </span><br><span class="line"> <span class="keyword">for</span> (string name : names) &#123; </span><br><span class="line"> mapper.insertname(name); </span><br><span class="line"> &#125; </span><br><span class="line"> sqlsession.commit(); </span><br><span class="line"> &#125;<span class="keyword">finally</span> &#123; </span><br><span class="line"> sqlsession.close(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h2><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。 </p>
<h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><p>一级缓存：一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p>
<p>二级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它指的是Mybatis中sqlSessionFactory对象的缓存。由同一SqlSessionFactory对象创建的SqlSession共享其缓存。存放的是数据不是对象</p>
<p>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
<h2 id="传递多个参数"><a href="#传递多个参数" class="headerlink" title="传递多个参数"></a>传递多个参数</h2><p><strong>顺序传参法</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">User</span> selectUser(String <span class="type">name</span>, <span class="type">int</span> deptId);</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">select</span> id=&quot;selectUser&quot; resultMap=&quot;UserResultMap&quot;&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">    <span class="keyword">where</span> user_name = #&#123;<span class="number">0</span>&#125; <span class="keyword">and</span> dept_id = #&#123;<span class="number">1</span>&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>

<p><strong>@Param注解传参法</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">User</span> selectUser(@Param(&quot;userName&quot;) String <span class="type">name</span>, <span class="type">int</span> @Param(&quot;deptId&quot;) deptId);</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">select</span> id=&quot;selectUser&quot; resultMap=&quot;UserResultMap&quot;&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">    <span class="keyword">where</span> user_name = #&#123;userName&#125; <span class="keyword">and</span> dept_id = #&#123;deptId&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Map传参法</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectUser</span>(<span class="params">Map&lt;String, Object&gt; <span class="keyword">params</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">select</span> id=<span class="string">&quot;selectUser&quot;</span> parameterType=<span class="string">&quot;java.util.Map&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> user</span><br><span class="line">    <span class="keyword">where</span> user_name = <span class="meta">#&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Java Bean传参法</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">User</span> selectUser(<span class="keyword">User</span> <span class="keyword">user</span>);</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">select</span> id=&quot;selectUser&quot; parameterType=&quot;com.jourwon.pojo.User&quot; resultMap=&quot;UserResultMap&quot;&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">    <span class="keyword">where</span> user_name = #&#123;userName&#125; <span class="keyword">and</span> dept_id = #&#123;deptId&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>

<p>#{}里面的名称对应的是User类里面的成员属性。 </p>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="多个mq如何选型？"><a href="#多个mq如何选型？" class="headerlink" title="多个mq如何选型？"></a>多个mq如何选型？</h2><table>
<thead>
<tr>
<th>MQ</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RabbitMQ</td>
<td>erlang开发，对消息堆积的支持并不好，当大量消息积压的时候，会导致 RabbitMQ 的性能急剧下降。每秒钟可以处理几万到十几万条消息。</td>
</tr>
<tr>
<td>RocketMQ</td>
<td>java开发，面向互联网集群化功能丰富，对在线业务的响应时延做了很多的优化，大多数情况下可以做到毫秒级的响应，每秒钟大概能处理几十万条消息。</td>
</tr>
<tr>
<td>Kafka</td>
<td>Scala开发，面向日志功能丰富，性能最高。当你的业务场景中，每秒钟消息数量没有那么多的时候，Kafka 的时延反而会比较高。所以，Kafka 不太适合在线业务场景。</td>
</tr>
<tr>
<td>ActiveMQ</td>
<td>java开发，简单，稳定，性能不如前面三个。小型系统用也ok，但是不推荐。推荐用互联网主流的。</td>
</tr>
</tbody></table>
<h2 id="为什么使用MQ？MQ的优缺点"><a href="#为什么使用MQ？MQ的优缺点" class="headerlink" title="为什么使用MQ？MQ的优缺点"></a>为什么使用MQ？MQ的优缺点</h2><p>异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。<br>应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。<br>流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。<br>日志处理 - 解决大量日志传输。<br>消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</p>
<p>优点：解耦、异步、削峰。</p>
<p>缺点：提高系统复杂度，降低系统可用性(消息系统挂掉 整个系统就挂了)，一致性问题(AB写库成功，C失败)</p>
<h2 id="MQ-有哪些常见问题？如何解决这些问题？"><a href="#MQ-有哪些常见问题？如何解决这些问题？" class="headerlink" title="MQ 有哪些常见问题？如何解决这些问题？"></a>MQ 有哪些常见问题？如何解决这些问题？</h2><p>MQ 的常见问题有：消息的顺序问题，消息的重复问题</p>
<p><strong>消息的顺序问题</strong></p>
<p>消息有序指的是可以按照消息的发送顺序来消费。</p>
<p>假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？</p>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210313112715648.png" alt="image-20210313112715648"></p>
<p>解决方案：<strong>保证生产者 - MQServer - 消费者是一对一对一的关系</strong></p>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210313112807676.png" alt="image-20210313112807676"></p>
<p>缺陷：</p>
<ul>
<li>并行度就会成为消息系统的瓶颈（吞吐量不够）</li>
<li>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。通过合理的设计或者将问题分解来规避。</li>
<li>不关注乱序的应用实际大量存在</li>
<li>队列无序并不意味着消息无序 所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。</li>
</ul>
<p><strong>消息的重复问题</strong></p>
<p>造成消息重复的根本原因是：网络不可达。</p>
<p>所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p>
<p>消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。保证每条消息都有唯一编号利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。</p>
<h2 id="rabbitmq-的使用场景"><a href="#rabbitmq-的使用场景" class="headerlink" title="rabbitmq 的使用场景"></a>rabbitmq 的使用场景</h2><p>（1）服务间异步通信</p>
<p>（2）顺序消费</p>
<p>（3）定时任务</p>
<p>（4）请求削峰</p>
<h2 id="消息怎么路由？"><a href="#消息怎么路由？" class="headerlink" title="消息怎么路由？"></a>消息怎么路由？</h2><p>常用的交换器主要分为一下三种：</p>
<p>fanout：如果交换器收到消息，将会广播到所有绑定的队列上</p>
<p>direct：如果路由键完全匹配，消息就被投递到相应的队列</p>
<p>topic：可以使来自不同源头的消息能够到达同一个队列。 使用 topic 交换器时，可以使用通配符</p>
<h2 id="如何保证RabbitMQ消息的可靠传输？"><a href="#如何保证RabbitMQ消息的可靠传输？" class="headerlink" title="如何保证RabbitMQ消息的可靠传输？"></a>如何保证RabbitMQ消息的可靠传输？</h2><p>答：消息不可靠的情况可能是消息丢失，劫持等原因；丢失又分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息；</p>
<p><strong>生产者丢失消息</strong>：从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息；</p>
<p>transaction：发送消息前，开启事务（channel.txSelect()）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()）。然而，这种方式有个缺点：吞吐量下降；</p>
<p>confirm模式用的居多：一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后；rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了；如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。</p>
<p><strong>消息队列丢数据</strong>：消息持久化。</p>
<p>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。</p>
<p>这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。</p>
<p>这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。</p>
<p>如何持久化</p>
<ol>
<li>将queue的持久化标识durable设置为true,则代表是一个持久的队列</li>
<li>发送消息的时候将deliveryMode=2</li>
</ol>
<p><strong>消费者丢失消息</strong>：消费者丢数据一般是因为采用了自动确认消息模式，改为手动确认消息即可！</p>
<h2 id="如何确保消息正确地发送至-RabbitMQ？-如何确保消息接收方消费了消息？"><a href="#如何确保消息正确地发送至-RabbitMQ？-如何确保消息接收方消费了消息？" class="headerlink" title="如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接收方消费了消息？"></a>如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接收方消费了消息？</h2><p><strong>发送方确认模式</strong></p>
<p>将信道设置成 confirm 模式（发送方确认模式）</p>
<p>发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</p>
<p><strong>接收方确认机制</strong></p>
<p>消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。</p>
<p>这里并没有用到超时机制，RabbitMQ 仅通过 Consumer 的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ 给了 Consumer 足够长的时间来处理消息。保证数据的最终一致性；</p>
<p>下面罗列几种特殊情况</p>
<ul>
<li>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重）</li>
<li>如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消费者繁忙，将不会给该消费者分发更多的消息。</li>
</ul>
<h2 id="为什么不应该对所有的-message-都使用持久化机制？"><a href="#为什么不应该对所有的-message-都使用持久化机制？" class="headerlink" title="为什么不应该对所有的 message 都使用持久化机制？"></a>为什么不应该对所有的 message 都使用持久化机制？</h2><p>首先，必然导致性能的下降，因为写磁盘比写 RAM 慢的多</p>
<p>其次，message 的持久化机制用在 RabbitMQ 的内置 cluster 方案时会出现“坑爹”问题。矛盾点在于，若 message 设置了 persistent 属性，但 queue 未设置 durable 属性，那么当该 queue 的 owner node 出现异常后，在未重建该 queue 前，发往该 queue 的 message 将被 blackholed ；若 message 设置了 persistent 属性，同时 queue 也设置了 durable 属性，那么当 queue 的 owner node 异常且无法重启的情况下，则该 queue 无法在其他 node 上重建，只能等待其 owner node 重启后，才能恢复该 queue 的使用，而在这段时间内发送给该 queue 的 message 将被 blackholed 。</p>
<p>所以，是否要对 message 进行持久化，需要综合考虑性能需要，以及可能遇到的问题。若想达到 100,000 条/秒以上的消息吞吐量（单 RabbitMQ 服务器），则要么使用其他的方式来确保 message 的可靠 delivery ，要么使用非常快速的存储系统以支持全持久化（例如使用 SSD）。</p>
<p>另外一种处理原则是：仅对关键消息作持久化处理（根据业务重要程度），且应该保证关键消息的量不会导致性能瓶颈。</p>
<h2 id="消息基于什么传输？"><a href="#消息基于什么传输？" class="headerlink" title="消息基于什么传输？"></a>消息基于什么传输？</h2><p>由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制</p>
<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="每个消费组在每个队列上维护一个消费位置-，为什么呢？"><a href="#每个消费组在每个队列上维护一个消费位置-，为什么呢？" class="headerlink" title="每个消费组在每个队列上维护一个消费位置 ，为什么呢？"></a><strong>每个消费组在每个队列上维护一个消费位置</strong> ，为什么呢？</h2><p>发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要呀)，它仅仅是为每个消费者组维护一个 <strong>消费位移(offset)</strong> ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。</p>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210315102718156.png" alt="image-20210315102718156"></p>
<h2 id="为什么一个topic中需要维护多个queue"><a href="#为什么一个topic中需要维护多个queue" class="headerlink" title="为什么一个topic中需要维护多个queue"></a><strong>为什么一个topic中需要维护多个queue</strong></h2><p><strong>提高并发能力</strong> </p>
<h2 id="解决顺序消费和重复消费问题"><a href="#解决顺序消费和重复消费问题" class="headerlink" title="解决顺序消费和重复消费问题"></a>解决顺序消费和重复消费问题</h2><h3 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h3><p>所谓普通顺序是指 消费者通过 <strong>同一个消费队列收到的消息是有顺序的</strong> ，不同消息队列收到的消息则可能是无顺序的。普通顺序消息在 <code>Broker</code> <strong>重启情况下不会保证消息顺序性</strong> (短暂时间) 。</p>
<p>所谓严格顺序是指 消费者收到的 <strong>所有消息</strong> 均是有顺序的。严格顺序消息 <strong>即使在异常情况下也会保证消息的顺序性</strong> 。</p>
<p>但是，严格顺序看起来虽好，实现它可会付出巨大的代价。如果你使用严格顺序模式，<code>Broker</code> 集群中只要有一台机器不可用，则整个集群都不可用。现在主要场景也就在 <code>binlog</code> 同步。</p>
<p>一般而言，我们的 <code>MQ</code> 都是能容忍短暂的乱序，所以推荐使用普通顺序模式。</p>
<p>解决方法：我们需要处理的仅仅是将同一语义下的消息放入同一个队列(比如这里是同一个订单)，那我们就可以使用 <strong>Hash取模法</strong> 来保证同一个订单在同一个队列中就行了。</p>
<h3 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h3><p>所以我们需要给我们的消费者实现 <strong>幂等</strong> ，也就是对同一个消息的处理结果，执行多少次都不变。</p>
<p>那么如何给业务实现幂等呢？这个还是需要结合具体的业务的。你可以使用 <strong>写入 <code>Redis</code></strong> 来保证，因为 <code>Redis</code> 的 <code>key</code> 和 <code>value</code> 就是天然支持幂等的。当然还有使用 <strong>数据库插入法</strong> ，基于数据库的唯一键来保证重复数据不会被插入多条。</p>
<p>不过最主要的还是需要 <strong>根据特定场景使用特定的解决方案</strong> ，你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的，然后再选择强校验和弱校验的方式。毕竟在 CS 领域还是很少有技术银弹的说法。</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>在 <code>RocketMQ</code> 中使用的是 <strong>事务消息加上事务反查机制</strong> 来解决分布式事务问题的</p>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210315103742139.png" alt="image-20210315103742139"></p>
<p>在第一步发送的 half 消息 ，它的意思是 <strong>在事务提交之前，对于消费者来说，这个消息是不可见的</strong> 。</p>
<p> 1、生产者向MQ服务器发送half消息。<br> 2、half消息发送成功后，MQ服务器返回确认消息给生产者。<br> 3、生产者开始执行本地事务。<br> 4、根据本地事务执行的结果（<code>UNKNOW</code>、<code>commit</code>、<code>rollback</code>）向MQ Server发送提交或回滚消息。<br> 5、如果错过了（可能因为网络异常、生产者突然宕机等导致的异常情况）提交/回滚消息，则MQ服务器将向同一组中的每个生产者发送回查消息以获取事务状态。<br> 6、回查生产者本地事物状态。<br> 7、生产者根据本地事务状态发送提交/回滚消息。<br> 8、MQ服务器将丢弃回滚的消息，但已提交（进行过二次确认的half消息）的消息将投递给消费者进行消费。</p>
<h2 id="你对-Namesrv-的了解？"><a href="#你对-Namesrv-的了解？" class="headerlink" title="你对 Namesrv 的了解？"></a><strong>你对 Namesrv 的了解？</strong></h2><p>Name Server 为 producer 和 consumer 提供路由信息</p>
<h2 id="请说说你对-Broker-的了解？"><a href="#请说说你对-Broker-的了解？" class="headerlink" title="请说说你对 Broker 的了解？"></a><strong>请说说你对 Broker 的了解？</strong></h2><p>Broker 接收来自生产者的消息，储存以及为消费者拉取消息的请求做好准备。</p>
<h2 id="RocketMQ-由哪些角色组成？"><a href="#RocketMQ-由哪些角色组成？" class="headerlink" title="RocketMQ 由哪些角色组成？"></a>RocketMQ 由哪些角色组成？</h2><p>生产者（Producer）：负责产生消息，生产者向消息服务器发送由业务应用程序系统生成的消息。</p>
<p>消费者（Consumer）：负责消费消息，消费者从消息服务器拉取信息并将其输入用户应用程序。</p>
<p>消息服务器（Broker）：是消息存储中心，主要作用是接收来自 Producer 的消息并存储， Consumer 从这里取得消息。</p>
<p>名称服务器（NameServer）：用来保存 Broker 相关 Topic 等元信息并给 Producer ，提供 Consumer 查找 Broker 信息。</p>
<h2 id="RocketMQ执行流程"><a href="#RocketMQ执行流程" class="headerlink" title="RocketMQ执行流程"></a>RocketMQ执行流程</h2><p>1、启动 Namesrv，Namesrv起来后监听端口，等待 Broker、Producer、Consumer 连上来，相当于一个路由控制中心。</p>
<p>2、Broker 启动，跟所有的 Namesrv 保持长连接，定时发送心跳包。</p>
<p>3、收发消息前，先创建 Topic 。创建 Topic 时，需要指定该 Topic 要存储在 哪些 Broker上。也可以在发送消息时自动创建Topic。</p>
<p>4、Producer 发送消息。</p>
<p>5、Consumer 消费消息。</p>
<h2 id="请说说你对-Producer-的了解？"><a href="#请说说你对-Producer-的了解？" class="headerlink" title="请说说你对 Producer 的了解？"></a>请说说你对 Producer 的了解？</h2><p>1、获得 Topic-Broker 的映射关系。</p>
<p>Producer 启动时，也需要指定 Namesrv 的地址，从 Namesrv 集群中选一台建立长连接。</p>
<p>生产者每 30 秒从 Namesrv 获取 Topic 跟 Broker 的映射关系，更新到本地内存中。然后再跟 Topic 涉及的所有 Broker 建立长连接，每隔 30 秒发一次心跳。</p>
<p>2、生产者端的负载均衡。</p>
<p>生产者发送时，会自动轮询当前所有可发送的broker，一条消息发送成功，下次换另外一个broker发送，以达到消息平均落到所有的broker上。</p>
<h2 id="说说你对-Consumer-的了解？"><a href="#说说你对-Consumer-的了解？" class="headerlink" title="说说你对 Consumer 的了解？"></a>说说你对 Consumer 的了解？</h2><p>1、获得 Topic-Broker 的映射关系。</p>
<p>Consumer 启动时需要指定 Namesrv 地址，与其中一个 Namesrv 建立长连接。消费者每隔 30 秒从 Namesrv 获取所有Topic 的最新队列情况，</p>
<p>Consumer 跟 Broker 是长连接，会每隔 30 秒发心跳信息到Broker .</p>
<p>2、消费者端的负载均衡。根据消费者的消费模式不同，负载均衡方式也不同。</p>
<h2 id="RocketMQ如何保证消息不丢失？"><a href="#RocketMQ如何保证消息不丢失？" class="headerlink" title="RocketMQ如何保证消息不丢失？"></a>RocketMQ如何保证消息不丢失？</h2><p><strong>Producer端</strong><br> 采取<code>send()</code>同步发送消息，发送结果是同步感知的。<br> 发送失败后可以重试，设置重试次数。默认3次。</p>
<p><strong>Broker端</strong><br> 修改刷盘策略为同步刷盘。默认情况下是异步刷盘的。</p>
<p><strong>Consumer端</strong><br> 完全消费正常后在进行手动ack确认</p>
<h2 id="消息堆积问题"><a href="#消息堆积问题" class="headerlink" title="消息堆积问题"></a>消息堆积问题</h2><p>我们可以从多个角度去思考解决这个问题，当流量到峰值的时候是因为生产者生产太快，我们可以使用一些 <strong>限流降级</strong> 的方法，当然你也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增。如果消费者消费过慢的话，我们可以先检查 <strong>是否是消费者出现了大量的消费错误</strong> ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题。</p>
<blockquote>
<p>当然，最快速解决消息堆积问题的方法还是增加消费者实例，不过 <strong>同时你还需要增加每个主题的队列数量</strong> 。</p>
</blockquote>
<h2 id="如果Broker宕了，NameServer是怎么感知到的？"><a href="#如果Broker宕了，NameServer是怎么感知到的？" class="headerlink" title="如果Broker宕了，NameServer是怎么感知到的？"></a>如果Broker宕了，NameServer是怎么感知到的？</h2><p>Broker会定时（30s）向NameServer发送心跳<br>然后 NameServer会定时（10s）运行一个任务，去检查一下各个Broker的最近一次心跳时间，如果某个Broker超过120s都没发送心跳了，那么就认为这个Broker已经挂掉了。</p>
<h2 id="RocketMQ消费模式有几种？"><a href="#RocketMQ消费模式有几种？" class="headerlink" title="RocketMQ消费模式有几种？"></a>RocketMQ消费模式有几种？</h2><p>消费模型由Consumer决定，消费维度为Topic。</p>
<ul>
<li>集群消费</li>
</ul>
<blockquote>
<p>1.一条消息只会被同Group中的一个Consumer消费</p>
<p>2.多个Group同时消费一个Topic时，每个Group都会有一个Consumer消费到数据</p>
</blockquote>
<ul>
<li>广播消费</li>
</ul>
<blockquote>
<p>消息将对一 个Consumer Group 下的各个 Consumer 实例都消费一遍。即即使这些 Consumer 属于同一个Consumer Group ，消息也会被 Consumer Group 中的每个 Consumer 都消费一次。</p>
</blockquote>
<h2 id="为什么要主动拉取消息而不使用事件监听方式？"><a href="#为什么要主动拉取消息而不使用事件监听方式？" class="headerlink" title="为什么要主动拉取消息而不使用事件监听方式？"></a>为什么要主动拉取消息而不使用事件监听方式？</h2><p>事件驱动方式是建立好长连接，由事件（发送数据）的方式来实时推送。</p>
<p>如果broker主动推送消息的话有可能push速度快，消费速度慢的情况，那么就会造成消息在consumer端堆积过多，同时又不能被其他consumer消费的情况。而pull的方式可以根据当前自身情况来pull，不会造成过多的压力而造成瓶颈。所以采取了pull的方式。</p>
<h2 id="当消费负载均衡consumer和queue不对等的时候会发生什么？"><a href="#当消费负载均衡consumer和queue不对等的时候会发生什么？" class="headerlink" title="当消费负载均衡consumer和queue不对等的时候会发生什么？"></a>当消费负载均衡consumer和queue不对等的时候会发生什么？</h2><p>Consumer和queue会优先平均分配，如果Consumer少于queue的个数，则会存在部分Consumer消费多个queue的情况，如果Consumer等于queue的个数，那就是一个Consumer消费一个queue，如果Consumer个数大于queue的个数，那么会有部分Consumer空余出来，白白的浪费了。</p>
<h2 id="Broker把自己的信息注册到哪个NameServer上？"><a href="#Broker把自己的信息注册到哪个NameServer上？" class="headerlink" title="Broker把自己的信息注册到哪个NameServer上？"></a>Broker把自己的信息注册到哪个NameServer上？</h2><p>这么问明显在坑你，因为Broker会向所有的NameServer上注册自己的信息，而不是某一个，是每一个，全部！</p>
<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="ack机制"><a href="#ack机制" class="headerlink" title="ack机制"></a>ack机制</h2><p>acks 参数配置：</p>
<ul>
<li>0：producer 不等待 broker 的 ack，这一操作提供了一个最低的延迟，broker 一接收到还没有写入磁盘就已经返回，当 broker 故障时有可能丢失数据；</li>
<li>1：producer 等待 broker 的 ack，partition 的 leader 落盘成功后返回 ack，如果在 follower 同步成功之前 leader 故障，那么将会丢失数据；</li>
<li>-1（all）：producer 等待 broker 的 ack，partition 的 leader 和 follower 全部落盘成功后才 返回 ack。但是如果在 follower 同步完成后，broker 发送 ack 之前，leader 发生故障，那么会 造成数据重复。</li>
</ul>
<h2 id="文件存储机制"><a href="#文件存储机制" class="headerlink" title="文件存储机制"></a>文件存储机制</h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210316101524541.png" alt="image-20210316101524541"></p>
<h2 id="kafka的消费者如何消费数据"><a href="#kafka的消费者如何消费数据" class="headerlink" title="kafka的消费者如何消费数据"></a>kafka的消费者如何消费数据</h2><p>消费者每次消费消费数据时，都会记录消费的offset偏移量位置，等待下次消费时，接着上次位置继续消费</p>
<h2 id="Kafka-判断一个节点是否还活着有那两个条件"><a href="#Kafka-判断一个节点是否还活着有那两个条件" class="headerlink" title="Kafka 判断一个节点是否还活着有那两个条件"></a><strong>Kafka 判断一个节点是否还活着有那两个条件</strong></h2><p>（1）节点必须维护和 ZooKeeper 的连接，Zookeeper 通过心跳机制检查每个节点的连接</p>
<p>（2）如果节点是个 follower,他必须能及时的同步 leader 的写操作，延时不能太久</p>
<h2 id="producer-是否直接将数据发送到-broker-的-leader-主节点-？"><a href="#producer-是否直接将数据发送到-broker-的-leader-主节点-？" class="headerlink" title="producer 是否直接将数据发送到 broker 的 leader(主节点)？"></a><strong>producer 是否直接将数据发送到 broker 的 leader(主节点)？</strong></h2><p>producer 直接将数据发送到 broker 的 leader(主节点)，不需要在多个节点进行分发，为了帮助 producer 做到这点，所有的 Kafka 节点都可以及时的告知:哪些节点是活动的，目标opic 目标分区的 leader 在哪。这样 producer 就可以直接将消息发送到目的地了</p>
<h2 id="Kafka-存储在硬盘上的消息格式是什么？"><a href="#Kafka-存储在硬盘上的消息格式是什么？" class="headerlink" title="Kafka 存储在硬盘上的消息格式是什么？"></a><strong>Kafka 存储在硬盘上的消息格式是什么？</strong></h2><p>消息由一个固定长度的头部和可变长度的字节数组组成。头部包含了一个版本号和 CRC32校验码。</p>
<p>消息长度: 4 bytes (value: 1+4+n)</p>
<p>版本号: 1 byte</p>
<p>CRC 校验码: 4 bytes</p>
<p>具体的消息: n bytes</p>
<h2 id="offset的作用"><a href="#offset的作用" class="headerlink" title="offset的作用"></a>offset的作用</h2><p>给分区中的消息提供了一个顺序ID号，我们称之为偏移量。因此，为了唯一地识别分区中的每条消息，我们使用这些偏移量。</p>
<h2 id="zookeeper的作用"><a href="#zookeeper的作用" class="headerlink" title="zookeeper的作用"></a>zookeeper的作用</h2><p>Apache Kafka是一个使用Zookeeper构建的分布式系统。虽然，Zookeeper的主要作用是在集群中的不同节点之间建立协调。但是，如果任何节点失败，我们还使用Zookeeper从先前提交的偏移量中恢复，因为它做周期性提交偏移量工作。</p>
<h2 id="在Kafka集群中保留期的目的是什么？"><a href="#在Kafka集群中保留期的目的是什么？" class="headerlink" title="在Kafka集群中保留期的目的是什么？"></a>在Kafka集群中保留期的目的是什么？</h2><blockquote>
<p>答：保留期限保留了Kafka群集中的所有已发布记录。它不会检查它们是否已被消耗。此外，可以通过使用保留期的配置设置来丢弃记录。而且，它可以释放一些空间。</p>
</blockquote>
<h2 id="为什么说Kafka性能很好，体现在哪里？"><a href="#为什么说Kafka性能很好，体现在哪里？" class="headerlink" title="为什么说Kafka性能很好，体现在哪里？"></a>为什么说Kafka性能很好，体现在哪里？</h2><p>①顺序读写 ②零拷贝 ③分区 ④批量发送 ⑤数据压缩 </p>
<h2 id="Kafka中的ISR、AR、OSR又代表什么？"><a href="#Kafka中的ISR、AR、OSR又代表什么？" class="headerlink" title="Kafka中的ISR、AR、OSR又代表什么？"></a>Kafka中的ISR、AR、OSR又代表什么？</h2><p>ISR:In-Sync Replicas 副本同步队列<br>AR:Assigned Replicas 所有副本<br>ISR是由leader维护，follower从leader同步数据有一些延迟（包括延迟时间replica.lag.time.max.ms和延迟条数replica.lag.max.messages两个维度, 当前最新的版本0.10.x中只支持replica.lag.time.max.ms这个维度），任意一个超过阈值都会把follower剔除出ISR, 存入OSR（Outof-Sync Replicas）列表，新加入的follower也会先存放在OSR中。AR=ISR+OSR。</p>
<h2 id="Kafka中是怎么体现消息顺序性的？"><a href="#Kafka中是怎么体现消息顺序性的？" class="headerlink" title="Kafka中是怎么体现消息顺序性的？"></a>Kafka中是怎么体现消息顺序性的？</h2><p>Kafka只能保证分区内消息顺序有序，无法保证全局有序</p>
<ul>
<li>生产者：通过分区的leader副本负责数据顺序写入，来保证消息顺序性</li>
<li>消费者：同一个分区内的消息只能被一个group里的一个消费者消费，保证分区内消费有序</li>
</ul>
<h2 id="Kafka-生产者客户端的整体结构是什么样子的？使用了几个线程来处理？分别是什么？"><a href="#Kafka-生产者客户端的整体结构是什么样子的？使用了几个线程来处理？分别是什么？" class="headerlink" title="Kafka 生产者客户端的整体结构是什么样子的？使用了几个线程来处理？分别是什么？"></a>Kafka 生产者客户端的整体结构是什么样子的？使用了几个线程来处理？分别是什么？</h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210317085906120.png" alt="image-20210317085906120"></p>
<p>main 线程将消息发送给 RecordAccumulator，Sender 线程不断从 RecordAccumulator 中拉取 消息发送到 Kafka broker。</p>
<h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><h2 id="什么是高可用？可用性的判断标准是啥？"><a href="#什么是高可用？可用性的判断标准是啥？" class="headerlink" title="什么是高可用？可用性的判断标准是啥？"></a>什么是高可用？可用性的判断标准是啥？</h2><p><strong>高可用描述的是一个系统在大部分时间都是可用的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。</strong></p>
<p><strong>一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。</strong></p>
<p>除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。</p>
<h2 id="提高可用性的方法"><a href="#提高可用性的方法" class="headerlink" title="提高可用性的方法"></a>提高可用性的方法</h2><ol>
<li>注重代码质量</li>
<li>使用集群，减少单点故障</li>
<li>限流</li>
<li>设置超时和重试机制</li>
<li>熔断机制</li>
<li>异步调用</li>
<li>使用缓存</li>
</ol>
<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="SpringCloud和SpringBoot的-区别"><a href="#SpringCloud和SpringBoot的-区别" class="headerlink" title="SpringCloud和SpringBoot的 区别"></a>SpringCloud和SpringBoot的 区别</h2><p>SpringBoot专注于快速方便的开发单个个体微服务。</p>
<p>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，</p>
<p>为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务</p>
<p>SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系</p>
<h2 id="Spring-Cloud-和dubbo区别"><a href="#Spring-Cloud-和dubbo区别" class="headerlink" title="Spring Cloud 和dubbo区别?"></a>Spring Cloud 和dubbo区别?</h2><p>（1）服务调用方式 dubbo是RPC springcloud Rest Api</p>
<p>（2）注册中心,dubbo 是zookeeper springcloud是eureka，也可以是zookeeper</p>
<p>（3）服务网关,dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud</p>
<h2 id="Hystrix如何实现容错"><a href="#Hystrix如何实现容错" class="headerlink" title="Hystrix如何实现容错"></a>Hystrix如何实现容错</h2><p>由于某种原因，公开的服务会抛出异常。我们在这种情况下使用 Hystrix 定义了一个回退方法。这种后备方法应该具有与公开服务相同的返回类型。如果暴露服务中出现异常，则回退方法将返回一些值。</p>
<h2 id="spring-cloud-的核心组件有哪些？"><a href="#spring-cloud-的核心组件有哪些？" class="headerlink" title="spring cloud 的核心组件有哪些？"></a><strong>spring cloud 的核心组件有哪些？</strong></h2><ul>
<li>Eureka：服务注册于发现。</li>
<li>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。</li>
<li>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。</li>
<li>Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。</li>
<li>Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</li>
</ul>
<h2 id="spring-cloud-断路器的作用是什么？"><a href="#spring-cloud-断路器的作用是什么？" class="headerlink" title="spring cloud 断路器的作用是什么？"></a><strong>spring cloud 断路器的作用是什么？</strong></h2><p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p>
<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>参考：<a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/CAP%E7%90%86%E8%AE%BA">https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/CAP%E7%90%86%E8%AE%BA</a></p>
<h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>参考：<a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/BASE%E7%90%86%E8%AE%BA">https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/BASE%E7%90%86%E8%AE%BA</a></p>
<h2 id="eureka自我保护机制是什么"><a href="#eureka自我保护机制是什么" class="headerlink" title="eureka自我保护机制是什么?"></a>eureka自我保护机制是什么?</h2><p>当Eureka Server 节点在短时间内丢失了过多实例的连接时（比如网络故障或频繁启动关闭客户端）节点会进入自我保护模式，自我保护机制会导致Eureka不再从注册列表移除因长时间没收到心跳而应该过期的服务 Eureka仍然能够接受新服务的注册和查询请求,但是不会被同步到其他节点(高可用)。当网络稳定时,当前实例新的注册信息会被同步到其他节点中(最终一致性)</p>
<h2 id="Eureka和Zookeeper的区别"><a href="#Eureka和Zookeeper的区别" class="headerlink" title="Eureka和Zookeeper的区别"></a>Eureka和Zookeeper的区别</h2><p>1.ZooKeeper保证的是CP,Eureka保证的是AP，ZooKeeper在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间是不可用的。Eureka各个节点是平等关系,只要有一台Eureka就可以保证服务可用,而查询到的数据并不是最新的。Eureka的自我保护机制可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper一样使得整个注册系统瘫痪</p>
<p>2.ZooKeeper有Leader和Follower角色,Eureka各个节点平等</p>
<p>3.ZooKeeper采用过半数存活原则,Eureka采用自我保护机制解决分区问题</p>
<p>4.Eureka本质上是一个工程,而ZooKeeper只是一个进程  </p>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="servlet生命周期"><a href="#servlet生命周期" class="headerlink" title="servlet生命周期"></a>servlet生命周期</h2><p>1.Servlet 通过调用 init () 方法进行初始化。</p>
<p>2.Servlet 调用 service() 方法来处理客户端的请求。<br>3.Servlet 通过调用 destroy() 方法终止（结束）。<br>4.最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>如果在类中定义成员变量，而在service中根据不同的线程对该成员变量进行更改，那么在并发的时候就会引起错误。最好是在方法中，定义局部变量，而不是类变量或者对象的成员变量。由于方法中的局部变量是在栈中，彼此各自都拥有独立的运行空间而不会互相干扰，因此才做到线程安全。</p>
<h2 id="转发与重定向的区别"><a href="#转发与重定向的区别" class="headerlink" title="转发与重定向的区别"></a>转发与重定向的区别</h2><p>forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，其实客户端浏览器只发了一次请求，所以它的地址栏中还是原来的地址，session,request参数都可以获取。</p>
<p>redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，相当于客户端浏览器发送了两次请求。</p>
<h2 id="什么是servlet"><a href="#什么是servlet" class="headerlink" title="什么是servlet"></a>什么是servlet</h2><p>Servlet是用来处理客户端请求并产生动态网页内容的Java类。Servlet主要是用来处理或者是存储HTML表单提交的数据，产生动态内容，在无状态的HTTP协议下管理状态信息。</p>
<h2 id="如何知道是哪一个客户端的机器正在请求你的servlet"><a href="#如何知道是哪一个客户端的机器正在请求你的servlet" class="headerlink" title="如何知道是哪一个客户端的机器正在请求你的servlet"></a>如何知道是哪一个客户端的机器正在请求你的servlet</h2><p>ServletRequest类可以找出客户端机器的IP地址或者是主机名。getRemoteAddr()方法获取客户端主机的IP地址，getRemoteHost()可以获取主机名</p>
<h2 id="doGet与doPost方法的两个参数是什么"><a href="#doGet与doPost方法的两个参数是什么" class="headerlink" title="doGet与doPost方法的两个参数是什么"></a>doGet与doPost方法的两个参数是什么</h2><p>HttpServletRequest：封装了与请求相关的信息</p>
<p>HttpServletResponse：封装了与响应相关的信息</p>
<h2 id="tomcat容器是如何创建servlet类实例？用到了什么原理？"><a href="#tomcat容器是如何创建servlet类实例？用到了什么原理？" class="headerlink" title="tomcat容器是如何创建servlet类实例？用到了什么原理？"></a>tomcat容器是如何创建servlet类实例？用到了什么原理？</h2><p>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对 xml文件进行解析，并读取servlet注册信息。然后，将每个应用中注册的servlet类都进行加载，并通过 反射的方式实例化。（有时候也是在第一次请求时实例化）<br>在servlet注册时加上1如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。</p>
<h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/basis-of-authority-certification?id=_6-%e4%bb%80%e4%b9%88%e6%98%af-token%e4%bb%80%e4%b9%88%e6%98%af-jwt%e5%a6%82%e4%bd%95%e5%9f%ba%e4%ba%8etoken%e8%bf%9b%e8%a1%8c%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81%ef%bc%9f">一些问题</a></p>
<p><a href="https://www.pianshen.com/article/3842346614/">springSecurity安全框架的学习和原理解读</a></p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="双亲委托机制模型的好处"><a href="#双亲委托机制模型的好处" class="headerlink" title="双亲委托机制模型的好处"></a>双亲委托机制模型的好处</h2><ul>
<li><p>可以确保java核心库的类型安全：所有的java应用都至少会引用java.lang.Object类，也就是说在运行期，java.lang.Object这个类会被加载到java虚拟机中；如果这个加载过程是由java应用自己的类加载器所完成的，那么很有可能就会在JVM中存在多个版本的Object类，而且这些类之间还是不兼容的，相互不可见的。借助于双亲委托机制，java核心类库中的类的加载工作都是由启动类加载器统一加载的，从而确保了java引用所使用的都是同一个版本的java核心类库，他们之间是相互兼容的</p>
</li>
<li><p>可以确保java核心类库所提供的类不会被自定义的类所替代</p>
</li>
<li><p>不同的类加载器可以为相同名称的类创建额外的命名空间。相同名称的类可同时存在java虚拟机中，只需要用不同的类加载器来加载他们即可。不同类加载器所加载的类之间是不兼容的。这就相当于在java虚拟机内部创建了一个又一个相互隔离的java类空间</p>
</li>
</ul>
<h2 id="什么情况下会发生栈内存溢出"><a href="#什么情况下会发生栈内存溢出" class="headerlink" title="什么情况下会发生栈内存溢出"></a>什么情况下会发生栈内存溢出</h2><p>思路： 描述栈定义，再描述为什么会溢出，再说明一下相关配置参数，OK的话可以给面试官手写是一个栈溢出的demo。</p>
<p>答案：</p>
<ul>
<li>栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型。</li>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常，方法递归调用产生这种结果。</li>
<li>如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是无法申请到足够的内存去完成扩展，或者在新建立线程的时候没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将抛出一个OutOfMemory 异常。(线程启动过多)。</li>
<li>参数 -Xss 去调整JVM栈的大小</li>
</ul>
<h2 id="HotSpot中的堆为什么要分为新生代和老年代？"><a href="#HotSpot中的堆为什么要分为新生代和老年代？" class="headerlink" title="HotSpot中的堆为什么要分为新生代和老年代？"></a>HotSpot中的堆为什么要分为新生代和老年代？</h2><p>将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集</p>
<p>一些参数的配置</p>
<ul>
<li>默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ，可以通过参数 –XX:NewRatio 配置。</li>
<li>默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定)</li>
<li>Survivor区中的对象被复制次数为15(对应虚拟机参数 -XX:+MaxTenuringThreshold)</li>
</ul>
<h2 id="新生代为什么要分为Eden和Survivor-为什么要设置两个Survivor区？"><a href="#新生代为什么要分为Eden和Survivor-为什么要设置两个Survivor区？" class="headerlink" title="新生代为什么要分为Eden和Survivor?为什么要设置两个Survivor区？"></a>新生代为什么要分为Eden和Survivor?为什么要设置两个Survivor区？</h2><p>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。<br>设置两个Survivor区最大的好处就是解决了碎片化，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）</p>
<h2 id="JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代"><a href="#JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代" class="headerlink" title="JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代"></a>JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代</h2><ol>
<li>当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。</li>
<li>大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年态；</li>
<li>如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，若年龄超过一定限制，则被晋升到老年态。即长期存活的对象进入老年态。</li>
<li>老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – 包括年轻代和年老代。</li>
</ol>
<h2 id="几种垃圾收集器"><a href="#几种垃圾收集器" class="headerlink" title="几种垃圾收集器"></a>几种垃圾收集器</h2><p>Serial收集器： 单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。</p>
<p>Serial Old收集器： 是Serial收集器的老年代版本，单线程收集器，使用标记整理算法。</p>
<p>ParNew收集器： Serial收集器的多线程版本，也需要stop the world，复制算法。<br>Parallel Scavenge收集器： 新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个可控的吞吐量。如果虚拟机总共运行100分钟，其中垃圾花掉1分钟，吞吐量就是99%。<br>Parallel Old收集器： 是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。<br>CMS(Concurrent Mark Sweep) 收集器： 是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片。<br>G1收集器： 标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选标记。不会产生空间碎片，可以精确地控制停顿。</p>
<h2 id="CMS收集器和G1收集器的区别"><a href="#CMS收集器和G1收集器的区别" class="headerlink" title="CMS收集器和G1收集器的区别"></a>CMS收集器和G1收集器的区别</h2><ol>
<li>CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；</li>
<li>CMS收集器以最小的停顿时间为目标的收集器；G1收集器可预测垃圾回收的停顿时间</li>
<li>CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片。G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片</li>
</ol>
<h2 id="简单说说你了解的类加载器"><a href="#简单说说你了解的类加载器" class="headerlink" title="简单说说你了解的类加载器"></a>简单说说你了解的类加载器</h2><p><strong>类加载器</strong> 就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。</p>
<p>有自定义类加载器 ，启动类加载器，扩展类加载器，应用程序类加载器</p>
<p><strong>双亲委派模型</strong>：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。</p>
<h2 id="为什么需要双亲委派模型？"><a href="#为什么需要双亲委派模型？" class="headerlink" title="为什么需要双亲委派模型？"></a>为什么需要双亲委派模型？</h2><p>在这里，先想一下，如果没有双亲委派，那么用户是不是可以自己定义一个java.lang.Object的同名类，java.lang.String的同名类，并把它放到ClassPath中,那么类之间的比较结果及类的唯一性将无法保证，双亲委派模型可以防止内存中出现多份同样的字节码</p>
<h2 id="怎么打破双亲委派模型"><a href="#怎么打破双亲委派模型" class="headerlink" title="怎么打破双亲委派模型"></a>怎么打破双亲委派模型</h2><ol>
<li>重写loadClass()方法：这里最主要的是重写loadclass()方法，因为双亲委派机制的实现都是通过这个方法实现的，这个方法可<br>以指定类通过什么加载器来进行加载，所以如果我们改写他的加载规则，就相当于打破了双亲委派机制。默认的过程是这样的，先判断这个类是不是已经被当前层的类加载器加载过了，如果没有加载过就就将该类委派给父类加载器，如果父加载器无法加载再向下传递，回来由自己来进行加载，重写了这个方法以后就能自己定义使用什么加载器了，也可以自定义加载委派机制，也就打破了双亲委派模型。</li>
<li>线程上下文类加载器：当高层提供了统一的接口让低层去实现，同时又要在高层加载（或实例化)低层的类时，就必须要通过线程上下文类加载器来帮助高层的classLoader找到并加载该类。线程上下文类加载器(Thread Context Clessloder)。这个类加载器可以通过java.lang.Thread类的setCcontextClessLoser()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。有了线程上下文类加载器，就可以做一些”舞弊”的事情了，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则</li>
</ol>
<h2 id="说说你知道的几种主要的JVM参数"><a href="#说说你知道的几种主要的JVM参数" class="headerlink" title="说说你知道的几种主要的JVM参数"></a>说说你知道的几种主要的JVM参数</h2><p>三大性能参数： -Xms -Xmx -Xss</p>
<p><strong>堆栈配置相关</strong></p>
<p>-Xmx3550m： 最大堆大小为3550m。</p>
<p>-Xms3550m： 设置初始堆大小为3550m。</p>
<p>-Xmn2g： 设置年轻代大小为2g。</p>
<p>-Xss128k： 每个线程的堆栈大小为128k。</p>
<p>-XX:MaxPermSize： 设置持久代大小为16m</p>
<p>-XX:NewRatio=4: 设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。</p>
<p>-XX:SurvivorRatio=4： 设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</p>
<p>-XX:MaxTenuringThreshold=0： 设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。</p>
<p><strong>垃圾收集器相关</strong></p>
<p>-XX:+UseParallelGC： 选择垃圾收集器为并行收集器。</p>
<p>-XX:ParallelGCThreads=20： 配置并行收集器的线程数</p>
<p>-XX:+UseConcMarkSweepGC： 设置年老代为并发收集。</p>
<p>-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</p>
<p>-XX:+UseCMSCompactAtFullCollection： 打开对年老代的压缩。可能会影响性能，但是可以消除碎片</p>
<h2 id="四种引用类型：强引用、软引用、弱引用、虚引用-的区别？"><a href="#四种引用类型：强引用、软引用、弱引用、虚引用-的区别？" class="headerlink" title="四种引用类型：强引用、软引用、弱引用、虚引用 的区别？"></a>四种引用类型：强引用、软引用、弱引用、虚引用 的区别？</h2><p><strong>强引用</strong>：我们平时new了一个对象就是强引用，例如 Object obj = new Object();即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。</p>
<p><strong>软引用</strong>：如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">SoftReference&lt;String&gt; softRef=<span class="keyword">new</span> SoftReference&lt;String&gt;(str);     <span class="comment">// 软引用</span></span><br></pre></td></tr></table></figure>

<p>用处： 软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。</p>
<p>（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建</p>
<p>（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出</p>
<p>如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Browser prev = <span class="keyword">new</span> Browser();               <span class="comment">// 获取页面进行浏览</span></span><br><span class="line">SoftReference sr = <span class="keyword">new</span> SoftReference(prev); <span class="comment">// 浏览完毕后置为软引用        </span></span><br><span class="line"><span class="keyword">if</span>(sr.get()!=<span class="keyword">null</span>)&#123; </span><br><span class="line">    rev = (Browser) sr.get();           <span class="comment">// 还没有被回收器回收，直接获取</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    prev = <span class="keyword">new</span> Browser();               <span class="comment">// 由于内存吃紧，所以对软引用的对象回收了</span></span><br><span class="line">    sr = <span class="keyword">new</span> SoftReference(prev);       <span class="comment">// 重新构建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>弱引用</strong>：弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);    </span><br><span class="line">WeakReference&lt;String&gt; abcWeakRef = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span><br><span class="line">str=<span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure>

<p><strong>虚引用</strong>：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。</p>
<h2 id="举例几种常见的垃圾收集算法？"><a href="#举例几种常见的垃圾收集算法？" class="headerlink" title="举例几种常见的垃圾收集算法？"></a>举例几种常见的垃圾收集算法？</h2><p>标记清除法：标记阶段从根节点对对象就行标记，从根节点开始可达的对象就标记，清除阶段 清除未被标记的对象</p>
<p>标记整理法：标记出对象是否存活，移动存活对象，移动完之后，清理边界外的对象</p>
<p>复制算法</p>
<h2 id="在JVM中，如何判断一个对象是否可被回收？"><a href="#在JVM中，如何判断一个对象是否可被回收？" class="headerlink" title="在JVM中，如何判断一个对象是否可被回收？"></a>在JVM中，如何判断一个对象是否可被回收？</h2><p>引用计数法是最简单最古老的算法，JVM为每个对象分配一个计数器，当对象被引用时，计数器就加1，当对象没有被引用或者离开作用域，计数器就减1。当计数器的值为0时，就代表该对象已经死亡。但是无法解决循环引用的问题</p>
<p>可达性分析算法，是用ＧＣROOTs 作为对象的起点开始往下搜索，能搜索到这个对象，就表示对象是可达的，不能搜素到表示对象是不可达的</p>
<p>在Java中采取了 可达性分析法</p>
<h2 id="OOM说一下？怎么排查？哪些会导致OOM-OOM出现在什么时候"><a href="#OOM说一下？怎么排查？哪些会导致OOM-OOM出现在什么时候" class="headerlink" title="OOM说一下？怎么排查？哪些会导致OOM? OOM出现在什么时候"></a>OOM说一下？怎么排查？哪些会导致OOM? OOM出现在什么时候</h2><p>OOM，全称“Out Of Memory”，官方说明：当JVM因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个error。<br>（没有空闲内存，并且垃圾收集器也无法提供更多内存。）<br>怎么排查？<br>首先可以查看服务器运行日志以及项目记录的日志，捕捉到内存溢出异常。<br>核心系统日志文件<br>OOM出现在什么时候？哪些会导致OOM?</p>
<ul>
<li>java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设。置不当引起。 可以通过虚拟机参数-Xms,-Xmx等修改。</li>
<li>java永久代溢出，即方法区溢出了，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemoryError 也非常多见 ，尤其是在运行时存在大量动态类型生成的场合；（ＪＤＫ８已经没有方法区了，改为元数据区）</li>
<li>JAVA虚拟机栈溢出，不会抛OOM error，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。类似这种情况，JVM 实际会抛出 StackOverFlowError；当然，如果 JVM 试图去扩展栈空间的的时候失败，则会抛出 OutOfMemoryError。</li>
<li>直接内存不足，也会导致 OOM</li>
</ul>
<h2 id="STW"><a href="#STW" class="headerlink" title="STW?"></a>STW?</h2><p>当程序运行到这些“安全点”(方法调用,循环跳转,异常跳转)的时候就会暂停所有当前运行的线程（Stop The World 所以叫STW）。</p>
<h2 id="安全点和安全区域"><a href="#安全点和安全区域" class="headerlink" title="安全点和安全区域"></a>安全点和安全区域</h2><p>执行系统停顿下来后 并不需要一个不漏的检查所有执行上下文和全局的引用位置 而是使用一组称为OopMap的数据结构得知哪些地方存放着对象引用。在OopMap的协助下 HotSpot可以快速且准确地完成GC Roots枚举，hotspot并没有为每条指令都使用OopMap，那样会使空间成本变高 ，而是在特殊的位置记录了这些信息 这些位置称为安全点 程序只有在安全点才暂停</p>
<p>安全点：安全点的选点不能太少以至于让GC等待时间太长 也不能过于频繁以至于过分增大运行时的负载 而是以是否具有让程序长时间执行的特征为标准进行选定的。长时间执行的最明显特征就是指令序列复用 例如方法调用 循环 异常跳转等 所以具有这些功能的指令才会产生SafePoint 有两种方法让所有线程都跑到最近的安全点：抢占式中断和主动式中断</p>
<p>抢占式中断：GC发生时 把所有线程中断 如果有线程中断的地方不在安全点 就恢复线程 让他跑到安全上</p>
<p>主动式中断：当GC需要中断线程时 设置一个标志 各个线程执行时主动去轮询这个标志 发现终端标志为真时就自己中断挂起 轮询标志的地方和安全点是重合的 另外再加上创建对象需要分配内存的地方</p>
<p>安全区域：safepoint解决了执行的程序如何进入GC的问题 而对于不执行的程序 即没有被分配cpu时间 比如处于sleep或者blocked状态 这时线程无法响应jvm中断请求 就需要安全区域来解决/当线程执行到safe region中的代码时 首先标识自己已经进入safe region，那样当这段时间里jvm要发起GC时 不用管进入safe region的线程 当线程离开 safe region时 要检查系统是否已经完成了根节点枚举 如果完成 程序继续执行 否则必须等到收到可以安全离开safe region的信号</p>
<h2 id="深拷贝和浅拷贝-1"><a href="#深拷贝和浅拷贝-1" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。</p>
<p>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存。</p>
<h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p><strong>内存分别</strong></p>
<p>堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。</p>
<p>栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。</p>
<p><strong>存放的内容</strong></p>
<p>堆存放的是对象的实例和数组。因此该区更关注的是数据的存储</p>
<p>栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。</p>
<p><strong>程序的可见度</strong></p>
<p>堆对于整个应用程序都是共享、可见的。</p>
<p>栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。</p>
<h2 id="对象创建的主要流程"><a href="#对象创建的主要流程" class="headerlink" title="对象创建的主要流程"></a>对象创建的主要流程</h2><p>虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载。类加载通过后，接下来分配内存。若Java堆中内存是绝对规整的，使用“指针碰撞“方式分配内存；如果不是规整的，】</p>
<p>9就从空闲列表中分配，叫做”空闲列表“方式。划分内存时还需要考虑一个问题-并发，也有两种方式: CAS同步处理，或者本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。然后内存空间初始化操作，接着是做一些必要的对象设置(元信息、哈希码…)，最后执行<init>方法。</init></p>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210326134759333.png" alt="image-20210326134759333"></p>
<p>对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：</p>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210326134912997.png" alt="image-20210326134912997"></p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p><strong>句柄访问</strong></p>
<p><code>Java</code>堆中划分出一块内存来作为<strong>句柄池</strong>，引用中存储对象的<strong>句柄地址</strong>，而句柄中包含了<strong>对象实例数据</strong>与<strong>对象类型数据</strong>各自的<strong>具体地址</strong>信息，具体构造如下图所示：</p>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210326135037672.png" alt="image-20210326135037672"></p>
<p><strong>优势</strong>：引用中存储的是<strong>稳定</strong>的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变<strong>句柄中</strong>的<strong>实例数据指针</strong>，而<strong>引用</strong>本身不需要修改。</p>
<p><strong>直接指针</strong></p>
<p>如果使用<strong>直接指针</strong>访问，<strong>引用</strong> 中存储的直接就是<strong>对象地址</strong>，那么<code>Java</code>堆对象内部的布局中就必须考虑如何放置访问<strong>类型数据</strong>的相关信息。</p>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210326135125898.png" alt="image-20210326135125898"></p>
<p><strong>优势</strong>：速度更<strong>快</strong>，节省了<strong>一次指针定位</strong>的时间开销。由于对象的访问在<code>Java</code>中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。</p>
<h2 id="Java会存在内存泄漏吗？请简单描述"><a href="#Java会存在内存泄漏吗？请简单描述" class="headerlink" title="Java会存在内存泄漏吗？请简单描述"></a>Java会存在内存泄漏吗？请简单描述</h2><p>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。</p>
<p>但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。</p>
<h2 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h2><p>在java中，程序员是不需要显式的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p>
<h2 id="垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"><a href="#垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？" class="headerlink" title="垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"></a>垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</h2><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</p>
<p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p>
<p>可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p>
<h2 id="详细介绍一下-CMS-垃圾回收器？"><a href="#详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="详细介绍一下 CMS 垃圾回收器？"></a>详细介绍一下 CMS 垃圾回收器？</h2><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。</p>
<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h2 id="简述分代垃圾回收器是怎么工作的？"><a href="#简述分代垃圾回收器是怎么工作的？" class="headerlink" title="简述分代垃圾回收器是怎么工作的？"></a>简述分代垃圾回收器是怎么工作的？</h2><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p>
<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、T  rvivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>
<p>把 Eden + From Survivor 存活的对象放入 To Survivor 区；<br>清空 Eden 和 From Survivor 分区；<br>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。<br>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p>
<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>
<h2 id="类加载的执行过程"><a href="#类加载的执行过程" class="headerlink" title="类加载的执行过程"></a>类加载的执行过程</h2><p>加载：根据查找路径找到相应的 class 文件然后导入；<br>验证：检查加载的 class 文件的正确性；<br>准备：给类中的静态变量分配内存空间；<br>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接向内存中的地址；<br>初始化：对静态变量和静态代码块执行初始化工作。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="23中设计模式分类"><a href="#23中设计模式分类" class="headerlink" title="23中设计模式分类"></a>23中设计模式分类</h2><p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210327110413003.png" alt="image-20210327110413003"></p>
<h2 id="设计模式的作用是什么？"><a href="#设计模式的作用是什么？" class="headerlink" title="设计模式的作用是什么？"></a>设计模式的作用是什么？</h2><p>答：（1）重用设计和代码，重用设计比重用代码更有意义，自动带来代码重用；（2）提高扩展性，大量使用面向接口编程，预留扩展插槽，新的功能或特性很容易加入到系统中来；（3）提高灵活性，通过组合提高灵活性，可允许代码修改平稳发生，对一处修改不会波及到其他模块；（4）提高开发效率，正确使用设计模式，可以节省大量的时间。</p>
<h2 id="写出几种熟悉的设计模式，并做简单介绍？"><a href="#写出几种熟悉的设计模式，并做简单介绍？" class="headerlink" title="写出几种熟悉的设计模式，并做简单介绍？"></a>写出几种熟悉的设计模式，并做简单介绍？</h2><p>代理设计模式：指由一个代理主题来操作真实主题，真实主题执行具体的业务操作，而代理主题负责其他相关业务的处理。比如生活中的通过代理访问网络，客户通过网络代理连接网络（具体业务），由代理服务器完成用户权限和访问限制等与上网相关的其他操作（相关业务）。</p>
<p>工厂模式：它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<p>适配器模式：适配器模式是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。</p>
<p>模板模式：在模板模式中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</p>
<h2 id="适配器模式和代理模式之间有什么不同？"><a href="#适配器模式和代理模式之间有什么不同？" class="headerlink" title="适配器模式和代理模式之间有什么不同？"></a>适配器模式和代理模式之间有什么不同？</h2><p>答：适配器模式和代理模式的区别在于他们的意图不同。由于适配器模式和代理模式都是封装真正执行动作的类，因此结构是一致的，但是适配器模式用于接口之间的转换，而代理模式则是增加一个额外的中间层，以便支持分配、控制或智能访问。</p>
<h2 id="十大常用的设计模式"><a href="#十大常用的设计模式" class="headerlink" title="十大常用的设计模式"></a>十大常用的设计模式</h2><p><a href="https://blog.csdn.net/dean_hu/article/details/71195133#t4">https://blog.csdn.net/dean_hu/article/details/71195133#t4</a></p>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="在Git中，你如何还原已经-push-并公开的提交？"><a href="#在Git中，你如何还原已经-push-并公开的提交？" class="headerlink" title="在Git中，你如何还原已经 push 并公开的提交？"></a>在Git中，你如何还原已经 push 并公开的提交？</h2><p>1.删除或修复新提交中的错误文件，并将其推送到远程存储库。这是修复错误的最自然方式。对文件进行必要的修改后，将其提交到我将使用的远程存储库</p>
<p>2.创建一个新的提交，撤消在错误提交中所做的所有更改。可以使用命令：git revert</p>
<p>git pull 和 git fetch</p>
<p><code>git pull</code> 命令从中央存储库中提取特定分支的新更改或提交，并更新本地存储库中的目标分支。</p>
<p><code>git fetch</code> 也用于相同的目的，但它的工作方式略有不同。当你执行 <code>git fetch</code> 时，它会从所需的分支中提取所有新提交，并将其存储在本地存储库中的新分支中。如果要在目标分支中反映这些更改，必须在 <code>git fetch</code> 之后执行<code>git merge</code>。只有在对目标分支和获取的分支进行合并后才会更新目标分支。为了方便起见，请记住以下等式：</p>
<p>git pull = git fetch + git merge</p>
<h2 id="git中的“staging-area”或“index”是什么？"><a href="#git中的“staging-area”或“index”是什么？" class="headerlink" title="git中的“staging area”或“index”是什么？"></a>git中的“staging area”或“index”是什么？</h2><p>在完成提交之前，可以在称为“staging area”或“index”的中间区域中对其进行格式化和审查。从图中可以看出，每个更改首先在暂存区域中进行验证，我将其称为“stage file”，然后将更改提交到存储库。</p>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210329133023463.png" alt="image-20210329133023463"></p>
<h2 id="什么是-git-stash"><a href="#什么是-git-stash" class="headerlink" title="什么是 git stash?"></a>什么是 git stash?</h2><p>首先应该解释 git stash 的必要性。</p>
<p>通常情况下，当你一直在处理项目的某一部分时，如果你想要在某个时候切换分支去处理其他事情，事情会处于混乱的状态。问题是，你不想把完成了一半的工作的提交，以便你以后就可以回到当前的工作。解决这个问题的答案是 git stash。</p>
<p>再解释什么是git stash。</p>
<p>stash 会将你的工作目录，即修改后的跟踪文件和暂存的更改保存在一堆未完成的更改中，你可以随时重新应用这些更改。</p>
<h2 id="什么是git-stash-drop？"><a href="#什么是git-stash-drop？" class="headerlink" title="什么是git stash drop？"></a>什么是git stash drop？</h2><p>通过说明我们使用 <code>git stash drop</code> 的目的来回答这个问题。</p>
<p><code>git stash drop</code> 命令用于删除隐藏的项目。默认情况下，它将删除最后添加的存储项，如果提供参数的话，它还可以删除特定项。</p>
<p>下面举个例子。</p>
<p>如果要从隐藏项目列表中删除特定的存储项目，可以使用以下命令：</p>
<p><strong>git stash list：</strong>它将显示隐藏项目列表，如：</p>
<p>stash@{0}: WIP on master: 049d078 added the index file<br>stash@{1}: WIP on master: c264051 Revert “added file_size”<br>stash@{2}: WIP on master: 21d80a5 added number to log</p>
<p>如果要删除名为 stash@{0} 的项目，请使用命令 **git stash drop stash@{0}**。</p>
<h2 id="提交时发生冲突，你能解释冲突是如何产生的吗？你是如何解决的？"><a href="#提交时发生冲突，你能解释冲突是如何产生的吗？你是如何解决的？" class="headerlink" title="提交时发生冲突，你能解释冲突是如何产生的吗？你是如何解决的？"></a>提交时发生冲突，你能解释冲突是如何产生的吗？你是如何解决的？</h2><p>开发过程中，我们都有自己的特性分支，所以冲突发生的并不多，但也碰到过。诸如公共类的公共方法，我和别人同时修改同一个文件，他提交后我再提交就会报冲突的错误。<br>发生冲突，在IDE里面一般都是对比本地文件和远程分支的文件，然后把远程分支上文件的内容手工修改到本地文件，然后再提交冲突的文件使其保证与远程分支的文件一致，这样才会消除冲突，然后再提交自己修改的部分。特别要注意下，修改本地冲突文件使其与远程仓库的文件保持一致后，需要提交后才能消除冲突，否则无法继续提交。必要时可与同事交流，消除冲突。<br>发生冲突，也可以使用命令。</p>
<p>通过git stash命令，把工作区的修改提交到栈区，目的是保存工作区的修改；<br>通过git pull命令，拉取远程分支上的代码并合并到本地分支，目的是消除冲突；<br>通过git stash pop命令，把保存在栈区的修改部分合并到最新的工作空间中；</p>
<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="Maven常见的依赖范围有哪些"><a href="#Maven常见的依赖范围有哪些" class="headerlink" title="Maven常见的依赖范围有哪些?"></a>Maven常见的依赖范围有哪些?</h2><p>compile:编译依赖，默认的依赖方式，在编译（编译项目和编译测试用例），运行测试用例，运行（项目实际运行）三个阶段都有效，典型地有spring-core等jar。<br>test:测试依赖，只在编译测试用例和运行测试用例有效，典型地有JUnit。<br>provided:对于编译和测试有效，不会打包进发布包中，典型的例子为servlet-api,一般的web工程运行时都使用容器的servlet-api。<br>runtime:只在运行测试用例和实际运行时有效，典型地是jdbc驱动jar包。<br>system: 不从maven仓库获取该jar,而是通过systemPath指定该jar的路径。<br>import: 用于一个dependencyManagement对另一个dependencyManagement的继承。</p>
<h2 id="maven基本命令"><a href="#maven基本命令" class="headerlink" title="maven基本命令"></a>maven基本命令</h2><p>compile:编将java源文件编译成class文件</p>
<p>test:执行test目录下的测试用例</p>
<p>package:将项目打成jar包</p>
<p>clean:删除target文件夹</p>
<p>install:将当前项目放到Maven的本地仓库中。供其他项目使用</p>
<p>validate ：验证 Maven 描述文件是否有效。</p>
<p>verify ：验证构件包是否有效。</p>
<p>deploy ：将构件包部署到远程仓库。</p>
<p>site ：生成项目站点。</p>
<h2 id="什么是Maven仓库？"><a href="#什么是Maven仓库？" class="headerlink" title="什么是Maven仓库？"></a>什么是Maven仓库？</h2><p>Maven仓库用来存放Maven管理的所有Jar包。分为：本地仓库 和 中央仓库。</p>
<p>本地仓库：Maven本地的Jar包仓库。<br>中央仓库： Maven官方提供的远程仓库。<br>当项目编译时，Maven首先从本地仓库中寻找项目所需的Jar包，若本地仓库没有，再到Maven的中央仓库下载所需Jar包。</p>
<h2 id="什么是“坐标”？"><a href="#什么是“坐标”？" class="headerlink" title="什么是“坐标”？"></a>什么是“坐标”？</h2><p>在Maven中，坐标是Jar包的唯一标识，Maven通过坐标在仓库中找到项目所需的Jar包。</p>
<p>groupId和artifactId构成了一个Jar包的坐标。</p>
<ul>
<li><strong>groupId</strong>:所需Jar包的项目名</li>
<li><strong>artifactId</strong>:所需Jar包的模块名</li>
<li><strong>version</strong>:所需Jar包的版本号</li>
</ul>
<h2 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h2><p>若项目中多个Jar同时引用了相同的Jar时，会产生依赖冲突，但Maven采用了两种避免冲突的策略，因此在Maven中是不存在依赖冲突的。</p>
<p>1.短路优先</p>
<p>本项目——&gt;A.jar——&gt;B.jar——&gt;X.jar<br>本项目——&gt;C.jar——&gt;X.jar<br>若本项目引用了A.jar，A.jar又引用了B.jar，B.jar又引用了X.jar，并且C.jar也引用了X.jar。</p>
<p>在此时，Maven只会引用引用路径最短的Jar。</p>
<p>2.声明优先:若引用路径长度相同时，在pom.xml中谁先被声明，就使用谁。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Maven有三套相互独立的生命周期，分别是 Clean、Default 和 Site。每个生命周期包含一些阶段，阶段是有顺序的，后面的阶段依赖于前面的阶段。</p>
<ul>
<li>1、Clean 生命周期：清理项目，包含三个 phase ：<ul>
<li>pre-clean：执行清理前需要完成的工作。</li>
<li>clean：清理上一次构建生成的文件。</li>
<li>post-clean：执行清理后需要完成的工作</li>
</ul>
</li>
<li>2、Default 生命周期：构建项目，重要的 phase 如下：<ul>
<li>validate：验证工程是否正确，所有需要的资源是否可用。</li>
<li>compile：编译项目的源代码。</li>
<li>test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。</li>
<li>package：把已编译的代码打包成可发布的格式，比如 jar、war 等。</li>
<li>integration-test：如有需要，将包处理和发布到一个能够进行集成测试的环境。</li>
<li>verify：运行所有检查，验证包是否有效且达到质量标准。</li>
<li>install：把包安装到maven本地仓库，可以被其他工程作为依赖来使用。</li>
<li>deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。</li>
</ul>
</li>
<li>3、Site 生命周期：建立和发布项目站点，phase 如下：<ul>
<li>pre-site：生成项目站点之前需要完成的工作</li>
<li>site：生成项目站点文档</li>
<li>post-site：生成项目站点之后需要完成的工作</li>
<li>site-deploy：将项目站点发布到服务器</li>
</ul>
</li>
</ul>
<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><p>反向代理（Reverse Proxy）对应的是正向代理（Forward Proxy），他们的区别：</p>
<p>正向代理： 一般的访问流程是客户端直接向目标服务器发送请求并获取内容，使用正向代理后，客户端改为向代理服务器发送请求，并指定目标服务器（原始服务器），然后由代理服务器和原始服务器通信，转交请求并获得的内容，再返回给客户端。正向代理隐藏了真实的客户端，为客户端收发请求，使真实客户端对服务器不可见；</p>
<p>举个具体的例子 🌰，你的浏览器无法直接访问谷哥，这时候可以通过一个代理服务器来帮助你访问谷哥，那么这个服务器就叫正向代理。</p>
<p>反向代理： 与一般访问流程相比，使用反向代理后，直接收到请求的服务器是代理服务器，然后将请求转发给内部网络上真正进行处理的服务器，得到的结果返回给客户端。反向代理隐藏了真实的服务器，为服务器收发请求，使真实服务器对客户端不可见。一般在处理跨域请求的时候比较常用。现在基本上所有的大型网站都设置了反向代理。</p>
<p>举个具体的例子 🌰，去饭店吃饭，可以点川菜、粤菜、江浙菜，饭店也分别有三个菜系的厨师 👨‍🍳，但是你作为顾客不用管哪个厨师给你做的菜，只用点菜即可，小二将你菜单中的菜分配给不同的厨师来具体处理，那么这个小二就是反向代理服务器。</p>
<p>简单的说，一般给客户端做代理的都是正向代理，给服务器做代理的就是反向代理。</p>
<p>正向代理和反向代理主要的原理区别可以参见下图：<br><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210329143246372.png" alt="image-20210329143246372"></p>
<p><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210329143253028.png" alt="image-20210329143253028"></p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>请求爆发式增长的情况下，单个机器性能再强劲也无法满足要求了，这个时候集群的概念产生了，单个服务器解决不了的问题，可以使用多个服务器，然后将请求分发到各个服务器上，将负载分发到不同的服务器，这就是负载均衡，核心是「分摊压力」。Nginx 实现负载均衡，一般来说指的是将请求转发给服务器集群。<br><img src="/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20210329143345411.png" alt="image-20210329143345411"></p>
<p>参考文章：<a href="https://blog.csdn.net/Janson_Lin/article/details/105954705?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161697945316780271557329%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161697945316780271557329&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-105954705.first_rank_v2_pc_rank_v29&amp;utm_term=nginx">https://blog.csdn.net/Janson_Lin/article/details/105954705?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161697945316780271557329%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161697945316780271557329&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-105954705.first_rank_v2_pc_rank_v29&amp;utm_term=nginx</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity</title>
    <url>/2020/10/06/SpringSecurity/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_22172133/article/details/86503223?ops_request_misc=%7B%22request_id%22:%22160190988819724839218447%22,%22scm%22:%2220140713.130102334..%22%7D&amp;request_id=160190988819724839218447&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v3~pc_rank_v2-1-86503223.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=springsecurity&amp;spm=1018.2118.3001.4187">参考博客</a> 项目：security</p>
<h1 id="Spring与SpringSecurity"><a href="#Spring与SpringSecurity" class="headerlink" title="Spring与SpringSecurity"></a>Spring与SpringSecurity</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>项目名称：spring_security_management</p>
<p>完成权限管理需要的三个对象</p>
<ul>
<li><p>用户：主要包含用户名，密码和当前用户的角色信息，可实现认证操作。 </p>
</li>
<li><p>角色：主要包含角色名称，角色描述和当前角色拥有的权限信息，可实现授权操作。</p>
</li>
<li><p>权限：权限也可以称为菜单，主要包含当前权限名称，url地址等信息，可实现动态展示菜单。</p>
</li>
<li><p>注：这三个对象中，用户与角色是多对多的关系，角色与权限是多对多的关系，用户与权限没有直接关系， 二者是通过角色来建立关联关系的。</p>
</li>
</ul>
<p>导入jar包</p>
<blockquote>
<p>Spring Security主要jar包功能介绍</p>
<p> spring-security-core.jar 核心包，任何Spring Security功能都需要此包。</p>
<p> spring-security-web.jar web工程必备，包含过滤器和相关的Web安全基础结构代码。</p>
<p> spring-security-config.jar 用于解析xml配置文件，用到Spring Security的xml配置文件的就要用到此包。</p>
<p> spring-security-taglibs.jar Spring Security提供的动态标签库，jsp页面可以用。</p>
</blockquote>
<p>在项目中只需要引入后两个jar包就可以</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-taglibs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在web.xml中进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    SpringSecurity核心过滤器链--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在类路径下创建spring-security.xml进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置springSecurity--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    auto-config表示自动加载springSecurity的配置文件--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    use-expressions表示使用spring的el表达式来配置springSecuritty--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">&quot;true&quot;</span> <span class="attr">use-expressions</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--拦截所有资源 只有ROLE_USER角色才能访问资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">&quot;/**&quot;</span> <span class="attr">access</span>=<span class="string">&quot;hasAnyRole(&#x27;ROLE_UESR&#x27;)&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--设置Spring Security认证用户信息的来源--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    noop表示不加密认证--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    先不从数据库中获取 在内存中定义两个用户--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security:authentication-provider</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">security:user-service</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">password</span>=<span class="string">&quot;&#123;noop&#125;user&quot;</span></span></span><br><span class="line"><span class="tag">                           <span class="attr">authorities</span>=<span class="string">&quot;ROLE_USER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">&quot;admin&quot;</span> <span class="attr">password</span>=<span class="string">&quot;&#123;noop&#125;admin&quot;</span></span></span><br><span class="line"><span class="tag">                           <span class="attr">authorities</span>=<span class="string">&quot;ROLE_ADMIN&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">security:user-service</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有springmvc的项目中有两个容器 一个是父容器 spring的 一个是子容器 springMVC的 子容器能访问父容器 父容器不能访问子容器 外界只能访问子容器 访问不到父容器 所以在父容器中引入spirngSecurity配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    引入springSecurity配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath: spring-security.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>常用过滤器</p>
<ul>
<li>org.springframework.security.web.context.SecurityContextPersistenceFilter:SecurityContextPersistenceFilter主要是使用SecurityContextRepository在session中保存或更新一个 SecurityContext，并将SecurityContext给以后的过滤器使用，来为后续filter建立所需的上下文。 SecurityContext中存储了当前用户的认证以及权限信息</li>
<li>org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter:此过滤器用于集成SecurityContext到Spring异步执行机制中的WebAsyncManager</li>
<li>org.springframework.security.web.header.HeaderWriterFilter：向请求的Header中添加相应的信息,可在http标签内部使用security:headers来控制</li>
<li>org.springframework.security.web.csrf.CsrfFilter:csrf又称跨域请求伪造，SpringSecurity会对所有post请求验证是否包含系统生成的csrf的token信息， 如果不包含，则报错。起到防止csrf攻击的效果。</li>
<li>org.springframework.security.web.authentication.logout.LogoutFilter:匹配URL为/logout的请求，实现用户退出,清除认证信息。</li>
<li>org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter:认证操作全靠这个过滤器，默认匹配URL为/login且必须为POST请求</li>
<li>org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter:如果没有在配置文件中指定认证页面，则由该过滤器生成一个默认认证页面。</li>
<li>org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter:由此过滤器可以生产一个默认的退出登录页面</li>
<li>org.springframework.security.web.authentication.<a href="http://www.basicauthenticationfilter/">www.BasicAuthenticationFilter</a> 此过滤器会自动解析HTTP请求中头部名字为Authentication，且以Basic开头的头信息。</li>
<li>org.springframework.security.web.savedrequest.RequestCacheAwareFilter:通过HttpSessionRequestCache内部维护了一个RequestCache，用于缓存HttpServletRequest</li>
<li>org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter:针对ServletRequest进行了一次包装，使得request具有更加丰富的API</li>
<li>org.springframework.security.web.authentication.AnonymousAuthenticationFilter:当SecurityContextHolder中认证信息为空,则会创建一个匿名用户存入到SecurityContextHolder中。 spring security为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份。</li>
<li>org.springframework.security.web.session.SessionManagementFilter SecurityContextRepository:限制同一用户开启多个会话的数量</li>
<li>org.springframework.security.web.access.ExceptionTranslationFilter:异常转换过滤器位于整个springSecurityFilterChain的后方，用来转换整个链路中出现的异常</li>
<li>org.springframework.security.web.access.intercept.FilterSecurityInterceptor:获取所配置资源访问的授权信息，根据SecurityContextHolder中存储的用户信息来决定其是否有权 限。</li>
</ul>
<p><a href="https://www.bilibili.com/video/BV1EE411u7YV?p=9">过滤器链加载原理</a></p>
<h2 id="使用自定义认证页面"><a href="#使用自定义认证页面" class="headerlink" title="使用自定义认证页面"></a>使用自定义认证页面</h2><p>在spring-security.xml的 &lt;security:http&gt;标签中进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        让认证页面可以匿名访问 要在释放所有资源前设置 不然会死循环：</span></span><br><span class="line"><span class="comment">			访问自定义的登录页面没有权限 跳转到默认的登录页面 但是 默认的登录页面被设置为自定义页面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">&quot;/login.jsp&quot;</span> <span class="attr">access</span>=<span class="string">&quot;permitAll()&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        配置登录信息--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--login-processing-url 指定认证的处理器地址 不用自己书写--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--defautl-target-url 默认跳转的页面--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--authentication-failure-url 失败跳转页面--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--登录验证页面使用username和password接受参数</span></span><br><span class="line"><span class="comment">            可以使用username-parameter password-parameter指定自定义登录页面的自定义的参数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">security:form-login</span> <span class="attr">login-page</span>=<span class="string">&quot;/login.jsp&quot;</span></span></span><br><span class="line"><span class="tag">                              <span class="attr">login-processing-url</span>=<span class="string">&quot;/login&quot;</span></span></span><br><span class="line"><span class="tag">                              <span class="attr">default-target-url</span>=<span class="string">&quot;/index.jsp&quot;</span></span></span><br><span class="line"><span class="tag">                              <span class="attr">authentication-failure-url</span>=<span class="string">&quot;/failer.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        配置退出登录信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">security:logout</span> <span class="attr">logout-url</span>=<span class="string">&quot;/logout&quot;</span> <span class="attr">logout-success-url</span>=<span class="string">&quot;/login.jsp&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<p>在&lt;secruity:http&gt;外配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    释放静态资源 不然页面不能被美化--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">pattern</span>=<span class="string">&quot;/css/**&quot;</span> <span class="attr">security</span>=<span class="string">&quot;none&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">pattern</span>=<span class="string">&quot;/img/**&quot;</span> <span class="attr">security</span>=<span class="string">&quot;none&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">pattern</span>=<span class="string">&quot;/plugins/**&quot;</span> <span class="attr">security</span>=<span class="string">&quot;none&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>login.jsp的表单提交必须是post方法(后面解释) 并且数据要提交到login处理器</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/login&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="csrf拦截"><a href="#csrf拦截" class="headerlink" title="csrf拦截"></a>csrf拦截</h2><p><a href="https://blog.csdn.net/xiaoxinshuaiga/article/details/80766369">什么是csrf</a></p>
<p>为了解决访问不成功的情况 可以关闭csrf拦截(不推荐)或者改变crsf防护措施</p>
<p>关闭csrf拦截：在spring-security.xml的 &lt;security:http&gt;标签中进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security:csrf</span> <span class="attr">disabled</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>crsf防护措施：</p>
<p>在login.jsp中添加tag </p>
<figure class="highlight erb"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby">@taglib prefix=<span class="string">&quot;security&quot;</span> uri=<span class="string">&quot;http://www.springframework.org/security/tags&quot;</span> </span><span class="xml"><span class="tag">%&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>在表单中添加下列代码，使form表单携带token</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;security:csrfInput/&gt;</span></span><br></pre></td></tr></table></figure>

<p>查看csrfFilter源码</p>
<p><img src="/2020/10/06/SpringSecurity/image-20201023221021102.png" alt="image-20201023221021102"></p>
<p><img src="/2020/10/06/SpringSecurity/image-20201023221037008.png" alt="image-20201023221037008"></p>
<p><img src="/2020/10/06/SpringSecurity/image-20201023221055177.png" alt="image-20201023221055177"></p>
<p>只有这四个请求方法 不被csrf拦截 所以login.jsp中的form表单提交方式是post 可以保证安全性 </p>
<h2 id="注销功能"><a href="#注销功能" class="headerlink" title="注销功能"></a>注销功能</h2><p>在header.jsp中设置注销的处理器logout</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;pull-right&quot;</span>&gt;</span><br><span class="line">   &lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/logout&quot;</span></span><br><span class="line">      class=&quot;btn btn-default btn-flat&quot;&gt;注销&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>但是这种方式是Get方式  不会被csrf拦截 不能保证安全 要改成post方法  </p>
<p>在head.jsp中添加tag</p>
<figure class="highlight erb"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby">@taglib prefix=<span class="string">&quot;security&quot;</span> uri=<span class="string">&quot;http://www.springframework.org/security/tags&quot;</span> </span><span class="xml"><span class="tag">%&gt;</span>	`</span></span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;pull-right&quot;</span></span><br><span class="line">   &lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/logout&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">	  &lt;security:csrfInput/&gt;</span><br><span class="line">      &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;注销&quot;</span>&gt;</span><br><span class="line">   &lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="用数据库信息做认证"><a href="#用数据库信息做认证" class="headerlink" title="用数据库信息做认证"></a>用数据库信息做认证</h2><p>使UserService接口继承UserDetailsService</p>
<p>并在UserServiceImpl中实现loadUesrByUesrname方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户在浏览器中输入的用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> UserDetails 是springSecurity自己的用户对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UsernameNotFoundException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SysUser user = userDao.findByName(username);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  <span class="comment">//返回null代表认证失败</span></span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;SimpleGrantedAuthority&gt; authorities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;SysRole&gt; roles = user.getRoles();</span><br><span class="line">        <span class="keyword">for</span>(SysRole role:roles)&#123;</span><br><span class="line">            authorities.add(<span class="keyword">new</span> SimpleGrantedAuthority(role.getRoleName()));</span><br><span class="line">        &#125;</span><br><span class="line">        UserDetails userDetails = <span class="keyword">new</span> User(user.getUsername(),<span class="string">&quot;&#123;noop&#125;&quot;</span>+user.getPassword(),authorities);</span><br><span class="line">        <span class="keyword">return</span> userDetails;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并在spring-security.xml中进行修改</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security:authentication-provider</span> <span class="attr">user-service-ref</span>=<span class="string">&quot;userServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>输入数据库中存储的usr的用户名和密码即可登录</p>
<p>在用户管理 修改角色 保存的时候会被csrf拦截 需要在user-role-add.jsp中进行配置</p>
<h2 id="加密认证"><a href="#加密认证" class="headerlink" title="加密认证"></a>加密认证</h2><p>在spring-security.xml中进行配置  把{noop}去掉</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;passwordEncoder&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder&quot;</span></span></span><br><span class="line">&lt;security:authentication-manager&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">security:authentication-provider</span> <span class="attr">user-service-ref</span>=<span class="string">&quot;userServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">security:password-encoder</span> <span class="attr">ref</span>=<span class="string">&quot;passwordEncoder&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在UserServiceImpl中注入 BCryptPasswordEncoder 并修改save方法 在保存用户的时候加密密码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(SysUser user)</span> </span>&#123;</span><br><span class="line">    user.setPassword(passwordEncoder.encode(user.getPassword()));</span><br><span class="line">    userDao.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>登录时发现登录不上 因为输入的密码时明文 数据库中的数据是加密后的密码 </p>
<p>并且密码错误的时候 不会跳转到失败页面 因为 失败页面需要权限 user或admin 登录失败的话没有权限 所以要把failer.jsp放行</p>
<h2 id="认证用户状态的判断"><a href="#认证用户状态的判断" class="headerlink" title="认证用户状态的判断"></a>认证用户状态的判断</h2><p>UserDetails的实现类User的另一个构造方法多出了4个bool值 默认为true</p>
<ul>
<li>boolean enabled 是否可用</li>
<li>boolean accountNonExpired 账户是否失效</li>
<li>boolean credentialsNonExpired 秘密是否失效</li>
<li>boolean accountNonLocked 账户是否锁定</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserDetails userDetails = <span class="keyword">new</span> User(user.getUsername(),user.getPassword(),user.getStatus() == <span class="number">1</span>,<span class="keyword">true</span>,<span class="keyword">true</span>,<span class="keyword">true</span>,authorities);</span><br></pre></td></tr></table></figure>

<h2 id="Remember-me"><a href="#Remember-me" class="headerlink" title="Remember-me"></a>Remember-me</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;checkbox icheck&quot;</span>&gt;</span><br><span class="line">   &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot; value=&quot;true&quot;&gt; 记住 下次自动登录&lt;/label&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>name的值一定是remember-me</p>
<p>查看源码 UsernamePasswordAuthenticationFilter的父类AbstractAuthenticationProcessingFilter的认证成功的方法successfulAuthentication</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">*/</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">successfulAuthentication</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">		HttpServletResponse response, FilterChain chain, Authentication authResult)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Authentication success. Updating SecurityContextHolder to contain: &quot;</span></span><br><span class="line">				+ authResult);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//把认证后得到的结果 放入到容器中</span></span><br><span class="line">	SecurityContextHolder.getContext().setAuthentication(authResult);</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fire event</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.eventPublisher != <span class="keyword">null</span>) &#123;</span><br><span class="line">		eventPublisher.publishEvent(<span class="keyword">new</span> InteractiveAuthenticationSuccessEvent(</span><br><span class="line">				authResult, <span class="keyword">this</span>.getClass()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看loginSuccess接口的实现类AbstractRememberMeServices </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">loginSuccess</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">      HttpServletResponse response, Authentication successfulAuthentication)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//parameter被定义为remember-me</span></span><br><span class="line">   <span class="keyword">if</span> (!rememberMeRequested(request, parameter)) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Remember-me login not requested.&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   onLoginSuccess(request, response, successfulAuthentication);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看rememberMeRequested方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">rememberMeRequested</span><span class="params">(HttpServletRequest request, String parameter)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (alwaysRemember) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String paramValue = request.getParameter(parameter);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (paramValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//这四个值都会开启remember-me功能</span></span><br><span class="line">      <span class="keyword">if</span> (paramValue.equalsIgnoreCase(<span class="string">&quot;true&quot;</span>) || paramValue.equalsIgnoreCase(<span class="string">&quot;on&quot;</span>)</span><br><span class="line">            || paramValue.equalsIgnoreCase(<span class="string">&quot;yes&quot;</span>) || paramValue.equals(<span class="string">&quot;1&quot;</span>)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Did not send remember-me cookie (principal did not set parameter &#x27;&quot;</span></span><br><span class="line">            + parameter + <span class="string">&quot;&#x27;)&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看onLoginSucess的实现类PersistentTokenBasedRememberMeServices</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLoginSuccess</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">      HttpServletResponse response, Authentication successfulAuthentication)</span> </span>&#123;</span><br><span class="line">   String username = successfulAuthentication.getName();</span><br><span class="line"></span><br><span class="line">   logger.debug(<span class="string">&quot;Creating new persistent login for user &quot;</span> + username);</span><br><span class="line"></span><br><span class="line">   PersistentRememberMeToken persistentToken = <span class="keyword">new</span> PersistentRememberMeToken(</span><br><span class="line">         username, generateSeriesData(), generateTokenData(), <span class="keyword">new</span> Date());</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//把token持久化到数据库中</span></span><br><span class="line">      tokenRepository.createNewToken(persistentToken);</span><br><span class="line">       <span class="comment">//把token写入到浏览器的cookie中</span></span><br><span class="line">      addCookie(persistentToken, request, response);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      logger.error(<span class="string">&quot;Failed to save persistent token &quot;</span>, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启remember-me过滤器 设置token存储时间为60s--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">security:remember-me</span> <span class="attr">token-validity-seconds</span>=<span class="string">&quot;60&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>安全分析</p>
<p>remember-me功能方便是大家看得见的，但是安全性却令人担忧。因为Cookie毕竟是保存在客户端的，很容易盗取，而且 cookie的值还与用户名、密码这些敏感数据相关，虽然加密了，但是将敏感信息存在客户端，还是不太安全。那么 这就要提醒喜欢使用此功能的，用完网站要及时手动退出登录，清空认证信息。 此外，SpringSecurity还提供了remember me的另一种相对更安全的实现机制 :在客户端的cookie中，仅保存一个 无意义的加密串（与用户名、密码等敏感数据无关），然后在db中保存该加密串-用户信息的对应关系，自动登录 时，用cookie中的加密串，到db中验证，如果通过，自动登录才算通过。</p>
<p>创建一个表 注意这张表的名称和字段都是固定的，不要修改。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`persistent_logins`</span> (</span><br><span class="line"><span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`series`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`token`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`last_used`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`series`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure>

<p>在spring-security.xml中进行修改</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	开启remember me过滤器，</span></span><br><span class="line"><span class="comment">	data-source-ref=&quot;dataSource&quot; 指定数据库连接池</span></span><br><span class="line"><span class="comment">	token-validity-seconds=&quot;60&quot; 设置token存储时间为60秒 可省略</span></span><br><span class="line"><span class="comment">	remember-me-parameter=&quot;remember-me&quot; 指定记住的参数名 可省略</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">security:remember-me</span> <span class="attr">data-source-ref</span>=<span class="string">&quot;dataSource&quot;</span></span></span><br><span class="line"><span class="tag">					  <span class="attr">token-validity-seconds</span>=<span class="string">&quot;60&quot;</span></span></span><br><span class="line"><span class="tag">					  <span class="attr">remember-me-parameter</span>=<span class="string">&quot;remember-me&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="认证通过后显示当前认证的用户名"><a href="#认证通过后显示当前认证的用户名" class="headerlink" title="认证通过后显示当前认证的用户名"></a>认证通过后显示当前认证的用户名</h2><p>使用动态标签：在header.jsp中导入springSecurity的标签</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hidden-xs&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">%--</span>&lt;<span class="attr">security:authentication</span> <span class="attr">property</span>=<span class="string">&quot;principal.username&quot;</span> /&gt;</span>--%&gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">security:authentication</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>这两种方式都能获取到用户名</p>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="页面控制菜单的显示或隐藏"><a href="#页面控制菜单的显示或隐藏" class="headerlink" title="页面控制菜单的显示或隐藏"></a>页面控制菜单的显示或隐藏</h3><p>在aside.jsp中引入动态标签</p>
<p>使用&lt;security:authorize&gt; 对不同的角色展示不同的内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;treeview-menu&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">security:authorize</span> <span class="attr">access</span>=<span class="string">&quot;hasAnyRole(&#x27;ROLE_PRODUCT&#x27;,&#x27;ROLE_USER&#x27;)&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;system-setting&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">                                    <span class="attr">href</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/product/findAll&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-circle-o&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 产品管理</span><br><span class="line">             <span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">security:authorize</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">security:authorize</span> <span class="attr">access</span>=<span class="string">&quot;hasAnyRole(&#x27;ROLE_ORDER&#x27;,&#x27;ROLE_USER&#x27;)&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;system-setting&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">                                    <span class="attr">href</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/order/findAll&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-circle-o&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 订单管理</span><br><span class="line">             <span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">security:authorize</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 现在虽然不同角色的用户看到的内容不同 但是 当一个order想要看product的内容时可以通过url进行访问</p>
<h3 id="IOC容器结构说明"><a href="#IOC容器结构说明" class="headerlink" title="IOC容器结构说明"></a>IOC容器结构说明</h3><p><img src="/2020/10/06/SpringSecurity/image-20201026154731075.png" alt="image-20201026154731075">    </p>
<p>Controller是子容器 Service是父容器</p>
<p>权限控制的注解要加在service层 安全性较高 现在项目中没有写order和product的业务层代码 所以先把注解写在controller层</p>
<h3 id="开启动态权限注解支持"><a href="#开启动态权限注解支持" class="headerlink" title="开启动态权限注解支持"></a>开启动态权限注解支持</h3><p><img src="/2020/10/06/SpringSecurity/image-20201026155851547.png" alt="image-20201026155851547"></p>
<p><img src="/2020/10/06/SpringSecurity/image-20201026155902297.png" alt="image-20201026155902297"></p>
<p>注解和注解支持必须配套 也就是说要同时在父容器或者同时在主容器：springsecurity.xml被父容器application.xml引用 </p>
<p>而@Secured注解在子容器上 所以不匹配 要把注解支持放在子容器spring-mvc.xml中</p>
<h3 id="动态权限注解使用说明"><a href="#动态权限注解使用说明" class="headerlink" title="动态权限注解使用说明"></a>动态权限注解使用说明</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@Secured(&#123;&quot;ROLE_PRODUCT&quot;,&quot;ROLE_USER&quot;&#125;) //springsecurity内部制定的注解</span><br><span class="line">@RolesAllowed(&#123;&quot;ROLE_PRODUCT&quot;,&quot;ROLE_USER&quot;&#125;) //jsr250注解</span><br><span class="line">@PreAuthorize(&quot;hasAnyAuthority(&#x27;ROLE_PRODUCT&#x27;,&#x27;ROLE_USER&#x27;)&quot;)//spring指定的注解 需要使用el表达式 hasAnyRole也可以</span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>方法一：在spring-security.xml中进行配置 这种方式比较单一 这能处理403异常</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">security</span>:<span class="keyword">access</span>-denied-<span class="keyword">handler</span> error-page=&quot;/403.jsp&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>方法二：在web.xml中进行配置 处理各种异常 这种方式只适合web项目</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方法三：使用处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerControllerException</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> httpServletRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> httpServletResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 出现异常的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 出现的异常信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ModelAndView</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> </span>&#123;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">//将异常信息放入request域 基本不用</span></span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;errorMsg&quot;</span>,e.getMessage());</span><br><span class="line">        <span class="comment">//指定不同异常跳转的页面</span></span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> AccessDeniedException)&#123;</span><br><span class="line">            modelAndView.setViewName(<span class="string">&quot;redirect:/403.jsp&quot;</span>); <span class="comment">//redict和forward不经过视图解析器</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            modelAndView.setViewName(<span class="string">&quot;redirect:/500.jsp&quot;</span>); <span class="comment">//redict和forward不经过视图解析器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简易写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerControllerAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(AccessDeniedException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handlerException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/403.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ExceptionHandler(RuntimeException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">runtimeException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/500.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SpringBoot与SpringSecurity"><a href="#SpringBoot与SpringSecurity" class="headerlink" title="SpringBoot与SpringSecurity"></a>SpringBoot与SpringSecurity</h1><h2 id="集中式版"><a href="#集中式版" class="headerlink" title="集中式版"></a>集中式版</h2><p>项目：springboot_security_jsp前端页面直接复用上一个项目</p>
<p>导入jar包：导入后就为项目配置了默认的安全认证</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>集中式的项目一般使用jsp 但是springboot官方不推荐使用jsp 想使用的话 需要导入tomcat插件启动项目 不能再用springboot默认的tomcat了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>把登录和注销的url改成login和logout处理器</p>
<p>创建一个配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(securedEnabled=true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使自己的类继承UserDetails并覆盖方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysUser</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="keyword">private</span> List&lt;SysRole&gt; roles;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="comment">//返回角色</span></span><br><span class="line">        <span class="keyword">return</span> roles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysRole</span> <span class="keyword">implements</span> <span class="title">GrantedAuthority</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String roleDesc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoleName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roleName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoleName</span><span class="params">(String roleName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roleName = roleName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoleDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roleDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoleDesc</span><span class="params">(String roleDesc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roleDesc = roleDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roleName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@jsonIgnoreL对象可能会和json字符串互相转换 需要将重写的属性忽略掉</p>
<p>创建role的mapper和user的mapper</p>
<p>使UserService继承UserDetailsService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.findByName(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再配置类中指定认证对象的来源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    auth.userDetailsService(userService).passwordEncoder(passwordEncoder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启动态授权 ：再配置类上添加@EnableGlobalMethodSecurity(securedEnabled=true) 查看源码 也有三种方式</p>
<p>再controller中的方法上添加注解：@Secured(“ROLE_PRODUCT”)</p>
<p>异常处理和spring处理方式相同</p>
<h2 id="分布式版"><a href="#分布式版" class="headerlink" title="分布式版"></a>分布式版</h2><p>项目：spirngboot_security_jwt_rsa_parent</p>
<p>分布式是单点登录的</p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027084357515.png" alt="image-20201027084357515"></p>
<p>token的安全与否，直接关系到系统的 健壮性，这里我们选择使用JWT来实现token的生成和校验。</p>
<p>JWT，全称JSON Web Token 是一款出色的分布式身份校验方案。可以生成token，也可 以解析检验token。</p>
<p>JWT生成的token由三部分组成：</p>
<ul>
<li>头部：主要设置一些规范信息，签名部分的编码格式就在头部中声明。</li>
<li>载荷：token中存放有效信息的部分，比如用户名，用户角色，过期时间等，但是不要放密码，会泄露！</li>
<li>签名：将头部与载荷分别采用base64编码后，用“.”相连，再加入盐，最后使用头部声明的编码类型进行编 码，就得到了签名。</li>
</ul>
<p>从JWT生成的token组成上来看，要想避免token被伪造，主要就得看签名部分了，而签名部分又有三部分组成，其 中头部和载荷的base64编码，几乎是透明的，毫无安全性可言，那么最终守护token安全的重担就落在了加入的盐上面了！</p>
<p>试想：如果生成token所用的盐与解析token时加入的盐是一样的。岂不是类似于中国人民银行把人民币防伪技术 公开了？大家可以用这个盐来解析token，就能用来伪造token。</p>
<p>这时，我们就需要对盐采用非对称加密(RAS)的方式进行加密，以达到生成token与校验token方所用的盐不一致的安全 效果！</p>
<p>RAS</p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027084854865.png" alt="image-20201027084854865"></p>
<p>jwt相关工具类</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>分布式认证流程</p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027090522281.png" alt="image-20201027090522281"></p>
<h3 id="common模块"><a href="#common模块" class="headerlink" title="common模块"></a>common模块</h3><p> 为了方便后期获取token中的用户信息，将token中载荷部分单独封装成一个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Payload</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> T userInfo;</span><br><span class="line">    <span class="keyword">private</span> Date expiration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三个工具类</p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027092638446.png" alt="image-20201027092638446"></p>
<p>再测试类中生成公钥和私钥</p>
<h3 id="认证模块"><a href="#认证模块" class="headerlink" title="认证模块"></a>认证模块</h3><p>创建一个配置类 在applacation.yml中配置公钥和私钥的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;rsa.key&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RsaKeyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pubKeyFile;</span><br><span class="line">    <span class="keyword">private</span> String priKeyFile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PublicKey publicKey;</span><br><span class="line">    <span class="keyword">private</span> PrivateKey privateKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createRsaKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        publicKey = RsaUtils.getPublicKey(pubKeyFile);</span><br><span class="line">        privateKey = RsaUtils.getPrivateKey(priKeyFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在项目启动的时候把这个配置类放到ioc容器中</p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027094026084.png" alt="image-20201027094026084"></p>
<p>重写认证的处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtLoginFilter</span> <span class="keyword">extends</span> <span class="title">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="keyword">private</span> RsaKeyProperties prop;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JwtLoginFilter</span><span class="params">(AuthenticationManager authenticationManager, RsaKeyProperties prop)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authenticationManager = authenticationManager;</span><br><span class="line">        <span class="keyword">this</span>.prop = prop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用户输入的账号和密码</span></span><br><span class="line">            SysUser sysUser = <span class="keyword">new</span> ObjectMapper().readValue(request.getInputStream(), SysUser.class);</span><br><span class="line">            UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(sysUser.getUsername(), sysUser.getPassword());</span><br><span class="line">            <span class="keyword">return</span> authenticationManager.authenticate(authRequest);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">                PrintWriter out = response.getWriter();</span><br><span class="line">                Map resultMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">                resultMap.put(<span class="string">&quot;code&quot;</span>, HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">                resultMap.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">                out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(resultMap));</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception outEx)&#123;</span><br><span class="line">                outEx.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//认证成功 返回一个token</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">successfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        SysUser user = <span class="keyword">new</span> SysUser();</span><br><span class="line">        user.setUsername(authResult.getName());</span><br><span class="line">        user.setRoles((List&lt;SysRole&gt;) authResult.getAuthorities());</span><br><span class="line">        String token = JwtUtils.generateTokenExpireInMinutes(user, prop.getPrivateKey(), <span class="number">24</span> * <span class="number">60</span>);</span><br><span class="line">        response.addHeader(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer &quot;</span>+token);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">            PrintWriter out = response.getWriter();</span><br><span class="line">            Map resultMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">            resultMap.put(<span class="string">&quot;code&quot;</span>, HttpServletResponse.SC_OK);</span><br><span class="line">            resultMap.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;认证通过！&quot;</span>);</span><br><span class="line">            out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(resultMap));</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception outEx)&#123;</span><br><span class="line">            outEx.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写验证的处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtVerifyFilter</span> <span class="keyword">extends</span> <span class="title">BasicAuthenticationFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RsaKeyProperties prop;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JwtVerifyFilter</span><span class="params">(AuthenticationManager authenticationManager, RsaKeyProperties prop)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(authenticationManager);</span><br><span class="line">        <span class="keyword">this</span>.prop = prop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        String header = request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (header == <span class="keyword">null</span> || !header.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//如果携带错误的token，则给用户提示请登录！</span></span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">            PrintWriter out = response.getWriter();</span><br><span class="line">            Map resultMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">            resultMap.put(<span class="string">&quot;code&quot;</span>, HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">            resultMap.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;请登录！&quot;</span>);</span><br><span class="line">            out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(resultMap));</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果携带了正确格式的token要先得到token</span></span><br><span class="line">            String token = header.replace(<span class="string">&quot;Bearer &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="comment">//验证tken是否正确</span></span><br><span class="line">            Payload&lt;SysUser&gt; payload = JwtUtils.getInfoFromToken(token, prop.getPublicKey(), SysUser.class);</span><br><span class="line">            SysUser user = payload.getUserInfo();</span><br><span class="line">            <span class="keyword">if</span>(user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                UsernamePasswordAuthenticationToken authResult = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(user.getUsername(), <span class="keyword">null</span>, user.getAuthorities());</span><br><span class="line">                SecurityContextHolder.getContext().setAuthentication(authResult);</span><br><span class="line">                chain.doFilter(request, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(securedEnabled=true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RsaKeyProperties prop;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BCryptPasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定认证对象的来源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService(userService).passwordEncoder(passwordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//SpringSecurity配置信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf()</span><br><span class="line">            .disable()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/product&quot;</span>).hasAnyRole(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">            .anyRequest()</span><br><span class="line">            .authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .addFilter(<span class="keyword">new</span> JwtLoginFilter(<span class="keyword">super</span>.authenticationManager(), prop))</span><br><span class="line">            .addFilter(<span class="keyword">new</span> JwtVerifyFilter(<span class="keyword">super</span>.authenticationManager(), prop))</span><br><span class="line">            <span class="comment">//分布式中不需要session 关闭session会话</span></span><br><span class="line">            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>csrf如果放到最后 就认为配置完了 他的后面不能接and()方法</p>
<h3 id="资源服务器"><a href="#资源服务器" class="headerlink" title="资源服务器"></a>资源服务器</h3><p>删除私钥的相关配置 删除验证的filter</p>
<h1 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h1><p>介绍</p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027103837995.png" alt="image-20201027103837995"></p>
<h2 id="四种授权模式"><a href="#四种授权模式" class="headerlink" title="四种授权模式"></a>四种授权模式</h2><p><img src="/2020/10/06/SpringSecurity/image-20201027134625845.png" alt="image-20201027134625845"></p>
<h3 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h3><p><img src="/2020/10/06/SpringSecurity/image-20201027134905409.png" alt="image-20201027134905409"></p>
<h3 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h3><p><img src="/2020/10/06/SpringSecurity/image-20201027141026128.png" alt="image-20201027141026128"></p>
<h3 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h3><p><img src="/2020/10/06/SpringSecurity/image-20201027141037837.png" alt="image-20201027141037837"></p>
<h3 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h3><p><img src="/2020/10/06/SpringSecurity/image-20201027141155826.png" alt="image-20201027141155826"></p>
<h2 id="OAuth2再项目中的使用"><a href="#OAuth2再项目中的使用" class="headerlink" title="OAuth2再项目中的使用"></a>OAuth2再项目中的使用</h2><p><img src="/2020/10/06/SpringSecurity/image-20201027142016480.png" alt="image-20201027142016480"></p>
<p>建表：oauth2</p>
<p>oauth_client_details</p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027142906886.png" alt="image-20201027142906886"></p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027142928308.png" alt="image-20201027142928308"></p>
<h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2><h3 id="资源服务器-1"><a href="#资源服务器-1" class="headerlink" title="资源服务器"></a>资源服务器</h3><p>其他服务可以通过token在资源服务器中访问资源</p>
<p>创建配置类:把当前服务器交给oauth2的一个资源服务管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span> <span class="comment">//作为资源服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OauthSourceConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定token的持久化策略</span></span><br><span class="line"><span class="comment">     * InMemoryTokenStore表示将token存储在内存</span></span><br><span class="line"><span class="comment">     * Redis表示将token存储在redis中</span></span><br><span class="line"><span class="comment">     * JdbcTokenStore存储在数据库中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TokenStore <span class="title">jdbcTokenStore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTokenStore(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定当前资源的id和存储方案</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resources</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        resources.resourceId(<span class="string">&quot;product_api&quot;</span>).tokenStore(jdbcTokenStore());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                <span class="comment">//指定不同请求方式访问资源所需要的权限，一般查询是read，其余是write。</span></span><br><span class="line">                .antMatchers(HttpMethod.GET, <span class="string">&quot;/**&quot;</span>).access(<span class="string">&quot;#oauth2.hasScope(&#x27;read&#x27;)&quot;</span>)</span><br><span class="line">                .antMatchers(HttpMethod.POST, <span class="string">&quot;/**&quot;</span>).access(<span class="string">&quot;#oauth2.hasScope(&#x27;write&#x27;)&quot;</span>)</span><br><span class="line">                .antMatchers(HttpMethod.PATCH, <span class="string">&quot;/**&quot;</span>).access(<span class="string">&quot;#oauth2.hasScope(&#x27;write&#x27;)&quot;</span>)</span><br><span class="line">                .antMatchers(HttpMethod.PUT, <span class="string">&quot;/**&quot;</span>).access(<span class="string">&quot;#oauth2.hasScope(&#x27;write&#x27;)&quot;</span>)</span><br><span class="line">                .antMatchers(HttpMethod.DELETE, <span class="string">&quot;/**&quot;</span>).access(<span class="string">&quot;#oauth2.hasScope(&#x27;write&#x27;)&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .headers().addHeaderWriter((request, response) -&gt; &#123;</span><br><span class="line">            response.addHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);<span class="comment">//允许跨域</span></span><br><span class="line">            <span class="keyword">if</span> (request.getMethod().equals(<span class="string">&quot;OPTIONS&quot;</span>)) &#123;<span class="comment">//如果是跨域的预检请求，则原封不动向下传达请求头信息</span></span><br><span class="line">                response.setHeader(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, request.getHeader(<span class="string">&quot;Access-Control-Request-Method&quot;</span>));</span><br><span class="line">                response.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, request.getHeader(<span class="string">&quot;Access-Control-Request-Headers&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入校检用户所需对象：用户是否能访问当前资源 </p>
<p>导入jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>导入用户对象：这个对象是给token用的 jwt中token是自己生成的 所以需要自己做验证 但是oauth2不是 所以需要导入用户对象 等到token验证的时候使用 </p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027145802700.png" alt="image-20201027145802700"></p>
<h3 id="认证服务"><a href="#认证服务" class="headerlink" title="认证服务"></a>认证服务</h3><p>在WebSecurityConfig中加入下面代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AuthenticationManager对象在OAuth2认证服务中要使用，提前放入IOC容器中</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建oauth2的配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OauthServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库连接池对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//认证业务对象:和springSecurity的认证是相互平行的</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//授权模式专用对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端信息来源</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcClientDetailsService <span class="title">jdbcClientDetailsService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcClientDetailsService(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//token保存策略</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TokenStore <span class="title">tokenStore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTokenStore(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//授权信息保存策略</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApprovalStore <span class="title">approvalStore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcApprovalStore(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//授权码模式数据来源</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationCodeServices <span class="title">authorizationCodeServices</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAuthorizationCodeServices(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定客户端信息的数据库来源</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.withClientDetails(jdbcClientDetailsService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查token的策略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//允许客户端以form表单的方式将token传达给你 否则只接受post请求</span></span><br><span class="line">        security.allowFormAuthenticationForClients();</span><br><span class="line">        security.checkTokenAccess(<span class="string">&quot;isAuthenticated()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//OAuth2的主配置信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        endpoints</span><br><span class="line">                .approvalStore(approvalStore())</span><br><span class="line">                .authenticationManager(authenticationManager)</span><br><span class="line">                .authorizationCodeServices(authorizationCodeServices())</span><br><span class="line">                .tokenStore(tokenStore());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向oauth_client_details中手动添加数据</p>
<h3 id="授权码模式测试"><a href="#授权码模式测试" class="headerlink" title="授权码模式测试"></a>授权码模式测试</h3><p>1.A系统向B系统申请授权码</p>
<p>在地址栏访问：<a href="http://localhost:9001/oauth/authorize?response_type=code&amp;client_id=bob">http://localhost:9001/oauth/authorize?response_type=code&amp;client_id=bob</a> </p>
<p>2.如果用户想授予A系统访问B系统的权限 需要先登录B系统</p>
<p>跳转到SpringSecurity默认认证页面，提示用户登录个人账户【这里是sys_user表中的数据】 登录后跳转到授权页面 选择approve 地址栏上会出授权码(code=FHeOhN)</p>
<p>3.在postman中进行测试</p>
<p>获取token</p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027192138055.png" alt="image-20201027192138055"></p>
<p>通过token 访问资源</p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027192322485.png" alt="image-20201027192322485"></p>
<h3 id="简化模式测试"><a href="#简化模式测试" class="headerlink" title="简化模式测试"></a>简化模式测试</h3><p>是授权码模式的简化</p>
<p>在地址栏中访问：<a href="http://localhost:9001/oauth/authorize?response_type=token&amp;client_id=bob">http://localhost:9001/oauth/authorize?response_type=token&amp;client_id=bob</a></p>
<p>在地址栏中直接返回token</p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027193505638.png" alt="image-20201027193505638"></p>
<h3 id="密码模式测试"><a href="#密码模式测试" class="headerlink" title="密码模式测试"></a>密码模式测试</h3><p>不需要在地址栏中进行访问了</p>
<p>直接在postman中进行测试</p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027194244309.png" alt="image-20201027194244309"></p>
<h3 id="客户端模式测试"><a href="#客户端模式测试" class="headerlink" title="客户端模式测试"></a>客户端模式测试</h3><p><img src="/2020/10/06/SpringSecurity/image-20201027194511486.png" alt="image-20201027194511486"></p>
<h3 id="刷新token测试"><a href="#刷新token测试" class="headerlink" title="刷新token测试"></a>刷新token测试</h3><p>刷新token的时候需要验证当前用户是否已经通过验证 需要在OauthServerConfig里的config方法中增加一条配置</p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027195405343.png" alt="image-20201027195405343"></p>
<p>授权码只能使用一次  </p>
<p>想要再次获取token需要刷利用refresh_token新token</p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027200048876.png" alt="image-20201027200048876"></p>
<h3 id="权限相关测试"><a href="#权限相关测试" class="headerlink" title="权限相关测试"></a>权限相关测试</h3><p>如果resource_id不符合 能获取到授权码 但是访问资源的时候会被拒绝</p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027200454873.png" alt="image-20201027200454873"></p>
<p>开启动态权限认证</p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027200614786.png" alt="image-20201027200614786"></p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027200834768.png" alt="image-20201027200834768"></p>
<h1 id="jwt"><a href="#jwt" class="headerlink" title="jwt"></a>jwt</h1><h2 id="jwt和传统认证对比"><a href="#jwt和传统认证对比" class="headerlink" title="jwt和传统认证对比"></a>jwt和传统认证对比</h2><p>基于传统的session认证</p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027223347608.png" alt="image-20201027223347608"></p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027223127872.png" alt="image-20201027223127872"></p>
<p>基于JWT认证</p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027223523496.png" alt="image-20201027223523496"></p>
<p><img src="/2020/10/06/SpringSecurity/image-20201027224645065.png" alt="image-20201027224645065"></p>
<h2 id="jwt结构"><a href="#jwt结构" class="headerlink" title="jwt结构"></a>jwt结构</h2><p><img src="/2020/10/06/SpringSecurity/image-20201028071311827.png" alt="image-20201028071311827"></p>
<p><img src="/2020/10/06/SpringSecurity/image-20201028071719291.png" alt="image-20201028071719291"></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>导入jar包</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;dependency&gt;</span></span><br><span class="line">    <span class="section">&lt;groupId&gt;</span><span class="attribute">com</span>.auth<span class="number">0</span>&lt;/groupId&gt;</span><br><span class="line">    <span class="section">&lt;artifactId&gt;</span><span class="attribute">java</span>-jwt&lt;/artifactId&gt;</span><br><span class="line">    <span class="section">&lt;version&gt;</span><span class="attribute">3</span>.<span class="number">4</span>.<span class="number">0</span>&lt;/version&gt;</span><br><span class="line"><span class="section">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JWT_Demo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Generate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.add(Calendar.SECOND,<span class="number">600</span>);</span><br><span class="line">        String token = JWT.create()</span><br><span class="line">                .withClaim(<span class="string">&quot;userId&quot;</span>,<span class="number">21</span>)</span><br><span class="line">                .withClaim(<span class="string">&quot;userName&quot;</span>,<span class="string">&quot;bob&quot;</span>)</span><br><span class="line">                .withExpiresAt(calendar.getTime())</span><br><span class="line">                .sign(Algorithm.HMAC256(<span class="string">&quot;dsf&quot;</span>));</span><br><span class="line">        System.out.println(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">verity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(<span class="string">&quot;dsf&quot;</span>)).build();</span><br><span class="line">        DecodedJWT verify = jwtVerifier.verify(<span class="string">&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyTmFtZSI6ImJvYiIsImV4cCI6MTYwMzg0Mjk2MSwidXNlcklkIjoyMX0.e4L6lswZH6BiWh-0fQ11iSxrJWdAFEwOPRfdLWIo6s0&quot;</span>);</span><br><span class="line">        String userName = verify.getClaim(<span class="string">&quot;userName&quot;</span>).asString();</span><br><span class="line">        <span class="keyword">int</span> userID = verify.getClaim(<span class="string">&quot;userId&quot;</span>).asInt();</span><br><span class="line">        System.out.println(userName);</span><br><span class="line">        System.out.println(userID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript</title>
    <url>/2020/10/19/javascript/</url>
    <content><![CDATA[<h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><p>document.write() 向body中输出内容</p>
<p>console.log() 向控制台输出内容</p>
<p>严格区分大小写 每一条语句以分号结尾 如果不写 系统会自动添加 但是会消耗系统资源 有时还会加错分号</p>
<p><strong>JS编写位置</strong>:可以将js代码编写到标签的onclick href属性中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">这种方式耦合度较高 不推荐使用</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;点我干什么&#x27;);&quot;</span> &gt;</span>点我试试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(&#x27;点我&#x27;);&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以在&lt;script&gt;中通过src属性 引入外部标签 一旦引入外部文件 就不能在<strong>这个</strong>&lt;script&gt;中编写其他代码了 即使编写也会被浏览器忽略 </p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>检查变量类型typeof</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">alert(<span class="keyword">typeof</span> str)</span><br></pre></td></tr></table></figure>

<p>js可以表示的数字的最大值：Number.MAX_VALUE 最小值：Number.MIN_VALUE</p>
<p>Infinity是字面量 是number类型</p>
<p>NaN也是字面量 表示不是一个数字 是number类型</p>
<p>进行浮点数运算可能不准确 0.1+0.2</p>
<p>null是object类型</p>
<p>undeined的类型就是undefined</p>
<p>其他类型转换为string ：</p>
<ul>
<li>调用toString方法 该方法不会影响到原变量 null和undefined没有该方法</li>
<li>调用函数String() null和undefined也可以转换</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">var</span> str = num.toString();</span><br><span class="line"><span class="comment">//  var str = String(num);</span></span><br><span class="line">    <span class="built_in">document</span>.write(<span class="keyword">typeof</span> num);</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&#x27;&lt;br&gt;&#x27;</span>)</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="keyword">typeof</span> str);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>其他类型转换为Number</p>
<ul>
<li>使用函数Number()：如果字符串中有非数字 转换结果为NaN 如果是空串转换结果为0 true转换为1 false转换为0 null转换为0 undefined转换为NaN</li>
<li>函数parseInt()和parseFloat():可以将字符串中开头部分的数字读取出来并转换 如果对非String使用会先将其转换为String然后再操作</li>
</ul>
<p>转换为boolean</p>
<ul>
<li>函数Boolean：数字除了0和NaN都是true  字符串除了空串 null undefined都是true</li>
</ul>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>字符串之间的+是拼接字符串  任何值和字符串做+运算都先转换为字符串然后再拼接</p>
<p>其余的运算都是先转化为number 再运算 任何值和NaN做运算都得到NaN</p>
<p>可以对任意数据类型取两次反 将其转换为bool值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> bool = !!num;</span><br></pre></td></tr></table></figure>

<p>script中使用:unicode编码<code> \uxxxx</code></p>
<p>页面中使用:unicode<code>&amp;#xxxx</code> 要把xxxx转换为十进制</p>
<p>== 如果类型不同 转换为相同类型再比较</p>
<p>=== 先比较类型是否相同 相同再继续比较值 NaN不和任何值相等 包括他本身 可以通过函数isNaN()判断一个值是否为NaN</p>
<p>代码块： 使用{}对语句进行分组 代码块中的语句要么不执行要么全执行 代码块中的内容 对外部完全可见</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>操作对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">      <span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">      person.name = <span class="string">&#x27;bob&#x27;</span>;</span><br><span class="line">      person.age = <span class="number">12</span>;</span><br><span class="line">      person.sex = <span class="string">&#x27;male&#x27;</span>;</span><br><span class="line">      <span class="comment">//删除对象属性</span></span><br><span class="line">      <span class="keyword">delete</span> person.sex</span><br><span class="line"></span><br><span class="line">      <span class="built_in">document</span>.write(person.person.sex)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>可以使用person[name] = ‘bob 定义属性 取值：<code>var name = person[name]</code>;</p>
<p>可以通过in检查对象中是否有某个属性 <code>var bool = &quot;name&quot; in person;</code></p>
<p>基本数据存储在栈内存中 值与值之间是独立存在的  修改一个变量不会影响另一个变量 </p>
<p>对象存储在堆内存中 变量是对地址的引用 修改一个变量会影响另一个变量</p>
<p>使用对象字面量创建对象<code> var person = &#123;name:&quot;bob&quot;,age:22&#125;;</code></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>定义函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> a+b;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span>  <span class="title">max</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">Math</span>.max(a,b);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">document</span>.write(sum(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line"><span class="built_in">document</span>.write(max(<span class="number">2</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>实参可以是任意类型解析器不会检查实参的数量 如果实参数量多余形参 多余的实参为undefined</p>
<p>没有return或者return后没有任何值 则返回undefined</p>
<p>函数的参数可以是任意类型 甚至可以是一个函数</p>
<p>立即执行函数 只执行一次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          alert(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">      &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如果一个函数作为对象的属性保存 称这个函数为这个对象的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">     <span class="keyword">var</span> person = &#123;<span class="attr">name</span>:<span class="string">&quot;bob&quot;</span>,<span class="attr">age</span>:<span class="number">12</span>&#125;;</span><br><span class="line">     person.method = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="built_in">document</span>.write(person.name);</span><br><span class="line">     &#125;;</span><br><span class="line">     person.method();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>遍历对象中的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>:<span class="string">&quot;bob&quot;</span>,<span class="attr">age</span>:<span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> n <span class="keyword">in</span> person)&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(n+<span class="string">&quot;&lt;br&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局作用域：页面打开时创建 页面关闭的时候销毁 创建的变量会作为window对象的属性保存</p>
<p>var声名的变量会在所有代码之前被声名 但是赋值会延迟执行  函数可以在创建之前被调用 但是通过var声名的函数 只是被声名 只能在创建之后调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//执行失败</span></span><br><span class="line">max(<span class="number">1</span>,<span class="number">2</span>)  <span class="comment">//执行成功</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">max</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数作用域：如果函数中找不到要操作的变量 就从上一级作用域中查找 直至全局作用域 没找到会报错ReferenceError</p>
<p>函数作用域中也有var声名提前的特性 定义形参就相当于在函数作用域中声明了这个变量</p>
<p>解析器在调用函数的时候会向函数内部传递一个隐式参数this this指向的是一个对象 这个对象我们称为函数执行的上下文对象 根据函数的调用方式不同 this会指向不同的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          alert(<span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> person = &#123;<span class="attr">name</span>:<span class="string">&quot;bob&quot;</span>,<span class="attr">age</span>:<span class="number">23</span>&#125;;</span><br><span class="line">      person.method = fun;</span><br><span class="line">      fun(); <span class="comment">//this:window</span></span><br><span class="line">      person.method(); <span class="comment">//this:object</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>以函数的方式调用this指向window以方法的方式调用 this指向对象</li>
</ul>
<p>构造函数：习惯上首字母大写 创建方式和普通参数没有区别 普通函数是直接调用 构造函数需要使用new关键字来使用 </p>
<p>构造函数的执行流程</p>
<pre><code>* 立即创建一个新的对象
* 将新建的对象设置为构造函数中的this
* 执行函数中的代码
* 将新建的对象作为返回值返回</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    	<span class="built_in">this</span>.name = name;</span><br><span class="line">    	<span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;bob&quot;</span>,<span class="number">23</span>);</span><br><span class="line">    <span class="built_in">document</span>.write(person.age);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>instanceof可以检查一个对象是否是一个类的实例 Object是所有对象的实例</li>
</ul>
<p>原型对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 原型 prototype</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * 	我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype</span></span><br><span class="line"><span class="comment">			 * 		这个属性对应着一个对象，这个对象就是我们所谓的原型对象</span></span><br><span class="line"><span class="comment">			 * 	如果函数作为普通函数调用prototype没有任何作用</span></span><br><span class="line"><span class="comment">			 * 	当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，</span></span><br><span class="line"><span class="comment">			 * 		指向该构造函数的原型对象，我们可以通过__proto__来访问该属性</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * 	原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，</span></span><br><span class="line"><span class="comment">			 * 		我们可以将对象中共有的内容，统一设置到原型对象中。</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，</span></span><br><span class="line"><span class="comment">			 * 	如果没有则会去原型对象中寻找，如果找到则直接使用</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * 以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，</span></span><br><span class="line"><span class="comment">			 * 	这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//向MyClass的原型中添加属性a</span></span><br><span class="line">			MyClass.prototype.a = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//向MyClass的原型中添加一个方法</span></span><br><span class="line">			MyClass.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				alert(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">var</span> mc = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">var</span> mc2 = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// console.log(MyClass.prototype);</span></span><br><span class="line">			<span class="built_in">console</span>.log(mc2.__proto__ == MyClass.prototype);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//向mc中添加a属性 会覆盖掉123</span></span><br><span class="line">			<span class="comment">// mc.a = &quot;我是mc中的a&quot;;</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// console.log(mc.a);</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// mc.sayHello();</span></span><br><span class="line">			<span class="comment">//使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true</span></span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> mc);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性</span></span><br><span class="line">			<span class="comment">//使用该方法只有当对象自身中含有属性时，才会返回true</span></span><br><span class="line">			<span class="built_in">console</span>.log(mc.hasOwnProperty(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 原型对象也是对象，所以它也有原型，</span></span><br><span class="line"><span class="comment">			 * 	当我们使用一个对象的属性或方法时，会现在自身中寻找，</span></span><br><span class="line"><span class="comment">			 * 		自身中如果有，则直接使用，</span></span><br><span class="line"><span class="comment">			 * 		如果没有则去原型对象中寻找，如果原型对象中有，则使用，</span></span><br><span class="line"><span class="comment">			 * 		如果没有则去原型的原型中寻找,直到找到Object对象的原型，</span></span><br><span class="line"><span class="comment">			 * 		Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>toString()方法</p>
<p>修改Person原型的toString</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Person[name=&quot;</span>+<span class="built_in">this</span>.name+<span class="string">&quot;,age=&quot;</span>+<span class="built_in">this</span>.age+<span class="string">&quot;,gender=&quot;</span>+<span class="built_in">this</span>.gender+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组中的元素可以是任意类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"><span class="comment">//创建一个长度为10的数组</span></span><br><span class="line"><span class="keyword">var</span> arr3 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> len = arr.length;</span><br></pre></td></tr></table></figure>

<p>数组的方法</p>
<ul>
<li><p>concat():可以连接两个或多个数组 并将新的数组返回 <code>arr.concat(arr2,&quot;xx&quot;);</code></p>
</li>
<li><p>join():该方法可以将数组转换成一个字符串 可以指定一个字符串作为参数 作为元素的连接符 不指定默认为,</p>
</li>
<li><p>reserve():反转数组</p>
</li>
<li><p>sort():排序数组 默认按照unicode进行排序</p>
<ul>
<li><pre><code>//降序排列:默认为升序
arr.sort(function (a,b)&#123;
    return b-a;
&#125;);
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">* push():该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">* pop():该方法可以删除数组的最后一个元素,并将被删除的元素作为返回值返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">* unshift():向数组开头添加一个或多个元素，并返回新的数组长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">* shift():可以删除数组的第一个元素，并将被删除的元素作为返回值返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">* slice():可以用来从数组提取指定元素 该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">  * ```javascript</span></span><br><span class="line">    参数：</span><br><span class="line"><span class="comment">    			 * 		1.截取开始的位置的索引,包含开始索引</span></span><br><span class="line"><span class="comment">    			 * 		2.截取结束的位置的索引,不包含结束索引</span></span><br><span class="line"><span class="comment">    			 * 			- 第二个参数可以省略不写,此时会截取从开始索引往后的所有元素</span></span><br><span class="line"><span class="comment">    			 * 		- 索引可以传递一个负值，如果传递一个负值，则从后往前计算</span></span><br><span class="line"><span class="comment">    			 * 			-1 倒数第一个</span></span><br><span class="line"><span class="comment">    			 * 			-2 倒数第二个</span></span><br><span class="line">    <span class="keyword">var</span> result = arr.slice(1,4);</span><br><span class="line">    result = arr.slice(1,-2);</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>splice():可以用于删除数组中的指定元素 会影响到原数组，会将指定元素从原数组中删除并返回 </p>
<ul>
<li><pre><code class="javascript">- 参数：
*     第一个，表示开始位置的索引
*     第二个，表示删除的数量
*     第三个及以后。。
*        可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边
arr = [&quot;孙悟空&quot;,&quot;猪八戒&quot;,&quot;沙和尚&quot;,&quot;唐僧&quot;,&quot;白骨精&quot;];
var result = arr.splice(3,0,&quot;牛魔王&quot;,&quot;铁扇公主&quot;,&quot;红孩儿&quot;);
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">数组的<span class="keyword">forEach</span>()方法</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">var arr = [&quot;孙悟空&quot;,&quot;猪八戒&quot;,&quot;沙和尚&quot;,&quot;唐僧&quot;,&quot;白骨精&quot;];</span><br><span class="line">//第一个参数：当前正在遍历的元素 第二个参数：就是当前正在遍历的元素的索引 第三个参数：遍历的数组</span><br><span class="line">arr.<span class="keyword">forEach</span>(<span class="keyword">function</span>(<span class="keyword">value</span> , <span class="keyword">index</span> , arr)&#123;</span><br><span class="line">   console.log(<span class="keyword">value</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>函数对象的call()和apply()</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">/<span class="emphasis">*</span></span><br><span class="line"><span class="emphasis"> *</span> call()和apply()</span><br><span class="line"><span class="bullet"> *</span>     - 这两个方法都是函数对象的方法，需要通过函数对象来调用</span><br><span class="line"><span class="bullet"> *</span>     - 当对函数调用call()和apply()都会调用函数执行</span><br><span class="line"><span class="bullet"> *</span>     - 在调用call()和apply()可以将一个对象指定为第一个参数</span><br><span class="line"><span class="bullet"> *</span>        此时这个对象将会成为函数执行时的this</span><br><span class="line"><span class="bullet"> *</span>     - call()方法可以将实参在对象之后依次传递</span><br><span class="line"><span class="bullet"> *</span>     - apply()方法需要将实参封装到一个数组中统一传递</span><br><span class="line"> <span class="emphasis">*</span></span><br><span class="line"><span class="emphasis"> *</span>     - this的情况：</span><br><span class="line"><span class="bullet"> *</span>        1.以函数形式调用时，this永远都是window</span><br><span class="line"><span class="bullet"> *</span>        2.以方法的形式调用时，this是调用方法的对象</span><br><span class="line"><span class="bullet"> *</span>        3.以构造函数的形式调用时，this是新创建的那个对象</span><br><span class="line"><span class="bullet"> *</span>        4.使用call和apply调用时，this是指定的那个对象</span><br><span class="line"> <span class="emphasis">*/</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">fun.call(obj,2,3);</span></span><br><span class="line"><span class="emphasis">fun.apply(obj,[2,3]);</span></span><br></pre></td></tr></table></figure>

<p>在调用函数时 浏览器除了this还会传递一个隐式的参数 arguments</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    - <span class="built_in">arguments</span>是一个类数组对象,它也可以通过索引来操作数据，也可以获取长度</span><br><span class="line"> *        - 在调用函数时，我们所传递的实参都会在<span class="built_in">arguments</span>中保存</span><br><span class="line"> *        - <span class="built_in">arguments</span>.length可以用来获取实参的长度</span><br><span class="line"> *        - 我们即使不定义形参，也可以通过<span class="built_in">arguments</span>来使用实参，</span><br><span class="line"> *           只不过比较麻烦</span><br><span class="line"> *           <span class="built_in">arguments</span>[<span class="number">0</span>] 表示第一个实参</span><br><span class="line"> *           <span class="built_in">arguments</span>[<span class="number">1</span>] 表示第二个实参 。。。</span><br><span class="line"> *    - 它里边有一个属性叫做callee，</span><br><span class="line"> *           这个属性对应一个函数对象，就是当前正在指向的函数的对象</span><br><span class="line"> *        </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//console.log(arguments instanceof Array);</span></span><br><span class="line">   <span class="comment">//console.log(Array.isArray(arguments));</span></span><br><span class="line">   <span class="comment">//console.log(arguments[1]);</span></span><br><span class="line">   <span class="comment">//console.log(arguments.length);</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee == fun);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">/创建正则表达式的对象</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 语法：</span></span><br><span class="line"><span class="comment"> *     var 变量 = new RegExp(&quot;正则表达式&quot;,&quot;匹配模式&quot;);</span></span><br><span class="line"><span class="comment"> *     var reg = new RegExp(&quot;a&quot;); 这个正则表达式可以来检查一个字符串中是否含有a</span></span><br><span class="line"><span class="comment"> * 在构造函数中可以传递一个匹配模式作为第二个参数，</span></span><br><span class="line"><span class="comment"> *        可以是</span></span><br><span class="line"><span class="comment"> *           i 忽略大小写</span></span><br><span class="line"><span class="comment"> *           g 全局匹配模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">reg</span> = new RegExp(<span class="string">&quot;ab&quot;</span>,<span class="string">&quot;i&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 正则表达式的方法：</span></span><br><span class="line"><span class="comment"> *     test()</span></span><br><span class="line"><span class="comment"> *      - 使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，</span></span><br><span class="line"><span class="comment"> *        如果符合则返回true，否则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">reg</span>.<span class="keyword">test</span>(str);</span><br><span class="line"><span class="comment">//console.log(result);</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">reg</span>.<span class="keyword">test</span>(<span class="string">&quot;Ac&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>使用字面量创建正则表达式</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/i</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个正则表达式检查一个字符串中是否有字母</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//reg = /a|b|c|d|e|f|g/;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * []里的内容也是或的关系</span></span><br><span class="line"><span class="comment"> * [ab] == a|b</span></span><br><span class="line"><span class="comment"> * [a-z] 任意小写字母</span></span><br><span class="line"><span class="comment"> * [A-Z] 任意大写字母</span></span><br><span class="line"><span class="comment"> * [A-z] 任意字母</span></span><br><span class="line"><span class="comment"> * [0-9] 任意数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">reg = <span class="regexp">/[A-z]/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查一个字符串中是否含有 abc 或 adc 或 aec</span></span><br><span class="line">reg = <span class="regexp">/a[bde]c/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [^ ] 除了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">reg = <span class="regexp">/[^ab]/</span>;</span><br><span class="line"></span><br><span class="line">reg = <span class="regexp">/[^0-9]/</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> str = <span class="string">&quot;1a2b3c4d5e6f7&quot;</span>;</span></span><br><span class="line">   /*</span><br><span class="line">    * split()</span><br><span class="line">    *     - 可以将一个字符串拆分为一个数组</span><br><span class="line">    *     - 方法中可以传递一个正则表达式作为参数，这样方法将会根据正则表达式去拆分字符串</span><br><span class="line">    *     - 这个方法即使不指定全局匹配，也会全都插分</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">   /*</span><br><span class="line">    * 根据任意字母来将字符串拆分</span><br><span class="line">    */</span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> result = str.split(<span class="regexp">/[A-z]/</span>);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">   <span class="comment">//console.log(result);</span></span></span><br><span class="line"></span><br><span class="line">   /*</span><br><span class="line">    * search()</span><br><span class="line">    *     - 可以搜索字符串中是否含有指定内容</span><br><span class="line">    *     - 如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回-1</span><br><span class="line">    *     - 它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串</span><br><span class="line">    *     - serach()只会查找第一个，即使设置全局匹配也没用</span><br><span class="line">    */</span><br><span class="line"><span class="javascript">   str = <span class="string">&quot;hello abc hello aec afc&quot;</span>;</span></span><br><span class="line">   /*</span><br><span class="line">    * 搜索字符串中是否含有abc 或 aec 或 afc</span><br><span class="line">    */</span><br><span class="line"><span class="javascript">   result = str.search(<span class="regexp">/a[bef]c/</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">   <span class="comment">//console.log(result);</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   /*</span><br><span class="line">    * match()</span><br><span class="line">    *     - 可以根据正则表达式，从一个字符串中将符合条件的内容提取出来</span><br><span class="line">    *     - 默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索</span><br><span class="line">    *        我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容</span><br><span class="line">    *        可以为一个正则表达式设置多个匹配模式，且顺序无所谓</span><br><span class="line">    *     - match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果</span><br><span class="line">    *</span><br><span class="line">    *</span><br><span class="line">    */</span><br><span class="line"><span class="javascript">   str = <span class="string">&quot;1a2a3a4a5e6f7A8B9C&quot;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">   result = str.match(<span class="regexp">/[a-z]/ig</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">   <span class="built_in">console</span>.log(result[<span class="number">2</span>]);</span></span><br><span class="line"></span><br><span class="line">   /*</span><br><span class="line">    * replace()</span><br><span class="line">    *     - 可以将字符串中指定内容替换为新的内容</span><br><span class="line">    *  - 参数：</span><br><span class="line">    *        1.被替换的内容，可以接受一个正则表达式作为参数</span><br><span class="line">    *        2.新的内容</span><br><span class="line">    *  - 默认只会替换第一个</span><br><span class="line">    */</span><br><span class="line"><span class="javascript">   <span class="comment">//result = str.replace(/[a-z]/gi , &quot;@_@&quot;);</span></span></span><br><span class="line"><span class="javascript">   result = str.replace(<span class="regexp">/[a-z]/gi</span> , <span class="string">&quot;&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">   <span class="comment">//console.log(result);</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   /*</span><br><span class="line">    * 创建一个正则表达式检查一个字符串中是否含有aaa</span><br><span class="line">    */</span><br><span class="line">   </span><br><span class="line">   /*</span><br><span class="line">    * 量词</span><br><span class="line">    *     - 通过量词可以设置一个内容出现的次数</span><br><span class="line">    *     - 量词只对它前边的一个内容起作用</span><br><span class="line">    *     - &#123;n&#125; 正好出现n次</span><br><span class="line">    *     - &#123;m,n&#125; 出现m-n次</span><br><span class="line">    *     - &#123;m,&#125; m次以上</span><br><span class="line">    *     - + 至少一个，相当于&#123;1,&#125;</span><br><span class="line">    *     - * 0个或多个，相当于&#123;0,&#125;</span><br><span class="line">    *     - ? 0个或1个，相当于&#123;0,1&#125;</span><br><span class="line">    */</span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> reg = <span class="regexp">/a&#123;3&#125;/</span>;</span></span><br><span class="line"><span class="javascript">   <span class="comment">//ababab</span></span></span><br><span class="line"><span class="javascript">   reg = <span class="regexp">/(ab)&#123;3&#125;/</span>;</span></span><br><span class="line">   </span><br><span class="line"><span class="javascript">   reg = <span class="regexp">/b&#123;3&#125;/</span>;</span></span><br><span class="line">   </span><br><span class="line"><span class="javascript">   reg = <span class="regexp">/ab&#123;1,3&#125;c/</span>;</span></span><br><span class="line">   </span><br><span class="line"><span class="javascript">   reg = <span class="regexp">/ab&#123;3,&#125;c/</span>;</span></span><br><span class="line">   </span><br><span class="line"><span class="javascript">   reg = <span class="regexp">/ab+c/</span>;</span></span><br><span class="line">   </span><br><span class="line"><span class="javascript">   reg = <span class="regexp">/ab*c/</span>;</span></span><br><span class="line">   </span><br><span class="line"><span class="javascript">   reg = <span class="regexp">/ab?c/</span>;</span></span><br><span class="line">   </span><br><span class="line"><span class="javascript">   <span class="comment">//console.log(reg.test(&quot;abbc&quot;));</span></span></span><br><span class="line">   </span><br><span class="line">   /*</span><br><span class="line">    * 检查一个字符串中是否以a开头</span><br><span class="line">    *     ^ 表示开头</span><br><span class="line">    *     $ 表示结尾</span><br><span class="line">    */</span><br><span class="line"><span class="javascript">   reg = <span class="regexp">/^a/</span>; <span class="comment">//匹配开头的a</span></span></span><br><span class="line">   </span><br><span class="line"><span class="javascript">   reg = <span class="regexp">/a$/</span>; <span class="comment">//匹配结尾的a</span></span></span><br><span class="line">   </span><br><span class="line"><span class="javascript">   <span class="comment">//console.log(reg.test(&quot;abcabca&quot;));</span></span></span><br><span class="line">   </span><br><span class="line">   /*</span><br><span class="line">    * 如果在正则表达式中同时使用^ $则要求字符串必须完全符合正则表达式</span><br><span class="line">    */</span><br><span class="line"><span class="javascript">   reg = <span class="regexp">/^a$/</span>;</span></span><br><span class="line">   </span><br><span class="line"><span class="javascript">   <span class="comment">//console.log(reg.test(&quot;bbca&quot;));</span></span></span><br><span class="line">   </span><br><span class="line">   /*</span><br><span class="line">    * 创建一个正则表达式，用来检查一个字符串是否是一个合法手机号</span><br><span class="line">    * </span><br><span class="line">    * 手机号的规则：</span><br><span class="line">    *     1 3 567890123 （11位）</span><br><span class="line">    *     </span><br><span class="line">    *     1. 以1开头</span><br><span class="line">    *  2. 第二位3-9任意数字</span><br><span class="line">    *     3. 三位以后任意数字9个</span><br><span class="line">    * </span><br><span class="line">    *  ^1   [3-9]  [0-9]&#123;9&#125;$  </span><br><span class="line">    * </span><br><span class="line">    */</span><br><span class="line">   </span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> phoneStr = <span class="string">&quot;13067890123&quot;</span>;</span></span><br><span class="line">   </span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> phoneReg = <span class="regexp">/^1[3-9][0-9]&#123;9&#125;$/</span>;</span></span><br><span class="line">   </span><br><span class="line"><span class="javascript">   <span class="built_in">console</span>.log(phoneReg.test(phoneStr));</span></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">   /*</span><br><span class="line">    * 检查一个字符串中是否含有 .</span><br><span class="line">    * . 表示任意字符</span><br><span class="line">    * 在正则表达式中使用\作为转义字符</span><br><span class="line">    * \. 来表示.</span><br><span class="line">    * \\  表示\</span><br><span class="line">    *</span><br><span class="line">    * 注意：使用构造函数时，由于它的参数是一个字符串，而\是字符串中转义字符，</span><br><span class="line">    *     如果要使用\则需要使用\\来代替</span><br><span class="line">    */</span><br><span class="line">   var reg = <span class="regexp">/\./</span>;</span><br><span class="line"></span><br><span class="line">   reg = <span class="regexp">/\\/</span>;</span><br><span class="line"></span><br><span class="line">   reg = new RegExp(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">   reg = new RegExp(<span class="string">&quot;\\\\&quot;</span>);</span><br><span class="line"></span><br><span class="line">   /*</span><br><span class="line">    * \w</span><br><span class="line">    *     - 任意字母、数字、_  [A-z0-<span class="number">9</span>_]</span><br><span class="line">    * \W</span><br><span class="line">    *     - 除了字母、数字、_  [^A-z0-<span class="number">9</span>_]</span><br><span class="line">    * \d</span><br><span class="line">    *     - 任意的数字 [<span class="number">0</span>-<span class="number">9</span>]</span><br><span class="line">    * \D</span><br><span class="line">    *     - 除了数字 [^<span class="number">0</span>-<span class="number">9</span>]</span><br><span class="line">    * \s</span><br><span class="line">    *     - 空格</span><br><span class="line">    * \S</span><br><span class="line">    *     - 除了空格</span><br><span class="line">    * \b</span><br><span class="line">    *     - 单词边界</span><br><span class="line">    * \B</span><br><span class="line">    *     - 除了单词边界</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">   reg = <span class="regexp">/\w/</span>;</span><br><span class="line">   reg = <span class="regexp">/\W/</span>;</span><br><span class="line"></span><br><span class="line">   reg = <span class="regexp">/\d/</span>;</span><br><span class="line">   reg = <span class="regexp">/\D/</span>;</span><br><span class="line"></span><br><span class="line">   reg = <span class="regexp">/\s/</span>;</span><br><span class="line">   reg = <span class="regexp">/\S/</span>;</span><br><span class="line"></span><br><span class="line">   /*</span><br><span class="line">    * 创建一个正则表达式检查一个字符串中是否含有单词child</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">   reg = <span class="regexp">/\bchild\b/</span>;</span><br><span class="line"></span><br><span class="line">   <span class="regexp">//</span>console.log(reg.test(<span class="string">&quot;hello child &quot;</span>));</span><br><span class="line"></span><br><span class="line">   <span class="regexp">//</span>接收一个用户的输入</span><br><span class="line">   <span class="regexp">//</span>var str = prompt(<span class="string">&quot;请输入你的用户名:&quot;</span>);</span><br><span class="line"></span><br><span class="line">   var str = <span class="string">&quot;              he      llo                &quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="regexp">//</span>去除掉字符串中的前后的空格</span><br><span class="line">   <span class="regexp">//</span>去除空格就是使用<span class="string">&quot;&quot;</span>来替换空格</span><br><span class="line">   console.log(str);</span><br><span class="line"></span><br><span class="line">   <span class="regexp">//</span>str = str.replace(<span class="regexp">/\s/g</span> , <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="regexp">//</span>去除开头的空格</span><br><span class="line">   <span class="regexp">//</span>str = str.replace(<span class="regexp">/^\s*/</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">   <span class="regexp">//</span>去除结尾的空格</span><br><span class="line">   <span class="regexp">//</span>str = str.replace(<span class="regexp">/\s*$/</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">   <span class="regexp">//</span> <span class="regexp">/^\s*|\s*$/g</span> 匹配开头和结尾的空格</span><br><span class="line">   str = str.replace(<span class="regexp">/^\s*|\s*$/g</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   console.log(str);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">   </span></span><br><span class="line"><span class="xml">   /*</span></span><br><span class="line"><span class="xml">    * 电子邮件</span></span><br><span class="line"><span class="xml">    *     hello  .nihao          @     abc  .com.cn</span></span><br><span class="line"><span class="xml">    * </span></span><br><span class="line"><span class="xml">    * 任意字母数字下划线    .任意字母数字下划线  @   任意字母数字     .任意字母（2-5位）   .任意字母（2-5位）</span></span><br><span class="line"><span class="xml">    * </span></span><br><span class="line"><span class="xml">    * \w</span><span class="template-variable">&#123;3,&#125;</span><span class="xml">  (\.\w+)*  @  [A-z0-9]+  (\.[A-z]</span><span class="template-variable">&#123;2,5&#125;</span><span class="xml">)</span><span class="template-variable">&#123;1,2&#125;</span></span><br><span class="line"><span class="xml">    */</span></span><br><span class="line"><span class="xml">   </span></span><br><span class="line"><span class="xml">   var emailReg = /^\w</span><span class="template-variable">&#123;3,&#125;</span><span class="xml">(\.\w+)*@[A-z0-9]+(\.[A-z]</span><span class="template-variable">&#123;2,5&#125;</span><span class="xml">)</span><span class="template-variable">&#123;1,2&#125;</span><span class="xml">$/;</span></span><br><span class="line"><span class="xml">   </span></span><br><span class="line"><span class="xml">   var email = &quot;abc.hello@163.com&quot;;</span></span><br><span class="line"><span class="xml">   </span></span><br><span class="line"><span class="xml">   console.log(emailReg.test(email));</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>文档：整个html网页</p>
<p>对象：网页的每个部分转换为对象</p>
<p>模型：表示对象之间的关系 </p>
<p>节点的属性</p>
<ul>
<li><img src="/2020/10/19/javascript/image-20201021092705861.png" alt="image-20201021092705861"></li>
</ul>
<p>文档的加载</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * onload事件会在整个页面加载完成之后才触发</span></span><br><span class="line"><span class="comment">    * 为window绑定一个onload事件</span></span><br><span class="line"><span class="comment">    *        该事件对应的响应函数将会在页面加载完成之后执行，</span></span><br><span class="line"><span class="comment">    *        这样可以确保我们的代码执行时所有的DOM对象已经加载完毕了</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//获取id为btn的按钮</span></span><br><span class="line">      <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line">      <span class="comment">//为按钮绑定一个单击响应函数</span></span><br><span class="line">      btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         alert(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>dom查询</p>
<p>获取元素节点的子节点：通过具体的元素节点调用</p>
<ul>
<li>getElementsByTagName():获取当前节点的指定标签名后代节点</li>
<li>childNodes:所有子节点</li>
<li>firstChild:当前节点的第一个节点</li>
<li>lastChild:当前节点的最后一个节点</li>
</ul>
<p>获取父节点和兄弟节点：通过具体的元素节点调用</p>
<ul>
<li><p>parentNode:表示当前节点的父节点</p>
</li>
<li><p>previousSibling:表示当前节点的前一个兄弟节点</p>
</li>
<li><p>nextSibling:表示当前节点的后一个兄弟节点</p>
</li>
</ul>
<p>dom查询的剩余方法</p>
<ul>
<li><p>获取body的引用：document.body</p>
</li>
<li><p>获取html根标签：document.documentElement</p>
</li>
<li><p>获取所有：document.all</p>
</li>
<li><pre><code>//.box1 div
/*
 * document.querySelector()
 *     - 需要一个选择器的字符串作为参数，可以根据一个CSS选择器来查询一个元素节点对象
 *     - 虽然IE8中没有getElementsByClassName()但是可以使用querySelector()代替
 *     - 使用该方法总会返回唯一的一个元素，如果满足条件的元素有多个，那么它只会返回第一个
 */
var div = document.querySelector(&quot;.box1 div&quot;);

var box1 = document.querySelector(&quot;.box1&quot;)

//console.log(div.innerHTML);
//console.log(box1.innerHTML);

/*
 * document.querySelectorAll()
 *     - 该方法和querySelector()用法类似，不同的是它会将符合条件的元素封装到一个数组中返回
 *     - 即使符合条件的元素只有一个，它也会返回数组
 */
box1 = document.querySelectorAll(&quot;.box1&quot;);
box1 = document.querySelectorAll(&quot;#box2&quot;);
console.log(box1);
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dom的增删改</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20201022103030099</span>](javascript/image<span class="number">-20201022103030099.</span>png)</span><br><span class="line"></span><br><span class="line">循环中的索引问题</span><br><span class="line"></span><br><span class="line">```<span class="javascript">javascript</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">   <span class="comment">/*</span></span></span><br><span class="line"><span class="javascript">    * 点击超链接以后，删除一个员工的信息</span></span><br><span class="line"><span class="javascript">    */</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">   <span class="comment">//获取所有额超链接</span></span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> allA = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;a&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">   <span class="comment">//为每个超链接都绑定一个单击响应函数</span></span></span><br><span class="line"><span class="javascript">   <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i &lt; allA.length ; i++)&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">/*</span></span></span><br><span class="line"><span class="javascript">       * <span class="keyword">for</span>循环会在页面加载完成之后立即执行，</span></span><br><span class="line"><span class="javascript">       *     而响应函数会在超链接被点击时才执行</span></span><br><span class="line"><span class="javascript">       * 当响应函数执行时，<span class="keyword">for</span>循环早已执行完毕</span></span><br><span class="line"><span class="javascript">       */</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      alert(<span class="string">&quot;for循环正在执行&quot;</span>+i);</span></span><br><span class="line"><span class="javascript">      <span class="comment">//this.onclick = function() 要使用this不能使用allA[i]</span></span></span><br><span class="line"><span class="javascript">      allA[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">         alert(<span class="string">&quot;响应函数正在执行&quot;</span>+i);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">         <span class="comment">//alert(allA[i]);</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">         <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">      &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">   &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">&#125;;</span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>操作内联样式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn01.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">					</span><br><span class="line">					<span class="comment">//修改box1的宽度</span></span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					 * 通过JS修改元素的样式：</span></span><br><span class="line"><span class="comment">					 * 	语法：元素.style.样式名 = 样式值</span></span><br><span class="line"><span class="comment">					 * </span></span><br><span class="line"><span class="comment">					 * 注意：如果CSS的样式名中含有-，</span></span><br><span class="line"><span class="comment">					 * 		这种名称在JS中是不合法的比如background-color</span></span><br><span class="line"><span class="comment">					 * 		需要将这种样式名修改为驼峰命名法，</span></span><br><span class="line"><span class="comment">					 * 		去掉-，然后将-后的字母大写</span></span><br><span class="line"><span class="comment">					 * </span></span><br><span class="line"><span class="comment">					 * 我们通过style属性设置的样式都是内联样式，</span></span><br><span class="line"><span class="comment">					 * 	而内联样式有较高的优先级，所以通过JS修改的样式往往会立即显示</span></span><br><span class="line"><span class="comment">					 * </span></span><br><span class="line"><span class="comment">					 * 但是如果在样式中写了!important，则此时样式会有最高的优先级，</span></span><br><span class="line"><span class="comment">					 * 	即使通过JS也不能覆盖该样式，此时将会导致JS修改样式失效</span></span><br><span class="line"><span class="comment">					 * 	所以尽量不要为样式添加!important</span></span><br><span class="line"><span class="comment">					 * </span></span><br><span class="line"><span class="comment">					 * </span></span><br><span class="line"><span class="comment">					 * </span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					box1.style.width = <span class="string">&quot;300px&quot;</span>;</span><br><span class="line">					box1.style.height = <span class="string">&quot;300px&quot;</span>;</span><br><span class="line">					box1.style.backgroundColor = <span class="string">&quot;yellow&quot;</span>;</span><br><span class="line">					</span><br><span class="line">				&#125;;</span><br></pre></td></tr></table></figure>

<p>读取元素当前样式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *getComputedStyle()这个方法来获取元素当前的样式</span></span><br><span class="line"><span class="comment"> *        这个方法是window的方法，可以直接使用</span></span><br><span class="line"><span class="comment"> * 需要两个参数</span></span><br><span class="line"><span class="comment"> *        第一个：要获取样式的元素</span></span><br><span class="line"><span class="comment"> *        第二个：可以传递一个伪元素，一般都传null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该方法会返回一个对象，对象中封装了当前元素对应的样式</span></span><br><span class="line"><span class="comment"> *     可以通过对象.样式名来读取样式</span></span><br><span class="line"><span class="comment"> *     如果获取的样式没有设置，则会获取到真实的值，而不是默认值</span></span><br><span class="line"><span class="comment"> *     比如：没有设置width，它不会获取到auto，而是一个长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 但是该方法不支持IE8及以下的浏览器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过currentStyle和getComputedStyle()读取到的样式都是只读的，</span></span><br><span class="line"><span class="comment"> *     不能修改，如果要修改必须通过style属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*alert(getComputedStyle(box1,null).width);*/</span></span><br><span class="line"><span class="comment">//正常浏览器的方式</span></span><br><span class="line">alert(getComputedStyle(box1,<span class="literal">null</span>).backgroundColor);</span><br><span class="line"><span class="comment">//IE8的方式</span></span><br><span class="line">alert(box1.currentStyle.backgroundColor);</span><br></pre></td></tr></table></figure>

<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>事件对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 当鼠标在areaDiv中移动时，在showMsg中来显示鼠标的坐标</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//获取两个div</span></span><br><span class="line">   <span class="keyword">var</span> areaDiv = <span class="built_in">document</span>.getElementById(<span class="string">&quot;areaDiv&quot;</span>);</span><br><span class="line">   <span class="keyword">var</span> showMsg = <span class="built_in">document</span>.getElementById(<span class="string">&quot;showMsg&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * onmousemove</span></span><br><span class="line"><span class="comment">    *     - 该事件将会在鼠标在元素中移动时被触发</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 事件对象</span></span><br><span class="line"><span class="comment">    *     - 当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数,</span></span><br><span class="line"><span class="comment">    *        在事件对象中封装了当前事件相关的一切信息，比如：鼠标的坐标  键盘哪个按键被按下  鼠标滚轮滚动的方向。。。</span></span><br><span class="line"><span class="comment">    */</span>	</span><br><span class="line">   areaDiv.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 在IE8中，响应函数被处罚时，浏览器不会传递事件对象，</span></span><br><span class="line"><span class="comment">       *     在IE8及以下的浏览器中，是将事件对象作为window对象的属性保存的</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">/*if(!event)&#123;</span></span><br><span class="line"><span class="comment">         event = window.event;</span></span><br><span class="line"><span class="comment">      &#125;*/</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//解决事件对象的兼容性问题</span></span><br><span class="line">      event = event || <span class="built_in">window</span>.event;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * clientX可以获取鼠标指针的水平坐标</span></span><br><span class="line"><span class="comment">       * cilentY可以获取鼠标指针的垂直坐标</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">var</span> x = event.clientX;</span><br><span class="line">      <span class="keyword">var</span> y = event.clientY;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//alert(&quot;x = &quot;+x + &quot; , y = &quot;+y);</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//在showMsg中显示鼠标的坐标</span></span><br><span class="line">      showMsg.innerHTML = <span class="string">&quot;x = &quot;</span>+x + <span class="string">&quot; , y = &quot;</span>+y;</span><br><span class="line">      </span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>div跟随鼠标移动</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">      &lt;title&gt;&lt;/title&gt;</span><br><span class="line">      &lt;style type=<span class="string">&quot;text/css&quot;</span>&gt;</span><br><span class="line">         #box1&#123;</span><br><span class="line">            width: <span class="number">100</span>px;</span><br><span class="line">            height: <span class="number">100</span>px;</span><br><span class="line">            background-color: #ff0000;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 开启box1的绝对定位</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            position: absolute;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">      &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">         <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 使div可以跟随鼠标移动</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取box1</span></span><br><span class="line">            <span class="keyword">var</span> box1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box1&quot;</span>);</span><br><span class="line">            <span class="comment">//绑定鼠标移动事件</span></span><br><span class="line">            <span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//解决兼容问题</span></span><br><span class="line">               event = event || <span class="built_in">window</span>.event;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//获取滚动条滚动的距离</span></span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * chrome认为浏览器的滚动条是body的，可以通过body.scrollTop来获取</span></span><br><span class="line"><span class="comment">                * 火狐等浏览器认为浏览器的滚动条是html的，</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="keyword">var</span> st = <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">               <span class="keyword">var</span> sl = <span class="built_in">document</span>.body.scrollLeft || <span class="built_in">document</span>.documentElement.scrollLeft;</span><br><span class="line">               <span class="comment">//var st = document.documentElement.scrollTop;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               <span class="comment">//获取到鼠标的坐标</span></span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * clientX和clientY</span></span><br><span class="line"><span class="comment">                *     用于获取鼠标在当前的可见窗口的坐标</span></span><br><span class="line"><span class="comment">                * div的偏移量，是相对于整个页面的</span></span><br><span class="line"><span class="comment">                *</span></span><br><span class="line"><span class="comment">                * pageX和pageY可以获取鼠标相对于当前页面的坐标</span></span><br><span class="line"><span class="comment">                *     但是这个两个属性在IE8中不支持，所以如果需要兼容IE8，则不要使用</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="keyword">var</span> left = event.clientX;</span><br><span class="line">               <span class="keyword">var</span>　top = event.clientY;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//设置div的偏移量</span></span><br><span class="line">               box1.style.left = left + sl + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">               box1.style.top = top + st + <span class="string">&quot;px&quot;</span>;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &lt;/script&gt;</span><br><span class="line">   &lt;/head&gt;</span><br><span class="line">   &lt;body style=<span class="string">&quot;height: 1000px;width: 2000px;&quot;</span>&gt;</span><br><span class="line">      &lt;div id=<span class="string">&quot;box1&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>事件的冒泡</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;style type=<span class="string">&quot;text/css&quot;</span>&gt;</span><br><span class="line">			#box1&#123;</span><br><span class="line">				width: <span class="number">200</span>px;</span><br><span class="line">				height: <span class="number">200</span>px;</span><br><span class="line">				background-color: yellowgreen;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			#s1&#123;</span><br><span class="line">				background-color: yellow;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&lt;/style&gt;</span><br><span class="line">		&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * 事件的冒泡（Bubble）</span></span><br><span class="line"><span class="comment">				 * 	- 所谓的冒泡指的就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件(都是onclick)也会被触发</span></span><br><span class="line"><span class="comment">				 * 	- 在开发中大部分情况冒泡都是有用的,如果不希望发生事件冒泡可以通过事件对象来取消冒泡</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">//为s1绑定一个单击响应函数</span></span><br><span class="line">				<span class="keyword">var</span> s1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;s1&quot;</span>);</span><br><span class="line">				s1.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">					event = event || <span class="built_in">window</span>.event;</span><br><span class="line">					alert(<span class="string">&quot;我是span的单击响应函数&quot;</span>);</span><br><span class="line"></span><br><span class="line">					<span class="comment">//取消冒泡</span></span><br><span class="line">					<span class="comment">//可以将事件对象的cancelBubble设置为true，即可取消冒泡</span></span><br><span class="line">					event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//为box1绑定一个单击响应函数</span></span><br><span class="line">				<span class="keyword">var</span> box1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box1&quot;</span>);</span><br><span class="line">				box1.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">					event = event || <span class="built_in">window</span>.event;</span><br><span class="line">					alert(<span class="string">&quot;我是div的单击响应函数&quot;</span>);</span><br><span class="line"></span><br><span class="line">					event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//为body绑定一个单击响应函数</span></span><br><span class="line">				<span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">					alert(<span class="string">&quot;我是body的单击响应函数&quot;</span>);</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line"></span><br><span class="line">		&lt;div id=<span class="string">&quot;box1&quot;</span>&gt;</span><br><span class="line">			我是box1</span><br><span class="line">			&lt;span id=<span class="string">&quot;s1&quot;</span>&gt;我是span&lt;/span&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>事件的委派</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=<span class="string">&quot;utf-8&quot;</span> /&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * 我们希望，只绑定一次事件，即可应用到多个的元素上，即使元素是后添加的</span></span><br><span class="line"><span class="comment">				 * 我们可以尝试将其绑定给元素的共同的祖先元素</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 * 事件的委派</span></span><br><span class="line"><span class="comment">				 * 	- 指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素</span></span><br><span class="line"><span class="comment">				 * 		从而通过祖先元素的响应函数来处理事件。</span></span><br><span class="line"><span class="comment">				 *  - 事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">//为ul绑定一个单击响应函数</span></span><br><span class="line">				u1.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">					event = event || <span class="built_in">window</span>.event;</span><br><span class="line"></span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					 * target</span></span><br><span class="line"><span class="comment">					 * 	- event中的target表示的触发事件的对象</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					<span class="comment">//alert(event.target);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">					<span class="comment">//如果触发事件的对象是我们期望的元素，则执行否则不执行</span></span><br><span class="line">					<span class="keyword">if</span>(event.target.className == <span class="string">&quot;link&quot;</span>)&#123;</span><br><span class="line">						alert(<span class="string">&quot;我是ul的单击响应函数&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;button id=<span class="string">&quot;btn01&quot;</span>&gt;添加超链接&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">		&lt;ul id=<span class="string">&quot;u1&quot;</span> style=<span class="string">&quot;background-color: #bfa;&quot;</span>&gt;</span><br><span class="line">			&lt;li&gt;</span><br><span class="line">				&lt;p&gt;我是p元素&lt;/p&gt;</span><br><span class="line">			&lt;/li&gt;</span><br><span class="line">			&lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;link&quot;</span>&gt;</span>超链接一<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">			&lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;link&quot;</span>&gt;</span>超链接二<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">			&lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;link&quot;</span>&gt;</span>超链接三<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">		&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>事件的绑定</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用 对象.事件 = 函数 的形式绑定响应函数，</span></span><br><span class="line"><span class="comment"> *     它只能同时为一个元素的一个事件绑定一个响应函数，</span></span><br><span class="line"><span class="comment"> *     不能绑定多个，如果绑定了多个，则后边会覆盖掉前边的</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * addEventListener()</span></span><br><span class="line"><span class="comment"> *     - 通过这个方法也可以为元素绑定响应函数</span></span><br><span class="line"><span class="comment"> *  - 参数：</span></span><br><span class="line"><span class="comment"> *        1.事件的字符串，不要on</span></span><br><span class="line"><span class="comment"> *        2.回调函数，当事件触发时该函数会被调用</span></span><br><span class="line"><span class="comment"> *        3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，</span></span><br><span class="line"><span class="comment"> *     这样当事件被触发时，响应函数将会按照函数的绑定顺序执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个方法不支持IE8及以下的浏览器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">btn01.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(<span class="number">1</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">btn01.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">btn01.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(<span class="number">3</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * attachEvent()</span></span><br><span class="line"><span class="comment"> *     - 在IE8中可以使用attachEvent()来绑定事件</span></span><br><span class="line"><span class="comment"> *  - 参数：</span></span><br><span class="line"><span class="comment"> *        1.事件的字符串，要on</span></span><br><span class="line"><span class="comment"> *        2.回调函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - 这个方法也可以同时为一个事件绑定多个处理函数，</span></span><br><span class="line"><span class="comment"> *        不同的是它是后绑定先执行，执行顺序和addEventListener()相反</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">btn01.attachEvent(<span class="string">&quot;onclick&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">btn01.attachEvent(<span class="string">&quot;onclick&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">btn01.attachEvent(<span class="string">&quot;onclick&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">/<span class="emphasis">*</span></span><br><span class="line"><span class="emphasis"> *</span> addEventListener()中的this，是绑定事件的对象</span><br><span class="line"><span class="bullet"> *</span> attachEvent()中的this，是window</span><br><span class="line"> <span class="emphasis">*/</span></span><br></pre></td></tr></table></figure>

<p>事件的传播</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*      </span>1.捕获阶段</span><br><span class="line"><span class="bullet">*        </span>- 在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件</span><br><span class="line"><span class="bullet">*     </span>2.目标阶段</span><br><span class="line"><span class="bullet">*        </span>- 事件捕获到目标元素，捕获结束开始在目标元素上触发事件</span><br><span class="line"><span class="bullet">*     </span>3.冒泡阶段</span><br><span class="line"><span class="bullet">*        </span>- 事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件</span><br></pre></td></tr></table></figure>

<p>拖拽</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">      &lt;title&gt;&lt;/title&gt;</span><br><span class="line">      &lt;style type=<span class="string">&quot;text/css&quot;</span>&gt;</span><br><span class="line">         </span><br><span class="line">         #box1&#123;</span><br><span class="line">            width: <span class="number">100</span>px;</span><br><span class="line">            height: <span class="number">100</span>px;</span><br><span class="line">            background-color: red;</span><br><span class="line">            position: absolute;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         #box2&#123;</span><br><span class="line">            width: <span class="number">100</span>px;</span><br><span class="line">            height: <span class="number">100</span>px;</span><br><span class="line">            background-color: yellow;</span><br><span class="line">            position: absolute;</span><br><span class="line">            </span><br><span class="line">            left: <span class="number">200</span>px;</span><br><span class="line">            top: <span class="number">200</span>px;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">      &lt;/style&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">         </span><br><span class="line">         <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 拖拽box1元素</span></span><br><span class="line"><span class="comment">             *  - 拖拽的流程</span></span><br><span class="line"><span class="comment">             *        1.当鼠标在被拖拽元素上按下时，开始拖拽  onmousedown</span></span><br><span class="line"><span class="comment">             *        2.当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove</span></span><br><span class="line"><span class="comment">             *        3.当鼠标松开时，被拖拽元素固定在当前位置  onmouseup</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//获取box1</span></span><br><span class="line">            <span class="keyword">var</span> box1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box1&quot;</span>);</span><br><span class="line">            <span class="comment">//为box1绑定一个鼠标按下事件</span></span><br><span class="line">            <span class="comment">//当鼠标在被拖拽元素上按下时，开始拖拽  onmousedown</span></span><br><span class="line">            box1.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">               event = event || <span class="built_in">window</span>.event;</span><br><span class="line">               <span class="comment">//div的偏移量 鼠标.clentX - 元素.offsetLeft</span></span><br><span class="line">               <span class="comment">//div的偏移量 鼠标.clentY - 元素.offsetTop</span></span><br><span class="line">               <span class="keyword">var</span> ol = event.clientX - box1.offsetLeft;</span><br><span class="line">               <span class="keyword">var</span> ot = event.clientY - box1.offsetTop;</span><br><span class="line">               </span><br><span class="line">               </span><br><span class="line">               <span class="comment">//为document绑定一个onmousemove事件</span></span><br><span class="line">               <span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">                  event = event || <span class="built_in">window</span>.event;</span><br><span class="line">                  <span class="comment">//当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove</span></span><br><span class="line">                  <span class="comment">//获取鼠标的坐标</span></span><br><span class="line">                  <span class="keyword">var</span> left = event.clientX - ol;</span><br><span class="line">                  <span class="keyword">var</span> top = event.clientY - ot;</span><br><span class="line">                  </span><br><span class="line">                  <span class="comment">//修改box1的位置</span></span><br><span class="line">                  box1.style.left = left+<span class="string">&quot;px&quot;</span>;</span><br><span class="line">                  box1.style.top = top+<span class="string">&quot;px&quot;</span>;</span><br><span class="line">                  </span><br><span class="line">               &#125;;</span><br><span class="line">               </span><br><span class="line">               <span class="comment">//为document绑定一个鼠标松开事件</span></span><br><span class="line">               <span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                  <span class="comment">//当鼠标松开时，被拖拽元素固定在当前位置  onmouseup</span></span><br><span class="line">                  <span class="comment">//取消document的onmousemove事件</span></span><br><span class="line">                  <span class="built_in">document</span>.onmousemove = <span class="literal">null</span>;</span><br><span class="line">                  <span class="comment">//取消document的onmouseup事件</span></span><br><span class="line">                  <span class="built_in">document</span>.onmouseup = <span class="literal">null</span>;</span><br><span class="line">               &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">         &#125;;</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">      &lt;/script&gt;</span><br><span class="line">   &lt;/head&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line">      &lt;div id=<span class="string">&quot;box1&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;div id=<span class="string">&quot;box2&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>BOM</span><br><span class="line"><span class="bullet">*  </span>- 浏览器对象模型</span><br><span class="line"><span class="bullet">*  </span>- BOM可以使我们通过JS来操作浏览器</span><br><span class="line"><span class="bullet">*  </span>- 在BOM中为我们提供了一组对象，用来完成对浏览器的操作</span><br><span class="line"><span class="bullet">*  </span>- BOM对象</span><br><span class="line"><span class="bullet">*     </span>Window</span><br><span class="line"><span class="bullet">*        </span>- 代表的是整个浏览器的窗口，同时window也是网页中的全局对象</span><br><span class="line"><span class="bullet">*     </span>Navigator</span><br><span class="line"><span class="bullet">*        </span>- 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器</span><br><span class="line"><span class="bullet">*     </span>Location</span><br><span class="line"><span class="bullet">*        </span>- 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面</span><br><span class="line"><span class="bullet">*     </span>History</span><br><span class="line"><span class="bullet">*        </span>- 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录</span><br><span class="line"><span class="bullet">*           </span>由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页</span><br><span class="line"><span class="bullet">*           </span>而且该操作只在当次访问时有效</span><br><span class="line"><span class="bullet">*     </span>Screen</span><br><span class="line"><span class="bullet">*        </span>- 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息</span><br><span class="line"><span class="bullet">* </span></span><br><span class="line"><span class="bullet">* </span></span><br><span class="line"><span class="bullet">*     </span>这些BOM对象在浏览器中都是作为window对象的属性保存的，</span><br><span class="line"><span class="bullet">*        </span>可以通过window对象来使用，也可以直接使用</span><br></pre></td></tr></table></figure>

<h2 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">* Navigator</span><br><span class="line">*  - 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器</span><br><span class="line">*  - 由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了</span><br><span class="line">*  - 一般我们只会使用userAgent来判断浏览器的信息，</span><br><span class="line">*     userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，</span><br><span class="line">*     不同的浏览器会有不同的userAgent</span><br><span class="line"><span class="keyword">var</span> ua = navigator.userAgent;</span><br><span class="line">			</span><br><span class="line"><span class="built_in">console</span>.log(ua);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="regexp">/firefox/i</span>.test(ua))&#123;</span><br><span class="line">    alert(<span class="string">&quot;你是火狐！！！&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="regexp">/chrome/i</span>.test(ua))&#123;</span><br><span class="line">    alert(<span class="string">&quot;你是Chrome&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="regexp">/msie/i</span>.test(ua))&#123;</span><br><span class="line">    alert(<span class="string">&quot;你是IE浏览器~~~&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;ActiveXObject&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">    alert(<span class="string">&quot;你是IE11，枪毙了你~~~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果通过UserAgent不能判断，还可以通过一些浏览器中特有的对象，来判断浏览器的信息</span></span><br><span class="line"><span class="comment">* 比如：ActiveXObject</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;ActiveXObject&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">    alert(<span class="string">&quot;你是IE，我已经抓住你了~~~&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;你不是IE~~~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*alert(&quot;ActiveXObject&quot; in window);*/</span></span><br></pre></td></tr></table></figure>

<h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">btn.onclick = function()&#123;</span><br><span class="line">   /<span class="emphasis">*</span></span><br><span class="line"><span class="emphasis">    *</span> length</span><br><span class="line"><span class="bullet">    *</span>     - 属性，可以获取到当次访问的链接数量</span><br><span class="line"><span class="code">    */</span></span><br><span class="line"><span class="code">   //alert(history.length);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">   /*</span></span><br><span class="line"><span class="code">    * back()</span></span><br><span class="line"><span class="code">    *     - 可以用来回退到上一个页面，作用和浏览器的回退按钮一样</span></span><br><span class="line"><span class="code">    */</span></span><br><span class="line"><span class="code">   //history.back();</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">   /*</span></span><br><span class="line"><span class="code">    * forward()</span></span><br><span class="line"><span class="code">    *     - 可以跳转下一个页面，作用和浏览器的前进按钮一样</span></span><br><span class="line"><span class="code">    */</span></span><br><span class="line"><span class="code">   //history.forward();</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">   /*</span></span><br><span class="line"><span class="code">    * go()</span></span><br><span class="line"><span class="code">    *     - 可以用来跳转到指定的页面</span></span><br><span class="line"><span class="code">    *     - 它需要一个整数作为参数</span></span><br><span class="line"><span class="code">    *        1:表示向前跳转一个页面 相当于forward()</span></span><br><span class="line"><span class="code">    *        2:表示向前跳转两个页面</span></span><br><span class="line"><span class="code">    *        -1:表示向后跳转一个页面</span></span><br><span class="line"><span class="code">    *        -2:表示向后跳转两个页面</span></span><br><span class="line"><span class="code">    */</span></span><br><span class="line"><span class="code">   history.go(-2);</span></span><br><span class="line"><span class="code">&#125;;</span></span><br></pre></td></tr></table></figure>

<h2 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径）</span></span><br><span class="line">   <span class="comment">//alert(location);</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 如果直接将location属性修改为一个完整的路径，或相对路径</span></span><br><span class="line"><span class="comment">    *     则我们页面会自动跳转到该路径，并且会生成相应的历史记录</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">// location = &quot;http://www.baidu.com&quot;;</span></span><br><span class="line">   <span class="comment">//location = &quot;01.BOM.html&quot;;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * assign()</span></span><br><span class="line"><span class="comment">    *     - 用来跳转到其他的页面，作用和直接修改location一样</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">// location.assign(&quot;http://www.baidu.com&quot;);</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * reload()</span></span><br><span class="line"><span class="comment">    *     - 用于重新加载当前页面，作用和刷新按钮一样</span></span><br><span class="line"><span class="comment">    *     - 如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//location.reload(true);</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * replace()</span></span><br><span class="line"><span class="comment">    *     - 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面</span></span><br><span class="line"><span class="comment">    *        不会生成历史记录，不能使用回退按钮回退</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   location.replace(<span class="string">&quot;01.BOM.html&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p>定时调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取count</span></span><br><span class="line">   <span class="keyword">var</span> count = <span class="built_in">document</span>.getElementById(<span class="string">&quot;count&quot;</span>);</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * setInterval()</span></span><br><span class="line"><span class="comment">    *     - 定时调用</span></span><br><span class="line"><span class="comment">    *     - 可以将一个函数，每隔一段时间执行一次</span></span><br><span class="line"><span class="comment">    *     - 参数：</span></span><br><span class="line"><span class="comment">    *        1.回调函数，该函数会每隔一段时间被调用一次</span></span><br><span class="line"><span class="comment">    *        2.每次调用间隔的时间，单位是毫秒</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *     - 返回值：</span></span><br><span class="line"><span class="comment">    *        返回一个Number类型的数据</span></span><br><span class="line"><span class="comment">    *        这个数字用来作为定时器的唯一标识</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">      count.innerHTML = num++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(num == <span class="number">11</span>)&#123;</span><br><span class="line">         <span class="comment">//关闭定时器</span></span><br><span class="line">         <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//console.log(timer);</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//clearInterval()可以用来关闭一个定时器</span></span><br><span class="line">   <span class="comment">//方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器</span></span><br><span class="line">   <span class="comment">//clearInterval(timer);</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>切换图片联系</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">      &lt;title&gt;&lt;/title&gt;</span><br><span class="line">      &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 使图片可以自动切换</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取img标签</span></span><br><span class="line">            <span class="keyword">var</span> img1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;img1&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建一个数组来保存图片的路径</span></span><br><span class="line">            <span class="keyword">var</span> imgArr = [<span class="string">&quot;img/1.jpg&quot;</span>,<span class="string">&quot;img/2.jpg&quot;</span>,<span class="string">&quot;img/3.jpg&quot;</span>,<span class="string">&quot;img/4.jpg&quot;</span>,<span class="string">&quot;img/5.jpg&quot;</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建一个变量，用来保存当前图片的索引</span></span><br><span class="line">            <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义一个变量，用来保存定时器的标识</span></span><br><span class="line">            <span class="keyword">var</span> timer;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为btn01绑定一个单击响应函数</span></span><br><span class="line">            <span class="keyword">var</span> btn01 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn01&quot;</span>);</span><br><span class="line">            btn01.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * 目前，我们每点击一次按钮，就会开启一个定时器，</span></span><br><span class="line"><span class="comment">                *     点击多次就会开启多个定时器，这就导致图片的切换速度过快，</span></span><br><span class="line"><span class="comment">                *     并且我们只能关闭最后一次开启的定时器</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">//在开启定时器之前，需要将当前元素上的其他定时器关闭</span></span><br><span class="line">               <span class="built_in">clearInterval</span>(timer);</span><br><span class="line"></span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * 开启一个定时器，来自动切换图片</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                  <span class="comment">//使索引自增</span></span><br><span class="line">                  index++;</span><br><span class="line">                  <span class="comment">//判断索引是否超过最大索引</span></span><br><span class="line">                  <span class="comment">/*if(index &gt;= imgArr.length)&#123;</span></span><br><span class="line"><span class="comment">                     //则将index设置为0</span></span><br><span class="line"><span class="comment">                     index = 0;</span></span><br><span class="line"><span class="comment">                  &#125;*/</span></span><br><span class="line">                  index %= imgArr.length;</span><br><span class="line">                  <span class="comment">//修改img1的src属性</span></span><br><span class="line">                  img1.src = imgArr[index];</span><br><span class="line"></span><br><span class="line">               &#125;,<span class="number">1000</span>);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为btn02绑定一个单击响应函数</span></span><br><span class="line">            <span class="keyword">var</span> btn02 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn02&quot;</span>);</span><br><span class="line">            btn02.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               <span class="comment">//点击按钮以后，停止图片的自动切换，关闭定时器</span></span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * clearInterval()可以接收任意参数，</span></span><br><span class="line"><span class="comment">                *     如果参数是一个有效的定时器的标识，则停止对应的定时器</span></span><br><span class="line"><span class="comment">                *     如果参数不是一个有效的标识，则什么也不做</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="built_in">clearInterval</span>(timer);</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line">      &lt;/script&gt;</span><br><span class="line">   &lt;/head&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line"></span><br><span class="line">      &lt;img id=<span class="string">&quot;img1&quot;</span> src=<span class="string">&quot;img/1.jpg&quot;</span>/&gt;</span><br><span class="line">      &lt;br /&gt;<span class="xml"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line">      &lt;button id=<span class="string">&quot;btn01&quot;</span>&gt;开始&lt;/button&gt;</span><br><span class="line">      &lt;button id=<span class="string">&quot;btn02&quot;</span>&gt;停止&lt;/button&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>延时调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 延时调用，</span></span><br><span class="line"><span class="comment">    *     延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">var</span> timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(num++);</span><br><span class="line">   &#125;,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//使用clearTimeout()来关闭一个延时调用</span></span><br><span class="line">   <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*     JSON分类：</span></span><br><span class="line"><span class="comment"> *           1.对象 &#123;&#125;</span></span><br><span class="line"><span class="comment"> *           2.数组 []</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *        JSON中允许的值：</span></span><br><span class="line"><span class="comment"> *           1.字符串</span></span><br><span class="line"><span class="comment"> *           2.数值</span></span><br><span class="line"><span class="comment"> *           3.布尔值</span></span><br><span class="line"><span class="comment"> *           4.null</span></span><br><span class="line"><span class="comment"> *           5.对象</span></span><br><span class="line"><span class="comment"> *           6.数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="string">&#x27;[1,2,3,&quot;hello&quot;,true]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * json --&gt; js对象</span></span><br><span class="line"><span class="comment"> *      JSON.parse()</span></span><br><span class="line"><span class="comment"> *        - 可以将以JSON字符串转换为js对象</span></span><br><span class="line"><span class="comment"> *        - 它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">JSON</span>.parse(arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;<span class="attr">name</span>:<span class="string">&quot;猪八戒&quot;</span> , <span class="attr">age</span>:<span class="number">28</span> , <span class="attr">gender</span>:<span class="string">&quot;男&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * JS对象 ---&gt; JSON</span></span><br><span class="line"><span class="comment"> *     JSON.stringify()</span></span><br><span class="line"><span class="comment"> *        - 可以将一个JS对象转换为JSON字符串</span></span><br><span class="line"><span class="comment"> *        - 需要一个js对象作为参数，会返回一个JSON字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="built_in">JSON</span>.stringify(obj3);</span><br></pre></td></tr></table></figure>

<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!--</span><br><span class="line"><span class="number">1.</span> 如何产生闭包?</span><br><span class="line">  * 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包</span><br><span class="line"><span class="number">2.</span> 闭包到底是什么?</span><br><span class="line">  * 使用chrome调试查看</span><br><span class="line">  * 理解一: 闭包是嵌套的内部函数(绝大部分人)</span><br><span class="line">  * 理解二: 包含被引用变量(函数)的对象(极少数人)</span><br><span class="line">  * 注意: 闭包存在于嵌套的内部函数中</span><br><span class="line"><span class="number">3.</span> 产生闭包的条件?</span><br><span class="line">  * 函数嵌套</span><br><span class="line">  * 内部函数引用了外部函数的数据(变量/函数)</span><br><span class="line">--&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;  <span class="comment">//执行函数定义就会产生闭包 不用调用</span></span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fn1()</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>常见的闭包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"><span class="number">1.</span> 将函数作为另一个函数的返回值</span><br><span class="line"><span class="number">2.</span> 将函数作为实参传递给另一个函数调用</span><br><span class="line">--&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">  <span class="comment">// 1. 将函数作为另一个函数的返回值</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      a++</span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fn2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> f = fn1()</span><br><span class="line">  f() <span class="comment">// 3</span></span><br><span class="line">  f() <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 将函数作为实参传递给另一个函数调用</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsgDelay</span>(<span class="params">msg, time</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(msg)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;</span><br><span class="line">  showMsgDelay(<span class="string">&#x27;hello&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>闭包的作用</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 使用函数内部的变量在函数执行完后, 仍然存活在内存中<span class="comment">(延长了局部变量的生命周期)</span></span><br><span class="line"><span class="number">2.</span> 让函数外部可以操作<span class="comment">(读写)</span>到函数内部的数据<span class="comment">(变量/函数)</span></span><br></pre></td></tr></table></figure>

<p>闭包的生命周期</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)</span><br><span class="line"><span class="number">2.</span> 死亡: 在嵌套的内部函数成为垃圾对象时</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js</title>
    <url>/2020/10/22/Vue-js/</url>
    <content><![CDATA[<h1 id="VUE基础"><a href="#VUE基础" class="headerlink" title="VUE基础"></a>VUE基础</h1><h2 id="列表展示"><a href="#列表展示" class="headerlink" title="列表展示"></a>列表展示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for&#x3D;&quot;item in names&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue (&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &#39;hello vue&#39;,</span><br><span class="line">                names: [&#39;bob&#39;,&#39;jack&#39;,&#39;rose&#39;],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;h2&gt;当前计数:&#123;&#123;counter&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;button v-on:click&#x3D;&quot;increment&quot;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">&lt;!--        @是v-on的简写 是语法糖--&gt;</span><br><span class="line">        &lt;button @click&#x3D;&quot;counter--&quot;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                counter: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                increment: function ()&#123;</span><br><span class="line">                    this.counter++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Vue的options"><a href="#Vue的options" class="headerlink" title="Vue的options"></a>Vue的options</h2><p>创建vue实例的时候 传入了一个对象options 包含一下选项</p>
<ul>
<li>el:决定之后vue实例管理哪个dom 类型:String|HtmlElement</li>
<li>data: vue实例对应的数据对象 类型：Object|Function 在组件中必须是函数类型</li>
<li>methods:定义vue的一些方法 可以在其他地方调用  也可以在指令中使用</li>
</ul>
<h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p><img src="file://D:/%E7%A5%9E%E7%A7%98%E6%96%87%E4%BB%B6/Java/%E4%B9%90%E4%BC%98/%E7%AC%94%E8%AE%B0/vue%E5%85%A5%E9%97%A8/assets/lifecycle.png?lastModify=1603424928" alt="Vue life cycle"></p>
<p><strong>钩子函数</strong></p>
<p>beforeCreated：我们在用Vue时都要进行实例化，因此，该函数就是在Vue实例化时调用，也可以将他理解为初始化函数比较方便一点，在Vue1.0时，这个函数的名字就是init。 </p>
<p>created：在创建实例之后进行调用。 </p>
<p>beforeMount：页面加载完成，没有渲染。如：此时页面还是</p>
<p>mounted：我们可以将他理解为原生js中的window.onload=function({.,.}),或许大家也在用jquery，所以也可以理解为jquery中的$(document).ready(function(){….})，他的功能就是：在dom文档渲染完毕之后将要执行的函数，该函数在Vue1.0版本中名字为compiled。 此时页面中的已被渲染成峰哥</p>
<p>beforeDestroy：该函数将在销毁实例前进行调用 。</p>
<p>destroyed：改函数将在销毁实例时进行调用。</p>
<p>beforeUpdate：组件更新之前。</p>
<p>updated：组件更新之后。</p>
<h2 id="插值操作"><a href="#插值操作" class="headerlink" title="插值操作"></a>插值操作</h2><p>mustache语法也就是双大括号 里面不仅可以直接写变量 也可以写简单的表达式 <code>&#123;&#123;namee * 2&#125;&#125;</code> </p>
<p>不能在属性值中使用&lt;img src=”“&gt;</p>
<p>v-once：当修改module中的数据时 view中的数据不会改变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">&lt;!--        在console中分别修改两个变量的值 查看是否改变--&gt;</span><br><span class="line">        &lt;h1 v-once&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;age&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                name: &#39;bob&#39;,</span><br><span class="line">                age: 23</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>v-html:将string中的html解析并渲染</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;h2 v-html&#x3D;&quot;url&quot;&gt;&#123;&#123;url&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;url&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                name: &#39;bob&#39;,</span><br><span class="line">                age: 23,</span><br><span class="line">                url: &#39;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度一下&lt;&#x2F;a&gt;&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>v-text:会把标签中的文本内容覆盖掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h2 v-text&#x3D;&quot;name&quot;&gt;我即将被覆盖&lt;&#x2F;h2&gt;</span><br></pre></td></tr></table></figure>

<p>v-pre:标签的内容不会编译解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">页面上直接显示&#123;&#123;name&#125;&#125;</span><br><span class="line">&lt;h2 v-pre&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;</span><br></pre></td></tr></table></figure>

<p>v-cloak:有时候页面可能加载过慢 先显示 再显示bob 为了避免这总情况 使用v-cloak vue解析之后v-cloak被删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        [v-cloak] &#123;</span><br><span class="line">            display: none;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot; v-cloak&gt;</span><br><span class="line">        &lt;h2 v-text&#x3D;&quot;name&quot;&gt;我即将被覆盖&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                name: &#39;bob&#39;,</span><br><span class="line">                age: 23,</span><br><span class="line">                url: &#39;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度一下&lt;&#x2F;a&gt;&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p>动态绑定:为属性绑定model中的数据 可以简写为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot; v-cloak&gt;</span><br><span class="line">        &lt;a v-bind:href&#x3D;&quot;baidu&quot;&gt;跳转到百度&lt;&#x2F;a&gt;</span><br><span class="line">        &lt;a :href&#x3D;&quot;baidu&quot;&gt;跳转百度&lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                baidu: &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>动态绑定class:对象语法</p>
<p><strong>方法一</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .active &#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .front &#123;</span><br><span class="line">            font-size:10px;</span><br><span class="line">        &#125;</span><br><span class="line">        .location &#123;</span><br><span class="line">            text-align:center;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot; v-cloak&gt;</span><br><span class="line">        &lt;h2 class&#x3D;&#39;location&#39; :class&#x3D;&quot;&#123;active:isActive,front:true&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &#39;一条信息&#39;,</span><br><span class="line">                title: &#39;title&#39;,</span><br><span class="line">                active: &#39;active&#39;,</span><br><span class="line">                isActive: true,</span><br><span class="line">                isFront: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot; v-cloak&gt;</span><br><span class="line">        &lt;h2 class&#x3D;&#39;location&#39; :class&#x3D;&quot;getClasses()&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &#39;一条信息&#39;,</span><br><span class="line">                title: &#39;title&#39;,</span><br><span class="line">                </span><br><span class="line">                isActive: true,</span><br><span class="line">                isFront: true</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                getClasses: function ()&#123;</span><br><span class="line">                    return &#123;active:this.isActive,front:this.isFront&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>数组语法：无法动态修改 很少使用 也可以封装成一个方法</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&lt;h2 <span class="keyword">class</span>=&#x27;<span class="symbol">location</span>&#x27; :<span class="symbol">class</span>=&quot;[<span class="symbol">active,</span>&#x27;<span class="symbol">front</span>&#x27;]&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure>

<p>作业：点击哪个 哪个变色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for&#x3D;&quot;(item,index) in movies&quot;</span><br><span class="line">                :class&#x3D;&quot;&#123;&#39;active&#39;:currentIndex&#x3D;&#x3D;index&#125;&quot;</span><br><span class="line">                @click&#x3D;&#39;changeColor(index)&#39;&gt;</span><br><span class="line">                &#123;&#123;item&#125;&#125;</span><br><span class="line">            &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                currentIndex: 0,</span><br><span class="line">                movies: [&quot;三国演义&quot;,&quot;水浒传&quot;,&quot;红楼梦&quot;,&quot;西游记&quot;]</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                changeColor: function(index)&#123;</span><br><span class="line">                    this.currentIndex &#x3D; index;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>v-bind动态绑定style：对象语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;h2 :style&#x3D;&quot;&#123;fontSize: &#39;20px&#39;,color: red&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                currentIndex: 0,</span><br><span class="line">                message: &#39;hello wolrd&#39;,</span><br><span class="line">                movies: [&quot;三国演义&quot;,&quot;水浒传&quot;,&quot;红楼梦&quot;,&quot;西游记&quot;],</span><br><span class="line">                red: &#39;red&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                changeColor: function(index)&#123;</span><br><span class="line">                    this.currentIndex &#x3D; index;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>返回的是一个属性 相比于method 可以缓存数据 调用多次 不用重复计算</p>
<p>简写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                firstName: &#39;Bob&#39;,</span><br><span class="line">                LastName: &#39;Allen&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            computed: &#123;</span><br><span class="line">                fullName: function ()&#123;</span><br><span class="line">                    return this.firstName + &#39; &#39; + this.LastName;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>属性有两个方法getter和setter 完整写法</p>
<h2 id="块级作用域var和let"><a href="#块级作用域var和let" class="headerlink" title="块级作用域var和let"></a>块级作用域var和let</h2><p>var的if和for没有块级作用域 函数有作用域 很多时候需要借助function的作用域来解决引用外面变量的问题 </p>
<p>ES6中加入了let let有if和for的块级作用域</p>
<h2 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h2><p>const修饰的变量不会被再次赋值 在es6开发中 优先使用const 需要改变某个标识符的时候才使用let</p>
<p>const修饰的标识符必须赋值  错误示范：const name;</p>
<p>指向的对象不能修改但是可以改变对象的内部属性</p>
<h2 id="对象增量写法"><a href="#对象增量写法" class="headerlink" title="对象增量写法"></a>对象增量写法</h2><p>ES6中新增的写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;自动解析：把变量和他的值最为对象的属性</span><br><span class="line">      const name &#x3D; &quot;bob&quot;;</span><br><span class="line">      const age &#x3D; 18;</span><br><span class="line">      const obj &#x3D; &#123;</span><br><span class="line">          name,age,</span><br><span class="line">          &#x2F;&#x2F;定义函数:并进行类型验证 传入的参数必须是String</span><br><span class="line">          run(name:String)&#123;</span><br><span class="line">              console.log(&quot;我要跑了&quot;)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p>.stop修饰符 阻止事件冒泡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">       &lt;div @click&#x3D;&quot;divClick&quot;&gt;</span><br><span class="line">           aaaa</span><br><span class="line">           &lt;button @click.stop&#x3D;&quot;btnClick&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">       &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue (&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &#39;hello vue&#39;,</span><br><span class="line">                names: [&#39;bob&#39;,&#39;jack&#39;,&#39;rose&#39;],</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                divClick()&#123;</span><br><span class="line">                    console.log(&quot;divClick&quot;)</span><br><span class="line">                &#125;,</span><br><span class="line">                btnClick()&#123;</span><br><span class="line">                    console.log(&quot;btnClick&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>.prevent阻止默认事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#执行自己的函数submitClick而不是跳转到baidu</span><br><span class="line">&lt;form action&#x3D;&quot;baidu&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; @click.prevent&#x3D;&quot;submitClick&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>监听键帽的点击</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; @keyup&#x3D;&quot;keyUp&quot;&gt;</span><br><span class="line">#只监听enter</span><br><span class="line">@keyUp.enter</span><br></pre></td></tr></table></figure>

<p>.once只触发一次回调</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button @click.once&#x3D;&quot;btnClick&quot;&gt;只触发一次&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<h2 id="v-if-v-else-if-v-else"><a href="#v-if-v-else-if-v-else" class="headerlink" title="v-if v-else-if v-else"></a>v-if v-else-if v-else</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;h2 v-if&#x3D;&quot;counter&gt;0&quot;&gt;&#123;&#123;message+&#39;counter&gt;0&#39;&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2 v-else-if&#x3D;&quot;counter&lt;0&quot;&gt;&#123;&#123;message+&#39;counter&lt;0&#39;&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2 v-else&gt;&#123;&#123;message+&#39;counter&#x3D;&#x3D;0&#39;&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                counter: 1,</span><br><span class="line">                message:&quot;hello world&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line"></span><br><span class="line">                increment: function ()&#123;</span><br><span class="line">                    this.counter++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>案例：登录切换 点击切换 输入框显示不同的内容</p>
<p><img src="/2020/10/22/Vue-js/image-20201026213741391.png" alt="image-20201026213741391"></p>
<p>小问题：在输入框输入内容后 点击切换 输入框中的内容还在 因为vue在进行dom渲染时 出于性能考虑 会尽可能的复用已经存在的元素 而不是重新创建新的元素  如果不希望重复利用  可以在input里添加key 如果两个input的key不同则不可以复用</p>
<h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>v-show当条件为false的时候 仅将元素的dispaly属性置为none </p>
<p>v-if条件为false的时候 不会有对应的元素在dom中</p>
<p>显示与隐藏切换频繁的时候使用v-show</p>
<h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p><strong>遍历数组</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li v-for&#x3D;&quot;(movie,index) in movies&quot;&gt;</span><br><span class="line">            &#123;&#123;index+1&#125;&#125;.&#123;&#123;movie&#125;&#125;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>第二个参数是index 顺序不能交换</p>
<p><strong>遍历对象</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &#x2F;&#x2F;key是下标</span><br><span class="line">        &lt;li v-for&#x3D;&quot;(value,key) in person&quot;&gt;</span><br><span class="line">            &#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/22/Vue-js/image-20201028082150266.png" alt="image-20201028082150266"></p>
<p>vue是响应式的 当数据发生变化的时候 vue会自动检测 数据变化 视图会发生对应的更新 </p>
<p>vue中包含了一组观察数组编译的方法 使用他们改变数组也会触发视图的更新:push pop shift unshift sort reverse</p>
<p>shift删除数组最前面的元素 unshift在数组前面添加元素</p>
<p>使用数组下标修改元素 不能做到响应式</p>
<h2 id="购物车案例"><a href="#购物车案例" class="headerlink" title="购物车案例"></a>购物车案例</h2><p>过滤器的使用：过滤器会把管道前的元素作为第一个参数传入</p>
<p><img src="/2020/10/22/Vue-js/image-20201028091630236.png" alt="image-20201028091630236"></p>
<p>​    <img src="/2020/10/22/Vue-js/image-20201028091636710.png" alt="image-20201028091636710"></p>
<h2 id="高阶函数的使用"><a href="#高阶函数的使用" class="headerlink" title="高阶函数的使用"></a>高阶函数的使用</h2><p>遍历的两种方式</p>
<p><img src="/2020/10/22/Vue-js/image-20201030090307298.png" alt="image-20201030090307298"></p>
<p><strong>filter</strong>：回调函数返回true时 函数内部将这次回调的n加入到新的数据中 返回false 这个n被过滤掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">       &lt;h2 v-for&#x3D;&quot;num in testFilter(nums)&quot;&gt;&#123;&#123;num&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue (&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                nums:[1,2,3,4,5],</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                testFilter(arr)&#123;</span><br><span class="line">                    return arr.filter(function (n)&#123;</span><br><span class="line">                        return n&lt;&#x3D;3;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p><strong>map</strong>:返回的值取代之前的值加入到回调函数的数组中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">       &lt;h2 v-for&#x3D;&quot;num in testMap(nums)&quot;&gt;&#123;&#123;num&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue (&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                nums:[1,2,3,4,5],</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                testMap(arr)&#123; </span><br><span class="line">                    return arr.map(function (n)&#123;</span><br><span class="line">                        return n*2;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>reduce:对数组中的所有内容进行汇总</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;testReduce(nums)&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue (&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                nums:[1,2,3,4,5],</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                testReduce(arr)&#123;</span><br><span class="line">                    &#x2F;&#x2F;n是数组的元素 preValue是每次返回的结果</span><br><span class="line">                    return arr.reduce(function (preValue,n)&#123;</span><br><span class="line">                        return preValue+n;</span><br><span class="line">                    &#125;,0)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>v-model可以实现表单元素和数据的双向绑定</p>
<p><strong>radio</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        男：&lt;input type&#x3D;&quot;radio&quot; value&#x3D;&quot;男&quot; name&#x3D;&quot;sex&quot; v-model&#x3D;&quot;sex&quot;&gt;&lt;br&gt;</span><br><span class="line">        女：&lt;input type&#x3D;&quot;radio&quot; value&#x3D;&quot;女&quot; name&#x3D;&quot;sex&quot; v-model&#x3D;&quot;sex&quot;&gt;&lt;br&gt;</span><br><span class="line">        选择结果:&#123;&#123;sex&#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                sex: &quot;&quot;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p><strong>checkbox</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;agree&quot; v-model&#x3D;&quot;isAgree&quot;&gt;同意协议</span><br><span class="line"></span><br><span class="line">        &lt;h2&gt;您选择的是&#123;&#123;isAgree&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;button :disabled&#x3D;&quot;!isAgree&quot;&gt;下一步&lt;&#x2F;button&gt;</span><br><span class="line">     &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                isAgree: false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;篮球&quot; v-model&#x3D;&quot;hobbies&quot;&gt;篮球</span><br><span class="line">        &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;足球&quot; v-model&#x3D;&quot;hobbies&quot;&gt;足球</span><br><span class="line">        &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;排球&quot; v-model&#x3D;&quot;hobbies&quot;&gt;排球</span><br><span class="line">        &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;羽毛球&quot; v-model&#x3D;&quot;hobbies&quot;&gt;羽毛球</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        你的爱好是:&#123;&#123;hobbies&#125;&#125;</span><br><span class="line">     &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                hobbies: []</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>值绑定：标签中的属性不要写死 使用动态绑定</p>
<p><img src="/2020/10/22/Vue-js/image-20201030103422316.png" alt="image-20201030103422316"></p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>延时加载v-model.lazy:当表格失去焦点或者回车的时候 数据才会更新</p>
<p>如果希望表格中数据是number类型 可以使用v-model.member</p>
<p>v-model.trim:去除掉首尾的空格</p>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><h3 id="基本使用过程"><a href="#基本使用过程" class="headerlink" title="基本使用过程"></a><strong>基本使用过程</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">&lt;!--        使用组件--&gt;</span><br><span class="line">        &lt;my-cpn&gt;&lt;&#x2F;my-cpn&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;&#x2F;创建组件</span><br><span class="line">        const cpn &#x3D; Vue.extend(&#123;</span><br><span class="line">            template: &#96;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h2&gt;我是标题&lt;&#x2F;h2&gt;</span><br><span class="line">                    &lt;h2&gt;不能引用data里的数据&lt;&#x2F;h2&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &#96;</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F;注册组件</span><br><span class="line">        Vue.component(&#39;my-cpn&#39;,cpn)</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h3 id="全局组件和局部组件"><a href="#全局组件和局部组件" class="headerlink" title="全局组件和局部组件"></a><strong>全局组件和局部组件</strong></h3><p>全局组件：使用Vue.component()进行注册  可以在多个vue实例中使用</p>
<p>局部组件:在vue中的conponents中进行组测只能在当前vue实例中使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const app &#x3D; new Vue(&#123;</span><br><span class="line">	el: &#39;#app&#39;,</span><br><span class="line">	components: &#123;</span><br><span class="line">		myCpn:cpn</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="父组件和局部组件"><a href="#父组件和局部组件" class="headerlink" title="父组件和局部组件"></a><strong>父组件和局部组件</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;parent&gt;&lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;&#x2F;创建组件</span><br><span class="line">        const child &#x3D; Vue.extend(&#123;</span><br><span class="line">            template: &#96;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h2&gt;我是子组件&lt;&#x2F;h2&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &#96;</span><br><span class="line">        &#125;)</span><br><span class="line">        const parent &#x3D; Vue.extend(&#123;</span><br><span class="line">            template: &#96;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h2&gt;我是父组件&lt;&#x2F;h2&gt;</span><br><span class="line">                    &lt;child&gt;&lt;&#x2F;child&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &#96;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                child: child</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                parent: parent</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h3 id="注册组件语法糖"><a href="#注册组件语法糖" class="headerlink" title="注册组件语法糖"></a><strong>注册组件语法糖</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;parent&gt;&lt;&#x2F;parent&gt;</span><br><span class="line">        &lt;cpn&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;&#x2F;直接创建并注册组件</span><br><span class="line">        Vue.component(&#39;child&#39;,&#123;</span><br><span class="line">            template: &#96;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h2&gt;我是子组件&lt;&#x2F;h2&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &#96;</span><br><span class="line">        &#125;)</span><br><span class="line">        Vue.component(&#39;parent&#39;,&#123;</span><br><span class="line">            template: &#96;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h2&gt;我是父组件&lt;&#x2F;h2&gt;</span><br><span class="line">                    &lt;child&gt;&lt;&#x2F;child&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &#96;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                &#39;cpn&#39;: &#123;</span><br><span class="line">                    template: &#96;</span><br><span class="line">                        &lt;div&gt;</span><br><span class="line">                            &lt;h2&gt;我是普通组件&lt;&#x2F;h2&gt;</span><br><span class="line">                        &lt;&#x2F;div&gt;</span><br><span class="line">                    &#96;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h3 id="组件模块抽离"><a href="#组件模块抽离" class="headerlink" title="组件模块抽离"></a><strong>组件模块抽离</strong></h3><p>template只能有一个根标签</p>
<p>方法一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;x-template&quot; id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;我是普通组件&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            &#39;cpn&#39;: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是普通组件&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            &#39;cpn&#39;: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="组件data"><a href="#组件data" class="headerlink" title="组件data"></a>组件data</h3><p>组件不能访问实例中的数据 有自己的data 保存在 data函数中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;child&gt;&lt;&#x2F;child&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                &#39;cpn&#39;: &#123;</span><br><span class="line">                    template: &#39;#cpn&#39;,</span><br><span class="line">                    date() &#123;</span><br><span class="line">                        return &#123;</span><br><span class="line">                            message: &#39;hello world&#39;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>为什么data必须是函数？防止相同组件定义多个的时候数据共享 导致错误 通过函数定义data可以保证每个组件都有自己单独的空间</p>
<h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><p>通过props向子组件传递数据 通过事件向父组件发送消息</p>
<h4 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a><strong>父传子</strong></h4><p>vue实例相当于一个父组件 template只能有一个根标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;cpn v-bind:cmovies&#x3D;&quot;movies&quot; v-bind:cmessage&#x3D;&quot;message&quot;&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;div&gt;&#123;&#123;cmovies&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div&gt;&#123;&#123;cmessage&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const cpn &#x3D;  &#123;</span><br><span class="line">            template: &#39;#cpn&#39;,</span><br><span class="line">            &#x2F;&#x2F;数组形式</span><br><span class="line">            &#x2F;&#x2F; props: [&quot;cmovies&quot;,&quot;cmessage&quot;]</span><br><span class="line">        &#x2F;&#x2F;    对象形式:可以对传入数据进行类型限制 支持 String Number Boolean Array Object Date Function Symbol</span><br><span class="line">            props: &#123;</span><br><span class="line">                cmovies: Array,</span><br><span class="line">                cmessage: &#123;</span><br><span class="line">                    type: [String,Number],&#x2F;&#x2F;可以定义多个</span><br><span class="line">                    default: &#39;aaa&#39;, &#x2F;&#x2F;如果父组件中message为null或message未定义 或者没绑定父组件的任何值则给他一个默认值 如果类型是数组或者对象 默认值必须是一个函数</span><br><span class="line">                    required: true, &#x2F;&#x2F;这个参数是必须的</span><br><span class="line">                    validate(value)&#123;</span><br><span class="line">                        &#x2F;&#x2F;进行一些判断</span><br><span class="line">                        return value &#x3D;&#x3D; 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        const app &#x3D; new Vue(&#123;</span><br><span class="line">            el: &#39;#app&#39;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &#39;hello world&#39;,</span><br><span class="line">                movies: [&quot;水浒传&quot;,&quot;红楼梦&quot;,&quot;三国演义&quot;],</span><br><span class="line">            &#125;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                cpn</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p><strong>props驼峰标识</strong></p>
<p><img src="/2020/10/22/Vue-js/image-20201030182132676.png" alt="image-20201030182132676"></p>
<h4 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a><strong>子传父</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpn @itemclick&#x3D;&quot;cpnClick&quot;&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;button v-for&#x3D;&quot;item in categories&quot; @click&#x3D;&quot;btnClick(item)&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const cpn &#x3D;  &#123;</span><br><span class="line">        template: &#39;#cpn&#39;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                categories: [</span><br><span class="line">                    &#123;id: &#39;1&#39;,name: &#39;热门推荐&#39;&#125;,</span><br><span class="line">                    &#123;id: &#39;2&#39;,name: &#39;电脑办公&#39;&#125;,</span><br><span class="line">                    &#123;id: &#39;3&#39;,name: &#39;家用电器&#39;&#125;,</span><br><span class="line">                    &#123;id: &#39;4&#39;,name: &#39;手机数码&#39;&#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            btnClick(item)&#123;</span><br><span class="line">                &#x2F;&#x2F;发送一个事件并且传递参数</span><br><span class="line">                this.$emit(&#39;itemclick&#39;,item)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;hello world&#39;,</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            cpnClick(item)&#123;</span><br><span class="line">                console.log(&#39;cpnClick&#39;+item.name)</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>组件中的btnClick方法会emit一个itemClick 通过itemClick会把参数传入到父组件的cpnClick方法中</li>
</ul>
<h4 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a><strong>双向绑定</strong></h4><p>现在通过子组件和父组件都能改变父组件中的data 但是为了避免混淆vue规定只能通过父组件改变data中的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpn&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;childnum1&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;childnum1&quot;&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;childnum2&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;childnum2&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            num1:1,</span><br><span class="line">            num2:2</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;,</span><br><span class="line">                props: &#123;</span><br><span class="line">                    childnum1: Number,</span><br><span class="line">                    childnum2: Number</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>在子组件中添加data 使其绑定一个中间值dnumber 修改的时候修改的是dnumber的值 而不是父组件中data的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpn :childnum1&#x3D;&quot;num1&quot; :childnum2&#x3D;&quot;num2&quot;&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;props:&#123;&#123;childnum1&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2&gt;data:&#123;&#123;dnumber1&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;childnum1&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;dnumber1&quot;&gt;</span><br><span class="line">        &lt;h2&gt;props:&#123;&#123;childnum2&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2&gt;props:&#123;&#123;dnumber2&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;dnumber2&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            numm1:1,</span><br><span class="line">            num2:2</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;,</span><br><span class="line">                props: &#123;</span><br><span class="line">                    childnum1: Number,</span><br><span class="line">                    childnum2: Number</span><br><span class="line">                &#125;,</span><br><span class="line">                data()&#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        dnumber1: this.childnum1,</span><br><span class="line">                        dnumber2: this.childnum2</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>增加新的功能 反向修改父组件中的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpn :childnum1&#x3D;&quot;num1&quot; :childnum2&#x3D;&quot;num2&quot; @num1change&#x3D;&quot;num1change&quot; @num2chage&#x3D;&quot;num2change&quot;&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;props:&#123;&#123;childnum1&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2&gt;data:&#123;&#123;dnumber1&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;!--使这个input绑定childnum并双向绑定方法childnum1input --&gt;</span><br><span class="line">        &lt;!--@input 一般用于监听事件 只要输入的值变化了就会触发input--&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;childnum1&quot; @input&#x3D;&quot;childnum1input&quot;&gt;</span><br><span class="line">        &lt;h2&gt;props:&#123;&#123;childnum2&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2&gt;data:&#123;&#123;dnumber2&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;childnum2&quot; @input&#x3D;&quot;childnum2input&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            num1:1,</span><br><span class="line">            num2:2</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">          num1change(value)&#123;</span><br><span class="line">              this.num1 &#x3D; parseFloat(value)</span><br><span class="line">          &#125;,</span><br><span class="line">          num2change(value)&#123;</span><br><span class="line">              this.num2 &#x3D; parseFloat(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;,</span><br><span class="line">                props: &#123;</span><br><span class="line">                    childnum1: Number,</span><br><span class="line">                    childnum2: Number</span><br><span class="line">                &#125;,</span><br><span class="line">                data()&#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        dnumber1: this.childnum1,</span><br><span class="line">                        dnumber2: this.childnum2</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    childnum1input(event) &#123;   </span><br><span class="line">                        &#x2F;&#x2F;event.target.value的值是childnum1 改变dnumber后把YX,递给父组件</span><br><span class="line">                        this.dnumber1 &#x3D; event.target.value;</span><br><span class="line">                        this.$emit(&#39;num1change&#39;,this.dnumber1)</span><br><span class="line">                        </span><br><span class="line">                    &#125;,</span><br><span class="line">                    childnum2input(event) &#123;</span><br><span class="line">                        this.dnumber2 &#x3D; event.target.value;</span><br><span class="line">                        this.$emit(&#39;num2change&#39;,this.dnumber2)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>增加新的功能 当在第一个input中输入内容的时候 第二个input的内容和数据 为第一个input的100</p>
<p><img src="/2020/10/22/Vue-js/image-20201031085733023.png" alt="image-20201031085733023"></p>
<p>watch实现双向绑定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpn :childnum1&#x3D;&quot;num1&quot; :childnum2&#x3D;&quot;num2&quot; @num1change&#x3D;&quot;num1change&quot; @num2chage&#x3D;&quot;num2change&quot;&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;props:&#123;&#123;childnum1&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2&gt;data:&#123;&#123;dnumber1&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;!--使这个input绑定childnum并双向绑定方法childnum1input --&gt;</span><br><span class="line">        &lt;!--@input 一般用于监听事件 只要输入的值变化了就会触发input--&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;dnumber1&quot;&gt;</span><br><span class="line">        &lt;h2&gt;props:&#123;&#123;childnum2&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2&gt;data:&#123;&#123;dnumber2&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;dnumber2&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            num1:1,</span><br><span class="line">            num2:2</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">          num1change(value)&#123;</span><br><span class="line">              this.num1 &#x3D; parseFloat(value)</span><br><span class="line">          &#125;,</span><br><span class="line">          num2change(value)&#123;</span><br><span class="line">              this.num2 &#x3D; parseFloat(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;,</span><br><span class="line">                props: &#123;</span><br><span class="line">                    childnum1: Number,</span><br><span class="line">                    childnum2: Number</span><br><span class="line">                &#125;,</span><br><span class="line">                data()&#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        dnumber1: this.childnum1,</span><br><span class="line">                        dnumber2: this.childnum2</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                watch:&#123;</span><br><span class="line">                    dnumber1(newvalue)&#123;</span><br><span class="line">                        this.dnumber2 &#x3D; newvalue * 100;</span><br><span class="line">                        this.$emit(&#39;num1change&#39;,newvalue)</span><br><span class="line">                    &#125;,</span><br><span class="line">                    dnumber2(newvalue)&#123;</span><br><span class="line">                        this.dnumber1 &#x3D; newvalue &#x2F; 100;</span><br><span class="line">                        this.$emit(&#39;num2change&#39;,newvalue)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h3 id="父组件访问子组件"><a href="#父组件访问子组件" class="headerlink" title="父组件访问子组件"></a>父组件访问子组件</h3><p>$children:需要根据自组件的下标获取 不方便 很少使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;cpn&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">        &lt;cpn&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">        &lt;button @click&#x3D;&quot;btnClick&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是子组件&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;hello world&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            btnClick()&#123;</span><br><span class="line">                console.log(this.$children)</span><br><span class="line">                this.$children[0].showMessage()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;,</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    showMessage()&#123;</span><br><span class="line">                        console.log(&#39;showMessage&#39;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>$refs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;cpn ref&#x3D;&quot;aaa&quot;&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">        &lt;cpn ref&#x3D;&quot;bbb&quot;&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">        &lt;cpn ref&#x3D;&quot;ccc&quot;&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">        &lt;button @click&#x3D;&quot;btnClick&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是子组件&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;hello world&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            btnClick()&#123;</span><br><span class="line">                console.log(this.$refs.aaa)</span><br><span class="line">                this.$refs.aaa.showMessage()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;,</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    showMessage()&#123;</span><br><span class="line">                        console.log(&#39;showMessage&#39;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h3 id="子组件访问父组件"><a href="#子组件访问父组件" class="headerlink" title="子组件访问父组件"></a>子组件访问父组件</h3><p>parent和root</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;cpn&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是子组件&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;button @click&#x3D;&quot;btnclick&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;hello world&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;,</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    btnclick()&#123;</span><br><span class="line">                        &#x2F;&#x2F;访问父组件</span><br><span class="line">                        console.log(this.$parent.message)</span><br><span class="line">                    	&#x2F;&#x2F;访问根组件</span><br><span class="line">                        console.log(this.$root.message)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpn&gt;</span><br><span class="line">        &lt;!--这种方式 如果有多个插槽 会替换所有插槽 --&gt;</span><br><span class="line">        &lt;h2&gt;呵呵呵&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;h2&gt;呵呵呵&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;cpn&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是子组件&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;!--        定义一个插槽 默认值为一个button 会把cpn标签中的所有内容都放在插槽中--&gt;</span><br><span class="line">        &lt;slot&gt;&lt;button&gt;按钮&lt;&#x2F;button&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>给插槽添加一个name属性 可以通过name插入指定的插槽    不指定名字会插入到没有name属性的插槽中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpn&gt;</span><br><span class="line">        &lt;span slot&#x3D;&quot;left&quot;&gt;呵呵呵&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;替换没有名字的插槽&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;cpn&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">&lt;!--        定义一个插槽 默认值为一个button 会把cpn标签中的所有内容都放在插槽中--&gt;</span><br><span class="line">        &lt;slot name&#x3D;&quot;left&quot;&gt;&lt;button&gt;左边&lt;&#x2F;button&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">        &lt;slot name&#x3D;&quot;mid&quot;&gt;&lt;button&gt;中间&lt;&#x2F;button&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">        &lt;slot name&#x3D;&quot;right&quot;&gt;&lt;button&gt;右边&lt;&#x2F;button&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">        &lt;slot&gt;&lt;button&gt;没有名字&lt;&#x2F;button&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h3><p>模板中的变量使用组件中的 视图中的变量使用vue实例中的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">&lt;!--    isshow为true--&gt;</span><br><span class="line">    &lt;cpn v-show&#x3D;&quot;isshow&quot;&gt;&lt;&#x2F;cpn&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;world&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;!--        isshow为false--&gt;</span><br><span class="line">        &lt;h2 v-show&#x3D;&quot;isshow&quot;&gt;hello&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;hello world&#39;,</span><br><span class="line">            isshow: true</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;,</span><br><span class="line">                data()&#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        isshow:false</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>父组件替换插槽的标签 但是内容由子组件来提供</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpn&gt;</span><br><span class="line">&lt;!--        改变展示方式--&gt;</span><br><span class="line">        &lt;!--    获取子组件中的数据 2.5版本以上可以用div代替template--&gt;</span><br><span class="line">        &lt;template slot-scope&#x3D;&quot;slot&quot;&gt;</span><br><span class="line">            &lt;span v-for&#x3D;&quot;movie in slot.data&quot;&gt;&#123;&#123;movie&#125;&#125;-&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;&#x2F;cpn&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;cpn&gt;</span><br><span class="line">            &lt;slot :data&#x3D;&quot;movies&quot;&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li v-for&#x3D;&quot;movie in movies&quot;&gt;&#123;&#123;movie&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;&#x2F;ul&gt;</span><br><span class="line">            &lt;&#x2F;slot&gt;</span><br><span class="line">        &lt;&#x2F;cpn&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;hello world&#39;,</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            cpn: &#123;</span><br><span class="line">                template: &#39;#cpn&#39;,</span><br><span class="line">                data()&#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        movies: [&#39;三国演义&#39;,&#39;水浒传&#39;,&#39;西游记&#39;,&#39;红楼梦&#39;]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p><strong>commonJS的导入和导出</strong></p>
<p><img src="/2020/10/22/Vue-js/image-20201101090719158.png" alt="image-20201101090719158"></p>
<p><strong>ES6的导入和导出</strong></p>
<p>导出变量</p>
<p><img src="/2020/10/22/Vue-js/image-20201101091751012.png" alt="image-20201101091751012"></p>
<p>导出函数和类</p>
<p><img src="/2020/10/22/Vue-js/image-20201101092123506.png" alt="image-20201101092123506"></p>
<p>上面的方式导入和导出的变量名必须保持一致</p>
<p>export default：导出的东西只能有一个</p>
<p><img src="/2020/10/22/Vue-js/image-20201101092458727.png" alt="image-20201101092458727"></p>
<p>导入</p>
<p><img src="/2020/10/22/Vue-js/image-20201101092634309.png" alt="image-20201101092634309"></p>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>主要功能是模块化和打包 支持各种模块化规范 可以处理模块之间的依赖 并且打包成一个文件</p>
<h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>创建mathUtils.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1* num2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    add,mul</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建一个main.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;add,mul&#125; = <span class="built_in">require</span>(<span class="string">&#x27;./mathUtils.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;name,age,height&#125; <span class="keyword">from</span> <span class="string">&quot;./info.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br><span class="line"><span class="built_in">console</span>.log(age)</span><br><span class="line"><span class="built_in">console</span>.log(height)</span><br></pre></td></tr></table></figure>

<p>创建info.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;bob&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">10</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> height = <span class="number">1.79</span></span><br></pre></td></tr></table></figure>

<p>通过webpack进行打包 ：webpack ./src/main.js  -o ./dist/bundle.js</p>
<p>创建一个index.html应用bundle.js</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>webpack.config.js配置</strong></p>
<p>执行webpack的时候自动找到webpack.config.js 读取其中的入口和出口</p>
<p>出口的path需要绝对路径  当前文件的绝对路径可以通过require(‘path’)获取 前期是安装node相关的包 执行npm init即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname,<span class="string">&#x27;dist&#x27;</span>),   <span class="comment">//要填入绝对路径 动态获取 __dirname是node中的属性 可以获取当前文件所在目录</span></span><br><span class="line">        filename: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>package.json配置</strong></p>
<p>当执行npm init后 会生成此文件 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;webpack1&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;webpack.config.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在scripts定义脚本 通过npm run xxx执行 该命令先在本地查找 再进行全局查找</p>
<p>本地安装不要加 -g :npm install webpack –save-dev (–save-dev是开发时依赖 项目打包后不需要继续使用)</p>
<p>安装后自动生成一个node_modules文件夹 并在pacckage.json中添加devDependencies</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;^3.6.0&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><p><img src="/2020/10/22/Vue-js/image-20201101190647078.png" alt="image-20201101190647078"></p>
<h4 id="处理css文件"><a href="#处理css文件" class="headerlink" title="处理css文件"></a>处理css文件</h4><p><strong>安装style-loader和css-loader添加css文件</strong></p>
<p>npm install css-loader –save-dev  安装css-loader同理</p>
<p>在webpack.config.js中进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">       rules: [</span><br><span class="line">           &#123;</span><br><span class="line">               test: &#x2F;\.css$&#x2F;,</span><br><span class="line">               &#x2F;&#x2F;多个loader时从右向左架子啊</span><br><span class="line">               use: [</span><br><span class="line">                   &#39;style-loader&#39;,      &#x2F;&#x2F;负责将样式添加到dom中</span><br><span class="line">                   &#39;css-loader&#39;         &#x2F;&#x2F;只负责加载css文件</span><br><span class="line">               ]</span><br><span class="line">           &#125;</span><br><span class="line">       ]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在main.js中引入css</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./css/normal.css&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="图片文件的处理"><a href="#图片文件的处理" class="headerlink" title="图片文件的处理"></a>图片文件的处理</h4><p>安装ur-loader：npm install –save-dev url-loader</p>
<p>在webpck.config.js中添加配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">//如果图片大于limit需要安装limit 执行webpack后会把图片打包并重新命名（32位hash 防止重复）</span></span><br><span class="line">            <span class="comment">// 小于limit会将图片编译成base64字符串形式</span></span><br><span class="line">            loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">8192</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打包后图片被放在dist目录中 但是浏览器访问的时候还是直接查找打包后的图片 这样会404 在webpack.config.js中的output中添加一行配置 <code>publicPath: &#39;dist/&#39;</code> 这样相当于在图片前面加了一个dist/ 就可以访问成功了</p>
<p><img src="/2020/10/22/Vue-js/image-20201102091142454.png" alt="image-20201102091142454"></p>
<p>选项</p>
<ul>
<li>img：文件要打包到的文件夹 </li>
<li>name：获取文件原来的名</li>
<li>hash:8：hash只保留八位</li>
<li>ext：获取图片原来的扩展名</li>
</ul>
<p>把生成的图片放在dist的img目录下 并且格式为name.hash:8.ext</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">    name: <span class="string">&#x27;img/[name].[hash:8].[ext]&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ES6转ES5"><a href="#ES6转ES5" class="headerlink" title="ES6转ES5"></a>ES6转ES5</h4><p>使用babel对应的loader</p>
<p>安装：npm install <a href="mailto:&#x62;&#97;&#x62;&#x65;&#x6c;&#45;&#108;&#111;&#97;&#x64;&#101;&#114;&#64;&#x38;&#46;&#x30;&#46;&#48;&#45;&#x62;&#101;&#x74;&#97;&#x2e;&#x30;">&#x62;&#97;&#x62;&#x65;&#x6c;&#45;&#108;&#111;&#97;&#x64;&#101;&#114;&#64;&#x38;&#46;&#x30;&#46;&#48;&#45;&#x62;&#101;&#x74;&#97;&#x2e;&#x30;</a> @babel/core @babel/preset-env webpack</p>
<p>配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [<span class="string">&#x27;es2015&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>执行npm run build</p>
<h3 id="使用vue的配置过程"><a href="#使用vue的配置过程" class="headerlink" title="使用vue的配置过程"></a>使用vue的配置过程</h3><p>安装vue：npm install vue –save</p>
<p>在js中导入vue：<code>import Vue from &#39;vue&#39;</code></p>
<p>vue运行的时候有两个版本</p>
<ul>
<li>runtime-only:代码中 不可以用任何的template</li>
<li>runtime-complier:代码中可以有template  因为有complier可以编译模块</li>
</ul>
<p>在webpack.config.js中进行配置使用runtime-complier</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">       alias: &#123;</span><br><span class="line">           <span class="string">&#x27;vue@&#x27;</span>: <span class="string">&#x27;vue/dist/vue.ems.js&#x27;</span> <span class="comment">//使vue指定具体文件夹</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在html正常使用vue 可以在vue中定义一个template 会替换掉&lt;div id=”app”&gt;中的内容</p>
<p>如果</p>
<h1 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h1><h3 id="vue-cli2"><a href="#vue-cli2" class="headerlink" title="vue-cli2"></a>vue-cli2</h3><p>vue-cli可以快速搭建 vue开发环境以及对应的webpack配置</p>
<p>安装vue-cli:npm uninstall -g @vue/cli </p>
<p>Vue CLI &gt;= 3 与旧版使用了相同的 <code>vue</code> 命令，所以 Vue CLI 2 (<code>vue-cli</code>) 被覆盖了。如果你仍然需要使用旧版本的 <code>vue init</code> 功能，你可以全局安装一个桥接工具：npm install -g @vue/cli-init</p>
<p>初始化项目：vue-cli2:vue init webpack xxx</p>
<p>node xxx.js可以直接执行js文件</p>
<p>build和config中进行了一些配置 npm run build 用来打包 npm run dev运行项目</p>
<p>static文件夹下的文件会原封不动的放入到dist中 其中的.gitKeep文件使即使改目录为空 也会上传到git服务器</p>
<p>vue程序运行过程</p>
<p><img src="/2020/10/22/Vue-js/image-20201102145346773.png" alt="image-20201102145346773"></p>
<p>创建项目的时候 vue build可选compiler和runtime 区别只体现在main.js中</p>
<ul>
<li><p><img src="/2020/10/22/Vue-js/image-20201102145518641.png" alt="image-20201102145518641"></p>
</li>
<li><p>compiler需要解析语法树并编译给render 代码更多 性能较低</p>
</li>
<li><p>所以初始化项目的时候一般选runtime-only</p>
</li>
<li><p>render的参数h是函数createElement  可以创建.vue文件</p>
<ul>
<li>普通用法<img src="/2020/10/22/Vue-js/image-20201102150311038.png" alt="image-20201102150311038"></li>
<li>还可以传入.vue文件 文件中的template由vue-template-complier解析为render() </li>
</ul>
</li>
</ul>
<h3 id="vue-cli3"><a href="#vue-cli3" class="headerlink" title="vue-cli3"></a>vue-cli3</h3><p><img src="/2020/10/22/Vue-js/image-20201102152512117.png" alt="image-20201102152512117"></p>
<p>初始化项目：vue create vue_cli3</p>
<p>在终端输入vue ui就可以启动vue ui</p>
<p>导入需要配置的项目</p>
<p><img src="/2020/10/22/Vue-js/image-20201102155709761.png" alt="image-20201102155709761"></p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const cli &#x3D; (参数列表)&#x3D;&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只有一行 大括号可以省略 并且自动返回</p>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>vue-cli</p>
<h2 id="url的hash"><a href="#url的hash" class="headerlink" title="url的hash"></a>url的hash</h2><p><img src="/2020/10/22/Vue-js/image-20201102192709374.png" alt="image-20201102192709374"></p>
<h2 id="history的pushState"><a href="#history的pushState" class="headerlink" title="history的pushState"></a>history的pushState</h2><p><img src="/2020/10/22/Vue-js/image-20201102192846900.png" alt="image-20201102192846900"></p>
<p>三个参数分别是：data，title，url 相当于把url压入栈中 当执行history.back的时候出栈 总是显示栈顶的url ，history.go(n)可以入栈n个 或者出栈n个url</p>
<p>相似的指令有replaceStatus 不能back</p>
<h2 id="router安装和配置方式"><a href="#router安装和配置方式" class="headerlink" title="router安装和配置方式"></a>router安装和配置方式</h2><p>安装：npm install vue-router –save</p>
<p>在src中创建router/index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置路由信息</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//通过Vue.use(插件)安装插件</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"><span class="comment">//创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> routes = []</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="comment">//配置路径和组件之间的映射关系</span></span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//将router实例传入到Vue实例中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<p>在main.js中导入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果导入的是router目录 自动查找index.js文件</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/index&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)  <span class="comment">//相当于el: &#x27;#pp&#x27;</span></span><br></pre></td></tr></table></figure>

<p> 创建路由组件</p>
<p>About.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是关于&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;div&gt;我是关于内容&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;About&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>Home.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是首页&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;div&gt;我是首页内容&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Home&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>在index.js中进行配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">        component: Home</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">        component: About</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在App.vue中进行渲染 roter-link会被渲染成&lt;a&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;home&quot; tag&#x3D;&quot;button&quot;&gt;首页&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;about&quot;&gt;关于&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>路由的默认值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  redirect: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>路由默认使用的是url的hash</p>
<p><img src="/2020/10/22/Vue-js/image-20201103104538701.png" alt="image-20201103104538701"></p>
<p>如果想展示localhost:8080/about可以使用history 默认使用replaceStatus</p>
<p>在index.js中进行配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="comment">//配置路径和组件之间的映射关系</span></span><br><span class="line">    routes,</span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span>  <span class="comment">//使用history</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="router-link的属性"><a href="#router-link的属性" class="headerlink" title="router-link的属性"></a>router-link的属性</h2><p>tag属性可以指定router-link渲染成什么组件</p>
<p><code>    &lt;router-link to=&quot;/home&quot; tag=&quot;button&quot;&gt;首页&lt;/router-link&gt;</code></p>
<p>使用history的replaceStatus模式使不能点击&lt;- 和-&gt; ：<code>   &lt;router-link to=&quot;/home&quot; tag=&quot;button&quot; replace&gt;首页&lt;/router-link&gt;</code></p>
<p>当点击router-link的时候 会为其加一个class：router-link-active<img src="/2020/10/22/Vue-js/image-20201103105508310.png" alt="image-20201103105508310"></p>
<p>可以利用这个class改变样式</p>
<p><img src="/2020/10/22/Vue-js/image-20201103105543332.png" alt="image-20201103105543332"></p>
<p>可以使用active-class=” xxx”重命名这个class:<code>    &lt;router-link to=&quot;/home&quot; active-class=&quot;active&quot;&gt;首页&lt;/router-link&gt;</code></p>
<p>也可以在VueRouter中统一修改</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes,</span><br><span class="line">    <span class="keyword">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">    linkActiveClas<span class="variable">s:</span> <span class="string">&#x27;active&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="通过代码跳转路由"><a href="#通过代码跳转路由" class="headerlink" title="通过代码跳转路由"></a>通过代码跳转路由</h2><p>router会为每个.vue文件添加一个$router属性 这个属性就是VueRouter对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;homeClick&quot;&gt;首页&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;aboutClick&quot;&gt;关于&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    homeClick()&#123;</span><br><span class="line">      &#x2F;&#x2F;相当于history.pushStatus</span><br><span class="line">      this.$router.push(&#39;&#x2F;home&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    aboutClick()&#123;</span><br><span class="line">      &#x2F;&#x2F;相当于history.replaceStatus</span><br><span class="line">      this.$router.replace(&#39;&#x2F;about&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="动态路由的使用"><a href="#动态路由的使用" class="headerlink" title="动态路由的使用"></a>动态路由的使用</h2><p>创建一个User.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是用户&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;div&gt;用户内容&lt;&#x2F;div&gt;</span><br><span class="line">     &#x2F;&#x2F;$this获得当前处于活跃状态的路由 参数名是在index.js中配置的参数名</span><br><span class="line">    &lt;div&gt;用户信息：&#123;&#123;this.$route.params.id&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>在index.js配置</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">//定义了一个参数id</span></span><br><span class="line">    <span class="attribute">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>,</span><br><span class="line">    <span class="attribute">component</span>: User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在App.vue中进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#39;&#x2F;user&#x2F;&#39;+userId&quot;&gt;用户&lt;&#x2F;router-link&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;配置一个属性userId 动态拼接在路由路径上</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      userId: &#39;bob&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>主要作用是将路由对应的组件打包成一个个的js代码块</p>
<p><img src="/2020/10/22/Vue-js/image-20201103124819887.png" alt="image-20201103124819887"></p>
<p>​    打包后一个懒加载对应要给js文件</p>
<h2 id="路由的嵌套使用"><a href="#路由的嵌套使用" class="headerlink" title="路由的嵌套使用"></a>路由的嵌套使用</h2><p>为Home组件添加两个子路由</p>
<p> 在index.js中进行配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">       path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">       component: Home,</span><br><span class="line">       children: [</span><br><span class="line">           &#123;</span><br><span class="line">             path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">             redirect: <span class="string">&#x27;/home/news&#x27;</span></span><br><span class="line">           &#125;,</span><br><span class="line">           &#123;</span><br><span class="line">               path: <span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">               component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/Home_news&#x27;</span>)</span><br><span class="line">           &#125;,</span><br><span class="line">           &#123;</span><br><span class="line">               path: <span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">               component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/Home_message&#x27;</span>)</span><br><span class="line">           &#125;</span><br><span class="line">       ]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在Home.vue中进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是首页&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;div&gt;我是首页内容&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;home&#x2F;news&quot;&gt;新闻&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;home&#x2F;message&quot;&gt;消息&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>创建一个组件Profile</p>
<p>在index.js中进行配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;/profile&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/Profile&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在App.vue中为其创建router-link并传入参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123;path: &#39;&#x2F;profile&#39;,query: &#123;name: &#39;bob&#39;,age: 18&#125;&#125;&quot;&gt;档案&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure>

<p>Profile.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;信息&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;this.$route.query.name&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;this.$route.query.age&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>动态传参和参数传递通过button实现跳转</p>
<p><img src="/2020/10/22/Vue-js/image-20201104073922502.png" alt="image-20201104073922502"></p>
<h2 id="导航首位"><a href="#导航首位" class="headerlink" title="导航首位"></a>导航首位</h2><p>如果实现跳转到不同页面时 title跟着变化</p>
<p>在index.js中为路由配置添加meta属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    component: About,</span><br><span class="line">    meta: &#123;</span><br><span class="line">        title: <span class="string">&#x27;关于&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>使用beforeEach(前置钩子：在路由跳转之前执行)实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//from是要离开的路由对象 to是要进入的路由对象 	</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.title = to.meta.title</span><br><span class="line">    <span class="built_in">console</span>.log(to)</span><br><span class="line">    next()  <span class="comment">//调用该方法 才能进入到下一个钩子</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是home中有两个子路由 不知道匹配哪一个 会undefined 使用：document.title = to.matched[0].meta.title 永远匹配第一个</p>
<p><img src="/2020/10/22/Vue-js/image-20201104082132846.png" alt="image-20201104082132846"></p>
<p>beforeEach就是一个全局守卫 还有afterEach 只有参数to和from</p>
<p>路由独享的守卫</p>
<p><img src="/2020/10/22/Vue-js/image-20201104083026727.png" alt="image-20201104083026727"></p>
<p>组件内的守卫</p>
<p><img src="/2020/10/22/Vue-js/image-20201104083222421.png" alt="image-20201104083222421"></p>
<h2 id="keepAlive"><a href="#keepAlive" class="headerlink" title="keepAlive"></a>keepAlive</h2><p>之前组件的状态没有被保留下来 当通过路由跳转的时候 会创建一个新的组件 希望保留状态可以使用keepAlive</p>
<p>把home路由下嵌套路由的重定向配置删除</p>
<p>在Vue.app中把roterLink放在keepAlive中</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;keep-alive&gt;</span></span><br><span class="line">  <span class="section">&lt;router-view&gt;</span><span class="section">&lt;/router-view&gt;</span></span><br><span class="line"><span class="section">&lt;/keep-alive&gt;</span></span><br></pre></td></tr></table></figure>

<p>在Home.vue中进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Home&quot;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      path: &#39;&#x2F;home&#x2F;news&#39; &#x2F;&#x2F;默认跳转到news</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  activated() &#123;</span><br><span class="line">    this.$router.push(this.path)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave(to,from,next)&#123;</span><br><span class="line">    this.path &#x3D; this.$route.path &#x2F;&#x2F;记录离开时当前路径</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>activated和deactivated只有在有keepAlive的时候才会生效</p>
<p><strong>属性</strong></p>
<p><img src="/2020/10/22/Vue-js/image-20201104100841241.png" alt="image-20201104100841241"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">exclude</span>=<span class="string">&quot;Profile&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>promise是异步编程的一种解决方案</p>
<p>定时器的异步事件</p>
<p><img src="/2020/10/22/Vue-js/image-20201104110609705.png" alt="image-20201104110609705"></p>
<p>resolve会执行the里的代码块 reject会执行catch里的代码块</p>
<p>then中可以传入两个参数then(data=&gt;{},error=&gt;{}) </p>
<h1 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a><strong>三种状态</strong></h1><p><img src="/2020/10/22/Vue-js/image-20201104153536990.png" alt="image-20201104153536990"></p>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p><img src="/2020/10/22/Vue-js/image-20201104155201850.png" alt="image-20201104155201850"></p>
<p>如果想让catch处理可以是：return Promise.resolve(res+”xxx”)</p>
<h2 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h2><p><img src="/2020/10/22/Vue-js/image-20201104205609194.png" alt="image-20201104205609194"></p>
<p>当两个请求都完成的时候 会执行then中的代码 返回结果存在results中</p>
<h1 id="VueX"><a href="#VueX" class="headerlink" title="VueX"></a>VueX</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><img src="/2020/10/22/Vue-js/image-20201104210407094.png" alt="image-20201104210407094"></p>
<p>管理什么状态？</p>
<p><img src="/2020/10/22/Vue-js/image-20201104211527323.png" alt="image-20201104211527323"></p>
<p>一般为vuex创建一个单独文件夹store 在其中创建于给index.js文件 并创建状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    counter: <span class="number">100</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>state是全局的 在任何组件中都能取到</p>
<p>在main.js中进行导入后就可以使用了</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="variable">&lt;template&gt;</span></span><br><span class="line">  <span class="variable">&lt;div&gt;</span>&#123;&#123;<span class="variable">$store</span>.<span class="keyword">state</span>.counter&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h2 id="状态管理图例"><a href="#状态管理图例" class="headerlink" title="状态管理图例"></a><strong>状态管理图例</strong></h2><p><img src="/2020/10/22/Vue-js/image-20201104231353077.png" alt="image-20201104231353077"></p>
<p>修改state一定要通过mutation修改 </p>
<p>actions省略 他是用来处理异步操作的 可以请求后端api    </p>
<p>devtools可以记录每次修改state的状态</p>
<p>mutations中定义方法 方法中默认传入一个参数state</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment () &#123;</span><br><span class="line">    <span class="built_in">this</span>.state.counter++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>在其他方法中通过commit使用方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123;$store.state.counter&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;button @click&#x3D;&quot;addition&quot;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  components: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addition () &#123;</span><br><span class="line">      this.$store.commit(&#39;increment&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>state单一状态树：在整个项目中只创建一个store </p>
<h2 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h2><p>getter中也有一个默认参数state</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  powerCounter () &#123;</span><br><span class="line">    return this.<span class="keyword">state</span>.counter * this.<span class="keyword">state</span>.counter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接通过$store.getters.powerCounter获取</p>
<p>如果需要为getter传入参数 可以使其返回一个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  powerCounter () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.state.counter * <span class="built_in">this</span>.state.counter</span><br><span class="line">  &#125;,</span><br><span class="line">  powerCounterAndAdd () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.getters.powerCounter + x</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过$store.getters.powerCounterAndAdd(x)获取</p>
<h2 id="数据响应式原理"><a href="#数据响应式原理" class="headerlink" title="数据响应式原理"></a>数据响应式原理</h2><p>state是响应式的 state中数据改变的时候 vue组件会自动更新</p>
<p>响应式的新增的属性和删除属性(在方法中)</p>
<p>Vue.set(state.person,’address’,’jiusan’)</p>
<p>vue.delete(state.person,’addres’)</p>
<h2 id="mutation的类型常量"><a href="#mutation的类型常量" class="headerlink" title="mutation的类型常量"></a>mutation的类型常量</h2><p>创建一个js文件存储常量</p>
<p>mutatiaon-types.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> POWERCOUNT = <span class="string">&#x27;powerCounter&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在index.js中导入并使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; POWERCOUNT &#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/mutations-types&#x27;</span></span><br><span class="line"></span><br><span class="line">mutations: &#123;</span><br><span class="line">    [POWERCOUNT] () &#123;</span><br><span class="line">        <span class="built_in">this</span>.state.counter++</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有导出是defalut的时候 import不用大括号包裹</p>
<p> 在App.vue中导入并使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; POWERCOUNT &#125; from &#39;@&#x2F;store&#x2F;mutations-types&#39;</span><br><span class="line">additionByAccount (count) &#123;</span><br><span class="line">	this.$store.commit(&#39;incrementByAccount&#39;, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>处理异步操作必须用action不能用mutation</p>
<p>action中的方法有一个默认值 context</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>createStore(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    counter: 100,</span><br><span class="line">    person: &#123;</span><br><span class="line">      age: 10,</span><br><span class="line">      name: <span class="string">&#x27;bob&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    updatePerson () &#123;</span><br><span class="line">      this.state.person.name = <span class="string">&#x27;jason&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    updatePerson (context) &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;updatePerson&#x27;</span>)</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>在App.vue中进行使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;&#123;&#123;$store.state.person&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;updatePerson&quot;&gt;修改person&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">updatePerson () &#123;</span><br><span class="line">  this.$store.dispatch(&#39;aupdatePerson&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><p>防止store臃肿 可以进行抽离 将store分割成模块</p>
<p><img src="/2020/10/22/Vue-js/image-20201105104634173.png" alt="image-20201105104634173"></p>
<p>可以使用state.a进行引用 其中的getters和mutations和之前使用方式相同 如果在store中找不到相应的方法 就去模块中查找</p>
<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>在项目中安装axios：npm install axios –save</p>
<p>在main.js中使用    </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    url: <span class="string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,</span><br><span class="line">    params: &#123;</span><br><span class="line">        type: <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">        page:<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    method: <span class="string">&#x27;get&#x27;</span> <span class="comment">//默认是get请求</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>请求方式</p>
<p><img src="/2020/10/22/Vue-js/image-20201105130459781.png" alt="image-20201105130459781"></p>
<p>发送并发请求:返回结果是一个数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.all([</span><br><span class="line">   axios(&#123;</span><br><span class="line">    url: <span class="string">&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span></span><br><span class="line">&#125;),axios(&#123;</span><br><span class="line">    url: <span class="string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,</span><br><span class="line">    params: &#123;</span><br><span class="line">        type: <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">        page:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以把返回结果分开处理</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">axios</span><span class="selector-class">.all</span>([</span><br><span class="line">   axios(&#123;</span><br><span class="line">    <span class="attribute">url</span>: <span class="string">&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span></span><br><span class="line">&#125;),axios(&#123;</span><br><span class="line">    <span class="attribute">url</span>: <span class="string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,</span><br><span class="line">    <span class="attribute">params</span>: &#123;</span><br><span class="line">        <span class="attribute">type</span>: <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">        <span class="attribute">page</span>:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)])<span class="selector-class">.then</span>(axios.spread((res1,res2) =&gt; &#123;</span><br><span class="line">    console.log(res1)</span><br><span class="line">    console.log(res2)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<p><strong>全局配置</strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">axios.defaults.baseURL</span>=<span class="string">&#x27;http://123.207.32.32:8000&#x27;</span></span><br><span class="line"><span class="attr">axios.defaults.timeout</span>= <span class="number">5000</span> //单位是毫秒</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/22/Vue-js/image-20201105133058548.png" alt="image-20201105133058548"></p>
<h2 id="axios实例和模块封装"><a href="#axios实例和模块封装" class="headerlink" title="axios实例和模块封装"></a><strong>axios实例和模块封装</strong></h2><p>如果像访问多个ip 把baseUrl设置为全局的话没有通用性 </p>
<p>可以创建实例 处理不同ip的请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建实例</span></span><br><span class="line"><span class="keyword">const</span> axiosInstance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout:<span class="number">5000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axiosInstance(&#123;</span><br><span class="line">    url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>模块封装：创建一个文件夹network 在其中创建一个request.js</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios from <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">export function <span class="title">request</span><span class="params">(config)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> axiosInstance = axios.create(&#123;</span><br><span class="line">        baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">        timeout:<span class="number">5000</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> axiosInstance(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main.js中进行使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&quot;@/network/request&quot;</span>;</span><br><span class="line"></span><br><span class="line">createApp(App).use(store).use(router).mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">    url: <span class="string">&#x27;/home/data&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>axios.create会返回一个promise 当需要用其他框架的时候 直接修改request.js文件使其也返回一个promise即可 模块中的代码不用修改</p>
<h2 id="axios拦截器的使用"><a href="#axios拦截器的使用" class="headerlink" title="axios拦截器的使用"></a>axios拦截器的使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function request(config)&#123;</span><br><span class="line">    const axiosInstance &#x3D; axios.create(&#123;</span><br><span class="line">        baseURL: &#39;http:&#x2F;&#x2F;123.207.32.32:8000&#39;,</span><br><span class="line">        timeout:5000</span><br><span class="line">    &#125;)</span><br><span class="line">    axiosInstance.interceptors.request.use(config &#x3D;&gt;&#123;</span><br><span class="line">        console.log(config)</span><br><span class="line">        return config</span><br><span class="line">    &#125;,error &#x3D;&gt; &#123;</span><br><span class="line">        console.log(error)</span><br><span class="line">    &#125;)</span><br><span class="line">    axiosInstance.interceptors.response.usr(result &#x3D;&gt; &#123;</span><br><span class="line">        console.log(result.data)</span><br><span class="line">        </span><br><span class="line">    &#125;,error &#x3D;&gt; &#123;</span><br><span class="line">        console.log(error)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return axiosInstance(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>leyou</title>
    <url>/2020/10/19/leyou/</url>
    <content><![CDATA[<h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><h2 id="注册中心leyou-registy"><a href="#注册中心leyou-registy" class="headerlink" title="注册中心leyou-registy"></a>注册中心leyou-registy</h2><p>eureka</p>
<ul>
<li><p>服务下线：当服务进行正常关闭操作时，它会触发一个服务下线的REST请求给Eureka Server，告诉服务注册中心：“我要下线了”。服务中心接受到请求之后，将该服务置为下线状态。</p>
</li>
<li><p>失效剔除：有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔n秒对所有失效的服务（超过90秒未响应）进行剔除。可以通过<code>eureka.server.eviction-interval-timer-in-ms</code>参数对其进行修改，单位是毫秒</p>
</li>
<li><p>自我保护：当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。</p>
<p>但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式</p>
</li>
</ul>
<p>客户端开启eureka使用@EnableDiscoveryClient 服务端开启eureka使用@EnableEurekaServer</p>
<h2 id="网关leyou-getway"><a href="#网关leyou-getway" class="headerlink" title="网关leyou-getway"></a>网关leyou-getway</h2><p>eureka</p>
<ul>
<li>当服务消费者启动时，会检测<code>eureka.client.fetch-registry=true</code>参数的值，如果为true(默认)，则会拉取Eureka Server服务的列表只读备份，然后缓存在本地</li>
</ul>
<p>item-service是微服务的应用名 /item/**是映射路径</p>
<p><img src="/2020/10/19/leyou/image-20201019154656989.png" alt="image-20201019154656989"></p>
<h2 id="商品微服务leyou-items"><a href="#商品微服务leyou-items" class="headerlink" title="商品微服务leyou-items"></a>商品微服务leyou-items</h2><p>创建商品的微服务模块leyou-item-service和接口模块leyou-item-interface</p>
<p>在leyou-item-service中导入了<a href="https://blog.csdn.net/qq360452913/article/details/86585468?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight">actuator</a>:是监控系统健康情况的工具</p>
<p><img src="/2020/10/19/leyou/image-20201019162157112.png" alt="image-20201019162157112"></p>
<h3 id="品牌新增"><a href="#品牌新增" class="headerlink" title="品牌新增"></a>品牌新增</h3><h4 id="QS工具"><a href="#QS工具" class="headerlink" title="QS工具"></a>QS工具</h4><p>QS是一个第三方库，我们可以用<code>npm install qs --save</code>来安装。不过我们在项目中已经集成了，大家无需安装：</p>
<p><img src="/2020/10/19/leyou/1530696509189-1604835487386.png" alt="1530696509189"></p>
<p>这个工具的名字：QS，即Query String，请求参数字符串。</p>
<p>什么是请求参数字符串？例如： name=jack&amp;age=21</p>
<p>QS工具可以便捷的实现 JS的Object与QueryString的转换。</p>
<p>在我们的项目中，将QS注入到了Vue的原型对象中，我们可以通过<code>this.$qs</code>来获取这个工具：</p>
<p><img src="/2020/10/19/leyou/1539821449329-1604835487386.png" alt="1539821449329"></p>
<p>我们将<code>this.$qs</code>对象打印到控制台：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$qs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现其中有3个方法：</p>
<p><img src="/2020/10/19/leyou/1532850873556-1604835487386.png" alt="1532850873556"></p>
<p>这里我们要使用的方法是stringify，它可以把Object转为QueryString。</p>
<p>测试一下，使用浏览器工具，把qs对象保存为一个临时变量temp1，然后调用stringify方法：</p>
<p><img src="/2020/10/19/leyou/qs-2-1604835487388.gif" alt="1526182230872"></p>
<p>成功将person对象变成了 name=zhangsan&amp;age=30的字符串了</p>
<h4 id="deBug"><a href="#deBug" class="headerlink" title="deBug"></a>deBug</h4><p>为表中的主键添加注解@Id 不然mapper不能确定哪个字段为主键 在调用brandMapper.deleteByPrimaryKey(id)的时候错把name当成了主键</p>
<p><img src="/2020/10/19/leyou/image-20201108204844641.png" alt="image-20201108204844641"></p>
<h3 id="品牌编辑"><a href="#品牌编辑" class="headerlink" title="品牌编辑"></a>品牌编辑</h3><p><img src="/2020/10/19/leyou/image-20201110204230166.png" alt="image-20201110204230166"></p>
<p>前端可能是put或者post请求 后端方法的注解要用@RequestMapping</p>
<p>编辑的时候发现虽然brand插入了表中但是没有插入到brand和category的中间表中 原因是无法获取到新插入brand自增id</p>
<p>为brand的主键增加一个注解</p>
<p><img src="/2020/10/19/leyou/image-20201111081741545.png" alt="image-20201111081741545"></p>
<p>这样brand中就有了自增id</p>
<p><img src="/2020/10/19/leyou/image-20201111081831355.png" alt="image-20201111081831355"></p>
<h3 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h3><p>项目：FileUpload</p>
<h4 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h4><p>图片上传的表单的enctype取值为Multipart/form-data会把表单分为几个部分提交 而不是value1=key&amp;value2=key的形式</p>
<p>需要文件上传的jar包：common-fileupload和common-io</p>
<p>在index.jsp中设置表单</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;文件上传&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;	</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%--multipart使表单分为几部分上传--%&gt;</span><br><span class="line">    &lt;form method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span> action=<span class="string">&quot;/FileUpload_war_exploded/user/fileUpLoad&quot;</span>&gt;</span><br><span class="line">        选择文件：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;upLoad&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>在springMVC.xml中定义视图解析器 </p>
<p>在web.xml中加载springMVC.xml</p>
<p>在controller中定义方法实现文件上传</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/fileUpLoad&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">FileUpLoad</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="number">111</span>);</span><br><span class="line">    <span class="comment">//使用fileUpload组件进行文件上传</span></span><br><span class="line">    <span class="comment">//上传的位置 如果不存在就创建:D:\IDEAWorkPlace\FileUpload\target\FileUpload\\uploads</span></span><br><span class="line">    String realPath = request.getSession().getServletContext().getRealPath(<span class="string">&quot;/uploads/&quot;</span>);</span><br><span class="line">    File file = <span class="keyword">new</span> File(realPath);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        file.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="number">333</span>);</span><br><span class="line">    <span class="comment">//解析request对象 获取文件上传项</span></span><br><span class="line">    DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">    ServletFileUpload upload = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line">    <span class="comment">//解析request</span></span><br><span class="line">    List&lt;FileItem&gt; items = upload.parseRequest(request);</span><br><span class="line">    <span class="keyword">for</span>(FileItem item : items)&#123;</span><br><span class="line">        <span class="comment">//判断是否是文件项</span></span><br><span class="line">        <span class="keyword">if</span>(item.isFormField())&#123;</span><br><span class="line">            <span class="comment">//普通表单项</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            String fileName = item.getName();</span><br><span class="line">            <span class="comment">//把文件名称设置为唯一值</span></span><br><span class="line">            String uuid = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">            fileName = uuid+<span class="string">&quot;_&quot;</span>+fileName;</span><br><span class="line">            <span class="comment">//完成文件上传</span></span><br><span class="line">            item.write(<span class="keyword">new</span> File(realPath,fileName));</span><br><span class="line">            <span class="comment">//删除临时文件：当上传的文件大于10kb 会产生临时文件 小于10kb 在内存中生成缓存</span></span><br><span class="line">            item.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="number">222</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="springMVC实现文件上传"><a href="#springMVC实现文件上传" class="headerlink" title="springMVC实现文件上传"></a>springMVC实现文件上传</h4><p>在SpringMVC.xml中进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsFileUploadSupport&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10485760&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>input的name和接收文件的mulitPartFile的名字必须相同</p>
<p>编写controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;springMVCFileUpLoad&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">SpringMVCFileUpLoad</span><span class="params">(HttpServletRequest request, MultipartFile upLoad)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//使用fileupload组件进行文件上传</span></span><br><span class="line">    <span class="comment">//上传的位置 如果不存在就创建</span></span><br><span class="line">    String realPath = request.getSession().getServletContext().getRealPath(<span class="string">&quot;/uploads&quot;</span>);</span><br><span class="line">    File file = <span class="keyword">new</span> File(realPath);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        file.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    String fileName = upLoad.getOriginalFilename();</span><br><span class="line">    String uuid = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    fileName = uuid+<span class="string">&quot;_&quot;</span>+fileName;</span><br><span class="line">    upLoad.transferTo(<span class="keyword">new</span> File(realPath,fileName));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="跨服务器上传"><a href="#跨服务器上传" class="headerlink" title="跨服务器上传"></a>跨服务器上传</h4><p>导入jar包：jersey-client,jersey-core</p>
<p>controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;overServerFileUpLoad&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">OverServerFileUpLoad</span><span class="params">(MultipartFile upLoad)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//定义上传服务器路径</span></span><br><span class="line">    String path = <span class="string">&quot;http://localhost:9090/fileUpload_war/uploads/&quot;</span>;</span><br><span class="line">    String fileName = upLoad.getOriginalFilename();</span><br><span class="line">    String uuid = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    fileName = uuid+<span class="string">&quot;_&quot;</span>+fileName;</span><br><span class="line">    <span class="comment">//创建客户端连接对象</span></span><br><span class="line">    Client client = Client.create();</span><br><span class="line">    <span class="comment">//和图片服务器建立连接</span></span><br><span class="line">    WebResource resource =  client.resource(path+fileName);</span><br><span class="line">    <span class="comment">//上传文件</span></span><br><span class="line">    resource.put(upLoad.getBytes());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="FastDFS实现文件上传"><a href="#FastDFS实现文件上传" class="headerlink" title="FastDFS实现文件上传"></a>FastDFS实现文件上传</h4><h5 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h5><p>分布式文件系统（Distributed File System）是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连。 </p>
<p>通俗来讲：</p>
<ul>
<li>传统文件系统管理的文件就存储在本机。</li>
<li>分布式文件系统管理的文件存储在很多机器，这些机器通过网络连接，要被统一管理。无论是上传或者访问文件，都需要通过管理中心来访问</li>
</ul>
<h5 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h5><p><img src="/2020/10/19/leyou/image-20210203224502441.png" alt="image-20210203224502441"></p>
<p>FastDFS两个主要的角色：Tracker Server 和 Storage Server 。</p>
<ul>
<li>Tracker Server：跟踪服务器，主要负责调度storage节点与client通信，在访问上起负载均衡的作用，和记录storage节点的运行状态，是连接client和storage节点的枢纽。 </li>
<li>Storage Server：存储服务器，保存文件和文件的meta data（元数据），每个storage server会启动一个单独的线程主动向Tracker cluster中每个tracker server报告其状态信息，包括磁盘使用情况，文件同步情况及文件上传下载次数统计等信息</li>
<li>Group：文件组，多台Storage Server的集群。上传一个文件到同组内的一台机器上后，FastDFS会将该文件即时同步到同组内的其它所有机器上，起到备份的作用。不同组的服务器，保存的数据不同，而且相互独立，不进行通信。 </li>
<li>Tracker Cluster：跟踪服务器的集群，有一组Tracker Server（跟踪服务器）组成。</li>
<li>Storage Cluster ：存储集群，有多个Group组成。</li>
</ul>
<h5 id="上传和下载流程"><a href="#上传和下载流程" class="headerlink" title="上传和下载流程"></a>上传和下载流程</h5><p><strong>上传</strong></p>
<p><img src="/2020/10/19/leyou/image-20210203224448364.png" alt="image-20210203224448364"></p>
<ol>
<li>Client通过Tracker server查找可用的Storage server。</li>
<li>Tracker server向Client返回一台可用的Storage server的IP地址和端口号。</li>
<li>Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并进行文件上传。</li>
<li>上传完成，Storage server返回Client一个文件ID，文件上传结束。</li>
</ol>
<p><strong>下载</strong></p>
<p><img src="/2020/10/19/leyou/image-20210203224437893.png" alt="image-20210203224437893"></p>
<ol>
<li>Client通过Tracker server查找要下载文件所在的的Storage server。</li>
<li>Tracker server向Client返回包含指定文件的某个Storage server的IP地址和端口号。</li>
<li>Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并指定要下载文件。</li>
<li>下载文件成功。</li>
</ol>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>安装FastDFS和nginx：FastDFS.md</p>
<p>启动tracker服务:/etc/init.d/fdfs_trackerd start</p>
<p>启动storage服务:/etc/init.d/fdfs_storaged start</p>
<p>启动nginx:nginx</p>
<p><strong>为什么需要安装nginx</strong></p>
<p>FastDFS通过Tracker服务器,将文件放在Storage服务器存储，但是同组存储服务器之间需要进入文件复制，有同步延迟的问题。</p>
<p>假设Tracker服务器将文件上传到了192.168.4.125，上传成功后文件ID已经返回给客户端。此时FastDFS存储集群机制会将这个文件同步到同组存储192.168.4.126，在文件还没有复制完成的情况下，客户端如果用这个文件ID在192.168.4.126上取文件,就会出现文件无法访问的错误。</p>
<p>而fastdfs-nginx-module可以重定向文件连接到文件上传时的源服务器取文件,避免客户端由于复制延迟导致的文件无法访问错误</p>
<h5 id="应用到项目中"><a href="#应用到项目中" class="headerlink" title="应用到项目中"></a>应用到项目中</h5><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.tobato<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastdfs-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在application.yml中追加配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fdfs:</span></span><br><span class="line">  <span class="attr">so-timeout:</span> <span class="number">1501</span> <span class="comment"># 超时时间</span></span><br><span class="line">  <span class="attr">connect-timeout:</span> <span class="number">601</span> <span class="comment"># 连接超时时间</span></span><br><span class="line">  <span class="attr">thumb-image:</span> <span class="comment"># 缩略图</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">60</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">60</span></span><br><span class="line">  <span class="attr">tracker-list:</span> <span class="comment"># tracker地址：你的虚拟机服务器地址+端口（默认是22122）</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.1228</span><span class="string">:22122</span></span><br></pre></td></tr></table></figure>

<p>创建一个配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(FdfsClientConfig.class)</span></span><br><span class="line"><span class="comment">// 解决jmx重复注册bean的问题</span></span><br><span class="line"><span class="meta">@EnableMBeanExport(registration = RegistrationPolicy.IGNORE_EXISTING)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastClientImporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UploadService uploadService;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;image&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">uploadImage</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span>MultipartFile file)</span></span>&#123;</span><br><span class="line">        String url = uploadService.uploadImage(file);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(url))</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.badRequest().build();</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.CREATED).body(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写service</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 白名单:文件后缀必须是白名单中的类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; CONTENT_TYPE = Arrays.asList(<span class="string">&quot;image/gif&quot;</span>,<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(UploadService.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FastFileStorageClient storageClient;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadImage</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        String originalFilename = file.getOriginalFilename();</span><br><span class="line">        <span class="comment">//检验文件类型</span></span><br><span class="line">        String contentType = file.getContentType();</span><br><span class="line">        <span class="keyword">if</span>(!CONTENT_TYPE.contains(contentType))&#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;文件类型不合法:&quot;</span>+originalFilename);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//校验文件内容ImageIO</span></span><br><span class="line">        BufferedImage read = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            read = ImageIO.read(file.getInputStream());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(read == <span class="keyword">null</span>)&#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;文件内容不合法:&quot;</span>+originalFilename);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保存到服务器</span></span><br><span class="line"></span><br><span class="line">        String s = StringUtils.substringAfterLast(originalFilename, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        StorePath storePath = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            storePath = <span class="keyword">this</span>.storageClient.uploadFile(file.getInputStream(), file.getSize(), s, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回url</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://image.leyou.com/&quot;</span>+storePath.getFullPath();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="商品规格管理"><a href="#商品规格管理" class="headerlink" title="商品规格管理"></a>商品规格管理</h3><p>表关系</p>
<p><img src="/2020/10/19/leyou/image-20201110134708213.png" alt="image-20201110134708213"></p>
<p>使分类表与参数表关联方便查询参数</p>
<p>如果使通用字段从spu获取值 否则从sku获取值</p>
<p>@GeneratedValue 注解详解:<a href="https://blog.csdn.net/sswqzx/article/details/84337921">博客</a></p>
<p><a href="https://blog.csdn.net/rongxiang111/article/details/86476028">@transient</a>:想要添加表中不存在字段，就要使用@Transient这个注解了</p>
<p>SpecParam</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Column(name = &quot;`numeric`&quot;)</span> <span class="comment">//表示这个字段不是关键字 而是一个列名 numeric是一个关键字</span></span><br><span class="line"><span class="keyword">private</span> Boolean numeric;</span><br></pre></td></tr></table></figure>

<h3 id="SpecGroup"><a href="#SpecGroup" class="headerlink" title="SpecGroup"></a>SpecGroup</h3><h4 id="编辑和新增"><a href="#编辑和新增" class="headerlink" title="编辑和新增"></a>编辑和新增</h4><p>因为SpecGroup类中的属性有list集合 所以前端传入参数的时候要按需传入需要的参数 否则会出现类型转换(string to list)异常400 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save()&#123;</span><br><span class="line">           const param &#x3D; &#123;&#125;</span><br><span class="line">           param.name &#x3D; this.group.name</span><br><span class="line">           param.id &#x3D; this.group.id</span><br><span class="line">           param.cid &#x3D; this.cid</span><br><span class="line">           this.$http(&#123;</span><br><span class="line">           method: this.isEdit ? &#39;put&#39; : &#39;post&#39;,</span><br><span class="line">           url: &#39;&#x2F;item&#x2F;spec&#x2F;save&#39;,</span><br><span class="line">           data: this.$qs.stringify(param)</span><br><span class="line">         &#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">           &#x2F;&#x2F; 关闭窗口</span><br><span class="line">           this.show &#x3D; false;</span><br><span class="line">           this.$message.success(&quot;保存成功！&quot;);</span><br><span class="line">           this.loadData();</span><br><span class="line">         &#125;).catch(() &#x3D;&gt; &#123;</span><br><span class="line">             this.$message.error(&quot;保存失败！&quot;);</span><br><span class="line">           &#125;);</span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;save&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title">saveSpecGroup</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Long id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="meta">@RequestParam(&quot;name&quot;)</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="meta">@RequestParam(&quot;cid&quot;)</span> Long cid)</span></span>&#123;</span><br><span class="line">    SpecGroup specGroup = <span class="keyword">new</span> SpecGroup();</span><br><span class="line">    specGroup.setCid(cid);</span><br><span class="line">    specGroup.setId(id);</span><br><span class="line">    specGroup.setName(name);</span><br><span class="line">    specificationService.saveSpecGroup(specGroup);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.status(HttpStatus.CREATED).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SPU和SKU"><a href="#SPU和SKU" class="headerlink" title="SPU和SKU"></a>SPU和SKU</h3><h4 id="spu"><a href="#spu" class="headerlink" title="spu"></a>spu</h4><p>数据库中spu的表有两个spu和spudetail 后者存放一些通用信息 减轻查询的负担</p>
<p>spu_detail中的字段generic_spec和special_spec的值的id对应spec中的id</p>
<h4 id="sku"><a href="#sku" class="headerlink" title="sku"></a>sku</h4><p>sku的indexes中存放着下标组合对应着spuDetail表中special_spec的数组</p>
<p>own_spec存放下标组合对应的值 方便进行渲染</p>
<p>spec中的通用字段去spuDetail的generic_spec中获取值 特殊字段去spk的own_spec中获取值</p>
<h3 id="商品查询"><a href="#商品查询" class="headerlink" title="商品查询"></a>商品查询</h3><p><img src="/2020/10/19/leyou/image-20201112123056356.png" alt="image-20201112123056356"></p>
<p>展示页面需要商品分类和品牌 对应着cname和bname</p>
<p>防止对表对应的实体类修改 需要对其扩展spu类</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SpuBo</span> <span class="keyword">extends</span> <span class="title">Spu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> cname;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> bname;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SpuDetail</span> spuDetail;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">List</span>&lt;<span class="type">Sku</span>&gt; skus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 查询分类名称的时候参数是一个集合 可以让CategoryMapper继承SelectByIdListMapper&lt;Category,Long&gt; 改接口是根据id集合查询对象集合 第一个泛型是对象类型 第二个泛型是主键类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">queryNameByIds</span><span class="params">(List&lt;Long&gt; ids)</span></span>&#123;</span><br><span class="line">    List&lt;Category&gt; categories = categoryMapper.selectByIdList(ids);</span><br><span class="line">    <span class="keyword">return</span> categories.stream().map(category -&gt; category.getName()).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="新增商品"><a href="#新增商品" class="headerlink" title="新增商品"></a>新增商品</h3><h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><p>goods.categories被监听 当选择商品分类时 会根据分类id查询品牌列表</p>
<p><img src="/2020/10/19/leyou/image-20201113105837276.png" alt="image-20201113105837276"></p>
<h4 id="富文本编辑器"><a href="#富文本编辑器" class="headerlink" title="富文本编辑器"></a>富文本编辑器</h4><h5 id="什么是富文本编辑器"><a href="#什么是富文本编辑器" class="headerlink" title="什么是富文本编辑器"></a>什么是富文本编辑器</h5><p>百度百科：</p>
<p><img src="/2020/10/19/leyou/1526290914491.png" alt="1526290914491"></p>
<p>通俗来说：富文本，就是比较丰富的文本编辑器。普通的框只能输入文字，而富文本还能给文字加颜色样式等。</p>
<p>富文本编辑器有很多，例如：KindEditor、Ueditor。但并不原生支持vue</p>
<p>但是我们今天要说的，是一款支持Vue的富文本编辑器：<code>vue-quill-editor</code></p>
<h5 id="Vue-Quill-Editor"><a href="#Vue-Quill-Editor" class="headerlink" title="Vue-Quill-Editor"></a>Vue-Quill-Editor</h5><p>GitHub的主页：<a href="https://github.com/surmon-china/vue-quill-editor">https://github.com/surmon-china/vue-quill-editor</a></p>
<p>Vue-Quill-Editor是一个基于Quill的富文本编辑器：<a href="https://quilljs.com/">Quill的官网</a></p>
<p><img src="/2020/10/19/leyou/1526291232678.png" alt="1526291232678"></p>
<h5 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h5><p>使用非常简单：已经在项目中集成。以下步骤不需操作，仅供参考</p>
<p>第一步：安装，使用npm命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> vue-quill-editor <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<p>第二步：加载，在js中引入：</p>
<p>全局引入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueQuillEditor <span class="keyword">from</span> <span class="string">&#x27;vue-quill-editor&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;&#125;; <span class="comment">/* &#123; default global options &#125; */</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueQuillEditor, options); <span class="comment">// options可选</span></span><br></pre></td></tr></table></figure>



<p>局部引入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;quill/dist/quill.core.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;quill/dist/quill.snow.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;quill/dist/quill.bubble.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;quillEditor&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-quill-editor&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    components:&#123;</span><br><span class="line">        quillEditor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们这里采用局部引用：</p>
<p><img src="/2020/10/19/leyou/1528465859061.png" alt="1528465859061"></p>
<p>第三步：页面使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">quill-editor</span> <span class="attr">v-model</span>=<span class="string">&quot;goods.spuDetail.description&quot;</span> <span class="attr">:options</span>=<span class="string">&quot;editorOption&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="自定义的富文本编辑器"><a href="#自定义的富文本编辑器" class="headerlink" title="自定义的富文本编辑器"></a>自定义的富文本编辑器</h5><p>不过这个组件有个小问题，就是图片上传的无法直接上传到后台，因此我们对其进行了封装，支持了图片的上传。</p>
<p> <img src="/2020/10/19/leyou/1526296083605.png" alt="1526296083605.png"></p>
<p>使用也非常简单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">v-stepper-content</span> <span class="attr">step</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">v-editor</span> <span class="attr">v-model</span>=<span class="string">&quot;goods.spuDetail.description&quot;</span> <span class="attr">upload-url</span>=<span class="string">&quot;/upload/image&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">v-stepper-content</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>upload-url：是图片上传的路径</li>
<li>v-model：双向绑定，将富文本编辑器的内容绑定到goods.spuDetail.description</li>
</ul>
<h5 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h5><p><img src="/2020/10/19/leyou/1528469209005.png" alt="1528469209005"></p>
<p>如果出错：无法获取服务端连接资源:can’t create connection to/192.168.182.128:22122</p>
<p>在虚拟机中关闭防火墙并执行：iptables -L ，iptables -F</p>
<h4 id="规格参数"><a href="#规格参数" class="headerlink" title="规格参数"></a>规格参数</h4><p>goods.categories被监听 当选择商品分类时 会根据分类id查询规格参数</p>
<h4 id="商品新增"><a href="#商品新增" class="headerlink" title="商品新增"></a>商品新增</h4><p>前端页面中GoodsForm.vue中这段代码不需要将价格格式化 因为后端的price字段是long类型 格式化就会传入string类型 会产生转换错误</p>
<p><img src="/2020/10/19/leyou/image-20201113144254082.png" alt="image-20201113144254082"></p>
<h4 id="商品修改"><a href="#商品修改" class="headerlink" title="商品修改"></a>商品修改</h4><p>一下报错是因为xxxbyExample没有传入Example实例：</p>
<p>There is no getter for property named ‘oredCriteria’ in ‘class com.domain.</p>
<h2 id="leyou-commons"><a href="#leyou-commons" class="headerlink" title="leyou-commons"></a>leyou-commons</h2><p>放入公共的代码</p>
<h2 id="leyou-search"><a href="#leyou-search" class="headerlink" title="leyou-search"></a>leyou-search</h2><p>需要调用leyou-item-interface 使用feign(微服务之间进行调用)  </p>
<h3 id="远程调用controller接口"><a href="#远程调用controller接口" class="headerlink" title="远程调用controller接口"></a>远程调用controller接口</h3><p>把Good中需要的属性相应的获取方法 封装在接口中 </p>
<p><img src="/2020/10/19/leyou/image-20201115153913617.png" alt="image-20201115153913617"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BrandApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">Brand <span class="title">queryBrandById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在leyou-search中使用feign进行调用</p>
<p><img src="/2020/10/19/leyou/image-20201115153948811.png" alt="image-20201115153948811"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;item-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BrandClient</span> <span class="keyword">extends</span> <span class="title">BrandApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spu转换为good</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CategoryClient categoryClient;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BrandClient brandClient;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SpecificationClient specificationClient;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodsClient goodsClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper MAPPER = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Goods <span class="title">BuildGoods</span><span class="params">(Spu spu)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="comment">//根据分类id获取分类名称</span></span><br><span class="line">        List&lt;String&gt; names = categoryClient.queryNamesByIds(Arrays.asList(spu.getCid1(), spu.getCid2(), spu.getCid3()));</span><br><span class="line">        <span class="comment">//查询品牌</span></span><br><span class="line">        Brand brand = brandClient.queryBrandById(spu.getBrandId());</span><br><span class="line">        <span class="comment">//根据spuId查询所有sku</span></span><br><span class="line">        List&lt;Sku&gt; skus = goodsClient.querySkusBySpuId(spu.getId());</span><br><span class="line">        <span class="comment">//sku价格集合</span></span><br><span class="line">        List&lt;Long&gt; prices = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//sku集合 ：sku中集合有很多没用的参数 把有用的参数抽取出来</span></span><br><span class="line">        List&lt;Map&lt;String,Object&gt;&gt; skuMapList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        skus.forEach(sku -&gt; &#123;</span><br><span class="line">            prices.add(sku.getPrice());</span><br><span class="line">            <span class="comment">//存放有用的  参数</span></span><br><span class="line">            Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;id&quot;</span>,sku.getId());</span><br><span class="line">            map.put(<span class="string">&quot;title&quot;</span>,sku.getTitle());</span><br><span class="line">            map.put(<span class="string">&quot;price&quot;</span>,sku.getPrice());</span><br><span class="line">            <span class="comment">//数据库中的图片可能是多张 只获取第一张</span></span><br><span class="line">            map.put(<span class="string">&quot;image&quot;</span>,StringUtils.isBlank(sku.getImages())?<span class="string">&quot;&quot;</span>:StringUtils.split(sku.getImages(),<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">            skuMapList.add(map);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//根据cid3和search==ture获取规格参数 并进行封装</span></span><br><span class="line">        List&lt;SpecParam&gt; params = specificationClient.queryParams(<span class="keyword">null</span>, spu.getCid3(), <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//参数值在spuDetail中</span></span><br><span class="line">        <span class="comment">//根据spuId查询spuDetail</span></span><br><span class="line">        SpuDetail spuDetail = goodsClient.querySpuDetailBySpuId(spu.getId());</span><br><span class="line">        <span class="comment">//反序列化通用参数:第一个参数是反序列化的对象 第二个参数是序列化的结果类型 用TypeReference接受</span></span><br><span class="line">        Map&lt;String, Object&gt; genericSpecMap = MAPPER.readValue(spuDetail.getGenericSpec(), <span class="keyword">new</span> TypeReference&lt;Map&lt;String, Object&gt;&gt;() &#123;&#125;);</span><br><span class="line">        <span class="comment">//反序列化非通用参数</span></span><br><span class="line">        Map&lt;String, List&lt;Object&gt;&gt; specialSpecMap = MAPPER.readValue(spuDetail.getSpecialSpec(), <span class="keyword">new</span> TypeReference&lt;Map&lt;String, List&lt;Object&gt;&gt;&gt;()&#123;&#125;);</span><br><span class="line">        Map&lt;String,Object&gt; specs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        params.forEach(param-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(param.getGeneric())&#123;</span><br><span class="line">                String value = genericSpecMap.get(param.getId().toString()).toString();</span><br><span class="line">                <span class="comment">//如果是搜索区间</span></span><br><span class="line">                <span class="keyword">if</span>(param.getNumeric())&#123;</span><br><span class="line">                    value = chooseSegment(value,param);</span><br><span class="line">                &#125;</span><br><span class="line">                specs.put(param.getName(),value);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                List&lt;Object&gt; value = specialSpecMap.get(param.getId().toString());</span><br><span class="line">                specs.put(param.getName(),value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//设置goods</span></span><br><span class="line">        Goods goods= <span class="keyword">new</span> Goods();</span><br><span class="line">        goods.setId(spu.getId());</span><br><span class="line">        goods.setCid1(spu.getCid1());</span><br><span class="line">        goods.setCid2(spu.getCid2());</span><br><span class="line">        goods.setCid3(spu.getCid3());</span><br><span class="line">        goods.setBrandId(spu.getBrandId());</span><br><span class="line">        goods.setCreateTime(spu.getCreateTime());</span><br><span class="line">        goods.setSubTitle(spu.getSubTitle());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * tile 分类名称和品牌名称 空格是为了在分词的时候进行分隔</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        goods.setAll(spu.getTitle()+<span class="string">&quot; &quot;</span>+ StringUtils.join(names,<span class="string">&quot; &quot;</span>)+<span class="string">&quot; &quot;</span>+brand.getName());</span><br><span class="line">        <span class="comment">//获取所有spu下sku的价格</span></span><br><span class="line">        goods.setPrice(prices);</span><br><span class="line">        <span class="comment">//获取spu下所有sku 并转换成json字符串</span></span><br><span class="line">        goods.setSkus(MAPPER.writeValueAsString(skuMapList));</span><br><span class="line">        <span class="comment">//获取spu下所有查询的规格参数 格式&#123;name:value&#125;</span></span><br><span class="line">        goods.setSpecs(specs);</span><br><span class="line">        <span class="keyword">return</span> goods;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">chooseSegment</span><span class="params">(String value, SpecParam p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> val = NumberUtils.toDouble(value);</span><br><span class="line">        String result = <span class="string">&quot;其它&quot;</span>;</span><br><span class="line">        <span class="comment">// 保存数值段</span></span><br><span class="line">        <span class="keyword">for</span> (String segment : p.getSegments().split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">            String[] segs = segment.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取数值范围</span></span><br><span class="line">            <span class="keyword">double</span> begin = NumberUtils.toDouble(segs[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">double</span> end = Double.MAX_VALUE;</span><br><span class="line">            <span class="keyword">if</span>(segs.length == <span class="number">2</span>)&#123;</span><br><span class="line">                end = NumberUtils.toDouble(segs[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否在范围内</span></span><br><span class="line">            <span class="keyword">if</span>(val &gt;= begin &amp;&amp; val &lt; end)&#123;</span><br><span class="line">                <span class="keyword">if</span>(segs.length == <span class="number">1</span>)&#123;</span><br><span class="line">                    result = segs[<span class="number">0</span>] + p.getUnit() + <span class="string">&quot;以上&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(begin == <span class="number">0</span>)&#123;</span><br><span class="line">                    result = segs[<span class="number">1</span>] + p.getUnit() + <span class="string">&quot;以下&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    result = segment + p.getUnit();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Feign 发现有body就会强制把GET转换成POST 导入jar包 不然会出错</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">okhttp:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>10.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>bug：如果把SpecParm的根据cid和根据gid查询合并成一个方法 并用specParamClient调用该方法调用的时候cid会传入null？</p>
<h3 id="导入图片信息"><a href="#导入图片信息" class="headerlink" title="导入图片信息"></a>导入图片信息</h3><p>现在商品表中虽然有数据，但是所有的图片信息都是无法访问的，我们需要把图片导入到虚拟机：</p>
<p>首先，把课前资料提供的数据上传到虚拟机下：<code>/leyou/static</code>目录：在leyou下创建static目录</p>
<p><img src="/2020/10/19/leyou/1528445149890.png" alt="1528445149890"></p>
<p><img src="/2020/10/19/leyou/1528479229165.png" alt="1528479229165"></p>
<p>然后，使用命令解压缩：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">unzip images.zip</span><br></pre></td></tr></table></figure>



<p>修改Nginx配置，使nginx反向代理这些图片地址：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /opt/nginx/config/nginx.conf</span><br></pre></td></tr></table></figure>

<p>修改成如下配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  image.leyou.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 监听域名中带有group的，交给FastDFS模块处理</span></span><br><span class="line">    <span class="attribute">location</span> ~/group([<span class="number">0</span>-<span class="number">9</span>])/ &#123;</span><br><span class="line">        ngx_fastdfs_module;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 将其它图片代理指向本地的/leyou/static目录</span></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /leyou/static/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要忘记重新加载nginx配置</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nginx -s reload</span></span><br></pre></td></tr></table></figure>

<h3 id="分类和品牌聚合"><a href="#分类和品牌聚合" class="headerlink" title="分类和品牌聚合"></a>分类和品牌聚合</h3><p><strong>修改search方法</strong></p>
<p>创建一个类SearchResult存放商品聚合后的结果集</p>
<p>修改SearchController中的search方法添加es的聚合查询 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">queryBuilder.addAggregation(AggregationBuilders.terms(categoryAggName).field(<span class="string">&quot;cid3&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>这句相当于</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">GET <span class="regexp">/goods/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;categories&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;cid3&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数据过滤</strong></p>
<p>用代码实现下面的操作</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">GET <span class="regexp">/goods/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;must&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;all&quot;</span>: <span class="string">&quot;手机&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;term&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;specs.CPU核数.keyword&quot;</span>: <span class="string">&quot;十核&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leyou-goods-web"><a href="#leyou-goods-web" class="headerlink" title="leyou-goods-web"></a>leyou-goods-web</h2><h3 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a><strong>页面跳转</strong></h3><p>配置一个controller</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(<span class="meta-string">&quot;item/&#123;id&#125;.html&quot;</span>)</span></span><br><span class="line">    <span class="keyword">public</span>  String toItemPage(<span class="meta">@PathVariable(<span class="meta-string">&quot;id&quot;</span>)</span> <span class="built_in">Long</span> id, Model model)&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="number">111</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;item&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在nginx.conf中进行配置</p>
<p><img src="/2020/10/19/leyou/image-20201122204401819.png" alt="image-20201122204401819"></p>
<p>当点击照片的时候跳转路径</p>
<p><img src="/2020/10/19/leyou/image-20201122204508895.png" alt="image-20201122204508895"></p>
<p>当点击照片的时候被反向代理到8084端口 然后跳转到item.html 同时请求静态资源</p>
<p><img src="/2020/10/19/leyou/image-20201122204743132.png" alt="image-20201122204743132"></p>
<p>这个静态资源被反向代理到9002端口 从portal项目中获取 </p>
<h3 id="封装模型数据"><a href="#封装模型数据" class="headerlink" title="封装模型数据"></a>封装模型数据</h3><p>跳转后的页面中 我们已知的条件是传递来的spu的id，我们需要根据spu的id查询到下面的数据：</p>
<ul>
<li>spu信息</li>
<li>spu的详情</li>
<li>spu下的所有sku</li>
<li>品牌</li>
<li>商品三级分类</li>
<li>商品规格参数、规格参数组</li>
</ul>
<p>在相应的controller中添加没有的方法</p>
<p>并在GoodsService中进行调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    GoodsService goodsService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;item/&#123;id&#125;.html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">toItemPage</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id, Model model)</span></span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = goodsService.loadDate(id);</span><br><span class="line">        model.addAllAttributes(map);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;item&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动时会报错</p>
<p><img src="/2020/10/19/leyou/image-20201122222918887.png" alt="image-20201122222918887"></p>
<p> 这是由于我在同一个项目中用了相同的两个@FeignClient(“item-service”)导致报错。</p>
<p>解决方法 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">      name: sxbs-mall-consumer</span><br><span class="line">    # 多个接口上的@FeignClient(“相同服务名”)会报错，overriding is disabled。</span><br><span class="line">    # 设置 为true ,即 允许 同名</span><br><span class="line">    main:</span><br><span class="line">      allow-bean-definition-overriding: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h3 id="thymeleaf实现页面静态化"><a href="#thymeleaf实现页面静态化" class="headerlink" title="thymeleaf实现页面静态化"></a>thymeleaf实现页面静态化</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>先说下Thymeleaf中的几个概念：</p>
<ul>
<li>Context：运行上下文</li>
<li>TemplateResolver：模板解析器</li>
<li>TemplateEngine：模板引擎</li>
</ul>
<blockquote>
<p>Context</p>
</blockquote>
<p>上下文： 用来保存模型数据，当模板引擎渲染时，可以从Context上下文中获取数据用于渲染。</p>
<p>当与SpringBoot结合使用时，我们放入Model的数据就会被处理到Context，作为模板渲染的数据使用。</p>
<blockquote>
<p>TemplateResolver</p>
</blockquote>
<p>模板解析器：用来读取模板相关的配置，例如：模板存放的位置信息，模板文件名称，模板文件的类型等等。</p>
<p>当与SpringBoot结合时，TemplateResolver已经由其创建完成，并且各种配置也都有默认值，比如模板存放位置，其默认值就是：templates。比如模板文件类型，其默认值就是html。</p>
<blockquote>
<p>TemplateEngine</p>
</blockquote>
<p>模板引擎：用来解析模板的引擎，需要使用到上下文、模板解析器。分别从两者中获取模板中需要的数据，模板文件。然后利用内置的语法规则解析，从而输出解析后的文件。来看下模板引擎进行处理的函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">templateEngine.process(<span class="string">&quot;模板名&quot;</span>, context, writer);</span><br></pre></td></tr></table></figure>

<p>三个参数：</p>
<ul>
<li>模板名称</li>
<li>上下文：里面包含模型数据</li>
<li>writer：输出目的地的流</li>
</ul>
<p>在输出时，我们可以指定输出的目的地，如果目的地是Response的流，那就是网络响应。如果目的地是本地文件，那就实现静态化了。</p>
<p>而在SpringBoot中已经自动配置了模板引擎，因此我们不需要关心这个。现在我们做静态化，就是把输出的目的地改成本地文件即可！</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>创建一个service处理html</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsHtmlService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TemplateEngine templateEngine;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodsService goodsService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createHtml</span><span class="params">(Long spuId)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化运行上下文</span></span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        <span class="comment">//设置数据模型</span></span><br><span class="line">        context.setVariables(goodsService.loadDate(spuId));</span><br><span class="line">        <span class="comment">//把静态文件生成到本地</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\nginx-1.19.2\\html\\item\\&quot;</span>+spuId+<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        PrintWriter printWriter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            printWriter = <span class="keyword">new</span> PrintWriter(file);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(printWriter!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                printWriter.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.templateEngine.process(<span class="string">&quot;item&quot;</span>,context,printWriter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在GoodsService中进行调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;item/&#123;id&#125;.html&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  String <span class="title">toItemPage</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id, Model model)</span></span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = goodsService.loadDate(id);</span><br><span class="line">    model.addAllAttributes(map);</span><br><span class="line">    goodsHtmlService.createHtml(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;item&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;item &#123;</span><br><span class="line">    # 先找本地 默认在nginx中寻找对应的文件名 html</span><br><span class="line">    root html;</span><br><span class="line">    if (!-f $request_filename) &#123; #请求的文件不存在，就反向代理</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:8084;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="整合rabitMQ到项目中"><a href="#整合rabitMQ到项目中" class="headerlink" title="整合rabitMQ到项目中"></a>整合rabitMQ到项目中</h2><p>为了防止并发 发送的消息越精简越好</p>
<p><img src="/2020/10/19/leyou/image-20201130225708860.png" alt="image-20201130225708860"></p>
<p>在item-service中增加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.52</span><span class="number">.131</span></span><br><span class="line">  <span class="attr">virtual-host:</span> <span class="string">/leyou</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">bob</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">Bbj0611..</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">exchange:</span> <span class="string">LEYOU.ITEM.EXCHANGE</span></span><br></pre></td></tr></table></figure>

<p>在GoodsServiceImpl中增加发送消息的方法</p>
<p><img src="/2020/10/19/leyou/image-20201130233851073.png" alt="image-20201130233851073"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String type, Long id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        amqpTemplate.convertAndSend(<span class="string">&quot;item.&quot;</span>+type,id);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (AmqpException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在leyou-goods-web和search服务中增加依赖 配置 监听的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodsHtmlService goodsHtmlService;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(value = &quot;LEYOU.ITEM.SAVE_QUEUE&quot;,durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(value = &quot;LEYOU_ITEM_EXCHANGE&quot;,ignoreDeclarationExceptions = &quot;true&quot;,type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;item.insert&quot;,&quot;item.update&quot;&#125;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.goodsHtmlService.createHtml(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(value = &quot;LEYOU.ITEM.DELETE_QUEUE&quot;,durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(value = &quot;LEYOU_ITEM_EXCHANGE&quot;,ignoreDeclarationExceptions = &quot;true&quot;,type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;item.delete&quot;&#125;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.goodsHtmlService.deleteHtml(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><h3 id="cookie写入问题"><a href="#cookie写入问题" class="headerlink" title="cookie写入问题"></a>cookie写入问题</h3><p>我们去Debug跟踪CookieUtils，看看到底是怎么回事：</p>
<p>我们发现内部有一个方法，用来获取Domain：</p>
<p><img src="/2020/10/19/leyou/1533303181817.png" alt="1533303181817"></p>
<p>它获取domain是通过服务器的host来计算的，然而我们的地址竟然是：127.0.0.1:8087，因此后续的运算，最终得到的domain就变成了：</p>
<p><img src="/2020/10/19/leyou/1533303213902.png" alt="1533303213902"></p>
<p>问题找到了：我们请求时的serverName明明是：api.leyou.com，现在却被变成了：127.0.0.1，因此计算domain是错误的，从而导致cookie设置失败！</p>
<p>那么问题来了：为什么我们这里的请求serverName变成了：127.0.0.1:8087呢？</p>
<p>这里的server name其实就是请求的时的主机名：Host，之所以改变，有两个原因：</p>
<ul>
<li>我们使用了nginx反向代理，当监听到api.leyou.com的时候，会自动将请求转发至127.0.0.1:10010，即Zuul。</li>
<li>而后请求到达我们的网关Zuul，Zuul就会根据路径匹配，我们的请求是/api/auth，根据规则被转发到了 127.0.0.1:8087 ，即我们的授权中心。</li>
</ul>
<p>我们首先去更改nginx配置，让它不要修改我们的host：<code>proxy_set_header Host $host;</code></p>
<p><img src="/2020/10/19/leyou/1533303544219.png" alt="1533303544219"></p>
<p>把nginx进行reload：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nginx -s reload</span></span><br></pre></td></tr></table></figure>



<p>这样就解决了nginx这里的问题。但是Zuul还会有一次转发，所以要去修改网关的配置（leyou-gateway工程）：</p>
<p><img src="/2020/10/19/leyou/1533303659673.png" alt="1533303659673"></p>
<p>重启后，我们再次测试。</p>
<p><img src="/2020/10/19/leyou/1533716093162.png" alt="1533716093162"></p>
<p>最后计算得到的domain：</p>
<p><img src="/2020/10/19/leyou/1533716136698.png" alt="1533716136698"></p>
<p>我们再次登录，发现依然没有cookie！！</p>
<p><img src="/2020/10/19/leyou/01348FC2.gif" alt="img"> </p>
<p>怎么回事呢？</p>
<p>我们通过RestClient访问下看看：</p>
<p><img src="/2020/10/19/leyou/1534225751381.png" alt="1534225751381"></p>
<p>发现，响应头中还是没有<code>set-cookie</code>。</p>
<p>这是怎么回事？？</p>
<p>Zuul内部有默认的过滤器，会对请求和响应头信息进行重组，过滤掉敏感的头信息：</p>
<p><img src="/2020/10/19/leyou/1533732985089.png" alt="1533732985089"></p>
<p>会发现，这里会通过一个属性为<code>SensitiveHeaders</code>的属性，来获取敏感头列表，然后添加到<code>IgnoredHeaders</code>中，这些头信息就会被忽略。</p>
<p>而这个<code>SensitiveHeaders</code>的默认值就包含了<code>set-cookie</code>：</p>
<p><img src="/2020/10/19/leyou/1533733081367.png" alt="1533733081367"></p>
<p>解决方案有两种：</p>
<p>全局设置：</p>
<ul>
<li><code>zuul.sensitive-headers=</code> </li>
</ul>
<p>指定路由设置：</p>
<ul>
<li><code>zuul.routes.&lt;routeName&gt;.sensitive-headers=</code></li>
<li><code>zuul.routes.&lt;routeName&gt;.custom-sensitive-headers=true</code></li>
</ul>
<p>思路都是把敏感头设置为null</p>
<p><img src="/2020/10/19/leyou/1533733356133.png" alt="1533733356133"></p>
<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>build中存放了webpack的配置文件 config中存放了webpack运行所需要的环境参数</p>
<p>dist是打包目录</p>
<p>该项目是单页面应用 只有一个index.html 其他内容都是组件</p>
<p>src下的asset存放静态资源 modules存放全局组件</p>
<p>目录结构</p>
<p><img src="/2020/10/19/leyou/image-20201020100244930.png" alt="image-20201020100244930"></p>
<p>调用关系</p>
<ul>
<li>index.html：html模板文件。定义了空的<code>div</code>，其id为<code>app</code>。</li>
<li>main.js：<strong>实例化vue对象</strong>，并且通过id选择器绑定到index.html的div中，因此<strong>main.js的内容都将在index.html的div中显示</strong>。main.js中使用了App组件，即App.vue，也就是说index.html中最终展现的是App.vue中的内容。index.html引用它之后，就拥有了vue的内容（包括组件、样式等），所以，main.js也是<strong>webpack打包的入口</strong>。</li>
<li>index.js：定义请求路径和组件的映射关系。相当于之前的<code>&lt;vue-router&gt;</code></li>
<li>App.vue中也没有内容，而是定义了vue-router的锚点：<code>&lt;router-view&gt;</code>,我们之前讲过，vue-router路由后的组件将会在锚点展示。</li>
<li>最终结论：<strong>一切路由后的内容都将通过App.vue在index.html中显示。</strong></li>
<li>访问流程：用户在浏览器输入路径，例如：<a href="http://localhost:9001/#/item/brand">http://localhost:9001/#/item/brand</a> –&gt; index.js(/item/brand路径对应pages/item/Brand.vue组件) –&gt; 该组件显示在App.vue的锚点位置 –&gt; main.js使用了App.vue组件，并把该组件渲染在index.html文件中（id为“app”的div中）</li>
</ul>
<h2 id="使用域名访问后台页面"><a href="#使用域名访问后台页面" class="headerlink" title="使用域名访问后台页面"></a>使用域名访问后台页面</h2><p>在SwitchHosts中进行配置</p>
<p><img src="/2020/10/19/leyou/image-20201105202038416.png" alt="image-20201105202038416"></p>
<p>在leyou-manage-web前端项目中配置的访问路径是localhost 不允许通过其他域名进行访问</p>
<p><img src="/2020/10/19/leyou/image-20201105202129847.png" alt="image-20201105202129847"></p>
<p>在webpack.dev.conf.js中的devServer配置使域名检查失效</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="attr">disableHostCheck:</span><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>但是现在要访问后台页面，还得自己加上端口：<code>http://manage.leyou.com:9001</code>。</p>
<p>这就不够优雅了。我们希望的是直接域名访问：<code>http://manage.taotao.com</code>。这种情况下端口默认是80，如何才能把请求转移到9001端口呢？</p>
<p>这里就要用到反向代理工具：Nginx</p>
<h2 id="使用nginx作为web服务器作为反向代理"><a href="#使用nginx作为web服务器作为反向代理" class="headerlink" title="使用nginx作为web服务器作为反向代理"></a>使用nginx作为web服务器作为反向代理</h2><p><strong>Web服务器分2类</strong></p>
<ul>
<li>web应用服务器，如：<ul>
<li>tomcat </li>
<li>resin</li>
<li>jetty</li>
</ul>
</li>
<li>web服务器，如：<ul>
<li>Apache 服务器 </li>
<li>Nginx</li>
<li>IIS  </li>
</ul>
</li>
</ul>
<p>区分：web服务器不能解析jsp等页面，只能处理js、css、html等静态资源。<br>并发：web服务器的并发能力远高于web应用服务器。</p>
<p>nginx可以作为web服务器，但更多的时候，我们把它作为网关，因为它具备网关必备的功能：反向代理,负载均衡,动态路由,请求过滤</p>
<p>什么是反向代理？</p>
<ul>
<li>代理：通过客户机的配置，实现让一台服务器代理客户机，客户的所有请求都交给代理服务器处理。</li>
<li>反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务器。</li>
</ul>
<p>nginx可以当做反向代理服务器来使用：</p>
<ul>
<li>我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理</li>
<li>当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能</li>
</ul>
<p>利用反向代理，就可以解决我们前面所说的端口问题，如图</p>
<p><img src="/2020/10/19/leyou/1526016663674.png" alt="1526016663674"></p>
<p><strong>反向代理配置</strong></p>
<p> <img src="/2020/10/19/leyou/1526188831504.png" alt="1"></p>
<p>nginx中的每个server就是一个反向代理配置，可以有多个server</p>
<p>启动nginx：start nginx 重新加载：nginx -s reload 停止：nginx -s stop</p>
<p><strong>流程</strong></p>
<ol>
<li><p>浏览器准备发起请求，访问<a href="http://mamage.leyou.com,但需要进行域名解析/">http://mamage.leyou.com，但需要进行域名解析</a></p>
</li>
<li><p>优先进行本地域名解析，因为我们修改了hosts，所以解析成功，得到地址：127.0.0.1</p>
</li>
<li><p>请求被发往解析得到的ip，并且默认使用80端口：<a href="http://127.0.0.1/">http://127.0.0.1:80</a></p>
<p>本机的nginx一直监听80端口，因此捕获这个请求</p>
</li>
<li><p>nginx中配置了反向代理规则，将manage.leyou.com代理到127.0.0.1:9001，因此请求被转发</p>
</li>
<li><p>后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx</p>
</li>
<li><p>nginx将得到的结果返回到浏览器</p>
</li>
</ol>
<h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><table>
<thead>
<tr>
<th>跨域原因说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>域名不同</td>
<td><code>www.jd.com</code> 与 <code>www.taobao.com</code></td>
</tr>
<tr>
<td>域名相同，端口不同</td>
<td><code>www.jd.com:8080</code> 与 <code>www.jd.com:8081</code></td>
</tr>
<tr>
<td>二级域名不同</td>
<td><code>item.jd.com</code> 与 <code>miaosha.jd.com</code></td>
</tr>
</tbody></table>
<p>http和https也属于跨域  </p>
<h2 id="cors解决跨域"><a href="#cors解决跨域" class="headerlink" title="cors解决跨域"></a>cors解决跨域</h2><h3 id="5-3-1-什么是cors"><a href="#5-3-1-什么是cors" class="headerlink" title="5.3.1.什么是cors"></a>5.3.1.什么是cors</h3><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p>
<p>它允许浏览器向跨源服务器，发出<a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html"><code>XMLHttpRequest</code></a>请求，从而克服了AJAX只能<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">同源</a>使用的限制。</p>
<p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<ul>
<li><p>浏览器端：</p>
<p>目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。</p>
</li>
<li><p>服务端：</p>
<p>CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否允许其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。</p>
</li>
</ul>
<h3 id="5-3-2-原理有点复杂"><a href="#5-3-2-原理有点复杂" class="headerlink" title="5.3.2.原理有点复杂"></a>5.3.2.原理有点复杂</h3><p>浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求。</p>
<h4 id="5-3-2-1-简单请求"><a href="#5-3-2-1-简单请求" class="headerlink" title="5.3.2.1.简单请求"></a>5.3.2.1.简单请求</h4><p>只要同时满足以下两大条件，就属于简单请求。：</p>
<p>（1) 请求方法是以下三种方法之一： </p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>（2）HTTP的头信息不超出以下几种字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
<p>当浏览器发现发起的ajax请求是简单请求时，会在请求头中携带一个字段：<code>Origin</code>.</p>
<p><img src="/2020/10/19/leyou/1530460311064.png" alt="1530460311064"></p>
<p>Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。</p>
<p>如果服务器允许跨域，需要在返回的响应头中携带下面信息：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: http://manage.leyou.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span>: true</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>

<ul>
<li>Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*（代表任意域名）</li>
<li>Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true</li>
</ul>
<blockquote>
<p>有关cookie：</p>
</blockquote>
<p>要想操作cookie，需要满足3个条件：</p>
<ul>
<li>服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。</li>
<li>浏览器发起ajax需要指定withCredentials 为true</li>
<li>响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名</li>
</ul>
<h4 id="5-3-2-2-特殊请求"><a href="#5-3-2-2-特殊请求" class="headerlink" title="5.3.2.2.特殊请求"></a>5.3.2.2.特殊请求</h4><p>不符合简单请求的条件，会被浏览器判定为特殊请求,，例如请求方式为PUT。</p>
<blockquote>
<p>预检请求</p>
</blockquote>
<p>特殊请求会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>
<p>一个“预检”请求的样板：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/cors</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Origin</span>: http://manage.leyou.com</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span>: PUT</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span>: X-Custom-Header</span><br><span class="line"><span class="attribute">Host</span>: api.leyou.com</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-US</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0...</span><br></pre></td></tr></table></figure>

<p>与简单请求相比，除了Origin以外，多了两个头：</p>
<ul>
<li>Access-Control-Request-Method：接下来会用到的请求方式，比如PUT</li>
<li>Access-Control-Request-Headers：会额外用到的头信息</li>
</ul>
<blockquote>
<p>预检请求的响应</p>
</blockquote>
<p>服务的收到预检请求，如果许可跨域，会发出响应：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span>: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line"><span class="attribute">Server</span>: Apache/2.0.61 (Unix)</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: http://manage.leyou.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span>: true</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span>: GET, POST, PUT</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span>: X-Custom-Header</span><br><span class="line"><span class="attribute">Access-Control-Max-Age</span>: 1728000</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span><br><span class="line"><span class="attribute">Content-Length</span>: 0</span><br><span class="line"><span class="attribute">Keep-Alive</span>: timeout=2, max=100</span><br><span class="line"><span class="attribute">Connection</span>: Keep-Alive</span><br><span class="line"><span class="attribute">Content-Type</span>: text/plain</span><br></pre></td></tr></table></figure>

<p>除了<code>Access-Control-Allow-Origin</code>和<code>Access-Control-Allow-Credentials</code>以外，这里又额外多出3个头：</p>
<ul>
<li>Access-Control-Allow-Methods：允许访问的方式</li>
<li>Access-Control-Allow-Headers：允许携带的头</li>
<li>Access-Control-Max-Age：本次许可的有效时长，单位是秒，<strong>过期之前的ajax请求就无需再次进行预检了</strong></li>
</ul>
<p>如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。</p>
<h3 id="5-3-3-实现非常简单"><a href="#5-3-3-实现非常简单" class="headerlink" title="5.3.3.实现非常简单"></a>5.3.3.实现非常简单</h3><p>虽然原理比较复杂，但是前面说过：</p>
<ul>
<li>浏览器端都有浏览器自动完成，我们无需操心</li>
<li>服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。</li>
</ul>
<p>事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。</p>
<p>在<code>leyou-gateway</code>中编写一个配置类，注册CorsFilter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.CorsFilter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeyouCorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.添加CORS配置信息</span></span><br><span class="line">        CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        <span class="comment">//1) 允许的域,不要写*，否则cookie就无法使用了</span></span><br><span class="line">        config.addAllowedOrigin(<span class="string">&quot;http://manage.leyou.com&quot;</span>);</span><br><span class="line">        <span class="comment">//2) 是否发送Cookie信息</span></span><br><span class="line">        config.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//3) 允许的请求方式</span></span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;OPTIONS&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;HEAD&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;PUT&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;DELETE&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;PATCH&quot;</span>);</span><br><span class="line">        <span class="comment">// 4）允许的头信息</span></span><br><span class="line">        config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加映射路径，我们拦截一切请求</span></span><br><span class="line">        UrlBasedCorsConfigurationSource configSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        configSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.返回新的CorsFilter.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(configSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="前台系统"><a href="#前台系统" class="headerlink" title="前台系统"></a>前台系统</h1><p>项目：leyou-portal-master</p>
<p>没有webpack，我们就无法使用webpack-dev-server运行这个项目，实现热部署。所以，这里我们使用另外一种热部署方式：live-server</p>
<p>使用npm安装</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g live-<span class="keyword">server</span></span><br></pre></td></tr></table></figure>

<p>运行:后面可以接一些参数</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">live-<span class="keyword">server</span></span><br></pre></td></tr></table></figure>

<p>使用端口9002启动并在switchhosts和nginx中进行配置 使其通过<a href="http://www.leyou.com进行访问/">www.leyou.com进行访问</a></p>
<h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><p>ly的getUrlParam可以获取到请求路径中的参数 loacation.search可以对参数进行编码 之后再转换为json对象</p>
<p><img src="/2020/10/19/leyou/image-20201116120558405.png" alt="image-20201116120558405"></p>
<p><strong>解决跨域</strong></p>
<p>在getway微服务中配置</p>
<p><img src="/2020/10/19/leyou/image-20201116121900049.png" alt="image-20201116121900049"></p>
<p>在LeyouCorsConfiguration中增加允许的域</p>
<p><img src="/2020/10/19/leyou/image-20201116121929930.png" alt="image-20201116121929930"></p>
<p>返回给前端的数据如下 只需要三个字段 可以把其他不需要的值过滤掉</p>
<p><img src="/2020/10/19/leyou/image-20201117091645008.png" alt="image-20201117091645008"></p>
<p>在application.yml中进行配置</p>
<p><img src="/2020/10/19/leyou/image-20201117091840572.png" alt="image-20201117091840572"></p>
<p><img src="/2020/10/19/leyou/image-20201117092012690.png" alt="image-20201117092012690"></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>leyou</tag>
      </tags>
  </entry>
  <entry>
    <title>netty</title>
    <url>/2020/12/10/netty/</url>
    <content><![CDATA[<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p><strong>介绍</strong></p>
<p>BIO(同步阻塞IO模式):服务器实现模式为 一个连接对应一个线程，即客户端有连接请求时服务端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销</p>
<p>适用于连接数目较少且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中</p>
<p><strong>工作流程</strong></p>
<ul>
<li>服务端启动一个ServerSocket</li>
<li>客户端启动socket对服务器进行通信，默认情况下服务器需要对每个客户 建立一个线程与之通讯</li>
<li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝</li>
<li>如果有响应，客户端线程会等待请求结束后，再继续执行</li>
</ul>
<p><img src="/2020/12/10/netty/image-20201211180810904.png"></p>
<p><strong>实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            pool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    handler(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getId());</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = inputStream.read(buff)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在linux中进行连接：<code>telnet 192.168.52.1 6666</code></p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>NIO(同步非阻塞IO模式):服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接时如果有IO请求就进行处理</p>
<p>适用于连接数目较多且连接比较短的架构 </p>
<p>AIO适合连接数目多且连接比较长的架构</p>
<p>三大核心：selector-&gt;channel-&gt;buffer</p>
<p><img src="/2020/12/10/netty/image-20201212231552096.png" alt="image-20201212231552096"></p>
<p>一个selector对应一个线程，buffer和channel之间是双向绑定的 客户端只能和buffer进行交互</p>
<h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>缓冲区本质是一个可以读写数据的内存块</p>
<p><strong>类型</strong></p>
<p><img src="/2020/12/10/netty/image-20201212233528926.png" alt="image-20201212233528926"></p>
<p><strong>方法</strong></p>
<p><img src="/2020/12/10/netty/image-20201212233156593.png" alt="image-20201212233156593"></p>
<p><strong>实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntBuffer buffer = IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;buffer.capacity();i++)&#123;</span><br><span class="line">            buffer.put(i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读写转换</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(buffer.hasRemaining())&#123;</span><br><span class="line">            System.out.println(buffer.mark());</span><br><span class="line">            System.out.println(buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/woshijpf/articles/3723364.html">java.nio.Buffer flip()方法的用法详解</a></p>
<p><strong>ByteBuffer(二进制数据)</strong></p>
<p><img src="/2020/12/10/netty/image-20201212233406121.png" alt="image-20201212233406121"></p>
<p>ByteBuffer支持类型化的put和int  put什么类型就应该get什么类型 不然会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//参数是bytes</span></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">20</span>);</span><br><span class="line">    byteBuffer.putInt(<span class="number">4</span>);</span><br><span class="line">    byteBuffer.putLong(<span class="number">5L</span>);</span><br><span class="line">    </span><br><span class="line">	byteBuffer.flip();</span><br><span class="line">    </span><br><span class="line">    byteBuffer.getInt();</span><br><span class="line">    byteBuffer.getLong();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将一个buffer转换成只读的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    byteBuffer.putInt(<span class="number">4</span>);</span><br><span class="line">    byteBuffer.putLong(<span class="number">5L</span>);</span><br><span class="line"></span><br><span class="line">    byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">    ByteBuffer readOnlyBuffer =  byteBuffer.asReadOnlyBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(readOnlyBuffer.hasRemaining())&#123;</span><br><span class="line">        System.out.println(readOnlyBuffer.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MappedByteBuffer可以直接在堆外内存中修改文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;D:\\data\\test.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Maps a region of this channel&#x27;s file directly into memory.</span></span><br><span class="line"><span class="comment">     * 参数1:文件以什么模式被映射到内存</span></span><br><span class="line"><span class="comment">     * 参数2:The position within the file at which the mapped region is to star</span></span><br><span class="line"><span class="comment">     * 参数3:The size of the region to be map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line">    mappedByteBuffer.put(<span class="number">0</span>,(<span class="keyword">byte</span>)<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">    mappedByteBuffer.put(<span class="number">2</span>,(<span class="keyword">byte</span>)<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    randomAccessFile.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>buffer的分散和聚集：通过多个buffer完成读写操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScatteringAndGathering</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Scattering:将数据依次写入到buffer</span></span><br><span class="line">    <span class="comment">//Gathering:将数据依次从buffer中读取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="number">7000</span>);</span><br><span class="line">        <span class="comment">//绑定端口到socket并启动</span></span><br><span class="line">        serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建buffer数据</span></span><br><span class="line">        ByteBuffer[] byteBuffers = <span class="keyword">new</span> ByteBuffer[<span class="number">2</span>];</span><br><span class="line">        byteBuffers[<span class="number">0</span>] = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">        byteBuffers[<span class="number">1</span>] = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待客户端连接</span></span><br><span class="line">        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">        <span class="keyword">int</span> messageLength = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> byteRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> byteWrite = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(byteRead &lt; messageLength)&#123;</span><br><span class="line">                <span class="keyword">long</span> n = socketChannel.read(byteBuffers);</span><br><span class="line">                byteRead += n;</span><br><span class="line">                System.out.println(<span class="string">&quot;byteRead=&quot;</span>+byteRead);</span><br><span class="line">                Arrays.asList(byteBuffers).stream().map(buffer-&gt; <span class="string">&quot;position=&quot;</span>+buffer.position()+<span class="string">&quot;, limit&quot;</span>+buffer.limit()).forEach(System.out::println);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(byteWrite &lt; messageLength)&#123;</span><br><span class="line">                <span class="keyword">long</span> n = socketChannel.write(byteBuffers);</span><br><span class="line">                byteWrite += n;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(buffer -&gt;buffer.clear());</span><br><span class="line">            System.out.println(<span class="string">&quot;byteWrite=&quot;</span>+byteWrite);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>类似于流 但是可以同时进行读写 可以实现异步读写数据 可以从缓冲读数据 也可以写数据到缓冲</p>
<p>常见的channel有：FileChannel(用于文件读写),DatagramChannel(用于UDP的数据读写),ServerSocketChannel,SocketChannel(TCP数据读写)</p>
<p><strong>FileChannel类的常用方法</strong></p>
<p><img src="/2020/12/10/netty/image-20201213001353087.png" alt="image-20201213001353087"></p>
<p>读文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\data\\test.txt&quot;</span>);</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="keyword">int</span> len = (<span class="keyword">int</span>) file.length();</span><br><span class="line">        ByteBuffer.allocate(len);</span><br><span class="line">        FileChannel channel = fileInputStream.getChannel();</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(len);</span><br><span class="line">        channel.read(byteBuffer);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(byteBuffer.array(),<span class="number">0</span>,len));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\data\\test.txt&quot;</span>);</span><br><span class="line">        FileChannel fileChannel = fileOutputStream.getChannel();</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(message.length());</span><br><span class="line">        byteBuffer.put(message.getBytes());</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        fileChannel.write(byteBuffer);</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读写文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用一个buffer完成文件读取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadAndBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//copy test.txt to test2.txt</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\data\\test.txt&quot;</span>);</span><br><span class="line">        FileChannel readChannel = fileInputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\data\\test2.txt&quot;</span>);</span><br><span class="line">        FileChannel writeChannel = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            len = readChannel.read(byteBuffer);</span><br><span class="line">            <span class="keyword">if</span>(len == -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            writeChannel.write(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用transferFrom直接拷贝文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\data\\test.txt&quot;</span>);</span><br><span class="line">        FileChannel readChannel = fileInputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\data\\test2.txt&quot;</span>);</span><br><span class="line">        FileChannel writeChannel = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        writeChannel.transferFrom(readChannel,<span class="number">0</span>,readChannel.size());</span><br><span class="line"></span><br><span class="line">        readChannel.close();</span><br><span class="line">        writeChannel.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h3><p>selector执行select的方法时会获取到所有selectionkey，可以通过selectionkey知道当前的channel发生了什么事件 从而去操作相关的channel</p>
<p><strong>常用方法</strong></p>
<ul>
<li><p>open：得到一个选择器对象</p>
</li>
<li><p>select：监控所有注册的通道，当其中有io操作可以进行时，将对应的selectionKey加入到内部集合中并返回。该方法不带参数的时候  当没有事件时会阻塞 带参数的时候 可以设置超时时间，selectNow立即获取selectionkey不进行等待</p>
</li>
<li><p>selectedKeys：从内部集合中得到所有的selectionkey</p>
</li>
<li><p>wakeup：唤醒selector</p>
<p><strong>Selector，SelectionKey，SocketChannel，ServerSocketChannel之间的关系</strong></p>
</li>
<li><p>当客户端连接时，会通过ServerSocketChannel得到SocketChannel</p>
</li>
<li><p>selector通过select方法 返回有事件发生的通道个数</p>
</li>
<li><p>将SocketChannel通过register方法注册到Selector上，一个selector可以注册多个channel</p>
</li>
<li><p>注册后返回一个SelectionKey，会和Selector关联</p>
</li>
<li><p>进一步得到各个SelectionKey(有事件发生的)</p>
</li>
<li><p>再通过SelectionKey反向获取SocketChannel</p>
</li>
<li><p>通过得到的channel完成业务处理</p>
</li>
</ul>
<p><img src="/2020/12/10/netty/image-20201228190103175.png" alt="image-20201228190103175"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//绑定端口</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line">		<span class="comment">//设置为非堵塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//把serverSocketChannel注册到selector</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(selector.select(<span class="number">1000</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;等待了1s,无连接&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey next = iterator.next();</span><br><span class="line">                <span class="comment">//如果有新的客户端连接</span></span><br><span class="line">                <span class="keyword">if</span>(next.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">//为该客户端生成一个SocketChannel</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    <span class="comment">//将socketChannel注册到selector关注事件为write 并关联一个buffer 这个buffer是位于selector和SocketChannel之间的</span></span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(next.isReadable())&#123;</span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel)next.channel();</span><br><span class="line">                    <span class="comment">//获取channel关联的buffer</span></span><br><span class="line">                    ByteBuffer byteBuffer = (ByteBuffer) next.attachment();</span><br><span class="line">                    socketChannel.read(byteBuffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;from客户端:&quot;</span>+<span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//移除当前selectionKey 防止多线程重复操作</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//如果链接不成功</span></span><br><span class="line">        <span class="keyword">if</span>(!socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>)))&#123;</span><br><span class="line">            <span class="keyword">while</span>(!socketChannel.finishConnect())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;因为连接需要时间 客户端不会阻塞 我可以做其他工作&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="comment">//根据字节数组大小生成buffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(s.getBytes());</span><br><span class="line"></span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SelectionKey定义的四种事件：<a href="https://www.cnblogs.com/liuxiuhao/p/5785027.html">https://www.cnblogs.com/liuxiuhao/p/5785027.html</a></p>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p><a href="https://blog.csdn.net/weixin_37782390/article/details/103833306">sendfile和mmap的区别以及什么是零拷贝</a></p>
<p>nio实现零拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroCopyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="number">7001</span>);</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        ServerSocket socket = serverSocketChannel.socket();</span><br><span class="line">        socket.bind(inetSocketAddress);</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            <span class="keyword">int</span> readCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(-<span class="number">1</span> != readCount)&#123;</span><br><span class="line">                socketChannel.read(byteBuffer);</span><br><span class="line">                <span class="comment">//倒带:position = 0 清除mark</span></span><br><span class="line">                byteBuffer.rewind();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroCopyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>,<span class="number">7001</span>));</span><br><span class="line">        String filename = <span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(filename).getChannel();</span><br><span class="line">        <span class="comment">//linux:一次transferTo方法就可以完成传输</span></span><br><span class="line">        <span class="comment">//windows: 一次transferTo只能传输8m</span></span><br><span class="line">        <span class="keyword">long</span> count = fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br><span class="line">        fileChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><h2 id="传统阻塞IO服务模型"><a href="#传统阻塞IO服务模型" class="headerlink" title="传统阻塞IO服务模型"></a>传统阻塞IO服务模型</h2><p><img src="/2020/12/10/netty/image-20210103141453740.png" alt="image-20210103141453740"></p>
<h2 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h2><p><img src="/2020/12/10/netty/image-20210103141349608.png" alt="image-20210103141349608"></p>
<p><img src="/2020/12/10/netty/image-20210103141723787.png" alt="image-20210103141723787"></p>
<p><img src="/2020/12/10/netty/image-20210103141852408.png" alt="image-20210103141852408"></p>
<p>根据Reactor的数量和处理资源池线程的数量不同 实现可以分为三种</p>
<ul>
<li>单Reactor单线程</li>
<li>单Reactor多线程</li>
<li>主从Reactor多线程</li>
</ul>
<h3 id="单Reactor单线程模式"><a href="#单Reactor单线程模式" class="headerlink" title="单Reactor单线程模式"></a>单Reactor单线程模式</h3><p><img src="/2020/12/10/netty/image-20210103142745489.png" alt="image-20210103142745489"></p>
<p>前面的NIO群聊系统就是这种类型</p>
<p>优缺点分析</p>
<p><img src="/2020/12/10/netty/image-20210103142901882.png" alt="image-20210103142901882"></p>
<h3 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程"></a>单Reactor多线程</h3><p><img src="/2020/12/10/netty/image-20210103143433032.png" alt="image-20210103143433032"></p>
<p>优缺点</p>
<p><img src="/2020/12/10/netty/image-20210103144843844.png" alt="image-20210103144843844"></p>
<h3 id="主从Reactor多线程"><a href="#主从Reactor多线程" class="headerlink" title="主从Reactor多线程"></a>主从Reactor多线程</h3><p><img src="/2020/12/10/netty/image-20210103144856459.png" alt="image-20210103144856459"></p>
<p><img src="/2020/12/10/netty/image-20210103145238171.png" alt="image-20210103145238171"></p>
<p>netty就是基于这种模型</p>
<h2 id="netty模型"><a href="#netty模型" class="headerlink" title="netty模型"></a>netty模型</h2><p><img src="/2020/12/10/netty/image-20210105203951914.png" alt="image-20210105203951914"></p>
<p><img src="/2020/12/10/netty/image-20210105205010494.png" alt="image-20210105205010494"></p>
<ul>
<li>该图中WorkerGroup中的NioEventGroup应为NioEventLoop</li>
<li>每个NioEventLoop都有一个selector 用于监听绑定在其上的多个socket网络通道（channel） 还包含一个taskQueue</li>
<li>每个NioChannel只会绑定再唯一的NioEventLoop上 每个NioChannel都绑定有一个自己的ChannelPipeline</li>
<li>NioEventLoop串行化执行 读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送</li>
</ul>
<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="入门实例"><a href="#入门实例" class="headerlink" title="入门实例"></a>入门实例</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        <span class="comment">//NioEventLoopGroup含有的子线程(NioEventLoop)的个数默认为cpu核心线程数 * 2</span></span><br><span class="line">        <span class="comment">//NioEventLoopGroup()传入参数可以指定子线程个数</span></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//创建服务端的启动服务并配置参数</span></span><br><span class="line">           ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">           bootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                   .channel(NioServerSocketChannel.class)<span class="comment">//使用NioSocketChannel作为服务器的通道实现</span></span><br><span class="line">                   .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>)<span class="comment">//设置线程队列得到连接个数</span></span><br><span class="line">               		<span class="comment">//handler对应bossGroup，childHandler对应workerGroup</span></span><br><span class="line">               		<span class="comment">//handler()是发生在初始化的时候，childHandler()是发生在客户端连接之后。</span></span><br><span class="line">                   .handler(<span class="keyword">null</span>)</span><br><span class="line">                   .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;()&#123;<span class="comment">//创建一个通道测试对象</span></span><br><span class="line">                       <span class="comment">//给pipeline设置处理器</span></span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                           <span class="comment">//传入自定义的handler</span></span><br><span class="line">                           ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">           System.out.println(<span class="string">&quot;server is ready&quot;</span>);</span><br><span class="line">           <span class="comment">//启动服务器，绑定一个端口并同步 生成了一个ChannelFuture对象</span></span><br><span class="line">           ChannelFuture channelFuture = bootstrap.bind(<span class="number">8888</span>).sync();</span><br><span class="line">           <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">           channelFuture.channel().closeFuture().sync();</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;	</span><br><span class="line">           bossGroup.shutdownGracefully();</span><br><span class="line">           workerGroup.shutdownGracefully();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端发来的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx:上下文对象 含有管道pipeline，通道channel，地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg:就是客户端发送的数据 默认是object类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//ByteBuf比Nio中的ByteBuffer性能更高</span></span><br><span class="line">        ByteBuf byteBuf = (ByteBuf)msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送的消息:&quot;</span>+byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端地址:&quot;</span>+ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取数据完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//把数据写到缓冲区并刷新(从缓冲区发送到管道)</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,client&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span>&#123;</span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        EventLoopGroup eventExecutors = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(eventExecutors).channel(NioSocketChannel.class)<span class="comment">//设置客户端通道的实现类</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;client is ready&quot;</span>);</span><br><span class="line">            <span class="comment">//启动客户端去连接服务端</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>).sync();</span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当通道就绪就会触发该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,server&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当通道有读取事件时会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf byteBuf = (ByteBuf)msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器回复的消息:&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器的地址:&quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="taskQueue"><a href="#taskQueue" class="headerlink" title="taskQueue"></a>taskQueue</h2><p>如果pipeline中的handler处理一个时间较长的任务时 可以把该任务交给该channel对应的NioEvenLoop的TaskQueue异步执行 防止阻塞</p>
<p><img src="/2020/12/10/netty/image-20210106144955073.png" alt="image-20210106144955073"> </p>
<p>修改NettyServerHandler中的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//ByteBuf比Nio中的ByteBuffer性能更高</span></span><br><span class="line"><span class="comment">//        ByteBuf byteBuf = (ByteBuf)msg;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;客户端发送的消息:&quot;+byteBuf.toString(CharsetUtil.UTF_8));</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;客户端地址:&quot;+ctx.channel().remoteAddress());</span></span><br><span class="line">		<span class="comment">//模拟耗时任务</span></span><br><span class="line">        Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,client,bbb&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;go on...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取数据完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//把数据写到缓冲区并刷新(从缓冲区发送到管道)</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,client,aaa&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>客户端先需要等待10s才能得到bbb 在得到aaa</p>
<p>解决方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">                ctx.writeAndFlush(Unpo oled.copiedBuffer(<span class="string">&quot;hello,client,bbb&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;go on...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端不会阻塞 立马输出go on 客户端也立刻得到aaa</p>
<p>如果在队列中再增加一个任务 ccc会间隔20s才被收到 taskQueue只有一个线程处理任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">                ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,client,bbb&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">                ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,client,ccc&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;go on...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="scheduledTaskQueue"><a href="#scheduledTaskQueue" class="headerlink" title="scheduledTaskQueue"></a>scheduledTaskQueue</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">                ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,client,bbb&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//延时执行</span></span><br><span class="line">    ctx.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,client,ccc&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(<span class="string">&quot;go on...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scheduleTaskQueue和taskQueue是两个线程</p>
<h2 id="异步模型"><a href="#异步模型" class="headerlink" title="异步模型"></a>异步模型</h2><p><img src="/2020/12/10/netty/image-20210107142433930.png" alt="image-20210107142433930"></p>
<p>工作原理</p>
<p><img src="/2020/12/10/netty/image-20210107143303168.png" alt="image-20210107143303168"></p>
<p>在使用Netty进行编程时，拦截操作和转换出入站数据只需要您提供callback或利用future即可。这使得链式操作简单、高效,并有利于编写可重用的、通用的代码</p>
<p><strong>Future-Listener机制</strong></p>
<p><img src="/2020/12/10/netty/image-20210107143917889.png" alt="image-20210107143917889"></p>
<p><img src="/2020/12/10/netty/image-20210107144247867.png" alt="image-20210107144247867"></p>
<ul>
<li>绑定端口是异步操作 当绑定操作处理完 将会调用相应的监听器处理逻辑</li>
</ul>
<h2 id="http服务程序实例"><a href="#http服务程序实例" class="headerlink" title="http服务程序实例"></a>http服务程序实例</h2><p>要求：服务器回复消息给客户端 并对特定请求资源过滤</p>
<p>新写法：把ChannelInitializer提取出来作为一个单独的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务端的启动服务并配置参数</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)<span class="comment">//使用NioSocketChannel作为服务器的通道实现</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> HttpServerInitializer());</span><br><span class="line">            <span class="comment">//启动服务器，绑定一个端口并同步 生成了一个ChannelFuture对象</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(<span class="number">8888</span>).sync();</span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//向管道加入处理器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到管道</span></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="comment">//加入一个netty 提供的 httpServerCodec（coder和encoder）</span></span><br><span class="line">        <span class="comment">//HttpServerCodec是netty提供的处理http的编解码器</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;MyHttpServerCodec&quot;</span>,<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        <span class="comment">//增加自定义的handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;handler&quot;</span>,<span class="keyword">new</span> HttpServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SimpleChannelInboundHandler是ChannelInboundHandlerAdapter的子类</span></span><br><span class="line"><span class="comment">//HttpObject:客户端和服务端相互通讯的数据被封装成 HttpObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//如果是httpRequest请求</span></span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> HttpRequest)&#123;</span><br><span class="line">            System.out.println(msg.getClass());</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress());</span><br><span class="line">            <span class="comment">//回复信息给浏览器</span></span><br><span class="line">            ByteBuf content = Unpooled.copiedBuffer(<span class="string">&quot;hello,i am server&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">            <span class="comment">//构造一个http的响应</span></span><br><span class="line">            DefaultFullHttpResponse httpResponse = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line">            httpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            httpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH,content.readableBytes());</span><br><span class="line">            <span class="comment">//返回response</span></span><br><span class="line">            ctx.writeAndFlush(httpResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动服务 在浏览器中访问localhost:8888 根据控制台打印的信息 可以判断出浏览器发出了两次请求</p>
<p><img src="/2020/12/10/netty/image-20210107152203610.png" alt="image-20210107152203610"></p>
<p>过滤掉favicon.ico的请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//如果是httpRequest请求</span></span><br><span class="line">    <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> HttpRequest)&#123;</span><br><span class="line">        System.out.println(msg.getClass());</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">        HttpRequest httpRequest = (HttpRequest)msg;</span><br><span class="line">        <span class="comment">//获取uri</span></span><br><span class="line">        URI uri = <span class="keyword">new</span> URI(httpRequest.uri());</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath()))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回复信息给浏览器</span></span><br><span class="line">        ByteBuf content = Unpooled.copiedBuffer(<span class="string">&quot;hello,i am server&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">        <span class="comment">//构造一个http的响应</span></span><br><span class="line">        DefaultFullHttpResponse httpResponse = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line">        httpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">        httpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH,content.readableBytes());</span><br><span class="line">        <span class="comment">//返回response</span></span><br><span class="line">        ctx.writeAndFlush(httpResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Netty核心模块"><a href="#Netty核心模块" class="headerlink" title="Netty核心模块"></a>Netty核心模块</h2><p>Bootstrap,ServerBootstrap</p>
<p><img src="/2020/12/10/netty/image-20210107154223866.png" alt="image-20210107154223866"></p>
<p>Future,ChannelFuture</p>
<p><img src="/2020/12/10/netty/image-20210107154759707.png" alt="image-20210107154759707"></p>
<p>Channel</p>
<p><img src="/2020/12/10/netty/image-20210107154914489.png" alt="image-20210107154914489"></p>
<p><img src="/2020/12/10/netty/image-20210107154925428.png" alt="image-20210107154925428"></p>
<p>Selector</p>
<p><img src="/2020/12/10/netty/image-20210107155214479.png" alt="image-20210107155214479"></p>
<p>ChannelHandler</p>
<p><img src="/2020/12/10/netty/image-20210107155510137.png" alt="image-20210107155510137"></p>
<p><img src="/2020/12/10/netty/image-20210107155716574.png" alt="image-20210107155716574"></p>
<p><img src="/2020/12/10/netty/image-20210107155955429.png" alt="image-20210107155955429"></p>
<p>ChannelPipeline</p>
<p><img src="/2020/12/10/netty/image-20210109140931439.png" alt="image-20210109140931439"></p>
<p><img src="/2020/12/10/netty/image-20210109141324593.png" alt="image-20210109141324593"></p>
<p><img src="/2020/12/10/netty/image-20210109141802136.png" alt="image-20210109141802136"></p>
<p>ChannelHandlerContext</p>
<p><img src="/2020/12/10/netty/image-20210109141930634.png" alt="image-20210109141930634"></p>
<p>ChannelOption</p>
<p><img src="/2020/12/10/netty/image-20210109142440513.png" alt="image-20210109142440513"></p>
<p>EventLoop</p>
<p><img src="/2020/12/10/netty/image-20210109142715578.png" alt="image-20210109142715578"></p>
<p><img src="/2020/12/10/netty/image-20210109143347566.png" alt="image-20210109143347566"></p>
<h2 id="Unpooled类"><a href="#Unpooled类" class="headerlink" title="Unpooled类"></a>Unpooled类</h2><p><img src="/2020/12/10/netty/image-20210109143543585.png" alt="image-20210109143543585"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个ByteBuf对象 该对象包含一个数组byte[10]</span></span><br><span class="line">    ByteBuf byteBuf = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        byteBuf.writeByte(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不需要读写转换 因为ByteBuf中有两个指针readerIndex和writerIndex表示下一个要写入和要读的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; byteBuf.capacity();i++)&#123;</span><br><span class="line">        <span class="comment">//该方法不会引起readIndex的变化</span></span><br><span class="line">        System.out.println(byteBuf.getByte(i));</span><br><span class="line">        <span class="comment">//根据readIndex读取</span></span><br><span class="line">        System.out.println(byteBuf.readByte());</span><br><span class="line">        <span class="comment">//readIndex,writeIndex,capacity将byteBuf划分为三个区间</span></span><br><span class="line">        <span class="comment">//0-readIndex:已读区间</span></span><br><span class="line">        <span class="comment">//readIndex-writeIndex:可读区间</span></span><br><span class="line">        <span class="comment">//writeIndex-capacity:可写区间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="群聊系统"><a href="#群聊系统" class="headerlink" title="群聊系统"></a>群聊系统</h2><p>服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//获取到pipeLine</span></span><br><span class="line">                            ChannelPipeline channelPipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//加入解码器和编码器</span></span><br><span class="line">                            channelPipeline.addLast(<span class="string">&quot;decoder&quot;</span>,<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            channelPipeline.addLast(<span class="string">&quot;encoder&quot;</span>,<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            <span class="comment">//加入自己的业务处理handler</span></span><br><span class="line">                            channelPipeline.addLast(<span class="keyword">new</span> ServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;netty服务器启动&quot;</span>);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(port).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GroupChatServer(<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//管理所有的channel</span></span><br><span class="line">    <span class="comment">//GlobalEventExecutor.INSTANCE)是全局事件执行器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelGroup channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接建立后 该方法第一个被执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将当前客户加入聊天的信息推送给其他在线的客户端</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">//该方法会将channelGroup中所有channel遍历并发送消息</span></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;客户端&quot;</span> + channel.remoteAddress() + <span class="string">&quot;加入聊天&quot;</span>);</span><br><span class="line">        <span class="comment">//将当前Channel加入到channelGroup</span></span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示channel处于活跃状态 提示xx上线</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress()+<span class="string">&quot;上线了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示channel处于非活跃状态 提示xx下线</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress()+<span class="string">&quot;下线了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//断开连接:提示在线用户xx离开</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//当前ChannelGroup容量会-1</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;客户端&quot;</span>+channel.remoteAddress()+<span class="string">&quot;离开了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据并转发给其他人</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">//根据不同情况 回送不同的消息</span></span><br><span class="line">        channelGroup.forEach(ch -&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(channel != ch)&#123;</span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;客户&quot;</span>+channel.remoteAddress() + <span class="string">&quot;发送了消息&quot;</span>+msg);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;自己发送了消息&quot;</span>+msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        NioEventLoopGroup eventExecutors = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(eventExecutors).channel(NioSocketChannel.class).handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ChannelPipeline channelPipeline = ch.pipeline();</span><br><span class="line">                    channelPipeline.addLast(<span class="string">&quot;decoder&quot;</span>,<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                    channelPipeline.addLast(<span class="string">&quot;encoder&quot;</span>,<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                    channelPipeline.addLast(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();</span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            System.out.println(channel.localAddress());</span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">                String msg = scanner.nextLine();</span><br><span class="line">                channel.writeAndFlush(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GroupChatClient(<span class="string">&quot;localhost&quot;</span>,<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="心跳检测案例"><a href="#心跳检测案例" class="headerlink" title="心跳检测案例"></a>心跳检测案例</h2><p>有数据交互的时候用SimpleChannelInboundHanlder没有的时候用ChannelInboundHandlerAdapter </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG))<span class="comment">//日志</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//IdleStateHandler是netty提供的处理空闲状态的处理器</span></span><br><span class="line">                            <span class="comment">//readerIdleTime表示多长时间没读 会发送一个心跳检测包检测是否连接</span></span><br><span class="line">                            <span class="comment">//writerIdleTime表示多长时间没写 会发送一个心跳检测包检测是否连接</span></span><br><span class="line">                            <span class="comment">//readerIdleTime表示多长时间没读写 会发送一个心跳检测包检测是否连接</span></span><br><span class="line">                            <span class="comment">//当IdleStatement触发后 就会传递给管道的下一个handler 通过userEventTriggered处理</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>, TimeUnit.SECONDS));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> Handler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture channelFuture = <span class="keyword">null</span>;</span><br><span class="line">            channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line">            IdleStateEvent stateEvent = (IdleStateEvent) evt;</span><br><span class="line">            String eventType = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (stateEvent.state())&#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;读空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;读写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot;++超时时间++&quot;</span> + eventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WebSocket长连接"><a href="#WebSocket长连接" class="headerlink" title="WebSocket长连接"></a>WebSocket长连接</h2><p>实例要求：</p>
<ul>
<li>http协议是无状态的，浏览器和服务器间的请求响应一次，下一次会重新创建连接</li>
<li>要求：实现基于webSocket的长连接的全双工的交互</li>
<li>改变http协议多次请求的约束，实现长连接后，服务器可以发送消息给浏览器</li>
<li>客户端浏览器和服务器会相互感知</li>
</ul>
<p>server</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG))<span class="comment">//日志</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//因为基于http协议 所以要使用http的编码器和解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                            <span class="comment">//http数据在传输过程中是分段的 HttpObjectAggregator可以将数据聚合起来</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">8192</span>));</span><br><span class="line">                            <span class="comment">//浏览器请求时 ws://localhost:7000/hello 表示请求的url</span></span><br><span class="line">                            <span class="comment">//WebSocketServerProtocolHandler的核心功能是将http协议升级为ws协议 保持长连接</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">&quot;/hello&quot;</span>));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> Handler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture channelFuture = <span class="keyword">null</span>;</span><br><span class="line">            channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TextWebSocketFrame表示一个文本帧 数据是以帧的形式传播的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器收到的消息:&quot;</span>+msg.text());</span><br><span class="line">        <span class="comment">//回复消息给浏览器</span></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(msg.text()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().id().asLongText());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//服务器关闭会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().id().asLongText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(cause.getMessage());</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> socket;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//判断当前浏览器是否支持WS</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(<span class="built_in">window</span>.WebSocket)&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//与服务器地址必须对应</span></span></span><br><span class="line"><span class="javascript">            socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:7000/hello&quot;</span>)</span></span><br><span class="line"><span class="javascript">            <span class="comment">//相当于channelRead0 可以接收服务器会送的消息</span></span></span><br><span class="line"><span class="javascript">            socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">&quot;responseText&quot;</span>).value += event.data;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="comment">//连接开启</span></span></span><br><span class="line"><span class="javascript">            socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">&quot;responseText&quot;</span>).value = <span class="string">&quot;连接开启&quot;</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="comment">//连接关闭</span></span></span><br><span class="line"><span class="javascript">            socket.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">&quot;responseText&quot;</span>).value += <span class="string">&quot;连接关闭&quot;</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;当前浏览器不支持ws&quot;</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//发送消息</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">message</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//先判断socket是否创建</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(!<span class="built_in">window</span>.socket)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span></span></span><br><span class="line"><span class="javascript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line">                if(socket.readyState == WebSocket.OPEN)&#123;</span><br><span class="line">                    socket.send(message)</span><br><span class="line"><span class="javascript">                &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                    alert(<span class="string">&quot;连接未开启&quot;</span>)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;发送消息&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;send(this.form.message.value)&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;responseText&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;清空&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="编码解码机制"><a href="#编码解码机制" class="headerlink" title="编码解码机制"></a>编码解码机制</h2><p><img src="/2020/12/10/netty/image-20210114171347281.png" alt="image-20210114171347281"></p>
<p><img src="/2020/12/10/netty/image-20210114171547184.png" alt="image-20210114171547184"></p>
<h2 id="ProToBuf"><a href="#ProToBuf" class="headerlink" title="ProToBuf"></a>ProToBuf</h2><p>protobuf是一种轻便高效的结构化数据存储方式，可以用于结构化数据串行化(序列化)，以message的方式管理数据，支持跨平台跨语言，高性能高可靠性</p>
<p>运行过程</p>
<p><img src="/2020/12/10/netty/image-20210114201233174.png" alt="image-20210114201233174"></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h3><p>编写proto文件</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">//版本</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;StudentPojo&quot;</span>; <span class="comment">//生成的外部类名，同时也是文件名</span></span><br><span class="line"><span class="comment">//使用message管理对象 会在StudentPojo外部类中生成一个内部类 它是真正要发送的pojo对象</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="comment">//proto类型与java类型的对应请查看官方文档 1表示属性序号 不是值</span></span><br><span class="line">  <span class="built_in">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下载protoc 把.proto文件放到protoc.exe同目录下 执行命令:protoc.exe –java_out=. Student.proto</p>
<p><strong>改写simple中的代码</strong></p>
<p>在client中加入encoder</p>
<p><img src="/2020/12/10/netty/image-20210114230945733.png" alt="image-20210114230945733"></p>
<p>在clientHandler中创建对象并发送</p>
<p><img src="/2020/12/10/netty/image-20210114231007239.png" alt="image-20210114231007239"></p>
<p>server中加入decoder</p>
<p><img src="/2020/12/10/netty/image-20210114231222528.png" alt="image-20210114231222528"></p>
<p>serverHandler中进行接收</p>
<p>方式一</p>
<p><img src="/2020/12/10/netty/image-20210114232038708.png" alt="image-20210114232038708"></p>
<p>方式二</p>
<h3 id="传输多种类型"><a href="#传输多种类型" class="headerlink" title="传输多种类型"></a>传输多种类型</h3><p>编写一个含有多个类型的proto文件</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">//版本</span></span><br><span class="line"><span class="keyword">option</span> optimize_for = SPEED; <span class="comment">//加快解析</span></span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;protobuf&quot;</span>; <span class="comment">//指定生成的包</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;DataInfo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MyMessage</span></span>&#123;</span><br><span class="line">  <span class="comment">//定义一个枚举类型</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">DataType</span></span>&#123;</span><br><span class="line">    StudentType = <span class="number">0</span>;</span><br><span class="line">    TeacherType = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//定义属性</span></span><br><span class="line">  DataType data_type = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//表示枚举类型只能出现其中一个</span></span><br><span class="line">  <span class="keyword">oneof</span> dataBody&#123;</span><br><span class="line">    Student student = <span class="number">2</span>;</span><br><span class="line">    Teacher teacher = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="comment">//proto类型与java类型的对应请查看官方文档 1表示属性序号 不是值</span></span><br><span class="line">  <span class="built_in">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改ClientHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//随机发送数据</span></span><br><span class="line">    <span class="keyword">int</span> nextInt = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">    DataInfo.MyMessage myMessage = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(nextInt == <span class="number">0</span>)&#123;</span><br><span class="line">        myMessage = DataInfo.MyMessage.newBuilder().setDataType(DataInfo.MyMessage.DataType.StudentType).setStudent(DataInfo.Student.newBuilder().setId(<span class="number">3</span>).setName(<span class="string">&quot;bob&quot;</span>).build()).build();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        myMessage = DataInfo.MyMessage.newBuilder().setDataType(DataInfo.MyMessage.DataType.TeacherType).setTeacher(DataInfo.Teacher.newBuilder().setAge(<span class="number">23</span>).setName(<span class="string">&quot;bob&quot;</span>).build()).build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ctx.writeAndFlush(myMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 修改server</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ch</span><span class="selector-class">.pipeline</span>()<span class="selector-class">.addLast</span>(&quot;<span class="selector-tag">decoder</span>&quot;,<span class="selector-tag">new</span> <span class="selector-tag">ProtobufDecoder</span>(<span class="selector-tag">DataInfo</span><span class="selector-class">.MyMessage</span><span class="selector-class">.getDefaultInstance</span>()));</span><br></pre></td></tr></table></figure>

<p>修改serverHandler</p>
<p><img src="/2020/12/10/netty/image-20210115142725948.png" alt="image-20210115142725948"></p>
<h2 id="入站与出栈机制"><a href="#入站与出栈机制" class="headerlink" title="入站与出栈机制"></a>入站与出栈机制</h2><p><img src="/2020/12/10/netty/image-20210115143455187.png" alt="image-20210115143455187"></p>
<h2 id="Handler链调用机制"><a href="#Handler链调用机制" class="headerlink" title="Handler链调用机制"></a>Handler链调用机制</h2><p>package：netty.handler</p>
<p><img src="/2020/12/10/netty/image-20210115144700212.png" alt="image-20210115144700212"></p>
<p>使用自定义编解码器来说明handler调用机制 ，客户端和服务端分别可以发送和接收long类型的数据</p>
<p><strong>Server</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ServerInitializer());</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(<span class="number">8888</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//入站的handler进行解码</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ByteToLongDecoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LongToByteEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;从客户端&quot;</span> + channelHandlerContext.channel().remoteAddress() + <span class="string">&quot;读取到long &quot;</span> + aLong);</span><br><span class="line">        System.out.println(<span class="string">&quot;给客户端发送数据&quot;</span>);</span><br><span class="line">        channelHandlerContext.writeAndFlush(<span class="number">54545L</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//该方法根据接受的数据 被多次调用 如果list内容不为空则将他传入给下一个handler处理 该handler的方法也会被调用多次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(byteBuf.readableBytes() &gt;= <span class="number">8</span>)&#123;</span><br><span class="line">            list.add(byteBuf.readLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, Long aLong, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(aLong);</span><br><span class="line">        byteBuf.writeLong(aLong);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>client</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        EventLoopGroup eventExecutors = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(eventExecutors).channel(NioSocketChannel.class)<span class="comment">//设置客户端通道的实现类</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> ClientInitializer());</span><br><span class="line">            System.out.println(<span class="string">&quot;client is ready&quot;</span>);</span><br><span class="line">            <span class="comment">//启动客户端去连接服务端</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>).sync();</span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">        <span class="comment">//加入一个出站的handler进行解码</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LongToByteEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ByteToLongDecoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息&quot;</span> + aLong);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(<span class="number">1234546L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//MessageToByteEncoder中有一个write方法该方法判断数据是否为Long类型如果不是不进行encoder直接发送</span></span><br><span class="line"><span class="comment">//        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;sdfsafdsadfsdf&quot;, CharsetUtil.UTF_8));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他常用编解码器"><a href="#其他常用编解码器" class="headerlink" title="其他常用编解码器"></a>其他常用编解码器</h2><p><strong>ReplayingDecoder</strong></p>
<p><img src="/2020/12/10/netty/image-20210116135659701.png" alt="image-20210116135659701"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToLongDecoder2</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//内部自动进行判断</span></span><br><span class="line">        list.add(byteBuf.readLong());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其他解码器</strong></p>
<p><img src="/2020/12/10/netty/image-20210116140257726.png" alt="image-20210116140257726"></p>
<h2 id="TCP粘包和拆包"><a href="#TCP粘包和拆包" class="headerlink" title="TCP粘包和拆包"></a>TCP粘包和拆包</h2><p>package：netty.tcp</p>
<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h3><p><img src="/2020/12/10/netty/image-20210116141719207.png" alt="image-20210116141719207"></p>
<p><img src="/2020/12/10/netty/image-20210116141840005.png" alt="image-20210116141840005"></p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.readableBytes()];</span><br><span class="line">        byteBuf.readBytes(buffer);</span><br><span class="line">        String s = <span class="keyword">new</span> String(buffer, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端收到消息&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">120</span>;i++)&#123;</span><br><span class="line">            ByteBuf buffer = Unpooled.copiedBuffer(<span class="string">&quot;hello world&quot;</span> + i, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            ctx.writeAndFlush(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.readableBytes()];</span><br><span class="line">        byteBuf.readBytes(buffer);</span><br><span class="line">        String message = <span class="keyword">new</span> String(buffer, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器收到数据&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回送数据</span></span><br><span class="line">        ByteBuf buf = Unpooled.copiedBuffer(UUID.randomUUID().toString(),Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        channelHandlerContext.writeAndFlush(buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义协议解决粘包拆包问题"><a href="#自定义协议解决粘包拆包问题" class="headerlink" title="自定义协议解决粘包拆包问题"></a>自定义协议解决粘包拆包问题</h3><p>package:netty.protocolTcp</p>
<p><img src="/2020/12/10/netty/image-20210116145332644.png" alt="image-20210116145332644"></p>
<h2 id="服务器启动源码分析"><a href="#服务器启动源码分析" class="headerlink" title="服务器启动源码分析"></a>服务器启动源码分析</h2><p><strong>EchoServer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> SSL = System.getProperty(<span class="string">&quot;ssl&quot;</span>) != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="string">&quot;port&quot;</span>, <span class="string">&quot;8007&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Configure SSL.</span></span><br><span class="line">        <span class="keyword">final</span> SslContext sslCtx;</span><br><span class="line">        <span class="keyword">if</span> (SSL) &#123;</span><br><span class="line">            SelfSignedCertificate ssc = <span class="keyword">new</span> SelfSignedCertificate();</span><br><span class="line">            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sslCtx = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bossGroup用于接收tcp请求,将请求交割workerGroup，workerGroup会获取真正的连接，然后和连接通信</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline p = ch.pipeline();</span><br><span class="line">                            <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">                            p.addLast(serverHandler);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start the server.</span></span><br><span class="line">            ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Shut down all event loops to terminate all threads.</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>EventLoopGroup</strong>是事件循环组 含有多个EventLoop 可以注册channel 默认线程数:核心线程数 * 2 </p>
<p>通过debug查看 断点：EventLoopGroup workerGroup = new NioEventLoopGroup()</p>
<p><img src="/2020/12/10/netty/image-20210117125453180.png" alt="image-20210117125453180"></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">NettyRuntime</span>.</span></span>available<span class="constructor">Processors()</span>获取核心线程数</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/10/netty/image-20210117130022398.png" alt="image-20210117130022398"></p>
<p>线程放在数组EventExcutor中：继续debug到方法MultithreadEventExecutorGroup中</p>
<p><img src="/2020/12/10/netty/image-20210117133132513.png" alt="image-20210117133132513"></p>
<p>参数说明：</p>
<ul>
<li>Executor：如果传入null则采用Netty默认的线程工厂和默认的执行器ThreadPerTaskExecutor</li>
<li>chooserFactory：单例new  EventExecutorChooserFactory ()</li>
<li>在创建执行器时传入的固定参数</li>
</ul>
<p><img src="/2020/12/10/netty/image-20210117130829226.png" alt="image-20210117130829226"></p>
<p>为每个单例线程池添加一个关闭监听器</p>
<p><img src="/2020/12/10/netty/image-20210117133602412.png" alt="image-20210117133602412"></p>
<p>将所有单例线程池添加到HashSet中</p>
<p><img src="/2020/12/10/netty/image-20210117133644923.png" alt="image-20210117133644923"></p>
<p>children的类型是EventExecutor他是NioEventLoop的父接口</p>
<p><img src="/2020/12/10/netty/image-20210117131059365.png" alt="image-20210117131059365"></p>
<p><strong>ServerBootStrap</strong>是一个引导类 用于启动服务器和引导整个程序的初始化。和ServerChannel有关联</p>
<p>首先变量b调用了group方法把两个group放入自己的字段</p>
<p>然后添加了一个channel 参数为Class，引导类通过这个class对象用ChannelFactory反射创建Channel </p>
<p>debug到AbstartBootstrap中</p>
<p><img src="/2020/12/10/netty/image-20210117132618131.png" alt="image-20210117132618131"></p>
<p>option方法传入tcp参数 放在LinkedHashMap中</p>
<p>handler方法传入一个handler这个handler专属于ServerSocketChannel而不是SocketChannel</p>
<p>childHandler传入一个handler 这个handler在每个客户端连接时调用供SocketChannel使用</p>
<p><strong>bind</strong>:底层调用了dobind，dobind中有两个核心方法initAndRegister()和doBind0</p>
<p>在iniAndResigter中创建了NioServerSocketChannel，channelFactory.newChannel()做了以下操作</p>
<ul>
<li>(1)通过NIO的SelectorProvider的openServerSocketChannel方法得到JDK的通道。目的是让Netty包装JDK的 channel。<br>(2)创建了一个唯一的ChannelId，创建了一个NioMessageUnsecurity，用于操作消息，创建了DefaultChannelPipeline 管道，是个双向链表结构，用于过滤所有的进出的消息。<br>(3创建了一个NioServerSocketChannelConfig对象，用于对外展示一些配置.</li>
</ul>
<p>init()方法：</p>
<ul>
<li>设置了NioServerSocketChannel的TCP属性</li>
<li>对NioServerSocketChannel的ChannelPipeline添加ChannelInitialize处理器</li>
<li>pipeLine是一个双向链表 本身初始化了head和tail 调用addLast方法是将handler插入到tail的前面 tail永远在最后面做一些系统的固定工作</li>
</ul>
<p>pipeLine的addLast方法</p>
<p><img src="/2020/12/10/netty/image-20210118123748135.png" alt="image-20210118123748135"></p>
<p>dobind0():bind会调用NioServerSocketChannel中的dobind方法</p>
<p><img src="/2020/12/10/netty/image-20210118125013825.png" alt="image-20210118125013825"></p>
<p>执行完后 服务启动完成 进入NioEventLoop对事件实行循环监听</p>
<h2 id="服务器接收客户端请求源码分析"><a href="#服务器接收客户端请求源码分析" class="headerlink" title="服务器接收客户端请求源码分析"></a>服务器接收客户端请求源码分析</h2><p>NioEventLoop的processSelectedKey方法</p>
<p><img src="/2020/12/10/netty/image-20210118130702064.png" alt="image-20210118130702064"></p>
<p>查看SelectionKey：当接受一个连接的时候readyOps是16</p>
<p><img src="/2020/12/10/netty/image-20210118130739324.png" alt="image-20210118130739324"></p>
<p>在unsafe.read()处标断点 debug 启动 在浏览器访问localhost:8007</p>
<p>read方法</p>
<p><img src="/2020/12/10/netty/image-20210118131430679.png" alt="image-20210118131430679"></p>
<p>doReadMessage方法</p>
<p><img src="/2020/12/10/netty/image-20210118131506713.png" alt="image-20210118131506713"></p>
<p>pipeline.fireChannelRead方法</p>
<p><img src="/2020/12/10/netty/image-20210118132243964.png" alt="image-20210118132243964"></p>
<p>channelRead方法</p>
<p><img src="/2020/12/10/netty/image-20210118135049425.png" alt="image-20210118135049425"></p>
<p><img src="/2020/12/10/netty/image-20210118132559863.png" alt="image-20210118132559863"></p>
<p><img src="/2020/12/10/netty/image-20210118140151220.png" alt="image-20210118140151220"></p>
<p>register底层调用</p>
<p><img src="/2020/12/10/netty/image-20210118140217227.png" alt="image-20210118140217227"></p>
<p>next返回一个Executor它是workGroup子线程中的一个</p>
<p>regiter把channel再次包装 </p>
<p><img src="/2020/12/10/netty/image-20210118140308861.png" alt="image-20210118140308861"></p>
<p>最后调用的是AbstractChannel中的register</p>
<p><img src="/2020/12/10/netty/image-20210118140655725.png" alt="image-20210118140655725"></p>
<p>最后调用doBeginRead开始监听读</p>
<h2 id="pipeline源码分析"><a href="#pipeline源码分析" class="headerlink" title="pipeline源码分析"></a>pipeline源码分析</h2><p>每当ServerSocket创建一个连接的时候 都会创建一个socket 每个新建的socket都会被分配一个ChannelPipeline 每个ChannelPipeline都会包含多个Context context是对handler的封装</p>
<p>入站出站是根据context的状态进行判断 找到链中相应的handler</p>
<p><img src="/2020/12/10/netty/image-20210122133352078.png" alt="image-20210122133352078"></p>
<p><img src="/2020/12/10/netty/image-20210122133737141.png" alt="image-20210122133737141"></p>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC—远程过程调用，是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程，当两个或多个应用程序都分布在不同的服务器上，它们之间的调用都像是本地方法调用一样(如图)</p>
<p><img src="/2020/12/10/netty/image-20210122140307335.png" alt="image-20210122140307335"></p>
]]></content>
      <categories>
        <category>高并发</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程</title>
    <url>/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><strong>并发和并行</strong>：并发是同一时间应对多件事情的能力 并行是同一时间动手做多件事情的能力，单核并发 多核既有并发又有并行</p>
<p><strong>同步和异步</strong>：需要等待结果返回才能继续运行的是同步，不需要结果返回 就能继续运行的是异步</p>
<ul>
<li>代码：case_java8.cn.itcast.n2</li>
</ul>
<p><strong>线程上下文</strong>：线程上下文切换频繁会影响性能 以下一些原因导致cpu不在执行当前线程 转而执行另一个线程的代码</p>
<ul>
<li>线程的时间片用完</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行</li>
<li>线程自己调用了sleep,yield,wait,join,park,synchronized,lock等方法</li>
</ul>
<p><strong>常见方法</strong></p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201005191950899.png" alt="image-20201005191950899"></p>
<ul>
<li>run启动线程后 执行run方法的依然是主线程 所以要想让新线程执行run方法要用start启动线程</li>
<li><a href="https://blog.csdn.net/ssssaaaawe/article/details/100511422">start和run的区别</a><ul>
<li><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201005192824004.png" alt="image-20201005192824004"></li>
</ul>
</li>
</ul>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201005192959678.png" alt="image-20201005192959678"></p>
<ul>
<li>TimeUnit也可以用于让线程休眠 他的可读性更强 并且可以指定时间单位<code>TimeUnit.MICROSECONDS.sleep(100);</code></li>
<li>Sleep会让线程从running转换为TIMED_WAITING状态 时间片会分配给就绪的线程 不会分配给阻塞的线程</li>
</ul>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201005194054103.png" alt="image-20201005194054103"></p>
<ul>
<li>Yield会让线程从running转换为Runnable状态 然后调度其他线程</li>
</ul>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201005193152039.png" alt="image-20201005193152039"></p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201005193157727.png" alt="image-20201005193157727"></p>
<ul>
<li>打断标记是一个bool值 成功打断为true</li>
<li>interrupt打断park：park会挂起当前线程 当打断标记为真的时候park会失效</li>
<li>这段代码中第二个park因为打断标记被设置为true而失效 所以会打印出”unpark…”<img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201005193744583.png" alt="image-20201005193744583"></li>
</ul>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201005194729446.png" alt="image-20201005194729446"></p>
<ul>
<li>如果没有join 主进程结束后r才开始赋值 这样主进程获取不到r的值 使用join方法使主进程等待t1结束 再执行后面的代码<img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201005200252020.png" alt="image-20201005200252020"> <img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201005203947502.png" alt="image-20201005203947502"></li>
<li>join可以传入一个long类型的值 表示等待的最长时间 单位为毫秒 如果线程提前结束 join也将结束</li>
</ul>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201005200809564.png" alt="image-20201005200809564"></p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201005200828808.png" alt="image-20201005200828808"></p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201005200844953.png" alt="image-20201005200844953"></p>
<p><strong>过时的方法</strong></p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201005204031566.png" alt="image-20201005204031566"></p>
<p><strong>线程状态</strong></p>
<p>​    操作系统层面</p>
<p>​    <img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201005204210400.png" alt="image-20201005204210400"></p>
<p>​    javaAPI层面</p>
<p>​        <img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201005204229906.png" alt="image-20201005204229906"></p>
<p><strong>状态转换</strong></p>
<p>t线程用synchronized(obj)获取对象锁后</p>
<p>RUNNABLE&lt;–&gt;WAITING</p>
<ul>
<li>调用obj.wait()方法使 t线程从RUNNABLE–&gt;WAITING</li>
<li>当前线程调用LockSupport.park()方法会让当前线程从RUNNABLE–&gt;WAITING</li>
<li>调用obj.notify(),obj.notifyAll(),t.interrupt()时<ul>
<li>竞争锁成功 ,t线程从WAITING–&gt;RUNNABLE</li>
<li>竞争锁失败 ,t线程从WAITING–&gt;BOLCKED</li>
</ul>
</li>
<li>当前线程调用t.join() 从RUNNABLE–&gt;WAITING 在t线程对象的监视器上等待</li>
<li>调用LockSupport.unpark(目标线程)或调用线程的interrupt() 会让线程从WAITING–&gt;RUNNABLE</li>
</ul>
<p>RUNNABLE&lt;–&gt;TIMED_WAITING</p>
<ul>
<li>调用obj.wait(long n)方法使 t线程从RUNNABLE–&gt;TIMED_WAITING</li>
<li>t线程等待时间超过了n毫秒或调用obj.notify(),obj.notifyAll(),t.interrupt()时<ul>
<li>竞争锁成功 ,t线程从TIMED_WAITING–&gt;RUNNABLE</li>
<li>竞争锁失败 ,t线程从TIMED_WAITING–&gt;BOLCKED</li>
</ul>
</li>
<li>当前线程调用t.join(long n) 从RUNNABLE–&gt;TIMED_WAITING 在t线程对象的监视器上等待</li>
<li>当前线程调用t.join(long n)  且等待时间超过了n毫秒 或t线程运行结束 或调用了当前线程的interrupt()时 当前线程从TIMED_WAITING–&gt;RUNNABL</li>
<li>当前线程调用Thread.sleep(long n)从RUNNABLE–&gt;TIMED_WAITING </li>
<li>当前线程调用Thread.sleep(long n)  且等待时间超过了n毫秒 当前线程从TIMED_WAITING–&gt;RUNNABL</li>
<li>当前线程调用LockSupport.parkNanos(long nanos）或LockSupport.parkUntil(long millis)时，当前线程从RUNNABLE–&gt;TIMED_WAITING</li>
<li>调用LockSupport.unpark(目标线程）或调用了线程的interrupt()，或是等待超时，会让目标线程从TIMED WAITING–&gt;RUNNABLE</li>
</ul>
<p>RUNNABLE&lt;–&gt;BLOCKED</p>
<ul>
<li>t线程用synchronized(obj)获取了对象锁时如果竞争失败，从RUNNABLE –&gt;BLOCKED</li>
<li>持obj锁线程的同步代码块执行完毕，会唤醒该对象上所有BLOCKED的线程重新竞争，如果其中t线程竞争成功，从BLOCKED –&gt;RUNNABLE，其它失败的线程仍然BLOCKED</li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h3 id="两阶段终止模式"><a href="#两阶段终止模式" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h3><p>t1终止t2之前 给t2一个    料理后事的机会</p>
<p>实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.main&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">        TwoPhaseTermination twoPhaseTermination = <span class="keyword">new</span> TwoPhaseTermination();</span><br><span class="line">        twoPhaseTermination.start();</span><br><span class="line">        Thread.sleep(<span class="number">3500</span>);</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;stop**********&quot;</span>);</span><br><span class="line">        twoPhaseTermination.stop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoPhaseTermination</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            Thread currentThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(currentThread.isInterrupted())&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;执行监控记录&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">//重新设计标记  如果不重新设置标记当抛出异常后会清除打断标记 会使循环继续执行下去</span></span><br><span class="line">                    currentThread.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201119104501196.png" alt="image-20201119104501196"></p>
<h1 id="并发之共享模型"><a href="#并发之共享模型" class="headerlink" title="并发之共享模型"></a>并发之共享模型</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>临界区：存在对共享资源的多线程读写操作的一段代码</p>
<p>竞态条件：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p>
<p>下面这段代码就发生了竞态条件</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201007102759353.png" alt="image-20201007102759353"></p>
<p>synchronized采用互斥的方法 让同一时刻之多有一个线程可以持有对象锁 可以解决上下文切换</p>
<p>java中互斥和同步都可以采用synchronized关键字完成 但是他们有区别</p>
<ul>
<li>互斥时为了防止临界区的竞态条件发生 同一时刻只能有一个线程执行临界区代码</li>
<li>同步是由于线程执行的先后顺序不同 需要一个线程等待其他线程运行到某个点</li>
</ul>
<p>这段代码中synchronized用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断。</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008070032289.png" alt="image-20201008070032289"></p>
<p><strong>方法上的synchronized</strong></p>
<p>加在普通方法上相当于锁住了this对象</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008070352538.png" alt="image-20201008070352538"></p>
<p>锁在静态方法上相当锁住这个类对象</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008070429129.png" alt="image-20201008070429129"></p>
<p>这段代码分别锁住了this和类对象 不存在互斥</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008082011946.png" alt="image-20201008082011946"></p>
<h2 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h2><p><strong>成员变量和静态变量是否线程安全</strong></p>
<ul>
<li>如果它们被共享了，根据它们的状态是否能够改变，分两种情况<ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<p><strong>局部变量是否线程安全</strong></p>
<ul>
<li>局部变量是线程安全的</li>
<li>但局部变量引用的对象则未必<ul>
<li>如果该对象没有逃离方法的作用访问，它是线程安全的</li>
<li>如果该对象逃离方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
</ul>
<p><strong>局部变量的暴露引用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadSafe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUMBER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOOP_NUMBER = <span class="number">200</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadSafeSubClass test = <span class="keyword">new</span> ThreadSafeSubClass();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                test.method1(LOOP_NUMBER);</span><br><span class="line">            &#125;, <span class="string">&quot;Thread&quot;</span> + (i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title">ThreadSafe</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>method1中的list对象逃离了该方法的作用范围 主线程创建了两个新的线程执行method3 他们对list共享从而引发线程安全问题 </li>
<li>最好把method1用final修饰 method2和method3用private修饰，防止子类重写导致不可预知的错误</li>
</ul>
<h2 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h2><p>String,Integer,StringBuffer,Random,Vector,Hashtable,java.util.concurrent 包下的类 是线程安全的</p>
<p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hashtable table = <span class="keyword">new</span> Hashtable();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> table.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> table.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<ul>
<li>他们的每个方法是原子的 但是他们多个方法的组合不是原子的</li>
</ul>
<p>不可变类如 Integer String内部状态是不可变的 所以他们的方法都是线程安全的</p>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>卖票：count是共享变量要给sell方法加上synchronized</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.ExerciseSell&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExerciseSell</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟多人买票</span></span><br><span class="line">        TicketWindow window = <span class="keyword">new</span> TicketWindow(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有线程的集合</span></span><br><span class="line">        List&lt;Thread&gt; threadList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 卖出的票数统计</span></span><br><span class="line">        List&lt;Integer&gt; amountList = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 买票</span></span><br><span class="line">                <span class="keyword">int</span> amount = window.sell(random(<span class="number">5</span>));</span><br><span class="line">                <span class="comment">// 统计买票数</span></span><br><span class="line">                amountList.add(amount);</span><br><span class="line">            &#125;);</span><br><span class="line">            threadList.add(thread);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计卖出的票数和剩余票数</span></span><br><span class="line">        log.debug(<span class="string">&quot;余票：&#123;&#125;&quot;</span>,window.getCount());</span><br><span class="line">        log.debug(<span class="string">&quot;卖出的票数：&#123;&#125;&quot;</span>, amountList.stream().mapToInt(i-&gt; i).sum());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Random 为线程安全</span></span><br><span class="line">    <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机 1~5</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">random</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(amount) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 售票窗口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicketWindow</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取余票数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 售票</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">sell</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.count &gt;= amount) &#123;</span><br><span class="line">            <span class="keyword">this</span>.count -= amount;</span><br><span class="line">            <span class="keyword">return</span> amount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>买票：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.ExerciseTransfer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExerciseTransfer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Account a = <span class="keyword">new</span> Account(<span class="number">1000</span>);</span><br><span class="line">        Account b = <span class="keyword">new</span> Account(<span class="number">1000</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                a.transfer(b, randomAmount());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                b.transfer(a, randomAmount());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        <span class="comment">// 查看转账2000次后的总金额</span></span><br><span class="line">        log.debug(<span class="string">&quot;total:&#123;&#125;&quot;</span>, (a.getMoney() + b.getMoney()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Random 为线程安全</span></span><br><span class="line">    <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机 1~100</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">randomAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 账户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转账</span></span><br><span class="line">    <span class="comment">//转账设计两个Account 如果只锁this不能保证target安全 如果同时锁住target和this可能会造成死锁 所以要锁Account.class</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Account.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.money &gt;= amount) &#123;</span><br><span class="line">                <span class="keyword">this</span>.setMoney(<span class="keyword">this</span>.getMoney() - amount);</span><br><span class="line">                target.setMoney(target.getMoney() + amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Synchronized底层原理"><a href="#Synchronized底层原理" class="headerlink" title="Synchronized底层原理"></a>Synchronized底层原理</h2><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a><strong>Monitor</strong></h3><p>普通对象的java对象头</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008092654698.png" alt="image-20201008092654698"></p>
<ul>
<li>Mark Word：用来表示对象的线程锁状态，另外还可以用来配合GC、存放该对象的hashCode</li>
</ul>
<p>其中Mark Word结构为</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008092720634.png" alt="image-20201008092720634"></p>
<p><strong>工作原理</strong></p>
<p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008092925731.png" alt="image-20201008092925731"></p>
<ul>
<li>刚开始 Monitor 中 Owner 为 null</li>
<li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一 个 Owner</li>
<li>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList BLOCKED</li>
<li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争是非公平的</li>
<li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify 时会分析</li>
</ul>
<blockquote>
<p>注意：</p>
<ul>
<li>synchronized 必须是进入同一个对象的 monitor 才有上述的效果</li>
<li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li>
</ul>
</blockquote>
<h3 id="Synchronized原理进阶"><a href="#Synchronized原理进阶" class="headerlink" title="Synchronized原理进阶"></a><strong>Synchronized原理进阶</strong></h3><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。 轻量级锁对使用者是透明的，即语法仍然是 synchronized。</p>
<p>如果线程的任务量很小 再很短的时间内就可以完成，轻量级锁可以减少线程进入阻塞状态带来的性能消耗</p>
<p>假设有两个方法同步块，利用同一个对象加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word的拷贝<img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008094008671.png" alt="image-20201008094008671"></p>
</li>
<li><p>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存 入锁记录<img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008094025494.png" alt="image-20201008094025494"></p>
</li>
<li><p>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下<img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008094041073.png" alt="image-20201008094041073"></p>
</li>
<li><p>如果 cas 失败，有两种情况</p>
<ul>
<li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li>
<li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li>
</ul>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008094107379.png" alt="image-20201008094107379"></p>
</li>
<li><p>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一<img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008094130830.png" alt="image-20201008094130830"></p>
</li>
<li><p>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象 头</p>
<ul>
<li>成功，则解锁成功</li>
<li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ul>
<h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有 竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p>
<ul>
<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁    <img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008094353567.png" alt="image-20201008094353567"></li>
<li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<ul>
<li>即为 Object 对象申请 Monitor 锁，让 Object 指向monitor</li>
<li>然后自己进入 Monitor 的 EntryList BLOCKED<img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008094425806.png" alt="image-20201008094425806"></li>
</ul>
</li>
<li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，会失败。这时进入重量级解锁 流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li>
</ul>
<p>锁升级的目的是为了减低了锁带来的性能消耗</p>
<h4 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h4><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p>
<p>很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都阻塞可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>
<p>自旋成功的情况</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008094753865.png" alt="image-20201008094753865"></p>
<p>自旋失败的情况</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008094805115.png" alt="image-20201008094805115"></p>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li>
<li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能</li>
<li>Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。 Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现 这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008120751217.png" alt="image-20201008120751217"></p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008120757859.png" alt="image-20201008120757859"></p>
<ul>
<li><p>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的 thread、epoch、age 都为 0</p>
</li>
<li><p>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 - XX:BiasedLockingStartupDelay=0 来禁用延迟</p>
</li>
<li><p>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、 age 都为 0，第一次用到 hashcode 时才会赋值</p>
</li>
<li><p>但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被 撤销</p>
<ul>
<li>轻量级锁会在锁记录中记录 hashCode</li>
<li>重量级锁会在 Monitor 中记录 hashCode</li>
</ul>
</li>
<li><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p>
</li>
<li><p>只有重量级锁有wait&amp;notify等待机制  如果轻量级锁使用会升级为重量级锁</p>
<ul>
<li><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008123003005.png" alt="image-20201008123003005"></li>
</ul>
</li>
</ul>
<h4 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h4><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的Thread ID，当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这类对象加锁时重新偏向至 加锁线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	Vector&lt;Dog&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"> 	Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line"> 			Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line"> 			list.add(d);</span><br><span class="line"> 			<span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line"> 				log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line"> 			list.notify();</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"> 	t1.start();</span><br><span class="line"></span><br><span class="line"> 	Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"> 		<span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line"> 			<span class="keyword">try</span> &#123;</span><br><span class="line"> 				list.wait();</span><br><span class="line"> 			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> 				e.printStackTrace();</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		log.debug(<span class="string">&quot;===============&gt; &quot;</span>);</span><br><span class="line"> 		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line"> 			Dog d = list.get(i);</span><br><span class="line"> 			log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line"> 			<span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line"> 				log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line"> 			&#125;</span><br><span class="line"> 			log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"> 	t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码先让t1把Dog对象添加到list中然后唤醒t2线程，d对象刚开始偏向t1 这时t2线程获取d的锁 重偏向锁被撤销 升级为轻量级锁</p>
<p>t1输出格式为</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008140023468.png" alt="image-20201008140023468"></p>
<p>t2线程前20轮循环输出格式为<img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008140629193.png" alt="image-20201008140629193"></p>
<p>20轮之后 批量重定向 全部偏向t2</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008140747166.png" alt="image-20201008140747166"></p>
<h4 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h4><p>当一个偏向锁如果撤销次数到达40的时候就认为这个对象设计的有问题；那么JVM会把这个对象所对应的类所有的对象都撤销偏向锁；并且新实例化的对象也是不可偏向的</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Fork(1)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@Warmup(iterations=3)</span></span><br><span class="line"><span class="meta">@Measurement(iterations=5)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBenchmark</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"> 	<span class="meta">@Benchmark</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> 		x++;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="meta">@Benchmark</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> 		Object o = <span class="keyword">new</span> Object();</span><br><span class="line"> 		<span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line"> 			x++;</span><br><span class="line">    	&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>JIT解释编译器会对代码进行优化 发现对象o不是共享对象 从而把synchronized去掉 所以a和b方法效率相同</li>
</ul>
<h2 id="wait-amp-notify原理"><a href="#wait-amp-notify原理" class="headerlink" title="wait&amp;notify原理"></a>wait&amp;notify原理</h2><p><strong>原理</strong></p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008143503042.png" alt="image-20201008143503042"></p>
<ul>
<li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li>
<li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li>
<li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li>
<li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争</li>
</ul>
<p>wait和notify都是线程间进行协作的手段 属于object对象的方法 必须获得此对象的锁 才能调用这些方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>wait和sleep的区别</strong></p>
<ul>
<li>sleep是Thread方法 wait是Object方法</li>
<li>sleep不需要强制和synchronized配合使用</li>
<li>sleep睡眠的时候不会释放锁对象 wait等待的时候会释放锁对象</li>
</ul>
<p><strong>虚假唤醒</strong>：当一个条件满足时，很多线程都被唤醒了，但是只有其中部分是有用的唤醒，其它的唤醒都是无用功 比如说买货，如果商品本来没有货物，突然进了一件商品，这是所有的线程都被唤醒了 但是只能一个人买，所以其他人都是假唤醒，获取不到对象的锁</p>
<h2 id="join原理"><a href="#join原理" class="headerlink" title="join原理"></a>join原理</h2><p><code>t1.join()</code>等价于下面这段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (t1) &#123;</span><br><span class="line"> 	<span class="comment">// 调用者线程(t2)进入 t1 的 waitSet 等待, 直到 t1 运行结束</span></span><br><span class="line">	<span class="keyword">while</span> (t1.isAlive()) &#123;</span><br><span class="line"> 		t1.wait(<span class="number">0</span>); <span class="comment">//如果 timeout 为零，则不考虑实际时间，在获得通知前waitset中的线程将一直等待。</span></span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h2><p> Guarded Suspension，用在一个线程等待另一个线程的执行结果</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）<ul>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li>
</ul>
</li>
<li>因为要等待另一方的结果，因此归类到同步模式</li>
</ul>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008144639714.png" alt="image-20201008144639714"></p>
<p>测试和实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestGuardedObject&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGuardedObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GuardedObject guardedObject = <span class="keyword">new</span> GuardedObject();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;String&gt; response = download();</span><br><span class="line">                log.debug(<span class="string">&quot;download complete...&quot;</span>);</span><br><span class="line">                guardedObject.complete(response);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">        Object response = guardedObject.get();</span><br><span class="line">        log.debug(<span class="string">&quot;get response: [&#123;&#125;] lines&quot;</span>, ((List&lt;String&gt;) response).size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuardedObject</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 条件不满足则等待</span></span><br><span class="line">            <span class="keyword">while</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Object response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 条件满足，通知等待线程</span></span><br><span class="line">            <span class="keyword">this</span>.response = response;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加超时功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestGuardedObjectV2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGuardedObjectV2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GuardedObjectV2 v2 = <span class="keyword">new</span> GuardedObjectV2();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            v2.complete(<span class="keyword">null</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            v2.complete(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Object response = v2.get(<span class="number">2500</span>);</span><br><span class="line">        <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;get response: [&#123;&#125;] lines&quot;</span>, ((List&lt;String&gt;) response).size());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;can&#x27;t get response&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加超时处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.GuardedObjectV2&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuardedObjectV2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> millis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 1) 记录最初时间</span></span><br><span class="line">            <span class="keyword">long</span> last = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 2) 已经经历的时间</span></span><br><span class="line">            <span class="keyword">long</span> timePassed = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等</span></span><br><span class="line">                <span class="keyword">long</span> waitTime = millis - timePassed;</span><br><span class="line">                log.debug(<span class="string">&quot;waitTime: &#123;&#125;&quot;</span>, waitTime);</span><br><span class="line">                <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;break...&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait(waitTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 3) 如果提前被唤醒，这时已经经历的时间假设为 400</span></span><br><span class="line">                timePassed = System.currentTimeMillis() - last;</span><br><span class="line">                log.debug(<span class="string">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>, timePassed, response == <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Object response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 条件满足，通知等待线程</span></span><br><span class="line">            <span class="keyword">this</span>.response = response;</span><br><span class="line">            log.debug(<span class="string">&quot;notify...&quot;</span>);</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>future</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008153226394.png" alt="image-20201008153226394"></p>
<h2 id="异步模式之生产者和消费者"><a href="#异步模式之生产者和消费者" class="headerlink" title="异步模式之生产者和消费者"></a>异步模式之生产者和消费者</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test21&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test21</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = <span class="keyword">new</span> MessageQueue(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = i;</span><br><span class="line">            <span class="comment">//lambada表达式内部引用的变量必须是final的所以创建一个id赋值i</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                queue.put(<span class="keyword">new</span> Message(id , <span class="string">&quot;值&quot;</span>+id));</span><br><span class="line">            &#125;, <span class="string">&quot;生产者&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                Message message = queue.take();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列类 ， java 线程之间通信</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.MessageQueue&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 消息的队列集合</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 队列容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capcity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageQueue</span><span class="params">(<span class="keyword">int</span> capcity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capcity = capcity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查队列是否为空：空的话就wait</span></span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span>(list.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;队列为空, 消费者线程等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从队列头部获取消息并返回</span></span><br><span class="line">            Message message = list.removeFirst();</span><br><span class="line">            log.debug(<span class="string">&quot;已消费消息 &#123;&#125;&quot;</span>, message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存入消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="comment">// 检查对象是否已满</span></span><br><span class="line">            <span class="keyword">while</span>(list.size() == capcity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;队列已满, 生产者线程等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将消息加入队列尾部</span></span><br><span class="line">            list.addLast(message);</span><br><span class="line">            log.debug(<span class="string">&quot;已生产消息 &#123;&#125;&quot;</span>, message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">int</span> id, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Message&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="park-amp-unpark"><a href="#park-amp-unpark" class="headerlink" title="park&amp;unpark"></a>park&amp;unpark</h2><p>LockSupport.park：暂停当前线程  LockSupporst.unpark：恢复某个线程的暂停</p>
<p>与Object的wait&amp;notify对比</p>
<ul>
<li>park unpark不用配合Object Monitor使用</li>
<li>以线程为单位唤醒和堵塞线程 notify只能随机唤醒一个线程 notifyAll唤醒所有线程 不精确</li>
<li>park&amp;unpark可以先unpark wait&amp;notify不能先notify</li>
</ul>
<p><strong>原理</strong></p>
<p>每个线程都有自己的一个 Parker 对象，由三部分组成 _counter ， _cond 和 _mutex 打个比喻</p>
<ul>
<li>线程就像一个旅人，Parker 就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter 就好比背包中 的备用干粮（0 为耗尽，1 为充足）</li>
<li>调用 park 就是要看需不需要停下来歇息<ul>
<li>如果备用干粮耗尽，那么钻进帐篷歇息</li>
</ul>
</li>
<li>调用 unpark，就好比令干粮充足<ul>
<li>如果这时线程还在帐篷，就唤醒让他继续前进</li>
<li>如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进<ul>
<li>因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.main&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">        Runnable target;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//                LockSupport.unpark(Thread.currentThread()); 如果有这行代码 程序就不会停止</span></span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.println(<span class="string">&quot;sdfsdf&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h2><p>死锁解决方法：按顺序为对象加锁</p>
<p>活锁：出现在两个线程互相改变对方的结束条件 最后谁也无法结束 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestLiveLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLiveLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count++;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>活锁解决方法：执行时间交错开 比如把sleep时间设置为随机数</p>
<p>饥饿：一个线程由于优先级过低 始终得不到cpu调度执行 也不能结束 </p>
<p>可以用ReentrantLock解决死锁和饥饿</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><strong>ReentrantLock</strong></h2><p>相对于 synchronized 它具备如下特点 可中断 可以设置超时时间 可以设置为公平锁 支持多个条件变量</p>
<p> 与 synchronized 一样，都支持可重入</p>
<p>基本语法</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 获取锁</span><br><span class="line">reentrantLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line"> 	<span class="regexp">//</span> 临界区</span><br><span class="line">&#125; finally &#123;</span><br><span class="line"> 	<span class="regexp">//</span> 释放锁</span><br><span class="line">	 reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a><strong>可重入</strong></h3><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁 如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestReentrant&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReentrant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;execute method1&quot;</span>);</span><br><span class="line">            method2();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;execute method2&quot;</span>);</span><br><span class="line">            method3();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;execute method3&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="可打断锁"><a href="#可打断锁" class="headerlink" title="可打断锁"></a><strong>可打断锁</strong></h3><p>可以避免死锁</p>
<p>lockInterruptibly允许在等待时由其它线程调用等待线程的Thread.interrupt方法来中断等待线程的等待而直接返回，这时不用获取锁，而会抛出一个InterruptedException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestInterrupt&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterrupt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            t1.interrupt();</span><br><span class="line">            log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                log.debug(<span class="string">&quot;等锁的过程中被打断&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            t1.interrupt();</span><br><span class="line">            log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test2方法的t1.interrupt()并没有真正进行打断</p>
<p>test1中在lock.lockInterruptibly()打断了锁</p>
<h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p>trylock返回值是bool类型 参数是等待时间 可以不加参数 表示立即尝试获取锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestTimeout&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTimeout</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;获取等待 1s 后失败，返回&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (!lock.tryLock()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获取立刻失败，返回&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁超时解决哲学家就餐问题 对比下图中两个类的代码<img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201008162100263.png" alt="image-20201008162100263"></p>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>ReentrantLock 默认是不公平的 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFair</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; running...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;t&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1s 之后去争抢锁</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; running...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;强行插入&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强行插入线程总是在t+i线程后输出</p>
<p>公平锁一般没有必要，会降低并发度</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待</p>
<p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的 ，这就好比</p>
<ul>
<li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li>
<li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li>
</ul>
<p>使用要点</p>
<ul>
<li>await 前需要获得锁 。await 执行后，会释放锁，进入 conditionObject 等待</li>
<li>await 的线程被唤醒（或打断、或超时）重新竞争 lock 锁。 竞争 lock 锁成功后，从 await 后继续执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestCondition&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCondition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">static</span> Condition waitCigaretteQueue = lock.newCondition();</span><br><span class="line">    <span class="keyword">static</span> Condition waitbreakfastQueue = lock.newCondition();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> hasCigrette = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> hasBreakfast = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">while</span> (!hasCigrette) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//使当当前线程在队列中等待</span></span><br><span class="line">                        waitCigaretteQueue.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;等到了它的烟&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">while</span> (!hasBreakfast) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        waitbreakfastQueue.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;等到了它的早餐&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        sendBreakfast();</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        sendCigarette();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendCigarette</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;送烟来了&quot;</span>);</span><br><span class="line">            hasCigrette = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//唤醒一个等待中的线程</span></span><br><span class="line">            waitCigaretteQueue.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendBreakfast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;送早餐来了&quot;</span>);</span><br><span class="line">            hasBreakfast = <span class="keyword">true</span>;</span><br><span class="line">            waitbreakfastQueue.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h2><h3 id="固定运行顺序"><a href="#固定运行顺序" class="headerlink" title="固定运行顺序"></a>固定运行顺序</h3><p>比如：必须先打印2再打印1</p>
<p><strong>wait&amp;notify</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test25&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test25</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 表示 t2 是否运行过</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> t2runned = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!t2runned) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                t2runned = <span class="keyword">true</span>;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>park&amp;unpark</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test26&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test26</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><p>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现</p>
<p><strong>wait&amp;notify</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test27&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test27</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaitNotify wn = <span class="keyword">new</span> WaitNotify(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wn.print(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wn.print(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wn.print(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出内容       等待标记     下一个标记</span></span><br><span class="line"><span class="comment">   a           1             2</span></span><br><span class="line"><span class="comment">   b           2             3</span></span><br><span class="line"><span class="comment">   c           3             1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag; <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaitNotify</span><span class="params">(<span class="keyword">int</span> flag, <span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印               a           1             2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, <span class="keyword">int</span> waitFlag, <span class="keyword">int</span> nextFlag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(flag != waitFlag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                flag = nextFlag;</span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>lock条件变量版</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test30</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AwaitSignal awaitSignal = <span class="keyword">new</span> AwaitSignal(<span class="number">5</span>);</span><br><span class="line">        Condition a = awaitSignal.newCondition();</span><br><span class="line">        Condition b = awaitSignal.newCondition();</span><br><span class="line">        Condition c = awaitSignal.newCondition();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;a&quot;</span>, a, b);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;b&quot;</span>, b, c);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;c&quot;</span>, c, a);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        awaitSignal.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;开始...&quot;</span>);</span><br><span class="line">            a.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitSignal.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwaitSignal</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AwaitSignal</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//            参数1 打印内容， 参数2 进入哪一间休息室, 参数3 下一间休息室</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, Condition current, Condition next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//当前线程等待</span></span><br><span class="line">                current.await();</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                next.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>park&amp;unpark</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test31&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test31</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Thread t1;</span><br><span class="line">    <span class="keyword">static</span> Thread t2;</span><br><span class="line">    <span class="keyword">static</span> Thread t3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ParkUnpark pu = <span class="keyword">new</span> ParkUnpark(<span class="number">5</span>);</span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            pu.print(<span class="string">&quot;a&quot;</span>, t2);</span><br><span class="line">        &#125;);</span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            pu.print(<span class="string">&quot;b&quot;</span>, t3);</span><br><span class="line">        &#125;);</span><br><span class="line">        t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            pu.print(<span class="string">&quot;c&quot;</span>, t1);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParkUnpark</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParkUnpark</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, Thread next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.print(str);</span><br><span class="line">            LockSupport.unpark(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="共享模型之内存"><a href="#共享模型之内存" class="headerlink" title="共享模型之内存"></a>共享模型之内存</h1><p>JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。</p>
<p>JMM 体现在以下几个方面</p>
<ul>
<li>原子性 - 保证指令不会受到线程上下文切换的影响</li>
<li>可见性 - 保证指令不会受 cpu 缓存的影响</li>
<li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	 Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> 		<span class="keyword">while</span>(run)&#123;</span><br><span class="line">		 <span class="comment">// ....</span></span><br><span class="line">		 &#125;</span><br><span class="line"> 	&#125;);</span><br><span class="line"> 	t.start();</span><br><span class="line"> 	sleep(<span class="number">1</span>);</span><br><span class="line"> 	run = <span class="keyword">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分析一下：</p>
<ol>
<li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。<img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009090313012.png" alt="image-20201009090313012"></li>
<li>. 因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中， 减少对主存中 run 的访问，提高效率<img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009090328610.png" alt="image-20201009090328610"></li>
<li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是旧值<img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009090345109.png" alt="image-20201009090345109"></li>
</ol>
<p><strong>解决方法</strong></p>
<p>volatile（易变关键字）： 它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取 它的值，线程操作 volatile 变量都是直接操作主存</p>
<p>volatile仅用在一个线程写 多个线程读的情况 不能保证原子性 下面这个例子中volatile只能保证看到最新值 不能解决指令交错， synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是synchronized 是属于重量级操作，性能相对更低</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009090702689.png" alt="image-20201009090702689"></p>
<p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？</p>
<ul>
<li>查看System.out.println()源码 <img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009090836508.png" alt="image-20201009090836508"></li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>jvm在不影响正确性的前提下 可以调整语句的执行顺序 通过重排序和组合指令的各个阶段可以实现指令级并行</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009093156092.png" alt="image-20201009093156092"></p>
<p>这个例子 ready = true 和 num = 2 可能重排序 结果可能是4 0 2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>改为volatile int num = 0可以禁止指令重排 加上volatile的变量相当于加了一个写屏障 这样num=2之前的语句都有可以禁用重排序</li>
</ul>
<h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a><strong>volatile原理</strong></h3><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）</p>
<ul>
<li>对 volatile 变量的写指令后会加入写屏障</li>
<li>对 volatile 变量的读指令前会加入读屏障</li>
</ul>
<h4 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a><strong>保证可见性</strong></h4><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009093714075.png" alt="image-20201009093714075"></p>
<p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009093758082.png" alt="image-20201009093758082"></p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009094010904.png" alt="image-20201009094010904"></p>
<h4 id="保证有序性"><a href="#保证有序性" class="headerlink" title="保证有序性"></a>保证有序性</h4><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p>
<p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p>
<p> 但是不能解决指令交错</p>
<ul>
<li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去</li>
<li>读跑到它前面去 而有序性的保证也只是保证了本线程内相关代码不被重排序</li>
<li><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009094107401.png" alt="image-20201009094107401"></li>
</ul>
<h4 id="double-checked-locking-问题"><a href="#double-checked-locking-问题" class="headerlink" title="double-checked locking 问题"></a>double-checked locking 问题</h4><p><strong>单例模式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"> 	 <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">	 <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"> 	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line"> 			<span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">    	    <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line"> 				<span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line"> 					INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"> 				&#125;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">return</span> INSTANCE;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上的实现特点是：</p>
<ul>
<li>懒惰实例化</li>
<li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li>
<li>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外</li>
</ul>
<p>但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009101445428.png" alt="image-20201009101445428"></p>
<p>其中</p>
<ul>
<li>17 表示创建对象，将对象引用入栈 // new Singleton</li>
<li>20 表示复制一份对象引用 // 引用地址</li>
<li>21 表示利用一个对象引用，调用构造方法</li>
<li>24 表示利用一个对象引用，赋值给 static INSTANCE</li>
</ul>
<p>也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行：</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009101654313.png" alt="image-20201009101654313"></p>
<p>关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取 INSTANCE 变量的值</p>
<p>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初 始化完毕的单例</p>
<p>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效</p>
<p>只有变量完全交给synchronized管理 才能保证变量的有序性 可见性 原子性 改例中INSTANCE也出现在了synchronized的外面 所以不能保证有序性</p>
<p><strong>解决</strong></p>
<p><code>private static volatile Singleton INSTANCE = null;</code></p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009101943969.png" alt="image-20201009101943969"></p>
<p><strong>happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛</strong></p>
<p><strong>开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</strong></p>
<ul>
<li>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见<ul>
<li><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009102406598.png" alt="image-20201009102406598"></li>
</ul>
</li>
<li>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见<ul>
<li><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009102435344.png" alt="image-20201009102435344"></li>
</ul>
</li>
<li>线程 start 前对变量的写，对该线程开始后对该变量的读可见<ul>
<li><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009102448814.png" alt="image-20201009102448814"></li>
</ul>
</li>
<li>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待 它结束）<ul>
<li><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009102703740.png" alt="image-20201009102703740"></li>
</ul>
</li>
<li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）<ul>
<li><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009102719322.png" alt="image-20201009102719322"></li>
</ul>
</li>
<li>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</li>
<li>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子<ul>
<li><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009102741448.png" alt="image-20201009102741448"></li>
</ul>
</li>
</ul>
<h2 id="线程安全单例习题"><a href="#线程安全单例习题" class="headerlink" title="线程安全单例习题"></a>线程安全单例习题</h2><ol>
<li><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009102952571.png" alt="image-20201009102952571"></li>
<li><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009102955672.png" alt="image-20201009102955672"></li>
<li><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009102958030.png" alt="image-20201009102958030">没有线程安全问题 synchronized把Singleton锁住了 缺点是锁粒度太大</li>
</ol>
<h2 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="两阶段终止模式Volatile"><a href="#两阶段终止模式Volatile" class="headerlink" title="两阶段终止模式Volatile"></a>两阶段终止模式Volatile</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestTwoPhaseTermination&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTwoPhaseTermination</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TPTVolatile t = <span class="keyword">new</span> TPTVolatile();</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">        t.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TPTVolatile&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TPTVolatile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                Thread current = Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span>(stop) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;将结果保存&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;监控线程&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>stop设置为真时 可能需要等Thread.sleep睡醒之后才能进行下一轮判断 使用interrupt进行打断 立即唤醒线程 如果不加interrupt会等待小于1s再料理后事</li>
</ul>
<h3 id="Balking"><a href="#Balking" class="headerlink" title="Balking"></a>Balking</h3><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做 了，直接结束返回</p>
<p>比如：一个程序中只需要一个监控线程 如果创建监控线程时 发现已经有了就不用创建 直接返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test13</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TwoPhaseTermination tpt = <span class="keyword">new</span> TwoPhaseTermination();</span><br><span class="line">        tpt.start();</span><br><span class="line">        tpt.start();</span><br><span class="line">        tpt.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*Thread.sleep(3500);</span></span><br><span class="line"><span class="comment">        log.debug(&quot;停止监控&quot;);</span></span><br><span class="line"><span class="comment">        tpt.stop();*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoPhaseTermination</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 监控线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread monitorThread;</span><br><span class="line">    <span class="comment">// 停止标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 判断是否执行过 start 方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> starting = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (starting) &#123; <span class="comment">// false</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            starting = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        monitorThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Thread current = Thread.currentThread();</span><br><span class="line">                <span class="comment">// 是否被打断</span></span><br><span class="line">                <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;执行监控记录&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;monitor&quot;</span>);</span><br><span class="line">        monitorThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">        monitorThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对比一下保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待。</p>
</li>
<li><p>这里starting不能使用volatile 因为其不能保证原子性： 一个线程调用start之后 变量starting修改之前 还会有多个线程调用start且starting状态仍然为false从而创建多个监控线程</p>
</li>
</ul>
<h1 id="共享模型之无锁"><a href="#共享模型之无锁" class="headerlink" title="共享模型之无锁"></a>共享模型之无锁</h1><h2 id="CAS与volatie"><a href="#CAS与volatie" class="headerlink" title="CAS与volatie"></a>CAS与volatie</h2><h3 id="保护共享资源"><a href="#保护共享资源" class="headerlink" title="保护共享资源"></a><strong>保护共享资源</strong></h3><p>加锁实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountUnsafe</span><span class="params">(Integer balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.balance -= amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无锁实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountCas</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountCas</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = <span class="keyword">new</span> AtomicInteger(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*while(true) &#123;</span></span><br><span class="line"><span class="comment">            // 获取余额的最新值</span></span><br><span class="line"><span class="comment">            int prev = balance.get();</span></span><br><span class="line"><span class="comment">            // 要修改的余额</span></span><br><span class="line"><span class="comment">            int next = prev - amount;</span></span><br><span class="line"><span class="comment">            // 真正修改 compareAndSet参数是修改前和修改后的值 如果修改成功返回true</span></span><br><span class="line"><span class="comment">            if(balance.compareAndSet(prev, next)) &#123;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        balance.getAndAdd(-<span class="number">1</span> * amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>AtomicInteger中方法compareAndSwap就是CAS 他是原子操作</p>
<p>实现</p>
<p>​    <img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009103823828.png" alt="image-20201009103823828"></p>
<pre><code>当前值与prev相同则修改为next 否则进入下一轮循环</code></pre>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009103958360.png" alt="image-20201009103958360"></p>
<blockquote>
<p>注意：</p>
<ul>
<li>其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【CAS】的原子性。</li>
<li>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再 开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子 的。</li>
</ul>
</blockquote>
<h3 id="与volatile的关系"><a href="#与volatile的关系" class="headerlink" title="与volatile的关系"></a>与volatile的关系</h3><p>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</p>
<p>AtomicInteger源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h3><p>为什么无锁效率高</p>
<ul>
<li>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时 候，发生上下文切换，进入阻塞。打个比喻</li>
<li>线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火， 等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大</li>
<li>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑 道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还 是会导致上下文切换。</li>
</ul>
<h3 id="CAS特点"><a href="#CAS特点" class="headerlink" title="CAS特点"></a>CAS特点</h3><p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。</p>
<ul>
<li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再 重试呗。</li>
<li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想 改，我改完了解开锁，你们才有机会。</li>
<li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思<ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
</li>
</ul>
<h2 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h2><p>J.U.C并发包提供了 </p>
<ul>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicLong</li>
</ul>
<p>updateAndGet方法：接收一个lambada作为参数（为了操作更灵活 可以进行各种计算）  更新当前值并返回 </p>
<p><code> i,updateAndGet(value -&gt; value * 10)</code></p>
<p>原理</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009105759472.png" alt="image-20201009105759472"></p>
<p>其他方法查看源码</p>
<h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><p>J.U.C并发包提供了:AtomicReference,AtomicMarkabkeReference,AtomicStampedReference</p>
<h3 id="Atomic-Reference"><a href="#Atomic-Reference" class="headerlink" title="Atomic Reference"></a>Atomic Reference</h3><p>使用和AtomicInteger差不多 适用于对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecimalAccountCas</span> <span class="keyword">implements</span> <span class="title">DecimalAccount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecimalAccountCas</span><span class="params">(BigDecimal balance)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        this.balance = balance;</span></span><br><span class="line">        <span class="keyword">this</span>.balance = <span class="keyword">new</span> AtomicReference&lt;&gt;(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(BigDecimal amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            BigDecimal prev = balance.get();</span><br><span class="line">            BigDecimal next = prev.subtract(amount);</span><br><span class="line">            <span class="keyword">if</span> (balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ABA问题</strong></p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009110359944.png" alt="image-20201009110359944"></p>
<p>主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程 希望：</p>
<p>​    只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号</p>
<h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a><strong>AtomicStampedReference</strong></h3><p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009110459308.png" alt="image-20201009110459308"></p>
<p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt; C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。</p>
<p>但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了 AtomicMarkableReference</p>
<h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009110541875.png" alt="image-20201009110541875"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test38&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test38</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        GarbageBag bag = <span class="keyword">new</span> GarbageBag(<span class="string">&quot;装满了垃圾&quot;</span>);</span><br><span class="line">        <span class="comment">// 参数2 mark 可以看作一个标记，表示垃圾袋满了</span></span><br><span class="line">        AtomicMarkableReference&lt;GarbageBag&gt; ref = <span class="keyword">new</span> AtomicMarkableReference&lt;&gt;(bag, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        GarbageBag prev = ref.getReference();</span><br><span class="line">        log.debug(prev.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">            bag.setDesc(<span class="string">&quot;空垃圾袋&quot;</span>);</span><br><span class="line">            ref.compareAndSet(bag, bag, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            log.debug(bag.toString());</span><br><span class="line">        &#125;,<span class="string">&quot;保洁阿姨&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;想换一只新垃圾袋？&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> success = ref.compareAndSet(prev, <span class="keyword">new</span> GarbageBag(<span class="string">&quot;空垃圾袋&quot;</span>), <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;换了么？&quot;</span> + success);</span><br><span class="line">        log.debug(ref.getReference().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GarbageBag</span> </span>&#123;</span><br><span class="line">    String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GarbageBag</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">&quot; &quot;</span> + desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h2><p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009111719552.png" alt="image-20201009111719552"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test40&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test40</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        AtomicReferenceFieldUpdater updater =</span><br><span class="line">                AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(updater.compareAndSet(stu, <span class="keyword">null</span>, <span class="string">&quot;张三&quot;</span>));</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test41</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            demo(</span><br><span class="line">                    () -&gt; <span class="keyword">new</span> AtomicLong(<span class="number">0</span>),</span><br><span class="line">                    (adder) -&gt; adder.getAndIncrement()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            demo(</span><br><span class="line">                    () -&gt; <span class="keyword">new</span> LongAdder(),</span><br><span class="line">                    adder -&gt; adder.increment()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    () -&gt; 结果    提供累加器对象</span></span><br><span class="line"><span class="comment">    (参数) -&gt;     执行累加操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> </span>&#123;</span><br><span class="line">        T adder = adderSupplier.get();</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 4 个线程，每人累加 50 万</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">500000</span>; j++) &#123;</span><br><span class="line">                    action.accept(adder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        ts.forEach(t -&gt; t.start());</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(adder + <span class="string">&quot; cost:&quot;</span> + (end - start) / <span class="number">1000_000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原子累加器相比普通的累加器会有性能提升：性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</p>
<h3 id="LongAdder原理"><a href="#LongAdder原理" class="headerlink" title="LongAdder原理"></a>LongAdder原理</h3><p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009113023807.png" alt="image-20201009113023807"></p>
<p>无锁实现为什么会有cellsBusy表示加锁</p>
<p>cellsBusy类似与cas锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cas锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockCas</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 没加锁</span></span><br><span class="line">    <span class="comment">// 1 加锁</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger state = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state.compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;unlock...&quot;</span>);</span><br><span class="line">        state.set(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockCas lock = <span class="keyword">new</span> LockCas();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;lock...&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;lock...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防止缓存行伪共享</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line"> 	Cell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值</span></span><br><span class="line">	 <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> prev, <span class="keyword">long</span> next)</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, prev, next);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">// 省略不重要代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。 而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long） 缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中 CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效。</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009131448068.png" alt="image-20201009131448068"></p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009131457185.png" alt="image-20201009131457185"></p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>参考博客:<a href="https://blog.csdn.net/qpzkobe/article/details/82317640">https://blog.csdn.net/qpzkobe/article/details/82317640</a></p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009135821600.png" alt="image-20201009135821600"></p>
<p><strong>add</strong></p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009140043473.png" alt="image-20201009140043473"></p>
<p><strong>longAccumulate</strong></p>
<p>cells不存在</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009141240221.png" alt="image-20201009141240221"></p>
<p>cell不存在</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009142309642.png" alt="image-20201009142309642"></p>
<p>每个线程刚进入 longAccumulate 时，会尝试对应一个 cell 对象（找到一个坑位）</p>
<p>cell存在</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009142407423.png" alt="image-20201009142407423"></p>
<p>获取最终结果通过sum方法</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201009144223193.png" alt="image-20201009144223193"></p>
<h2 id="unsafe方法"><a href="#unsafe方法" class="headerlink" title="unsafe方法"></a>unsafe方法</h2><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeAccessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cas相关方法<strong>：线程安全的修改对象的属性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUnsafe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//获取unsafe</span></span><br><span class="line">        Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 1. 获取域的偏移地址</span></span><br><span class="line">        <span class="keyword">long</span> idOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        <span class="keyword">long</span> nameOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        Teacher t = <span class="keyword">new</span> Teacher();</span><br><span class="line">        <span class="comment">// 2. 执行 cas 操作</span></span><br><span class="line">        unsafe.compareAndSwapInt(t, idOffset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        unsafe.compareAndSwapObject(t, nameOffset, <span class="keyword">null</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 验证</span></span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>模拟实现AtomicInteger</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test42</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account.demo(<span class="keyword">new</span> MyAtomicInteger(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAtomicInteger</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNSAFE = UnsafeAccessor.getUnsafe();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset(MyAtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = <span class="keyword">this</span>.value;</span><br><span class="line">            <span class="keyword">int</span> next = prev - amount;</span><br><span class="line">            <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAtomicInteger</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        decrement(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="共享模型之不可变"><a href="#共享模型之不可变" class="headerlink" title="共享模型之不可变"></a>共享模型之不可变</h1><h2 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h2><p><strong>不可变类的使用</strong></p>
<p>下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的 有很大几率出现 java.lang.NumberFormatException 或者出现不正确的日期解析结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sdf) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="string">&quot;1951-04-21&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改 这样的对象在 Java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter stf = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        TemporalAccessor parse = stf.parse(<span class="string">&quot;1951-04-21&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, parse);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>属性用 final 修饰保证了该属性是只读的，不能修改</li>
<li>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</li>
</ul>
<p><strong>不可变对象的设计：保护性拷贝</strong></p>
<p>使用字符串时，也有一些跟修改相关的方法，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		 <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">int</span> subLen = value.length - beginIndex;</span><br><span class="line"> 	<span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现其内部是调用 String 的构造方法创建了一个新字符串，再进入这个构造看看，是否对 final char[] value 做出 了修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> 			<span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">if</span> (offset &lt;= value.length) &#123;</span><br><span class="line"> 			<span class="keyword">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line"> 			<span class="keyword">return</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line"> 	<span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">		 <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果发现也没有，构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为<strong>保护性拷贝</strong></p>
<h2 id="设计模式之享元模式"><a href="#设计模式之享元模式" class="headerlink" title="设计模式之享元模式"></a>设计模式之享元模式</h2><p>不可变类使用保护性拷贝虽然实现了线程安全但是对象创建过于频繁 一般不可变对象都关联一个享元模式</p>
<h3 id="体现"><a href="#体现" class="headerlink" title="体现"></a><strong>体现</strong></h3><p>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的 valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对 象：</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201011110138604.png" alt="image-20201011110138604"></p>
<p>包装类 String BigDecimal BigInteger也体现了享元模式</p>
<p>为什么在之前的例子中BigDecimal要用AtimocInteger保护起来？</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">private AtomicReference&lt;BigDecimal&gt; balance<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>因为 BigDecimal单个方法是原子的但是方法的组合不是原子的 不能保证线程安全</p>
<h3 id="自定义连接池"><a href="#自定义连接池" class="headerlink" title="自定义连接池"></a>自定义连接池</h3><p><strong>分析</strong></p>
<p>例如：一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时 预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约 了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。</p>
<p><strong>实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pool pool = <span class="keyword">new</span> Pool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                Connection conn = pool.borrow();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                pool.free(conn);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Pool&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 连接池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> poolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接对象数组</span></span><br><span class="line">    <span class="keyword">private</span> Connection[] connections;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span></span><br><span class="line">    <span class="comment">//这里不能使用普通数组 因为它不是线程安全的</span></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray states;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 构造方法初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">(<span class="keyword">int</span> poolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.poolSize = poolSize;</span><br><span class="line">        <span class="keyword">this</span>.connections = <span class="keyword">new</span> Connection[poolSize];</span><br><span class="line">        <span class="keyword">this</span>.states = <span class="keyword">new</span> AtomicIntegerArray(<span class="keyword">new</span> <span class="keyword">int</span>[poolSize]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            connections[i] = <span class="keyword">new</span> MockConnection(<span class="string">&quot;连接&quot;</span> + (i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 借连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">borrow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取空闲连接</span></span><br><span class="line">                <span class="keyword">if</span>(states.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (states.compareAndSet(i, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);</span><br><span class="line">                        <span class="keyword">return</span> connections[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有空闲连接，当前线程进入等待</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 归还连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connections[i] == conn) &#123;</span><br><span class="line">                <span class="comment">//线程使用者归还连接不会发生线程竞争</span></span><br><span class="line">                states.set(i, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;free &#123;&#125;&quot;</span>, conn);</span><br><span class="line">                    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockConnection</span> <span class="keyword">implements</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MockConnection</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MockConnection&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fianl原理"><a href="#fianl原理" class="headerlink" title="fianl原理"></a>fianl原理</h2><p><strong>设置final的原理</strong></p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201011115151905.png" alt="image-20201011115151905"></p>
<p><strong>获取final的原理</strong></p>
<p>数字比较小的变量在栈内存中 超过短整形的最大值在常量池中 如果其他类要使用final变量 直接复制一份，如果不加final修饰就在堆中 需要通过字节码指令getStatic获取 ，读取效率较低</p>
<h1 id="共享模型之工具"><a href="#共享模型之工具" class="headerlink" title="共享模型之工具"></a>共享模型之工具</h1><h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><p>如果当前线程数不够 任务就在队列中等待</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201012134450306.png" alt="image-20201012134450306"></p>
<p><strong>实现</strong></p>
<p>先看BlockingQueue在看TreadPool</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestPool&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPool threadPool = <span class="keyword">new</span> ThreadPool(<span class="number">1</span>,</span><br><span class="line">                <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">1</span>, (queue, task)-&gt;&#123;</span><br><span class="line">            <span class="comment">// 1. 死等</span></span><br><span class="line"><span class="comment">//            queue.put(task);</span></span><br><span class="line">            <span class="comment">// 2) 带超时等待</span></span><br><span class="line"><span class="comment">//            queue.offer(task, 1500, TimeUnit.MILLISECONDS);</span></span><br><span class="line">            <span class="comment">// 3) 让调用者放弃任务执行：队列满了没有做任何操作</span></span><br><span class="line"><span class="comment">//            log.debug(&quot;放弃&#123;&#125;&quot;, task);</span></span><br><span class="line">            <span class="comment">// 4) 让调用者抛出异常 抛出异常的线程之后的线程都不会被执行</span></span><br><span class="line"><span class="comment">//            throw new RuntimeException(&quot;任务执行失败 &quot; + task);</span></span><br><span class="line">            <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">            task.run();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, j);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span> <span class="comment">// 拒绝策略</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RejectPolicy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue, T task)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.ThreadPool&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程集合</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务时的超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行</span></span><br><span class="line">        <span class="comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">            <span class="keyword">if</span>(workers.size() &lt; coreSize) &#123;</span><br><span class="line">                Worker worker = <span class="keyword">new</span> Worker(task);</span><br><span class="line">                log.debug(<span class="string">&quot;新增 worker&#123;&#125;, &#123;&#125;&quot;</span>, worker, task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                taskQueue.put(task);</span></span><br><span class="line">                <span class="comment">// 1) 死等</span></span><br><span class="line">                <span class="comment">// 2) 带超时等待</span></span><br><span class="line">                <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line">                <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line">                <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">                <span class="comment">//有以上多种情况 决策权交给线程使用者 而不是写死在线程池的代码中 把具体操作抽象成一个接口</span></span><br><span class="line">                taskQueue.tryPut(rejectPolicy, task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">long</span> timeout, TimeUnit timeUnit, <span class="keyword">int</span> queueCapcity, RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="keyword">this</span>.taskQueue = <span class="keyword">new</span> BlockingQueue&lt;&gt;(queueCapcity);</span><br><span class="line">        <span class="keyword">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            <span class="comment">// 1) 当 task 不为空，执行任务</span></span><br><span class="line">            <span class="comment">// 2) 当 task 执行完毕，再接着从任务队列获取任务并执行</span></span><br><span class="line"><span class="comment">//            while(task != null || (task = taskQueue.take()) != null) &#123;</span></span><br><span class="line">            <span class="keyword">while</span>(task != <span class="keyword">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;正在执行...&#123;&#125;&quot;</span>, task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;worker 被移除&#123;&#125;&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">                workers.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是平衡生产者线程和消费者线程之间的桥梁</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.BlockingQueue&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 锁：防止对任务的争抢</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 生产者条件变量：任务满的话停止生产</span></span><br><span class="line">    <span class="keyword">private</span> Condition fullWaitSet = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 消费者条件变量：没有任务的时候阻塞等待</span></span><br><span class="line">    <span class="keyword">private</span> Condition emptyWaitSet = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 队列容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capcity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockingQueue</span><span class="params">(<span class="keyword">int</span> capcity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capcity = capcity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//升级版的take：带超时阻塞获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将 timeout 统一转换为 纳秒</span></span><br><span class="line">            <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 返回值是剩余时间</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//等待时间-已经经过的时间 返回结果是剩余时间</span></span><br><span class="line">                    nanos = emptyWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();  <span class="comment">// 1</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T task)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            <span class="comment">//唤醒 1 处阻塞的线程</span></span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 升级版的put：带超时时间阻塞添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(T task, <span class="keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> nanos = timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    log.debug(<span class="string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);</span><br><span class="line">                    nanos = fullWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断队列是否满</span></span><br><span class="line">            <span class="keyword">if</span>(queue.size() == capcity) &#123;</span><br><span class="line">                rejectPolicy.reject(<span class="keyword">this</span>, task);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 有空闲</span></span><br><span class="line">                log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyWaitSet.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlockQueue中前四个方法 其中两个是另两个方法的升级 加入了超时功能 第五个方法是为了提高程序的灵活性 传入了自定义的接口RejectPolicy</p>
<p>ThreadPool中的execute会调用worker中的start方法 从而执行线程的run方法 </p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201013132726928.png" alt="image-20201013132726928"></p>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201013132841414.png" alt="image-20201013132841414"></p>
<p>这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作 进行赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c 为旧值， ctlOf 返回结果为新值</span></span><br><span class="line">ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));</span><br><span class="line"><span class="comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201013172228794.png" alt="image-20201013172228794"></p>
<p>工作方式</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201013172338562.png" alt="image-20201013172338562"></p>
<ul>
<li>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</li>
<li>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排 队，直到有空闲的线程。</li>
<li>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线 程来救急</li>
<li>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 4 种实现，其它著名框架也提供了实现<ul>
<li>AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略</li>
<li>CallerRunsPolicy 让调用者运行任务</li>
<li>DiscardPolicy 放弃本次任务</li>
<li>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</li>
<li><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201013175333736.png" alt="image-20201013175333736"></li>
</ul>
</li>
<li>当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由 keepAliveTime 和 unit 来控制</li>
</ul>
<p>根据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池</p>
<h3 id="创建线程池的工厂方法"><a href="#创建线程池的工厂方法" class="headerlink" title="创建线程池的工厂方法"></a>创建线程池的工厂方法</h3><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><p>适用于任务量已知，相对耗时的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line"> 								  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line"> 								  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间</li>
<li>阻塞队列是无界的，可以放任意数量的任务</li>
</ul>
<p>可以传入一个工厂方法 自定义线程名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>, <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger t = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r,<span class="string">&quot;mypool&quot;</span>+t.getAndIncrement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line"> 								   <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line"> 								   <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点:整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线 程。 适合任务数比较密集，但每个任务执行时间较短的情况</p>
<ul>
<li>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着<ul>
<li>全部都是救急线程（60s 后可以回收）</li>
<li>救急线程可以无限创建</li>
</ul>
</li>
<li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交 货）</li>
</ul>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><p>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程 也不会被释放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line"> 		(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line"> 								<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">								<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区别：</p>
<ul>
<li><p>如果自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</p>
</li>
<li><p>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改</p>
<ul>
<li>FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因 此不能调用 ThreadPoolExecutor 中特有的方法</li>
</ul>
</li>
<li><p>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改</p>
<ul>
<li>对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li>
</ul>
</li>
</ul>
<h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><p>Future是一个接口，他给我们提供了方法来检测当前的任务是否已经结束，还可以等待任务结束并且拿到一个结果，通过调用Future的get（）方法可以当任务结束后返回一个结果值，如果工作没有结束，则会阻塞当前线程，直到任务执行完毕</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line"><span class="comment">// 提交任务 task，用返回值 Future 获得任务执行结果 Collable与Runnable的区别是有返回值</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line"> 		<span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line"> 								<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line"> 		<span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params"> 				<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"> 		<span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br></pre></td></tr></table></figure>

<p>创建只有一个线程的线程池调用下面的提交方法</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">ExecutorService<span class="built_in"> pool </span>= Executors.newFixedThreadPool(1);</span><br></pre></td></tr></table></figure>

<p>submit</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(ExecutorService pool)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    Future&lt;String&gt; future = pool.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, future.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invokeAll</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ExecutorService pool)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    List&lt;Future&lt;String&gt;&gt; futures = pool.invokeAll(Arrays.asList(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    futures.forEach( f -&gt;  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, f.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invokeAny</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ExecutorService pool)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    String result = pool.invokeAny(Arrays.asList(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;begin 1&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;end 1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;begin 2&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;end 2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;begin 3&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;end 3&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    ));</span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>shutdown：线程池状态变为 SHUTDOWN</p>
<ul>
<li><p>不会接收新任务  但已提交任务会执行完 </p>
</li>
<li><p>阻塞队列中的线程也能执行完成</p>
</li>
<li><p>此方法不会阻塞调用线程的执行 执行shutdown后不会堵塞主线程的其他代码</p>
</li>
</ul>
<p>shutdownNow：线程池状态变为 STOP - 不会接收新任务 - 会将队列中的任务返回 - 并用 interrupt 的方式中断正在执行的任务</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201014154942351.png" alt="image-20201014154942351"></p>
<h3 id="任务调度线程池"><a href="#任务调度线程池" class="headerlink" title="任务调度线程池"></a>任务调度线程池</h3><p><strong>Timer的缺点</strong></p>
<p>在『任务调度线程池』功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但 由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个 任务的延迟或异常都将会影响到之后的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">    TimerTask task1 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task 1&quot;</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="comment">//如果任务一出现了异常 任务二得不到执行</span></span><br><span class="line">            <span class="comment">//int i = 1 / 0;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    TimerTask task2 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task 2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">    <span class="comment">//使用 timer 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line">    <span class="comment">//但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行</span></span><br><span class="line">    timer.schedule(task1, <span class="number">1000</span>);</span><br><span class="line">    timer.schedule(task2, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ScheduledExecutorService改写</strong></p>
<p>延迟执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建的是固定大小的线程池 参数是核心数</span></span><br><span class="line">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ScheduledExecutorService pool)</span> </span>&#123;</span><br><span class="line">    pool.schedule(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    pool.schedule(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task2&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一个参数是任务对象 第二个参数是延迟执行的时间 第三个参数是时间单位</p>
</li>
<li><p>第一个任务出现异常不会影响第二个线程的执行</p>
<p>定时执行：确保任务之间的执行不会重叠</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">    <span class="comment">//以固定速率执行任务 第二个参数是初始延迟时间 第三个参数是间隔时间</span></span><br><span class="line">    pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">        <span class="comment">//如果任务本身的执行时间&gt;间隔时间 则需要等待任务执行结束 在执行下一个任务 相当于两个任务紧挨着执行 没有间隔时间</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要实现 无论任务执行多长时间  两个任务之间总是有间隔时间 可以用scheduleWithFixedDelay() </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">    <span class="comment">//从任务结束时间开始间隔1s</span></span><br><span class="line">    pool.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="正确处理线程池异常"><a href="#正确处理线程池异常" class="headerlink" title="正确处理线程池异常"></a>正确处理线程池异常</h3><p>主动捕获异常</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015132406145.png" alt="image-20201015132406145"></p>
<p>使用future</p>
<p>​    submit会返回future 如果有异常会get到异常信息</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015132434527.png" alt="image-20201015132434527"></p>
<h3 id="线程池应用-定时执行任务"><a href="#线程池应用-定时执行任务" class="headerlink" title="线程池应用-定时执行任务"></a>线程池应用-定时执行任务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如何让每周四 18:00:00 定时执行任务？</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  获取当前时间</span></span><br><span class="line">    LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    System.out.println(now);</span><br><span class="line">    <span class="comment">// 获取周四时间</span></span><br><span class="line">    LocalDateTime time = now.withHour(<span class="number">18</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>).with(DayOfWeek.THURSDAY);</span><br><span class="line">    <span class="comment">// 如果 当前时间 &gt; 本周周四，必须找到下周周四</span></span><br><span class="line">    <span class="keyword">if</span>(now.compareTo(time) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        time = time.plusWeeks(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(time);</span><br><span class="line">    <span class="comment">// initailDelay 代表当前时间和周四的时间差</span></span><br><span class="line">    <span class="comment">// period 一周的间隔时间</span></span><br><span class="line">    <span class="keyword">long</span> initailDelay = Duration.between(now, time).toMillis();</span><br><span class="line">    <span class="keyword">long</span> period = <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>;</span><br><span class="line">    ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">    pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">    &#125;, initailDelay, period, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Tomcat线程池"><a href="#Tomcat线程池" class="headerlink" title="Tomcat线程池"></a>Tomcat线程池</h3><p>用到线程池的地方</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015133655910.png" alt="image-20201015133655910"></p>
<ul>
<li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲</li>
<li>Acceptor 只负责【接收新的 socket 连接】</li>
<li>Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】</li>
<li>一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理</li>
<li>Executor 线程池中的工作线程最终负责【处理请求】</li>
</ul>
<p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同 如果总线程数达到 maximumPoolSize 这时不会立刻抛 RejectedExecutionException 异常 而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常</p>
<p>connector配置</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015134557594.png" alt="image-20201015134557594"></p>
<p>Executor 线程配置</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015134611144.png" alt="image-20201015134611144"></p>
<h2 id="ForkJoin线程池"><a href="#ForkJoin线程池" class="headerlink" title="ForkJoin线程池"></a>ForkJoin线程池</h2><p><strong>概念</strong></p>
<p>Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型运算</p>
<p>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计 算，如归并排序、斐波那契数列、都可以用分治思想进行求解</p>
<p>Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运 算效率</p>
<p>Fork/Join 默认会创建与 cpu 核心数大小相同的线程池</p>
<p><strong>使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool(<span class="number">4</span>);</span><br><span class="line">System.out.println(pool.invoke(<span class="keyword">new</span> AddTask1(<span class="number">5</span>)));</span><br><span class="line"><span class="comment">//求和1~n</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.AddTask&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTask1</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddTask1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> + n + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;join() &#123;&#125;&quot;</span>, n);</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        AddTask1 t1 = <span class="keyword">new</span> AddTask1(n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//让另一个线程执行t1</span></span><br><span class="line">        t1.fork();</span><br><span class="line">        log.debug(<span class="string">&quot;fork() &#123;&#125; + &#123;&#125;&quot;</span>, n, t1);</span><br><span class="line">        <span class="keyword">int</span> result = n + t1.join();</span><br><span class="line">        log.debug(<span class="string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, n, t1, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015143826045.png" alt="image-20201015143826045"></p>
<p>这种拆分方式 一个线程需要依赖另一个线程的结果 并发度不高</p>
<p><strong>任务拆分和优化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.AddTask&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTask2</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> begin;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddTask2</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.begin = begin;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> + begin + <span class="string">&quot;,&quot;</span> + end + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只剩下最后一个数字 直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;join() &#123;&#125;&quot;</span>, begin);</span><br><span class="line">            <span class="keyword">return</span> begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果这剩下两个数组 没必要拆分</span></span><br><span class="line">        <span class="keyword">if</span> (end - begin == <span class="number">1</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, begin, end, end + begin);</span><br><span class="line">            <span class="keyword">return</span> end + begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (end + begin) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        AddTask2 t1 = <span class="keyword">new</span> AddTask2(begin, mid - <span class="number">1</span>);</span><br><span class="line">        t1.fork();</span><br><span class="line">        AddTask2 t2 = <span class="keyword">new</span> AddTask2(mid + <span class="number">1</span>, end);</span><br><span class="line">        t2.fork();</span><br><span class="line">        log.debug(<span class="string">&quot;fork() &#123;&#125; + &#123;&#125; + &#123;&#125; = ?&quot;</span>, mid, t1, t2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = mid + t1.join() + t2.join();</span><br><span class="line">        log.debug(<span class="string">&quot;join() &#123;&#125; + &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, mid, t1, t2, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015143959262.png" alt="image-20201015143959262"></p>
<h2 id="异步模式之工作线程"><a href="#异步模式之工作线程" class="headerlink" title="异步模式之工作线程"></a>异步模式之工作线程</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。也可以将其归类为分工模式，它的典型实现 就是线程池，也体现了经典设计模式中的享元模式。</p>
<p>例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那 么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message）</p>
<p>注意，不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率</p>
<p>例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成 服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工</p>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>固定大小线程池会有饥饿现象</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015112749881.png" alt="image-20201015112749881"></p>
<p>这段代码就会发生死锁 thread1 和thread2 都在处理点餐 </p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015113443373.png" alt="image-20201015113443373"></p>
<p>解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService waiterPool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    ExecutorService cookPool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    waiterPool.execute(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;处理点餐...&quot;</span>);</span><br><span class="line">        Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> cooking();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    waiterPool.execute(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;处理点餐...&quot;</span>);</span><br><span class="line">        Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> cooking();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>waiterPool处理点餐  cookPool处理做菜</li>
</ul>
<h3 id="创建多少线程池合适"><a href="#创建多少线程池合适" class="headerlink" title="创建多少线程池合适"></a>创建多少线程池合适</h3><p>过小会导致程序不能充分地利用系统资源、容易导致饥饿。过大会导致更多的线程上下文切换，占用更多内存</p>
<p>cpu密集型计算</p>
<p>通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</p>
<p>I/O密集型运算</p>
<p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015114019841.png" alt="image-20201015114019841"></p>
<h1 id="J-U-C"><a href="#J-U-C" class="headerlink" title="J.U.C"></a>J.U.C</h1><p>在 Java 5.0 提供了 <code>java.util.concurrent</code>(简称JUC)包,在此包中增加了在并发编程中很常用的工具类,用于定义类似于线程的自定义子系统,包括线程池,异步 IO 和轻量级任务框架;还提供了设计用于多线程上下文中的 Collection 实现等;</p>
<h2 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关同步器工具的框架 </p>
<p>特点： </p>
<ul>
<li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁 <ul>
<li>getState - 获取 state 状态 </li>
<li>setState - 设置 state 状态 </li>
<li>compareAndSetState - cas 机制设置 state 状态 </li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源 </li>
</ul>
</li>
<li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList </li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet </li>
</ul>
<p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException） tryAcquire tryRelease tryAcquireShared tryReleaseShared isHeldExclusively</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015145114472.png" alt="image-20201015145114472"></p>
<h3 id="自定义锁"><a href="#自定义锁" class="headerlink" title="自定义锁"></a>自定义锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义锁（不可重入锁）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不可重入锁 同步器类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MySync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">//如果是可重入锁需要用arg做一些操作</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 加上了锁，并设置 owner 为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//变量state被volatie修饰 exclusiveOwnerThread不是 所以setState操作放在后面</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">// 是否持有独占锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MySync sync = <span class="keyword">new</span> MySync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁（不成功会进入等待队列）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁，可打断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁（一次）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁，带超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//release内部会调用tryRelease方法 并使用unpark唤醒阻塞的线程</span></span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 创建条件变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestAqs&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAqs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLock lock = <span class="keyword">new</span> MyLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//因为是不可重入的 所以不能重复上锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reentrantlock"><a href="#Reentrantlock" class="headerlink" title="Reentrantlock"></a>Reentrantlock</h2><p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015153928781.png" alt="image-20201015153928781"></p>
<h3 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a>非公平锁实现原理</h3><p><strong>加锁解锁流程</strong> </p>
<p>从构造器开始看 默认为非公平锁实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentranLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">	sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NonfairSync 继承自 AQS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有竞争时：执行if里面的语句</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015154530955.png" alt="image-20201015154530955"></p>
<p>第一个竞争出现时：执行else中的语句</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015154541060.png" alt="image-20201015154541060"></p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015155146781.png" alt="image-20201015155146781"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread-1 执行了</p>
<ol>
<li>Thread-1 执行了</li>
<li>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败</li>
<li>接下来进入 addWaiter 逻辑，构造 Node 队列<ul>
<li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态</li>
<li>Node 的创建是懒惰的</li>
<li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li>
</ul>
</li>
<li>当前线程进入 acquireQueued 逻辑<ol>
<li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</li>
<li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li>
<li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false,waitStatus为-1的节点有职责唤醒他的后继节点</li>
<li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li>
<li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true</li>
<li>进入 parkAndCheckInterrupt 该方法调用Thread-1 park（灰色表示）</li>
</ol>
</li>
</ol>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015160031729.png" alt="image-20201015160031729"></p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015160041428.png" alt="image-20201015160041428"></p>
<p>再次有多个线程经历上述过程竞争失败，变成这个样子</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015160443088.png" alt="image-20201015160443088"></p>
<p>Thread-0 释放锁，进入 tryRelease 流程，如果成功</p>
<ul>
<li>设置 exclusiveOwnerThread 为 null</li>
<li>state = 0</li>
</ul>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015160611118.png" alt="image-20201015160611118"></p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015160810148.png" alt="image-20201015160810148"></p>
<p>当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程 找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1 回到 Thread-1 的 acquireQueued 流程</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015160912517.png" alt="image-20201015160912517"></p>
<p>如果加锁成功（没有竞争），会设置</p>
<ul>
<li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li>
<li>原本的 head 因为从链表断开，而可被垃圾回收</li>
</ul>
<p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015161010623.png" alt="image-20201015161010623"></p>
<p>如果不巧又被 Thread-4 占了先</p>
<ul>
<li>Thread-4 被设置为 exclusiveOwnerThread，state = 1</li>
<li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li>
</ul>
<h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><p>重入时state++ 解锁时state– 只有当state为0时才能释放锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//acquires是1 如果获取锁成功的情况 这里体现了非公平性：不回去检查AQS队列</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果获得了锁 线程还是当前线程 表示发生了锁重入</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h3><p><strong>不可打断模式</strong></p>
<p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">//如果打断状态为true进入</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//需要获得到锁以后 才能返回打断状态</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//1在此处被打断</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">//如果是因为interrupt被唤醒，返回打断状态为true 之后继续下一次for循环</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2进行打断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果打断标记为true park会失效</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//清除打断标记</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重新产生一次中断</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可打断模式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        <span class="comment">//如果没有获得锁 进去</span></span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可打断的获取锁流程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">//在park过程中如果被interrupt会抛出异常 而不会再次进入for循环</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="公平锁原理"><a href="#公平锁原理" class="headerlink" title="公平锁原理"></a>公平锁原理</h3><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//先检查AQS队列中是否有前驱节点，没有再去竞争</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">//h!=t表示队列中有Node</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            <span class="comment">//如果队列中没有老二 或者老二不是当前线程 (说明当前线程优先级更低不应该获取锁)</span></span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h3><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject</p>
<h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015165427358.png" alt="image-20201015165427358"></p>
<p>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程 创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015165638415.png" alt="image-20201015165638415"></p>
<p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015165648663.png" alt="image-20201015165648663"></p>
<p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015165659089.png" alt="image-20201015165659089"></p>
<p>park 阻塞 Thread-0 等待被唤醒</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201015165715106.png" alt="image-20201015165715106"></p>
<h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果不是锁的持有者 失败</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把当前节点从ConditionObject中断开</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>; </span><br><span class="line"><span class="comment">//把节点转移到NonfairSync队列 如果失败（超时 打断等原因）或者下一个节点也为null 则再次执行循环 找下一个可用的node进行唤醒</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//尝试把 状态码改为0</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">//把节点加入到等待队列尾部 成功的话 返回前驱节点</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="comment">//检查前驱节点状态并改为-1</span></span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>假设 Thread-1 要来唤醒 Thread-0</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016093458861.png" alt="image-20201016093458861"></p>
<p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016093731362.png" alt="image-20201016093731362"></p>
<p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的 waitStatus 改为 -1</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016093741693.png" alt="image-20201016093741693"></p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><h3 id="ReentrantLock-1"><a href="#ReentrantLock-1" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>当读操作远远高于写操作时，这时候使用 读写锁 让 读-读 可以并发，提高性能。</p>
<p>提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestReadWriteLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        DataContainer dataContainer = <span class="keyword">new</span> DataContainer();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            dataContainer.read();</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            dataContainer.read();</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.DataContainer&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rw = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="comment">//创建读写锁</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.ReadLock r = rw.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.WriteLock w = rw.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取读锁...&quot;</span>);</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;读取&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;释放读锁...&quot;</span>);</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取写锁...&quot;</span>);</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;写入&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;释放写锁...&quot;</span>);</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>读读可以并发 读写和写写不行</li>
</ul>
<p>注意事项</p>
<ul>
<li><p>读锁不支持条件变量</p>
</li>
<li><p>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待<img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016102323111.png" alt="image-20201016102323111"></p>
</li>
<li><p>重入时降级支持：即持有写锁的情况下去获取读锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="comment">// 是否有效，如果失效，需要重新计算 data</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">    <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">// 获取写锁前必须释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 双重判断 因为上一重判断没受到线程安全保护判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新</span></span><br><span class="line">                <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                    data = ...</span><br><span class="line">                        cacheValid = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存</span></span><br><span class="line">                rwl.readLock().lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 rwl.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自己用完数据, 释放读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            use(data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个</p>
<p>下图以给t1上写锁 t2上读锁为例</p>
<p> t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 16 位，而读锁 使用的是 state 的高 16 位</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016111343872.png" alt="image-20201016111343872"></p>
<p>t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写 锁占据，那么 tryAcquireShared 返回 -1 表示失败</p>
<ul>
<li>tryAcquireShared 返回值表示<ul>
<li>-1 表示失败</li>
<li>0 表示成功，但后继节点不会继续唤醒</li>
<li>正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回 1</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016111504812.png" alt="image-20201016111504812"></p>
<p>这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016111557407.png" alt="image-20201016111557407"></p>
<p>t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁</p>
<p>如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一 次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 park</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016111633691.png" alt="image-20201016111633691"></p>
<p>假设又有 t3 加读锁和 t4 加写锁，这期间 t1 仍然持有锁，就变成了下面的样子</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016111716318.png" alt="image-20201016111716318"></p>
<p>当t1 w.unlock() 会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016111813803.png" alt="image-20201016111813803"></p>
<p>接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行</p>
<p>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016111833404.png" alt="image-20201016111833404"></p>
<p>这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016111844940.png" alt="image-20201016111844940"></p>
<p>事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016111951965.png" alt="image-20201016111951965"></p>
<p>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016112006195.png" alt="image-20201016112006195"></p>
<p>这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016112018317.png" alt="image-20201016112018317"></p>
<p>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点</p>
<p>当t2 r.unlock，t3 r.unlock</p>
<p>t2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016112122059.png" alt="image-20201016112122059"></p>
<p>t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入 doReleaseShared() 将头节点从 -1 改为 0 并唤醒老二，即</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016112140459.png" alt="image-20201016112140459"></p>
<p>之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他 竞争，tryAcquire(1) 成功，修改头结点，流程结束</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016112241250.png" alt="image-20201016112241250"></p>
<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p>
<p>加解读锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.readLock();</span><br><span class="line">lock.unlockRead(stamp);</span><br></pre></td></tr></table></figure>

<p>加解写锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.writeLock();</span><br><span class="line">lock.unlockWrite(stamp)</span><br></pre></td></tr></table></figure>

<p>乐观读，StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通 过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 验戳</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123;</span><br><span class="line"> <span class="comment">// 锁升级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStampedLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DataContainerStamped dataContainer = <span class="keyword">new</span> DataContainerStamped(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            dataContainer.read(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        sleep(<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            dataContainer.read(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.DataContainerStamped&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataContainerStamped</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock lock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataContainerStamped</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> readTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = lock.tryOptimisticRead();</span><br><span class="line">        log.debug(<span class="string">&quot;optimistic read locking...&#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        sleep(readTime);</span><br><span class="line">        <span class="comment">//戳验证成功返回数据</span></span><br><span class="line">        <span class="keyword">if</span> (lock.validate(stamp)) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 戳失效：锁升级 - 读锁</span></span><br><span class="line">        log.debug(<span class="string">&quot;updating to read lock... &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp = lock.readLock();</span><br><span class="line">            log.debug(<span class="string">&quot;read lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            sleep(readTime);</span><br><span class="line">            log.debug(<span class="string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;read unlock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            lock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> newData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = lock.writeLock();</span><br><span class="line">        log.debug(<span class="string">&quot;write lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">this</span>.data = newData;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;write unlock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不支持可重入 不支持条件变量</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><p>信号量，用来限制能同时访问共享资源的线程上限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建 semaphore 对象</span></span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 10个线程同时运行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用</p>
<ul>
<li>使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机 线程数量，并且仅是限制线程数，而不是限制资源数</li>
<li>用 Semaphore 实现简单连接池，对比『享元模式』下的实现（用wait notify），性能和可读性显然更好</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 连接池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> poolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接对象数组</span></span><br><span class="line">    <span class="keyword">private</span> Connection[] connections;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray states;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 构造方法初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">(<span class="keyword">int</span> poolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.poolSize = poolSize;</span><br><span class="line">        <span class="comment">// 让许可数与资源数一致</span></span><br><span class="line">        <span class="keyword">this</span>.semaphore = <span class="keyword">new</span> Semaphore(poolSize);</span><br><span class="line">        <span class="keyword">this</span>.connections = <span class="keyword">new</span> Connection[poolSize];</span><br><span class="line">        <span class="keyword">this</span>.states = <span class="keyword">new</span> AtomicIntegerArray(<span class="keyword">new</span> <span class="keyword">int</span>[poolSize]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            connections[i] = <span class="keyword">new</span> MockConnection(<span class="string">&quot;连接&quot;</span> + (i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 借连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">borrow</span><span class="params">()</span> </span>&#123;<span class="comment">// t1, t2, t3</span></span><br><span class="line">        <span class="comment">// 获取许可</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(); <span class="comment">// 没有许可的线程，在此等待</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取空闲连接</span></span><br><span class="line">            <span class="keyword">if</span>(states.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (states.compareAndSet(i, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);</span><br><span class="line">                    <span class="keyword">return</span> connections[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不会执行到这里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6. 归还连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connections[i] == conn) &#123;</span><br><span class="line">                states.set(i, <span class="number">0</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;free &#123;&#125;&quot;</span>, conn);</span><br><span class="line">                semaphore.release();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>Semaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后 停车场显示空余车位减一，刚开始，permits（state）为 3，这时 5 个线程来获取资源</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016135138148.png" alt="image-20201016135138148"></p>
<p>假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列 park 阻塞</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016135148361.png" alt="image-20201016135148361"></p>
<p>这时 Thread-4 释放了 permits，状态如下</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016135222036.png" alt="image-20201016135222036"></p>
<p>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接 下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016135246328.png" alt="image-20201016135246328"></p>
<ul>
<li>查看acquire和release的源码</li>
</ul>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><p>用来进行线程同步协作，等待所有线程完成倒计时。 其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">    ExecutorService service = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1.5</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">            latch.await();</span><br><span class="line">            log.debug(<span class="string">&quot;wait end...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>模拟王者荣耀是个人加载完毕进入游戏</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    AtomicInteger num = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>, (r) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">&quot;t&quot;</span> + num.getAndIncrement());</span><br><span class="line">    &#125;);</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">    String[] all = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = j;</span><br><span class="line">        service.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(r.nextInt(<span class="number">100</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                all[x] = Thread.currentThread().getName() + <span class="string">&quot;(&quot;</span> + (i + <span class="string">&quot;%&quot;</span>) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                System.out.print(<span class="string">&quot;\r&quot;</span> + Arrays.toString(all));</span><br><span class="line">            &#125;</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    latch.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;\n游戏开始...&quot;</span>);</span><br><span class="line">    service.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行</p>
<p>CountDownLatch不可重用 次数减到0的时候 需要重新创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//当tast1 and tast2 都执行完毕时 执行第二个参数里的代码</span></span><br><span class="line">    <span class="comment">//线程数最好和任务数保持一致 如果线程数设置为3 由于task2执行时间为2s task1执行时间为1s </span></span><br><span class="line">    <span class="comment">//任务执行顺序是 tast1 tast1 tst2 最终两个tast1先执行完 把parties减为0 而不是理想的 1 2 1</span></span><br><span class="line">    CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, ()-&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task1, task2 finish...&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; <span class="comment">// task1  task2  task1</span></span><br><span class="line">        <span class="comment">//每轮循环都会重置CyclicBarrier的第一个参数</span></span><br><span class="line">        service.submit(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task1 begin...&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//等到第一个参数减为0时和其他任务一起执行</span></span><br><span class="line">                barrier.await(); <span class="comment">// 2-1=1</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        service.submit(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task2 begin...&quot;</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier.await(); <span class="comment">// 1-1=0</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    service.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程安全集合类"><a href="#线程安全集合类" class="headerlink" title="线程安全集合类"></a>线程安全集合类</h2><p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016145715240.png" alt="image-20201016145715240"></p>
<p><img src="/2020/10/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20201016145748941.png" alt="image-20201016145748941"></p>
<p>concurrentHashMap原理</p>
<p>linkedBlockingQueue原理</p>
<p>concurrentlinkedQueue原理</p>
<p>copyOnWriteArrayList原理</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>org.springframework.core.io.buffer.NettyDataBufferFactory</title>
    <url>/2021/02/22/org-springframework-core-io-buffer-NettyDataBufferFactory/</url>
    <content><![CDATA[<p>在做商城项目的时候启动网关后路由到登录页面出现了下面的错误</p>
<p><img src="/2021/02/22/org-springframework-core-io-buffer-NettyDataBufferFactory/log\source_posts\org-springframework-core-io-buffer-NettyDataBufferFactory\image-20210222200203003.png" alt="image-20210222200203003"></p>
<p>解决方法： 由于springcloud的gateway使用的是webflux,默认使用netty,所以从依赖中排除 tomcat相关的依赖 ，就可以了</p>
<p>安装Maven Helper插件</p>
<p><img src="/2021/02/22/org-springframework-core-io-buffer-NettyDataBufferFactory/log\source_posts\org-springframework-core-io-buffer-NettyDataBufferFactory\image-20210222200252334.png" alt="image-20210222200252334"></p>
<p>排除该依赖</p>
]]></content>
      <categories>
        <category>bug</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>谷粒商城</title>
    <url>/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/</url>
    <content><![CDATA[<h1 id="商品服务"><a href="#商品服务" class="headerlink" title="商品服务"></a>商品服务</h1><h1 id="Oss对象存储"><a href="#Oss对象存储" class="headerlink" title="Oss对象存储"></a>Oss对象存储</h1><p>文件存储</p>
<p><strong><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210408200004406.png" alt="image-20210408200004406"></strong></p>
<p>上传方式：采用JavaScript客户端直接签名（参见JavaScript客户端签名直传)时，AccessKey lD和AcessKey Secret会暴露在前端页面,因此存在严重的安全隐患。因此，OSS提供了服务端签名后直传的方案。</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210408201741526.png" alt="image-20210408201741526"></p>
<p>创建一个新的module(mall-thirdparty)用于存放第三方应用</p>
<p>导入jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alicloud-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在配置文件中进行配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">alicloud:</span></span><br><span class="line">          <span class="attr">access-key:</span> <span class="string">LTAI4G5zyHGVo57wWXZSsBv6</span></span><br><span class="line">          <span class="attr">secret-key:</span> <span class="string">hNTww8jjeAHGe92BuxkEeVHDia4dAx</span></span><br><span class="line">          <span class="attr">oss:</span></span><br><span class="line">            <span class="attr">endpoint:</span> <span class="string">oss-cn-beijing.aliyuncs.com</span></span><br></pre></td></tr></table></figure>

<p>创建一个controller用于向oss上传文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OssController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OSS ossClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.cloud.alicloud.oss.endpoint&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.cloud.alicloud.oss.bucket&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String bucket;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.cloud.alicloud.access-key&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/oss/policy&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">policy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String bucket = <span class="string">&quot;mall-pict&quot;</span>; <span class="comment">// 请填写您的 bucketname 。</span></span><br><span class="line">        String host = <span class="string">&quot;https://&quot;</span> + bucket + <span class="string">&quot;.&quot;</span> + endpoint; <span class="comment">// host的格式为 bucketname.endpoint</span></span><br><span class="line">        <span class="comment">// callbackUrl为 上传回调服务器的URL，请将下面的IP和Port配置为您自己的真实信息。</span></span><br><span class="line">        String callbackUrl = <span class="string">&quot;http://88.88.88.88:8888&quot;</span>;</span><br><span class="line">        String format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">        String dir = format + <span class="string">&quot;/&quot;</span>; <span class="comment">// 用户上传文件时指定的前缀。上传图片的日期</span></span><br><span class="line">        Map&lt;String, String&gt; respMap = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> expireTime = <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">long</span> expireEndTime = System.currentTimeMillis() + expireTime * <span class="number">1000</span>;</span><br><span class="line">            Date expiration = <span class="keyword">new</span> Date(expireEndTime);</span><br><span class="line">            <span class="comment">// PostObject请求最大可支持的文件大小为5GB，即CONTENT_LENGTH_RANGE为5*1024*1024*1024。</span></span><br><span class="line">            PolicyConditions policyConds = <span class="keyword">new</span> PolicyConditions();</span><br><span class="line">            policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, <span class="number">0</span>, <span class="number">1048576000</span>);</span><br><span class="line">            policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);</span><br><span class="line"></span><br><span class="line">            String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);</span><br><span class="line">            <span class="keyword">byte</span>[] binaryData = postPolicy.getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            String encodedPolicy = BinaryUtil.toBase64String(binaryData);</span><br><span class="line">            String postSignature = ossClient.calculatePostSignature(postPolicy);</span><br><span class="line"></span><br><span class="line">            respMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">            respMap.put(<span class="string">&quot;accessid&quot;</span>, accessId);</span><br><span class="line">            respMap.put(<span class="string">&quot;policy&quot;</span>, encodedPolicy);</span><br><span class="line">            respMap.put(<span class="string">&quot;signature&quot;</span>, postSignature);</span><br><span class="line">            respMap.put(<span class="string">&quot;dir&quot;</span>, dir);</span><br><span class="line">            respMap.put(<span class="string">&quot;host&quot;</span>, host);</span><br><span class="line">            respMap.put(<span class="string">&quot;expire&quot;</span>, String.valueOf(expireEndTime / <span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// Assert.fail(e.getMessage());</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ossClient.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R.ok().put(<span class="string">&quot;data&quot;</span>,respMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端有一个文件上传组件 前端从后端拿到policy和签名 然后连同文件一起发送给oss服务器完成文件的上传</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210422153538601.png" alt="image-20210422153538601"></p>
<p>配置跨域</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210223210510929.png" alt="image-20210223210510929"></p>
<p><strong>JSR303表单校验</strong></p>
<p>为需要校验的字段加上注解</p>
<p>@Valid开启校验</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">save</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> BrandEntity brand, BindingResult bindingResult)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//BindingResult可以获取到校验的结果</span></span><br><span class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line">        bindingResult.getFieldErrors().forEach(item -&gt; &#123;</span><br><span class="line">            String message = item.getDefaultMessage();</span><br><span class="line">            <span class="comment">//错误的属性名</span></span><br><span class="line">            String field = item.getField();</span><br><span class="line">            map.put(field,message);</span><br><span class="line">        &#125;);</span><br><span class="line">        R.error(<span class="number">400</span>,<span class="string">&quot;提交的数据不可发&quot;</span>).put(<span class="string">&quot;data&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">    brandService.save(brand);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次都这么获取叫校验结果太麻烦 创建一个类进行统一异常处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice(&quot;com.baobingjiang.mall.product.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionControllerAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">handlerValidException</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;数据校验出现问题&#123;&#125;,异常类型&#123;&#125;&quot;</span>,e.getMessage(),e.getClass());</span><br><span class="line">        <span class="keyword">return</span> R.error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分组校验：新增和修改使用两种校验方法</p>
<ul>
<li><p>字段校验注解指定分组</p>
</li>
<li><p>在controller中使用@Validated注解</p>
</li>
<li><p>没有指定分组的注解在没有指定@Validated时才会生效</p>
</li>
</ul>
<p>自定义校验</p>
<ul>
<li><p>编写一个自定义的校验注解</p>
<ul>
<li><pre><code class="java">@Documented
//指定校验器
@Constraint(validatedBy = &#123;ListValueConstraintValidator.class&#125;)
@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)
@Retention(RetentionPolicy.RUNTIME)
public @interface ListValue &#123;
    //要有这三个基本属性
    //错误信息去哪取
    String message() default &quot;&#123;javax.validation.constraints.NotBlank.message&#125;&quot;;
    //支持分组
    Class&lt;?&gt;[] groups() default &#123;&#125;;
    //支持负载信息
    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;

    int[] vals() default &#123;&#125;;
&#125;
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 编写一个自定义的校验器</span><br><span class="line"></span><br><span class="line">  * ```java</span><br><span class="line">    <span class="built_in">public</span> <span class="keyword">class</span> ListValueConstraintValidator implements ConstraintValidator&lt;ListValue,<span class="type">Integer</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">Set</span>&lt;<span class="type">Integer</span>&gt; <span class="keyword">set</span> = <span class="built_in">new</span> HashSet&lt;&gt;();</span><br><span class="line">        @Override</span><br><span class="line">        <span class="built_in">public</span> <span class="type">void</span> initialize(ListValue constraintAnnotation) &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="type">int</span>[] vals = constraintAnnotation.vals(); // <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> val:vals)&#123;</span><br><span class="line">                <span class="keyword">set</span>.<span class="keyword">add</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        <span class="built_in">public</span> <span class="type">boolean</span> isValid(<span class="type">Integer</span> <span class="type">integer</span>, ConstraintValidatorContext constraintValidatorContext) 	   &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">set</span>.contains(<span class="type">integer</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>关联校验器和校验注解</p>
</li>
</ul>
<p>自定义更新两种方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBrand</span><span class="params">(Long brandId, String name)</span> </span>&#123;</span><br><span class="line">    CategoryBrandRelationEntity categoryBrandRelationEntity = <span class="keyword">new</span> CategoryBrandRelationEntity();</span><br><span class="line">    categoryBrandRelationEntity.setBrandId(brandId);</span><br><span class="line">    categoryBrandRelationEntity.setBrandName(name);</span><br><span class="line">    <span class="keyword">this</span>.update(categoryBrandRelationEntity,<span class="keyword">new</span> UpdateWrapper&lt;CategoryBrandRelationEntity&gt;				().eq(<span class="string">&quot;brand_id&quot;</span>,brandId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCategory</span><span class="params">(Long catId, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.baseMapper.updateCategory(catId,name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="属性分组"><a href="#属性分组" class="headerlink" title="属性分组"></a>属性分组</h1><p>spu和sku</p>
<p>使用mybatisplus的QueryWrapper条件查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String key = (String) params.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">QueryWrapper&lt;AttrGroupEntity&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;AttrGroupEntity&gt;().eq(<span class="string">&quot;catelog_id&quot;</span>,catelogId);</span><br><span class="line"><span class="keyword">if</span>(!StringUtils.isEmpty(key))&#123;</span><br><span class="line">    queryWrapper.and(obj -&gt; &#123;</span><br><span class="line">        obj.eq(<span class="string">&quot;attr_group_id&quot;</span>,key).or().like(<span class="string">&quot;attr_group_name&quot;</span>,key);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">page = <span class="keyword">this</span>.page(<span class="keyword">new</span> Query&lt;AttrGroupEntity&gt;().getPage(params),queryWrapper);</span><br></pre></td></tr></table></figure>

<p>配置分页插件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.baobingjiang.mall.product.dao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PaginationInterceptor paginationInterceptor = <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">        <span class="comment">//如果请求的页码大于最后一页 返回首页</span></span><br><span class="line">        paginationInterceptor.setOverflow(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//设置最大单页限制数量 默认500</span></span><br><span class="line">        paginationInterceptor.setLimit(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> paginationInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义更新两种方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBrand</span><span class="params">(Long brandId, String name)</span> </span>&#123;</span><br><span class="line">    CategoryBrandRelationEntity categoryBrandRelationEntity = <span class="keyword">new</span> CategoryBrandRelationEntity();</span><br><span class="line">    categoryBrandRelationEntity.setBrandId(brandId);</span><br><span class="line">    categoryBrandRelationEntity.setBrandName(name);</span><br><span class="line">    <span class="keyword">this</span>.update(categoryBrandRelationEntity,<span class="keyword">new</span> UpdateWrapper&lt;CategoryBrandRelationEntity&gt;				().eq(<span class="string">&quot;brand_id&quot;</span>,brandId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCategory</span><span class="params">(Long catId, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.baseMapper.updateCategory(catId,name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Elasctic-Search"><a href="#Elasctic-Search" class="headerlink" title="Elasctic Search"></a>Elasctic Search</h1><p>es:索引-&gt;文档-&gt;属性</p>
<p>sql:库-&gt;表-&gt;行-&gt;属性</p>
<p><strong>乐观锁修改</strong></p>
<p>字段信息：</p>
<ul>
<li><p>if_seq_no:并发控制字段 每次更新就会+1 用来做乐观锁</p>
</li>
<li><p>if_primary_term:同上 当主分片重新分配如重启 就会变化</p>
</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">PUT <span class="regexp">/customer/</span>_doc/<span class="number">1</span>?if_primary_term = <span class="number">1</span>&amp;if_seq_no = <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用elasticsearch-rest-high-level-client操作ES 需要手动编写配置类 如果使用springdataES就不用</p>
<p>nested数据类型：用于嵌套数据 如果嵌套的数据不使用此类型就会扁平化处理</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210301204040670.png" alt="image-20210301204040670"><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210301204128260.png" alt="image-20210301204128260"></p>
<h1 id="商城服务"><a href="#商城服务" class="headerlink" title="商城服务"></a>商城服务</h1><p>使用thymeleaf渲染页面</p>
<p>使用nginx动静分离 </p>
<h1 id="性能压测"><a href="#性能压测" class="headerlink" title="性能压测"></a>性能压测</h1><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><p><strong>jmeter</strong></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210303175000122.png" alt="image-20210303175000122"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210303175105717.png" alt="image-20210303175105717"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210303175242261.png" alt="image-20210303175242261"></p>
<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><p>使用nginx设置域名 </p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210304225009660.png" alt="image-20210304225009660"></p>
<p><strong>nginx配置</strong></p>
<p>mall.conf</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210408193950651.png" alt="image-20210408193950651"></p>
<p>nginx.conf</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210408194636512.png" alt="image-20210408194636512"></p>
<ul>
<li>server_name会监听来自mall.com或者*.mall.com域名下的请求 这些请求的请求头的host属性为*.mall.com根据这个host属性 把请求转交给上游服务器<a href="http://mall/">http://mall</a> mall是在nginx.conf中配置的项目gateway服务的url。当nginx把请求转给网关的时候会丢失请求头中的host所以要在配置文件中配置$host表示取出当前请求真正的host的值</li>
</ul>
<p>网关增加设置：当访问mall.com的时候经过网关路由到商品服务 这条设置要放在最后 不然不能路由到具体服务</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210304225023610.png" alt="image-20210304225023610"></p>
<p>动静分离 </p>
<p>当访问静态资源例如<a href="http://mall.com/static/index/img/lunbo6.png%E4%BC%9A%E5%8E%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84html/static%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%9F%A5%E6%89%BE">http://mall.com/static/index/img/lunbo6.png会去服务器的html/static目录下查找</a></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210304225131282.png" alt="image-20210304225131282"></p>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p><strong>redis</strong></p>
<p>导入jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用jedis而不使用lettuce的原因：lettuce使用netty进行网络通信 有bug会导致堆外内存移除</p>
<p>解决问题</p>
<ul>
<li>缓存穿透：空结果缓存</li>
<li>缓存雪崩：设置随机过期时间</li>
<li>加锁：解决缓存击穿</li>
</ul>
<p><strong>使用Redisson作为分布式锁等功能框架</strong></p>
<p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>进行配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedissonConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean(destroyMethod = &quot;shutdown&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redissonClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.52.131:6379&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * 阻塞时等待 默认加锁是<span class="number">30</span>s</span><br><span class="line"> * RLock锁有看门狗机制 如果业务超长，会自动帮我们续期，默认三十秒（续期时间为占锁之后 看门狗时间[<span class="number">30</span>] / <span class="number">3</span>）</span><br><span class="line"> * 只要业务完成 就不会为当前锁续期 即使不手动解锁 也会在<span class="number">30</span>s后自动删除</span><br><span class="line"> * 如果指定过期事件 lock.lock(<span class="number">10</span>,TimeUnit.SECONDS); 指定的时间一定要大于业务的时间 否则会出现死锁的情况</span><br><span class="line"> * 建议指定时间 省掉了续期操作</span><br><span class="line"> */</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/index/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RLock lock = redissonClient.getLock(<span class="string">&quot;my-lock&quot;</span>);</span><br><span class="line">   <span class="comment">// 阻塞式等待</span></span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缓存一致性</strong></p>
<ul>
<li>双写模式：修改数据库后 修改缓存<ul>
<li><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210312162006542.png" alt="image-20210312162006542"></li>
</ul>
</li>
<li>失效模式：修改数据库后 删除缓存<ul>
<li><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210312162309012.png" alt="image-20210312162309012"></li>
</ul>
</li>
</ul>
<p>解决方法</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210312162639760.png" alt="image-20210312162639760"></p>
<p><strong>SpringCache</strong></p>
<p>使用SpringCache可以方便的操作缓存</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置使用redis作为缓存</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cache</span>:</span><br><span class="line">  <span class="keyword">type</span>: redis</span><br><span class="line">  redis:</span><br><span class="line">    <span class="built_in">time</span>-<span class="keyword">to</span>-live: <span class="number">60000</span></span><br><span class="line">    <span class="keyword">cache</span>-<span class="literal">null</span>-<span class="keyword">values</span>: <span class="literal">true</span> <span class="comment">#解决缓存穿透问题</span></span><br><span class="line">    <span class="keyword">use</span>-<span class="keyword">key</span>-prefix: <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210312165037949.png" alt="image-20210312165037949"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将结果放入缓存中 命名空间为category key如果不指定自动生成 value默认使用java序列化机制 默认过期时间为-1</span></span><br><span class="line"><span class="comment">//spring.cache.redis.time-to-live指定过期时间</span></span><br><span class="line"><span class="comment">//sync表示同步方法 进行加锁 解决缓存击穿问题</span></span><br><span class="line"><span class="meta">@Cacheable(value = &#123;&quot;category&quot;&#125;, key = &quot;#root.method.name&quot;, sync = true)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;CategoryEntity&gt; <span class="title">getOneLevelCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> baseMapper.selectList(<span class="keyword">new</span> QueryWrapper&lt;CategoryEntity&gt;().eq(<span class="string">&quot;cat_level&quot;</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置序列化并且让配置文件中的内容生效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(CacheProperties.class)</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCacheConfig</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 配置文件中 TTL设置没用上</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 原来:</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@ConfigurationProperties</span>(prefix = &quot;spring.cache&quot;)</span></span><br><span class="line"><span class="comment">    * public class CacheProperties</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 现在要让这个配置文件生效    : <span class="doctag">@EnableConfigurationProperties</span>(CacheProperties.class)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function">RedisCacheConfiguration <span class="title">redisCacheConfiguration</span><span class="params">(CacheProperties cacheProperties)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置kv的序列化机制</span></span><br><span class="line">      config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> StringRedisSerializer()));</span><br><span class="line">      config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer()));</span><br><span class="line">      CacheProperties.Redis redisproperties = cacheProperties.getRedis();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置配置</span></span><br><span class="line">      <span class="keyword">if</span>(redisproperties.getTimeToLive() != <span class="keyword">null</span>)&#123;</span><br><span class="line">         config = config.entryTtl(redisproperties.getTimeToLive());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(redisproperties.getKeyPrefix() != <span class="keyword">null</span>)&#123;</span><br><span class="line">         config = config.prefixKeysWith(redisproperties.getKeyPrefix());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(!redisproperties.isCacheNullValues())&#123;</span><br><span class="line">         config = config.disableCachingNullValues();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(!redisproperties.isUseKeyPrefix())&#123;</span><br><span class="line">         config = config.disableKeyPrefix();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> config;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>异步</strong></p>
<p>使用CompletableFuture查询商品详情页</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315224725781.png" alt="image-20210315224725781"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315201921385.png" alt="image-20210315201921385"></p>
<p>可以传入线程池也可以用默认的线程池 </p>
<p>计算完成时四种回调方法</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315202333923.png" alt="image-20210315202333923"></p>
<p>​    <img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315202450608.png" alt="image-20210315202450608"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315202725005.png" alt="image-20210315202725005"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315202759835.png" alt="image-20210315202759835"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315203322054.png" alt="image-20210315203322054"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315203129342.png" alt="image-20210315203129342"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315203625063.png" alt="image-20210315203625063"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315203651895.png" alt="image-20210315203651895"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315203834812.png" alt="image-20210315203834812"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315204000061.png" alt="image-20210315204000061"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315204112240.png" alt="image-20210315204112240"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315204137458.png" alt="image-20210315204137458"></p>
<p>两任务组合 一个完成</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315204245453.png" alt="image-20210315204245453"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315204252228.png" alt="image-20210315204252228"></p>
<p>多任务组合</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210315210854511.png" alt="image-20210315210854511"></p>
<h1 id="短信验证"><a href="#短信验证" class="headerlink" title="短信验证"></a>短信验证</h1><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318153820543.png" alt="image-20210318153820543"></p>
<p>购买开通服务</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318154220934.png" alt="image-20210318154220934"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318154209250.png" alt="image-20210318154209250"><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318154158785.png" alt="image-20210318154158785"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318154238215.png" alt="image-20210318154238215"></p>
<p>配置文件</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318155247830.png" alt="image-20210318155247830"></p>
<p>添加配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.cloud.alicloud.sms&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String skin;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String sign;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String appCode;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">sendSmsCode</span><span class="params">(String phone, String code)</span></span>&#123;</span><br><span class="line">      String method = <span class="string">&quot;GET&quot;</span>;</span><br><span class="line">      Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">      <span class="comment">//最后在header中的格式(中间是英文空格)为Authorization:APPCODE 83359fd73fe94948385f570e3c139105</span></span><br><span class="line">      headers.put(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;APPCODE &quot;</span> + <span class="keyword">this</span>.appCode);</span><br><span class="line">      Map&lt;String, String&gt; querys = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">      querys.put(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line">      querys.put(<span class="string">&quot;phone&quot;</span>, phone);</span><br><span class="line">      querys.put(<span class="string">&quot;skin&quot;</span>, <span class="keyword">this</span>.skin);</span><br><span class="line">      querys.put(<span class="string">&quot;sign&quot;</span>, <span class="keyword">this</span>.sign);</span><br><span class="line">      HttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         response = HttpUtils.doGet(<span class="keyword">this</span>.host, <span class="keyword">this</span>.path, method, headers, querys);</span><br><span class="line">         <span class="comment">//获取response的body</span></span><br><span class="line">         <span class="keyword">if</span>(response.getStatusLine().getStatusCode() == <span class="number">200</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> EntityUtils.toString(response.getEntity());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;fail_&quot;</span> + response.getStatusLine().getStatusCode();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/sms&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSendController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> SmsComponent smsComponent;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 提供给别的服务进行调用的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/sendcode&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> R <span class="title">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone, <span class="meta">@RequestParam(&quot;code&quot;)</span> String code)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!<span class="string">&quot;fail&quot;</span>.equals(smsComponent.sendSmsCode(phone, code).split(<span class="string">&quot;_&quot;</span>)[<span class="number">0</span>]))&#123;</span><br><span class="line">         <span class="keyword">return</span> R.ok();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> R.error(BizCodeEnum.SMS_SEND_CODE_EXCEPTION.getCode(), BizCodeEnum.SMS_SEND_CODE_EXCEPTION.getMsg());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>md5加盐加密</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318165754894.png" alt="image-20210318165754894"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318181950449.png" alt="image-20210318181950449"></p>
<p>每次验证密码的时候 对输入的密码进行加密 再加盐 与数据库中的密码进行比较</p>
<p>加密工具类：这种方式不用在数据库中存放盐值</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318182206735.png" alt="image-20210318182206735"></p>
<h1 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h1><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210318204701452.png" alt="image-20210318204701452"></p>
<p><strong>微博登录</strong></p>
<p>首先创建一个微连接</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210322190331191.png" alt="image-20210322190331191"></p>
<p>根据文档进行操作：<a href="https://open.weibo.com/wiki/%E6%8E%88%E6%9D%83%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E">https://open.weibo.com/wiki/%E6%8E%88%E6%9D%83%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E</a></p>
<p>获取到token之后 可以根据接口进行一些操作</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210322190950142.png" alt="image-20210322190950142"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210322191945969.png" alt="image-20210322191945969"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210322202853884.png" alt="image-20210322202853884"></p>
<ul>
<li>不能跨域名就行共享</li>
<li>同一个服务 复制多份 session不同步的问题</li>
</ul>
<p><strong>session共享问题解决</strong></p>
<p>方案一</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210322203932791.png" alt="image-20210322203932791"></p>
<p>方案二</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210322204057403.png" alt="image-20210322204057403"></p>
<p>方案三</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210322204146229.png" alt="image-20210322204146229"></p>
<p>方案四</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210322204312176.png" alt="image-20210322204312176"></p>
<p><strong>SpringSession</strong></p>
<p>导入依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.8.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>配置</p>
<ul>
<li><p>spring-session-store-type=redis</p>
</li>
<li><p>server.serlvet.session.timeout=30m #30分钟</p>
</li>
</ul>
<p>在启动类添加注解：@EnableRedisHttpSession</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//页面之间共享用户信息 session会存到redis中</span></span><br><span class="line">httpSession.set<span class="constructor">Attribute(AuthServerConstant.LOGIN_USER, <span class="params">rsepVo</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>在product服务中也引入springsession 在首页就可以取出session中的数据</p>
<p>问题：</p>
<ul>
<li>默认使用java的序列化机制 需要实现Serializable 接口，推荐使用JSON的方式序列化到redis</li>
<li>默认发的当前域的session (需要解决子域session共享问题)</li>
</ul>
<p>自定义session</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MallSessionConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> CookieSerializer <span class="title">cookieSerializer</span><span class="params">()</span></span>&#123;</span><br><span class="line">      DefaultCookieSerializer cookieSerializer = <span class="keyword">new</span> DefaultCookieSerializer();</span><br><span class="line">      <span class="comment">// 明确的指定Cookie的作用域</span></span><br><span class="line">      cookieSerializer.setDomainName(<span class="string">&quot;mall.com&quot;</span>);<span class="comment">//auth.mall.com的父域 *.mall.com可以访问到</span></span><br><span class="line">      cookieSerializer.setCookieName(<span class="string">&quot;FIRESESSION&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> cookieSerializer;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 自定义序列化机制</span></span><br><span class="line"><span class="comment">    * 这里方法名必须是：springSessionDefaultRedisSerializer</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RedisSerializer&lt;Object&gt; <span class="title">springSessionDefaultRedisSerializer</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> GenericJackson2JsonRedisSerializer();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单点登录</strong></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210323193007455.png" alt="image-20210323193007455"></p>
<p>不能使用session解决单点登录问题 比如在auth.gulimall.com登录之后 session的作用域只能放大到gulimall.com 其他的域名下的服务不能得到这个session    </p>
<h1 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h1><p>离线购物车和在线购物车 </p>
<p>购物车的内容存在redis中 使用redis持久化存储</p>
<p>当离线使用购物车的时候 在cookie中存储一个user-key标识身份  每次添加购物车的时候通过一个拦截器(拦截器在controller之前执行)如果没有的话创建一个user-key</p>
<p>把用户信息放在threadLocal中 ThreadLocal本质是一个Map&lt;Thread,Object&gt; </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MallWebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">   <span class="comment">//添加拦截器</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">      registry.addInterceptor(<span class="keyword">new</span> CartInterceptor()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;UserInfoTo&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">      UserInfoTo userInfoTo = <span class="keyword">new</span> UserInfoTo();</span><br><span class="line">      HttpSession session = request.getSession();</span><br><span class="line">      MemberRsepVo user = (MemberRsepVo) session.getAttribute(AuthServerConstant.LOGIN_USER);</span><br><span class="line">      <span class="keyword">if</span> (user != <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="comment">// 用户登陆了</span></span><br><span class="line">         userInfoTo.setUsername(user.getUsername());</span><br><span class="line">         userInfoTo.setUserId(user.getId());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//从cookie中获取user-key</span></span><br><span class="line">      Cookie[] cookies = request.getCookies();</span><br><span class="line">      <span class="keyword">if</span>(cookies != <span class="keyword">null</span> &amp;&amp; cookies.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            String name = cookie.getName();</span><br><span class="line">            <span class="keyword">if</span>(name.equals(CartConstant.TEMP_USER_COOKIE_NAME))&#123;</span><br><span class="line">               userInfoTo.setUserKey(cookie.getValue());</span><br><span class="line">               userInfoTo.setTempUser(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果没有临时用户 则分配一个临时用户</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isEmpty(userInfoTo.getUserKey()))&#123;</span><br><span class="line">         String uuid = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">         userInfoTo.setUserKey(<span class="string">&quot;FIRE-&quot;</span> + uuid);</span><br><span class="line">      &#125;</span><br><span class="line">      threadLocal.set(userInfoTo);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 执行完毕之后分配临时用户让浏览器保存</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">      UserInfoTo userInfoTo = threadLocal.get();</span><br><span class="line">      <span class="keyword">if</span>(!userInfoTo.isTempUser())&#123;</span><br><span class="line">         Cookie cookie = <span class="keyword">new</span> Cookie(CartConstant.TEMP_USER_COOKIE_NAME, userInfoTo.getUserKey());</span><br><span class="line">         <span class="comment">// 设置这个cookie作用域 过期时间</span></span><br><span class="line">         cookie.setDomain(<span class="string">&quot;mall.com&quot;</span>);</span><br><span class="line">         cookie.setMaxAge(CartConstant.TEMP_USER_COOKIE_TIME_OUT);</span><br><span class="line">         response.addCookie(cookie);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.52</span><span class="number">.131</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">      <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">admin</span></span><br></pre></td></tr></table></figure>

<p>在启动类上加入注解@EnableRabbit</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AmqpAdmin amqpAdmin;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DirectExchange directExchange = <span class="keyword">new</span> DirectExchange(<span class="string">&quot;mall-exchange&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br><span class="line">    amqpAdmin.declareExchange(directExchange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Queue queue = <span class="keyword">new</span> Queue(<span class="string">&quot;mall-queue&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>);</span><br><span class="line">    amqpAdmin.declareQueue(queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Binding binding = <span class="keyword">new</span> Binding(<span class="string">&quot;mall-queue&quot;</span>,Binding.DestinationType.QUEUE,<span class="string">&quot;mall-exchange&quot;</span>,<span class="string">&quot;mall.*&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">    amqpAdmin.declareBinding(binding);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果想把传入的内容转换为json格式 需要创建配置类MyRabbitConfig进行注入Jackson2JsonMessageConverter</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;mall-exchange&quot;</span>,<span class="string">&quot;mall.order&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@RabbitListener监听队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(value = &quot;spring.test.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(</span></span><br><span class="line"><span class="meta">                    value = &quot;spring.test.exchange&quot;,</span></span><br><span class="line"><span class="meta">                    ignoreDeclarationExceptions = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">                    type = ExchangeTypes.TOPIC</span></span><br><span class="line"><span class="meta">            ),</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;#.#&quot;&#125;))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>多个服务监听 同一个消息只能有一个客户端收到</li>
<li>只有一个消息处理完 方法运行结束 才可以接受下一条消息</li>
</ul>
<p>@RabbitListener可以用在方法和类上 </p>
<p>@RabbitHandler只能用在方法上 根据不同的方法 对消息进行不同的处理</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210327233040000.png" alt="image-20210327233040000"></p>
<p>进行重载处理 不同的handler处理不同内容的消息 如果是OrderEntity格式的消息就进入2方法 否则进入1方法</p>
<h2 id="可靠投递"><a href="#可靠投递" class="headerlink" title="可靠投递"></a><strong>可靠投递</strong></h2><p>如果使用事务 会使吞吐量下降250倍 所以要使用可靠抵达</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329145159509.png" alt="image-20210329145159509"></p>
<p><strong>ConfirmCallBach</strong></p>
<p>spring.rabbitmq.publisher-confirms=true #开启发送端确认</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initRabbitTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//当收到消息的时候 执行这个回调</span></span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> correlationData 消息的唯一关联数据</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> ack 消息是否成功收到</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> cause 失败原因</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">            System.out.println(cause + ack + correlationData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>returnCallBack</strong>:未投递到queue退回模式</p>
<p>spring.rabbitmq.publisher-returns=true #开启发送端消息抵达队列的确认</p>
<p>spring.rabbit.template.mandatory=true #只要抵达队列，以异步发送的方式优先回调returnCallback</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initRabbitTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//当收到消息的时候 执行这个回调</span></span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> correlationData 消息的唯一关联数据</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> ack 消息是否成功收到</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> cause 失败原因</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">            System.out.println(cause + ack + correlationData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息没有投递到指定队列 执行这个失败回调</span></span><br><span class="line">    rabbitTemplate.setReturnCallback(<span class="keyword">new</span> RabbitTemplate.ReturnCallback() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> message 投递失败的消息详细信息</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> replyCode 回复的状态码</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> replyText 回复的文本内容</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> exchange 当时整个消息发送给了哪个交换机</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> routingKey 当时这个消息用哪个路由键</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费端确认：如果是自动确认 当宕机的时候 没有确认的消息会丢失 所以要采用 手动确认</p>
<p>spirng.rabbitmq.listener.simple.acknowledge-mode = manual </p>
<p>使用Channel的basicAck方法进行手动确认 使用basicNack和basicReject进行拒绝</p>
<h1 id="订单服务"><a href="#订单服务" class="headerlink" title="订单服务"></a>订单服务</h1><p><strong>远程调用丢失请求头的问题</strong></p>
<p>feign远程调用丢失请求头的问题：用户信息存储在cookie中 当order服务进行远程调用的时候 feign会重新构建一个Request 但是这个请求没有任何请求头 。 </p>
<p>解决方法：使用拦截器进行增强</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;requestInterceptor&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestInterceptor <span class="title">requestInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// Feign在远程调用之前都会先经过这个方法</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> RequestInterceptor() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// RequestContextHolder拿到刚进来这个请求:当一开始收到请求时就把request放在其中</span></span><br><span class="line">         ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">         <span class="keyword">if</span>(attributes != <span class="keyword">null</span>)&#123;</span><br><span class="line">            HttpServletRequest request = attributes.getRequest();</span><br><span class="line">            <span class="keyword">if</span>(request != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">// 同步请求头数据</span></span><br><span class="line">               String cookie = request.getHeader(<span class="string">&quot;Cookie&quot;</span>);</span><br><span class="line">               <span class="comment">// 给新请求同步Cookie</span></span><br><span class="line">               template.header(<span class="string">&quot;Cookie&quot;</span>, cookie);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>异步调用丢失请求头的问题</strong></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329184323469.png" alt="image-20210329184323469"></p>
<p>request再72线程上 当101 和 102 获取不到request</p>
<p>解决方法：</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329184440551.png" alt="image-20210329184440551"></p>
<p><strong>接口幂等性</strong></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329192433223.png" alt="image-20210329192433223"></p>
<p>解决方案</p>
<p><strong>锁机制</strong></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329193508214.png" alt="image-20210329193508214"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329193618788.png" alt="image-20210329193618788"></p>
<p><strong>唯一约束</strong></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329193645549.png" alt="image-20210329193645549"></p>
<p><strong>防重表</strong></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329193953028.png" alt="image-20210329193953028"></p>
<p><strong>全局请求唯一id</strong></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329194038739.png" alt="image-20210329194038739"></p>
<p><strong>token机制</strong></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210329194534250.png" alt="image-20210329194534250"></p>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330200638297.png" alt="image-20210330200638297"></p>
<p>传播行为</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330201230382.png" alt="image-20210330201230382"></p>
<p>a和b会回滚 因为用的是一个事务 c不会回滚 他是单独的一个事务    并且b事务 会继承a事务的特性 超时时间为30s 自己设置也不会覆盖</p>
<p><strong>事务失效问题</strong></p>
<p><a href="https://blog.csdn.net/zsycode/article/details/109630940">https://blog.csdn.net/zsycode/article/details/109630940</a></p>
<p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@<span class="constructor">EnableAspectJAutoProxy(<span class="params">exposeProxy</span> = <span class="params">true</span>)</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330213827403.png" alt="image-20210330213827403"></p>
<p><strong>几种分布式事务</strong></p>
<p>2pc</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330231420073.png" alt="image-20210330231420073"></p>
<p>柔性事务 TCC事务补偿方案</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330231521134.png" alt="image-20210330231521134"></p>
<p>柔性事务 最大努力通知型方案</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330231730835.png" alt="image-20210330231730835"></p>
<p>柔性事务：可靠消息+最终一致性方案</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330232008685.png" alt="image-20210330232008685"></p>
<p>Seata</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330232234617.png" alt="image-20210330232234617"></p>
<p>seata术语</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330232341751.png" alt="image-20210330232341751"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210330232428409.png" alt="image-20210330232428409"></p>
<p>如果Account失败了 就通知TC TC通知Order和Storage也回滚</p>
<p><strong>seata实战</strong></p>
<p>每一个微服务中创建一个undo表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;undo_log&#96; (</span><br><span class="line">  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;branch_id&#96; bigint(20) NOT NULL,</span><br><span class="line">  &#96;xid&#96; varchar(100) NOT NULL,</span><br><span class="line">  &#96;context&#96; varchar(128) NOT NULL,</span><br><span class="line">  &#96;rollback_info&#96; longblob NOT NULL,</span><br><span class="line">  &#96;log_status&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;log_created&#96; datetime NOT NULL,</span><br><span class="line">  &#96;log_modified&#96; datetime NOT NULL,</span><br><span class="line">  &#96;ext&#96; varchar(100) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;ux_undo_log&#96; (&#96;xid&#96;,&#96;branch_id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>

<p>安装seata的TC：<a href="https://blog.csdn.net/weixin_43835659/article/details/103920319">https://blog.csdn.net/weixin_43835659/article/details/103920319</a></p>
<ul>
<li>在该项目中只修改了nacos地址 没有做db相关的修改</li>
</ul>
<p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-starter-alibaba-seata --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>开启全局事务</p>
<p>@GlobalTransactional</p>
<p>所有想要用到分布式服务的微服务使用sesata 都要用DataSourceProxy代理自己的数据源</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210331232657313.png" alt="image-20210331232657313"></p>
<p>项目中采用的是 可靠消息+最终一致性方案</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210331234809440.png" alt="image-20210331234809440"></p>
<p>定时任务的时效性问题</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210331235025742.png" alt="image-20210331235025742"></p>
<p>延时队列场景</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210331234839434.png" alt="image-20210331234839434"></p>
<p>消息的TTL</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210331235356724.png" alt="image-20210331235356724"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210331235616030.png" alt="image-20210331235616030"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401001119884.png" alt="image-20210401001119884"></p>
<p>升级版：省去了一个exchange</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401001331160.png" alt="image-20210401001331160"></p>
<p>订单消息过了30min 被死信路由传送到死信队列中 处理死信队列中的消息 如果订单被取消或者不存在 就自动关单 锁库存</p>
<p>延时队列实现1(推荐)</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401000259018.png" alt="image-20210401000259018"></p>
<p>延时队列实现2</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401000344064.png" alt="image-20210401000344064"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401222103061.png" alt="image-20210401222103061"></p>
<p>如果网络延时 库存解锁的时候看订单为新建状态就不解锁了 当订单响应过来 状态改变的时候 库存不会被释放 所以当订单服务被释放的时候就发送消息 告诉交换机 交换机通知库存服务解锁</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401223019011.png" alt="image-20210401223019011"></p>
<p><strong>消息丢失</strong></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401230137822.png" alt="image-20210401230137822"></p>
<ul>
<li>建立一张关于消息日志的表 每次发送消息 利用回调函数(setConfirmCallback) 都在表中记录 定期扫描数据库 将失败的消息再发送一遍 //待完善<ul>
<li><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401232340983.png" alt="image-20210401232340983"></li>
</ul>
</li>
</ul>
<p><strong>重复消费</strong></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401231554346.png" alt="image-20210401231554346"></p>
<p><strong>消息挤压</strong></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210401231859860.png" alt="image-20210401231859860"></p>
<h1 id="支付宝"><a href="#支付宝" class="headerlink" title="支付宝"></a>支付宝</h1><p>异步通知</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210402233947791.png" alt="image-20210402233947791"></p>
<p>收单</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210403190829087.png" alt="image-20210403190829087"></p>
<p>传入参数timeout_express自动收单</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210403191143687.png" alt="image-20210403191143687"></p>
<p>手动收单</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210403191539698.png" alt="image-20210403191539698"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210403191527587.png" alt="image-20210403191527587"></p>
<h1 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h1><p>秒杀商品上架流程</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406182508787.png" alt="image-20210406182508787"></p>
<p>在线cron表达式生成器：<a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSchedule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在Spring中 只允许6位 [* * * ? * 1] : 每周一每秒执行一次</span></span><br><span class="line"><span class="comment">    *                    [* /5 * * ? * 1] : 每周一 每5秒执行一次</span></span><br><span class="line"><span class="comment">    *     1.定时任务不应阻塞 [默认是阻塞的]</span></span><br><span class="line"><span class="comment">    *     2.定时任务线程池 spring.task.scheduling.pool.size=5</span></span><br><span class="line"><span class="comment">    *     3.让定时任务异步执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Async</span></span><br><span class="line">   <span class="meta">@Scheduled(cron = &quot;*/5 * * ? * 1&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;i love you...&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同一个商品可能上架很多次 所以要加分布式锁保证幂等性 避免重复上架</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406161847358.png" alt="image-20210406161847358"></p>
<p>秒杀流程 </p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406182522103.png" alt="image-20210406182522103"></p>
<h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><p>集限流 熔断 降级为一身的微服务组件</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406191721581.png" alt="image-20210406191721581"></p>
<ul>
<li>线程池隔离 会为每个请求创建一个线程池 如果请求很多 线程池也会很多 占用大量资源 </li>
</ul>
<p><strong>整合springboot</strong></p>
<p>导入依赖 ，下载dashboard(dashboard启动 nohup java -jar sentinel-dashboard-1.7.0.jar –server.port=8333 )</p>
<p>配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">cloud:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">   <span class="attr">transport:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line">    <span class="attr">dashboard:</span> <span class="string">$&#123;ipaddr&#125;:8333</span></span><br></pre></td></tr></table></figure>



<p>这里的 spring.cloud .sentinel.transport.port端口配置会在应用对应的机器上启动一个Http Server,该Server会与Sentinel控制台做交互</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406201357783.png" alt="image-20210406201357783"></p>
<p><strong>流量控制</strong></p>
<p>自定义流控响应</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKillSentinelConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SecKillSentinelConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//被限制之后返回自定义的R对象 而不是默认的一句话</span></span><br><span class="line">      WebCallbackManager.setUrlBlockHandler((request, response, exception) -&gt; &#123;</span><br><span class="line">         R error = R.error(BizCodeEnum.TO_MANY_REQUEST.getCode(), BizCodeEnum.TO_MANY_REQUEST.getMsg());</span><br><span class="line">         response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">         response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">         response.getWriter().write(JSON.toJSONString(error));</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>熔断降级</strong></p>
<p>熔断：</p>
<p>调用方开启配置<code>feign.sentinel.enabled=true</code></p>
<p>熔断方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKillFeignServiceFalback</span> <span class="keyword">implements</span> <span class="title">SeckillFeignService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> R <span class="title">getSkuSeckillInfo</span><span class="params">(Long skuId)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;触发熔断&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> R.error(BizCodeEnum.TO_MANY_REQUEST.getCode(), BizCodeEnum.TO_MANY_REQUEST.getMsg());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用方指定默认回调方法 当访问远程服务的时候 进行降级处理</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406203417097.png" alt="image-20210406203417097"></p>
<p>降级：当有超大流量的时候 需要牺牲一部分不重要的远程服务 可以在远程服务设置熔断降级 返回的是默认的降级数据</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406204842517.png" alt="image-20210406204842517"></p>
<p>返回这个json数据</p>
<p><strong>自定义受保护的资源</strong></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406214238941.png" alt="image-20210406214238941"></p>
<p>把要被保护的代码放在try中 并且在catch中调用entry.close()进行关闭</p>
<p>利用这个资源名可以在dashboard中进行流控等操作</p>
<p><strong>网关流控</strong></p>
<p>服务转发到网关的时候sentinel就进行处理</p>
<p>在网关微服务中导入依赖:spring-icloud-alibaba-sentinel-gateway</p>
<p>在dashboard中进行设置</p>
<h1 id="Sleuth-Zipkin服务链路追踪"><a href="#Sleuth-Zipkin服务链路追踪" class="headerlink" title="Sleuth+Zipkin服务链路追踪"></a>Sleuth+Zipkin服务链路追踪</h1><p>基本术语</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406225319096.png" alt="image-20210406225319096"></p>
<p><strong>整合sleuth</strong></p>
<p>导入依赖：spring-cloud-starter-sleuth</p>
<p><strong>整合Zipkin可视化观察</strong></p>
<p>在docker中安装：docker run -d -p 9411:9411 openzipkin/zipkin</p>
<p>导入依赖：spring-cloud-starter-zipkin</p>
<p>在每个服务中进行配置</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406230319341.png" alt="image-20210406230319341"></p>
<p>zipkin数据持久化：默认存储在内存中 重启会丢失，存储在es中</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406230749235.png" alt="image-20210406230749235"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>nacos作为注册中心和配置中心</p>
<p>open-feign进行远程服务调用</p>
<p>getway作为网关</p>
<p>前端为vue</p>
<p>商品服务</p>
<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><h2 id="Product"><a href="#Product" class="headerlink" title="Product"></a>Product</h2><p>获取分类及其子分类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/list/tree&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;CategoryEntityDTO&gt; entityDTOS = categoryService.listWithTree();</span><br><span class="line">    <span class="keyword">return</span> R.ok().put(<span class="string">&quot;data&quot;</span>, entityDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Oss对象存储</p>
<p>后端引用ingJSR-303进行数据校验：<a href="https://blog.csdn.net/weixin_44440642/article/details/106335653">https://blog.csdn.net/weixin_44440642/article/details/106335653</a></p>
<p>spu和sku</p>
<ul>
<li>SPU是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，属性值、特性相同的商品就可以称为一个SPU。</li>
<li>SKU是物理上不可分割的最小存货单元。在使用时要根据不同业态，不同管理模式来处理。在服装、鞋类商品中使用最多最普遍。</li>
</ul>
<p>根据三级分类id获取</p>
<p>检索功能：创建一个查询参数类 把要进行筛选的参数封装 通过es的高级客户端操作查询并对结果进行解析 创建一个返回结果类 把查询结果进行封装</p>
<h2 id="购物车-1"><a href="#购物车-1" class="headerlink" title="购物车"></a>购物车</h2><p>当没登陆的时候 会在cookie中用一个字段(uesr-key)标识用户身份 一段时间后过期 如果第一次访问就创建cookie</p>
<p>添加购物车之前先利用Interceptor判断用户状态 并把用户信息存入ThreadLocal中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MallWebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">   <span class="comment">//添加拦截器</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">      registry.addInterceptor(<span class="keyword">new</span> CartInterceptor()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210522145706554.png" alt="image-20210522145706554"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210522145715269.png" alt="image-20210522145715269"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210522145505872.png" alt="image-20210522145505872"></p>
<p>用户登陆就设置userId没登陆就设置userKey 登陆的话也要设置UserKey用于获取离线购物车的数据</p>
<h2 id="锁定库存"><a href="#锁定库存" class="headerlink" title="锁定库存"></a>锁定库存</h2><p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210522161248264.png" alt="image-20210522161248264"></p>
<p>先查询该商品都在哪个仓库中</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210522161416774.png" alt="image-20210522161416774"></p>
<p>锁库存就是更新表 增加stock_locked 直到stock的数量 如果库存中的数量不足 锁库存失败会回滚</p>
<p>锁库村失败也不会生成订单  要靠分布式事务完成</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210522163022041.png" alt="image-20210522163022041"></p>
<p>Trancation本地事务的缺点：如果方法中调用了远程服务 改事务控制不了远程服务的回滚 如果出现问题 该事务回滚 但远程服务仍执行成功 会出现不一致的情况</p>
<p><strong>延时队列</strong>：</p>
<p>为消息队列设置存活时间 超过一定时间之后通过死信路由发送到死信队列 进行处理 </p>
<p>也可以给消息设置ttl 但是是惰性检查 当有一个一分钟过期(后面)和一个五分钟过期的时间(前面)如果检查到第一个消息没过期 就过一段时间在来检查</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210522171059681.png" alt="image-20210522171059681"></p>
<p>改进版</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210522171410267.png" alt="image-20210522171410267"></p>
<p>流程：下订单 如果锁库存失败则回滚 成功则发送消息到延时队列 消息内容为 订单id和哪个商品id在哪个库存锁了几件等等</p>
<p>未付款的订单如果主动取消直接发送给死信队列 如果超过一定时间自动取消也发送到死信队列 进行以下处理。</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210522173716626.png" alt="image-20210522173716626"></p>
<p>如果订单被成功支付 则需要主动发送消息到死信队列 通过库存解锁服务 进行解锁 防止以下情况发生：当订单创建后因为网络等原因延迟创建 则库存解锁服务处理消息队列中的消息时 发现改订单是创建状态就不进行库存解锁 之后订单解锁的时候直接解锁而响应库存没有解锁 所以需要订单解锁时再次发送消息到消息队列进行库存解锁</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210522181225299.png" alt="image-20210522181225299"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210522174030183.png" alt="image-20210522174030183"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210522174051513.png" alt="image-20210522174051513"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210522170048966.png" alt="image-20210522170048966"></p>
<h2 id="秒杀-1"><a href="#秒杀-1" class="headerlink" title="秒杀"></a>秒杀</h2><p>秒杀是高并发的服务所以要放在一个单独的服务中</p>
<h3 id="秒杀商品上架"><a href="#秒杀商品上架" class="headerlink" title="秒杀商品上架"></a>秒杀商品上架</h3><p>使用springboot中的scheduled功能 定时上架秒杀商品。</p>
<p>使用redis加分布式锁 解决定时任务在分布式环境下的问题 也可以使用分布式任务调度XXL-JOB</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210523111757038.png" alt="image-20210523111757038"></p>
<p>把秒杀活动信息和相关的商品信息缓存在redis中</p>
<p>流程</p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210406182508787.png" alt="image-20210406182508787"></p>
<p><img src="/2021/02/15/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/log\source_posts\谷粒商城\image-20210523113107262-1621740667756.png" alt="image-20210523113107262"></p>
<h3 id="秒杀-2"><a href="#秒杀-2" class="headerlink" title="秒杀"></a>秒杀</h3><p><img src="file://D:\log\source_posts%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E\image-20210406182522103.png?lastModify=1621748458" alt="image-20210406182522103"></p>
<p>订单服务拿到mq中的消息进行创建订单</p>
]]></content>
  </entry>
  <entry>
    <title>rabbitmq</title>
    <url>/2021/03/13/rabbitmq/</url>
    <content><![CDATA[<h1 id="五种消息模型"><a href="#五种消息模型" class="headerlink" title="五种消息模型"></a>五种消息模型</h1><p>RabbitMQ提供了6种消息模型，但是第6种其实是RPC，并不是MQ，因此不予学习。那么也就剩下5种。</p>
<p>但是其实3、4、5这三种都属于订阅模型，只不过进行路由的方式不同。</p>
<p><img src="/2021/03/13/rabbitmq/1527068544487.png" alt="1527068544487"></p>
<p>我们通过一个demo工程来了解下RabbitMQ的工作方式：</p>
<p>导入工程：itcast-rabbitmq</p>
<p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们抽取一个建立RabbitMQ连接的工具类，方便其他程序获取连接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立与RabbitMQ的连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//定义连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置服务地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.56.101&quot;</span>);</span><br><span class="line">        <span class="comment">//端口</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//设置账号信息，用户名、密码、vhost</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/leyou&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;leyou&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;leyou&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过工程获取连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本消息模型"><a href="#基本消息模型" class="headerlink" title="基本消息模型"></a>基本消息模型</h2><p>RabbitMQ是一个消息代理：它接受和转发消息。 你可以把它想象成一个邮局：当你把邮件放在邮箱里时，你可以确定邮差先生最终会把邮件发送给你的收件人。 在这个比喻中，RabbitMQ是邮政信箱，邮局和邮递员。</p>
<p>RabbitMQ与邮局的主要区别是它不处理纸张，而是接受，存储和转发数据消息的二进制数据块。</p>
<p> <img src="/2021/03/13/rabbitmq/1532762975546.png" alt="1532762975546"></p>
<p>P（producer/ publisher）：生产者，一个发送消息的用户应用程序。</p>
<p>C（consumer）：消费者，消费和接收有类似的意思，消费者是一个主要用来等待接收消息的用户应用程序</p>
<p>队列（红色区域）：rabbitmq内部类似于邮箱的一个概念。虽然消息流经rabbitmq和你的应用程序，但是它们只能存储在队列中。队列只受主机的内存和磁盘限制，实质上是一个大的消息缓冲区。许多生产者可以发送消息到一个队列，许多消费者可以尝试从一个队列接收数据。</p>
<p>总之：</p>
<p>生产者将消息发送到队列，消费者从队列中获取消息，队列是存储消息的缓冲区。</p>
<p>我们将用Java编写两个程序;发送单个消息的生产者，以及接收消息并将其打印出来的消费者。我们将详细介绍Java API中的一些细节，这是一个消息传递的“Hello World”。</p>
<p>我们将调用我们的消息发布者（发送者）Send和我们的消息消费者（接收者）Recv。发布者将连接到RabbitMQ，发送一条消息，然后退出。</p>
<h3 id="生产者发送消息"><a href="#生产者发送消息" class="headerlink" title="生产者发送消息"></a>生产者发送消息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;simple_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接以及mq通道</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 从连接中创建通道，这是完成大部分API的地方。</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明（创建）队列，必须声明队列才能够发送消息，我们可以把消息发送到队列中。</span></span><br><span class="line">        <span class="comment">// 声明一个队列是幂等的 - 只有当它不存在时才会被创建</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="管理工具中查看消息"><a href="#管理工具中查看消息" class="headerlink" title="管理工具中查看消息"></a>管理工具中查看消息</h3><p>进入队列页面，可以看到新建了一个队列：simple_queue</p>
<p><img src="/2021/03/13/rabbitmq/1532763817830.png" alt="1532763817830"></p>
<p>点击队列名称，进入详情页，可以查看消息：</p>
<p><img src="/2021/03/13/rabbitmq/1532763489858.png" alt="1532763489858"></p>
<p>在控制台查看消息并不会将消息消费，所以消息还在。</p>
<h3 id="消费者获取消息"><a href="#消费者获取消息" class="headerlink" title="消费者获取消息"></a>消费者获取消息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;simple_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [x] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，第二个参数：是否自动进行消息确认。</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，消费者已经获取了消息，但是程序没有停止，一直在监听队列中是否有新的消息。一旦有新的消息进入队列，就会立即打印.</p>
<h3 id="消息确认机制（ACK）"><a href="#消息确认机制（ACK）" class="headerlink" title="消息确认机制（ACK）"></a>消息确认机制（ACK）</h3><p>通过刚才的案例可以看出，消息一旦被消费者接收，队列中的消息就会被删除。</p>
<p>那么问题来了：RabbitMQ怎么知道消息被接收了呢？</p>
<p>如果消费者领取消息后，还没执行操作就挂掉了呢？或者抛出了异常？消息消费失败，但是RabbitMQ无从得知，这样消息就丢失了！</p>
<p>因此，RabbitMQ有一个ACK机制。当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。不过这种回执ACK分两种情况：</p>
<ul>
<li>自动ACK：消息一旦被接收，消费者自动发送ACK</li>
<li>手动ACK：消息接收后，不会发送ACK，需要手动调用</li>
</ul>
<p>大家觉得哪种更好呢？</p>
<p>这需要看消息的重要性：</p>
<ul>
<li>如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便</li>
<li>如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。如果此时消费者宕机，那么消息就丢失了。</li>
</ul>
<p>我们之前的测试都是自动ACK的，如果要手动ACK，需要改动我们的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;simple_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [x] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">                <span class="comment">// 手动进行ACK</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，第二个参数false，手动进行ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到最后一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br></pre></td></tr></table></figure>

<p>如果第二个参数为true，则会自动进行ACK；如果为false，则需要手动ACK。方法的声明：</p>
<p><img src="/2021/03/13/rabbitmq/1532764253019.png" alt="1532764253019"></p>
<h4 id="自动ACK存在的问题"><a href="#自动ACK存在的问题" class="headerlink" title="自动ACK存在的问题"></a>自动ACK存在的问题</h4><p>修改消费者，添加异常，如下：</p>
<p><img src="/2021/03/13/rabbitmq/1532764600849.png" alt="1532764600849"></p>
<p>生产者不做任何修改，直接运行，消息发送成功：</p>
<p><img src="/2021/03/13/rabbitmq/1532764694290.png" alt="1532764694290"></p>
<p>运行消费者，程序抛出异常。但是消息依然被消费：</p>
<p><img src="/2021/03/13/rabbitmq/1532764717995.png" alt="1532764717995"></p>
<p>管理界面：</p>
<p><img src="/2021/03/13/rabbitmq/1532764734232.png" alt="1532764734232"></p>
<h4 id="演示手动ACK"><a href="#演示手动ACK" class="headerlink" title="演示手动ACK"></a>演示手动ACK</h4><p>修改消费者，把自动改成手动（去掉之前制造的异常）</p>
<p><img src="/2021/03/13/rabbitmq/1532764831241.png" alt="1532764831241"></p>
<p>生产者不变，再次运行：</p>
<p><img src="/2021/03/13/rabbitmq/1532764895239.png" alt="1532764895239"></p>
<p>运行消费者</p>
<p><img src="/2021/03/13/rabbitmq/1532764957092.png" alt="1532764957092"></p>
<p>但是，查看管理界面，发现：</p>
<p><img src="/2021/03/13/rabbitmq/1532765013834.png" alt="1532765013834"></p>
<p>停掉消费者的程序，发现：</p>
<p><img src="/2021/03/13/rabbitmq/1532765038088.png" alt="1532765038088"></p>
<p>这是因为虽然我们设置了手动ACK，但是代码中并没有进行消息确认！所以消息并未被真正消费掉。</p>
<p>当我们关掉这个消费者，消息的状态再次称为Ready</p>
<p>修改代码手动ACK：</p>
<p><img src="/2021/03/13/rabbitmq/1532765123282.png" alt="1532765123282"></p>
<p>执行：</p>
<p><img src="/2021/03/13/rabbitmq/1532765151039.png" alt="1532765151039"></p>
<p>消息消费成功！</p>
<h2 id="work消息模型"><a href="#work消息模型" class="headerlink" title="work消息模型"></a>work消息模型</h2><p>工作队列或者竞争消费者模式</p>
<p> <img src="/2021/03/13/rabbitmq/1532765197277.png" alt="1532765197277"></p>
<p>在第一篇教程中，我们编写了一个程序，从一个命名队列中发送并接受消息。在这里，我们将创建一个工作队列，在多个工作者之间分配耗时任务。</p>
<p>工作队列，又称任务队列。主要思想就是避免执行资源密集型任务时，必须等待它执行完成。相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列。 在后台运行的工作进程将获取任务并最终执行作业。当你运行许多消费者时，任务将在他们之间共享，但是<strong>一个消息只能被一个消费者获取</strong>。</p>
<p>这个概念在Web应用程序中特别有用，因为在短的HTTP请求窗口中无法处理复杂的任务。</p>
<p>接下来我们来模拟这个流程：</p>
<pre><code>P：生产者：任务的发布者

C1：消费者，领取任务并且完成任务，假设完成速度较快

C2：消费者2：领取任务并完成任务，假设完成速度慢</code></pre>
<p>面试题：避免消息堆积？</p>
<p>1）采用workqueue，多个消费者监听同一队列。</p>
<p>2）接收到消息以后，而是通过线程池，异步消费。 </p>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>生产者与案例1中的几乎一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;test_work_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 循环发布任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 消息内容</span></span><br><span class="line">            String message = <span class="string">&quot;task .. &quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过这里我们是循环发送50条消息。</p>
<h3 id="消费者1"><a href="#消费者1" class="headerlink" title="消费者1"></a>消费者1</h3><p><img src="/2021/03/13/rabbitmq/1527085386747.png" alt="1527085386747"></p>
<h3 id="消费者2"><a href="#消费者2" class="headerlink" title="消费者2"></a>消费者2</h3><p><img src="/2021/03/13/rabbitmq/1527085448377.png" alt="1527085448377"></p>
<p>与消费者1基本类似，就是没有设置消费耗时时间。</p>
<p>这里是模拟有些消费者快，有些比较慢。</p>
<p>接下来，两个消费者一同启动，然后发送50条消息：</p>
<p><img src="/2021/03/13/rabbitmq/1527085826462.png" alt="1527085826462"></p>
<p>可以发现，两个消费者各自消费了25条消息，而且各不相同，这就实现了任务的分发。</p>
<h3 id="能者多劳"><a href="#能者多劳" class="headerlink" title="能者多劳"></a>能者多劳</h3><p>刚才的实现有问题吗？</p>
<ul>
<li>消费者1比消费者2的效率要低，一次任务的耗时较长</li>
<li>然而两人最终消费的消息数量是一样的</li>
<li>消费者2大量时间处于空闲状态，消费者1一直忙碌</li>
</ul>
<p>现在的状态属于是把任务平均分配，正确的做法应该是消费越快的人，消费的越多。</p>
<p>怎么实现呢？</p>
<p>我们可以使用basicQos方法和prefetchCount = 1设置。 这告诉RabbitMQ一次不要向工作人员发送多于一条消息。 或者换句话说，不要向工作人员发送新消息，直到它处理并确认了前一个消息。 相反，它会将其分派给不是仍然忙碌的下一个工作人员。</p>
<p><img src="/2021/03/13/rabbitmq/1532765689904.png" alt="1532765689904"></p>
<p>再次测试：</p>
<p><img src="/2021/03/13/rabbitmq/1527086159534.png" alt="1527086159534"></p>
<h2 id="订阅模型分类"><a href="#订阅模型分类" class="headerlink" title="订阅模型分类"></a>订阅模型分类</h2><p>在之前的模式中，我们创建了一个工作队列。 工作队列背后的假设是：每个任务只被传递给一个工作人员。 在这一部分，我们将做一些完全不同的事情 - 我们将会传递一个信息给多个消费者。 这种模式被称为“发布/订阅”。 </p>
<p>订阅模型示意图：</p>
<p> <img src="/2021/03/13/rabbitmq/1527086284940.png" alt="1527086284940"></p>
<p>解读：</p>
<p>1、1个生产者，多个消费者</p>
<p>2、每一个消费者都有自己的一个队列</p>
<p>3、生产者没有将消息直接发送到队列，而是发送到了交换机</p>
<p>4、每个队列都要绑定到交换机</p>
<p>5、生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者获取的目的</p>
<p>X（Exchanges）：交换机一方面：接收生产者发送的消息。另一方面：知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</p>
<p>Exchange类型有以下几种：</p>
<pre><code>Fanout：广播，将消息交给所有绑定到交换机的队列

Direct：定向，把消息交给符合指定routing key 的队列 

Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</code></pre>
<p>我们这里先学习</p>
<pre><code>Fanout：即广播模式</code></pre>
<p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>
<h2 id="订阅模型-Fanout"><a href="#订阅模型-Fanout" class="headerlink" title="订阅模型-Fanout"></a>订阅模型-Fanout</h2><p>Fanout，也称为广播。</p>
<p>流程图：</p>
<p> <img src="/2021/03/13/rabbitmq/1527086564505.png" alt="1527086564505"></p>
<p>在广播模式下，消息发送流程是这样的：</p>
<ul>
<li>1）  可以有多个消费者</li>
<li>2）  每个<strong>消费者有自己的queue</strong>（队列）</li>
<li>3）  每个<strong>队列都要绑定到Exchange</strong>（交换机）</li>
<li>4）  <strong>生产者发送的消息，只能发送到交换机</strong>，交换机来决定要发给哪个队列，生产者无法决定。</li>
<li>5）  交换机把消息发送给绑定过的所有队列</li>
<li>6）  队列的消费者都能拿到消息。实现一条消息被多个消费者消费</li>
</ul>
<h3 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h3><p>两个变化：</p>
<ul>
<li>1）  声明Exchange，不再声明Queue</li>
<li>2）  发送消息到Exchange，不再发送到Queue</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;fanout_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为fanout</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">&quot;Hello everyone&quot;</span>;</span><br><span class="line">        <span class="comment">// 发布消息到Exchange</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [生产者] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者1-1"><a href="#消费者1-1" class="headerlink" title="消费者1"></a>消费者1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;fanout_exchange_queue_1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;fanout_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者1] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动返回完成</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意代码中：<strong>队列需要和交换机绑定</strong></p>
<h3 id="消费者2-1"><a href="#消费者2-1" class="headerlink" title="消费者2"></a>消费者2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;fanout_exchange_queue_2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;fanout_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者2] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，手动返回完成</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们运行两个消费者，然后发送1条消息：</p>
<p><img src="/2021/03/13/rabbitmq/1532766264386.png" alt="1532766264386"></p>
<p><img src="/2021/03/13/rabbitmq/1532766291204.png" alt="1532766291204"></p>
<h2 id="订阅模型-Direct"><a href="#订阅模型-Direct" class="headerlink" title="订阅模型-Direct"></a>订阅模型-Direct</h2><p>有选择性的接收消息</p>
<p>在订阅模式中，生产者发布消息，所有消费者都可以获取所有消息。</p>
<p>在路由模式中，我们将添加一个功能 - 我们将只能订阅一部分消息。 例如，我们只能将重要的错误消息引导到日志文件（以节省磁盘空间），同时仍然能够在控制台上打印所有日志消息。</p>
<p>但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p>
<p>在Direct模型下，队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）</p>
<p>消息的发送方在向Exchange发送消息时，也必须指定消息的routing key。</p>
<p> <img src="/2021/03/13/rabbitmq/1532766437787.png" alt="1532766437787"></p>
<p>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</p>
<p>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</p>
<p>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</p>
<p>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</p>
<h3 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h3><p>此处我们模拟商品的增删改，发送消息的RoutingKey分别是：insert、update、delete</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;direct_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为direct</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">&quot;商品新增了， id = 1001&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息，并且指定routing key 为：insert ,代表新增商品</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;insert&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [商品服务：] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者1-2"><a href="#消费者1-2" class="headerlink" title="消费者1"></a>消费者1</h3><p>我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;direct_exchange_queue_1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;direct_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。假设此处需要update和delete消息</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;update&quot;</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;delete&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者1] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者2-2"><a href="#消费者2-2" class="headerlink" title="消费者2"></a>消费者2</h3><p>我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;direct_exchange_queue_2&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;direct_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;insert&quot;</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;update&quot;</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;delete&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者2] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>我们分别发送增、删、改的RoutingKey，发现结果：</p>
<p> <img src="/2021/03/13/rabbitmq/1527088296131.png" alt="1527088296131"></p>
<h2 id="订阅模型-Topic"><a href="#订阅模型-Topic" class="headerlink" title="订阅模型-Topic"></a>订阅模型-Topic</h2><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p>
<p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p>
<p> 通配符规则：</p>
<pre><code>`#`：匹配一个或多个词

`*`：匹配不多不少恰好1个词</code></pre>
<p>举例：</p>
<pre><code>`audit.#`：能够匹配`audit.irs.corporate` 或者 `audit.irs`

`audit.*`：只能匹配`audit.irs`</code></pre>
<p> <img src="/2021/03/13/rabbitmq/1532766712166.png" alt="1532766712166"></p>
<p>在这个例子中，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：“<speed>.<color>.<species>”。</species></color></speed></p>
<p>我们创建了三个绑定：Q1绑定了绑定键“* .orange.<em>”，Q2绑定了“</em>.*.rabbit”和“lazy.＃”。</p>
<p>Q1匹配所有的橙色动物。</p>
<p>Q2匹配关于兔子以及懒惰动物的消息。</p>
<p>练习，生产者发送如下消息，会进入那个队列：</p>
<p>quick.orange.rabbit     Q1 Q2</p>
<p>lazy.orange.elephant     </p>
<p>quick.orange.fox      </p>
<p>lazy.pink.rabbit      </p>
<p>quick.brown.fox     </p>
<p>quick.orange.male.rabbit </p>
<p>orange </p>
<h3 id="生产者-3"><a href="#生产者-3" class="headerlink" title="生产者"></a>生产者</h3><p>使用topic类型的Exchange，发送消息的routing key有3种： <code>item.isnert</code>、<code>item.update</code>、<code>item.delete</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;topic_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为topic</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">&quot;新增商品 : id = 1001&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息，并且指定routing key 为：insert ,代表新增商品</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;item.insert&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [商品服务：] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者1-3"><a href="#消费者1-3" class="headerlink" title="消费者1"></a>消费者1</h3><p>我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;topic_exchange_queue_1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;topic_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。需要 update、delete</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;item.update&quot;</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;item.delete&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者1] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者2-3"><a href="#消费者2-3" class="headerlink" title="消费者2"></a>消费者2</h3><p>我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;topic_exchange_queue_2&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;topic_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;item.*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者2] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>如何避免消息丢失？</p>
<p>1）  消费者的ACK机制。可以防止消费者丢失消息。</p>
<p>2）  但是，如果在消费者消费之前，MQ就宕机了，消息就没了。</p>
<p>是可以将消息进行持久化呢？</p>
<p>要将消息持久化，前提是：队列、Exchange都持久化</p>
<h3 id="交换机持久化"><a href="#交换机持久化" class="headerlink" title="交换机持久化"></a>交换机持久化</h3><p><img src="/2021/03/13/rabbitmq/1532766951432.png" alt="1532766951432"></p>
<h3 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h3><p><img src="/2021/03/13/rabbitmq/1532766981230.png" alt="1532766981230"></p>
<h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p><img src="/2021/03/13/rabbitmq/1532767057491.png" alt="1532767057491"></p>
<h1 id="Spring-AMQP"><a href="#Spring-AMQP" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring-amqp是对AMQP协议的抽象实现，而spring-rabbit 是对协议的具体实现，也是目前的唯一实现。底层使用的就是RabbitMQ。</p>
<h2 id="依赖和配置"><a href="#依赖和配置" class="headerlink" title="依赖和配置"></a>依赖和配置</h2><p>添加AMQP的启动器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>application.yml</code>中添加RabbitMQ地址：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.101</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">leyou</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">leyou</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/leyou</span></span><br></pre></td></tr></table></figure>

<h2 id="监听者"><a href="#监听者" class="headerlink" title="监听者"></a>监听者</h2><p>在SpringAmqp中，对消息的消费者进行了封装和抽象，一个普通的JavaBean中的普通方法，只要通过简单的注解，就可以成为一个消费者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(value = &quot;spring.test.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(</span></span><br><span class="line"><span class="meta">                    value = &quot;spring.test.exchange&quot;,</span></span><br><span class="line"><span class="meta">                    ignoreDeclarationExceptions = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">                    type = ExchangeTypes.TOPIC</span></span><br><span class="line"><span class="meta">            ),</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;#.#&quot;&#125;))</span></span><br><span class="line">    <span class="comment">//Message:原生消息详细信息：消息头+消息体</span></span><br><span class="line">    <span class="comment">//OrderReturnReasonEntity:消息内容</span></span><br><span class="line">    <span class="comment">//Channel:当前传输数据的通道</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(Message message,OrderReturnReasonEntity content,Channel channel)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@RabbitListener</code>：方法上的注解，声明这个方法是一个消费者方法，需要指定下面的属性：<ul>
<li><code>bindings</code>：指定绑定关系，可以有多个。值是<code>@QueueBinding</code>的数组。<code>@QueueBinding</code>包含下面属性：<ul>
<li><code>value</code>：这个消费者关联的队列。值是<code>@Queue</code>，代表一个队列</li>
<li><code>exchange</code>：队列所绑定的交换机，值是<code>@Exchange</code>类型</li>
<li><code>key</code>：队列和交换机绑定的<code>RoutingKey</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>类似listen这样的方法在一个类中可以写多个，就代表多个消费者。</p>
<h2 id="AmqpTemplate"><a href="#AmqpTemplate" class="headerlink" title="AmqpTemplate"></a>AmqpTemplate</h2><p>Spring最擅长的事情就是封装，把他人的框架进行封装和整合。</p>
<p>Spring为AMQP提供了统一的消息处理模板：AmqpTemplate，非常方便的发送消息，其发送方法：</p>
<p><img src="/2021/03/13/rabbitmq/1527090258083.png" alt="1527090258083"></p>
<p>红框圈起来的是比较常用的3个方法，分别是：</p>
<ul>
<li>指定交换机、RoutingKey和消息体</li>
<li>指定消息</li>
<li>指定RoutingKey和消息，会向默认的交换机发送消息</li>
</ul>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = Application.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSend</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String msg = <span class="string">&quot;hello, Spring boot amqp&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate.convertAndSend(<span class="string">&quot;spring.test.exchange&quot;</span>,<span class="string">&quot;a.b&quot;</span>, msg);</span><br><span class="line">        <span class="comment">// 等待10秒后再结束</span></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后查看日志：</p>
<p><img src="/2021/03/13/rabbitmq/1532767726274.png" alt="1532767726274"></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka</title>
    <url>/2021/03/14/kafka/</url>
    <content><![CDATA[<h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p><img src="/2021/03/14/kafka/image-20210314153956902.png" alt="image-20210314153956902"></p>
<p>3）Consumer Group （CG）：消费者组，由多个 consumer 组成。消费者组内每个消费者负 责消费不同分区的数据，<strong>一个分区只能由一个组内消费者消费</strong>；消费者组之间互不影响。</p>
<p>4）Broker ：一台 kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic。</p>
<p> 5）Topic ：可以理解为一个队列，生产者和消费者面向的都是一个 topic；</p>
<p> 6）Partition：为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上， 一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列；</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>Kafka 中消息是以 topic 进行分类的，生产者生产消息，消费者消费消息，都是面向 topic 的。</p>
<p>topic 是逻辑上的概念，而 partition 是物理上的概念，每个 partition 对应于一个 log文件，该log 文件中存储的就是 producer 生产的数据。</p>
<p>Producer 生产的数据会被不断追加到该 log 文件末端，且每条数据都有自己的 offset。消费者组中的每个消费者，都会实时记录自消费到了哪个 offset，以便出错恢复时，从上次的位置继续消费。</p>
<h2 id="文件存储机制"><a href="#文件存储机制" class="headerlink" title="文件存储机制"></a>文件存储机制</h2><p><img src="/2021/03/14/kafka/image-20210315111943178.png" alt="image-20210315111943178"></p>
<p>由于生产者生产的消息会不断追加到 log 文件末尾，为防止 log 文件过大导致数据定位 效率低下，Kafka 采取了分片和索引机制，将每个 partition 分为多个 segment。每个 segment 对应两个文件——“.index”文件和“.log”文件。这些文件位于一个文件夹下，该文件夹的命名 规则为：topic 名称+分区序号。例如，first 这个 topic 有三个分区，则其对应的文件夹为 first0,first-1,first-2</p>
<p>index 和 log 文件以当前 segment 的第一条消息的 offset 命名。下图为 index 文件和 log 文件的结构示意图。</p>
<p><img src="/2021/03/14/kafka/image-20210315112241317.png" alt="image-20210315112241317"></p>
<p>“.index”文件存储大量的索引信息，“.log”文件存储大量的数据，索引文件中的元 数据指向对应数据文件中 message 的物理偏移地址。</p>
<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><h3 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h3><p>分区原因:负载均衡,提高并发</p>
<p>分区原则:    </p>
<p>（1）指明 partition 的情况下，直接将指明的值直接作为 partiton 值； </p>
<p>（2）没有指明 partition 值但有 key 的情况下，将 key 的 hash 值与 topic 的 partition 数进行取余得到 partition 值； </p>
<p>（3）既没有 partition 值又没有 key 值的情况下，第一次调用时随机生成一个整数（后 面每次调用在这个整数上自增），将这个值与 topic 可用的 partition 总数取余得到 partition 值，也就是常说的 round-robin 算法。</p>
<h3 id="数据可靠性保证"><a href="#数据可靠性保证" class="headerlink" title="数据可靠性保证"></a>数据可靠性保证</h3><p>为保证 producer 发送的数据，能可靠的发送到指定的 topic，topic 的每个 partition 收到 producer 发送的数据后，都需要向 producer 发送 ack（acknowledgement 确认收到），如果 producer 收到 ack，就会进行下一轮的发送，否则重新发送数据。</p>
<p><img src="/2021/03/14/kafka/image-20210315112849500.png"></p>
<h4 id="副本数据同步策略"><a href="#副本数据同步策略" class="headerlink" title="副本数据同步策略"></a>副本数据同步策略</h4><p><img src="/2021/03/14/kafka/image-20210315113323908.png" alt="image-20210315113323908"></p>
<p>Kafka 选择了第二种方案，原因如下：</p>
<ol>
<li>同样为了容忍 n 台节点的故障，第一种方案需要 2n+1 个副本，而第二种方案只需要 n+1 个副本，而 Kafka 的每个分区都有大量的数据，第一种方案会造成大量数据的冗余。</li>
<li>2.虽然第二种方案的网络延迟会比较高，但网络延迟对 Kafka 的影响较小。</li>
</ol>
<h4 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h4><p>采用第二种方案之后，设想以下情景：leader 收到数据，所有 follower 都开始同步数据， 但有一个 follower，因为某种故障，迟迟不能与 leader 进行同步，那 leader 就要一直等下去， 直到它完成同步，才能发送 ack。这个问题怎么解决呢？ </p>
<p>Leader 维护了一个动态的 in-sync replica set (ISR)，意为和 leader 保持同步的 follower 集 合。当 ISR 中的 follower 完成数据的同步之后，leader 就会给 follower 发送 ack。如果 follower 长时间未向leader 同 步 数 据 ， 则 该 follower 将 被 踢 出 ISR</p>
<h4 id="ack应答机制"><a href="#ack应答机制" class="headerlink" title="ack应答机制"></a>ack应答机制</h4><p>对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失， 所以没必要等 ISR 中的 follower 全部接收成功。 所以 Kafka 为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡， 选择以下的配置。</p>
<p>acks 参数配置：</p>
<ul>
<li><p>0：producer 不等待 broker 的 ack，这一操作提供了一个最低的延迟，broker 一接收到还没有写入磁盘就已经返回，当 broker 故障时有可能丢失数据；</p>
</li>
<li><p>1：producer 等待 broker 的 ack，partition 的 leader 落盘成功后返回 ack，如果在 follower 同步成功之前 leader 故障，那么将会丢失数据；</p>
</li>
<li><p>-1（all）：producer 等待 broker 的 ack，partition 的 leader 和 follower 全部落盘成功后才 返回 ack。但是如果在 follower 同步完成后，broker 发送 ack 之前，leader 发生故障，那么会 造成数据重复。</p>
</li>
</ul>
<h4 id="故障处理细节"><a href="#故障处理细节" class="headerlink" title="故障处理细节"></a>故障处理细节</h4><p><img src="/2021/03/14/kafka/image-20210315133821379.png" alt="image-20210315133821379"></p>
<p>（1）follower 故障 follower 发生故障后会被临时踢出 ISR，待该 follower 恢复后，follower 会读取本地磁盘 记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步。 等该 follower 的 LEO 大于等于该 Partition 的 HW，即 follower 追上 leader 之后，就可以重 新加入 ISR 了。</p>
<p>（2）leader 故障 leader 发生故障之后，会从 ISR 中选出一个新的 leader，之后，为保证多个副本之间的数据一致性，其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader 同步数据。</p>
<h4 id="Exactly-Once-语义"><a href="#Exactly-Once-语义" class="headerlink" title="Exactly Once 语义"></a>Exactly Once 语义</h4><p>将服务器的 ACK 级别设置为-1，可以保证 Producer 到 Server 之间不会丢失数据，即 At Least Once 语义。相对的，将服务器 ACK 级别设置为 0，可以保证生产者每条消息只会被 发送一次，即 At Most Once 语义。但是，对于一些非常重要的信息，比如说交易数据，下游数据消费者要求数据既不重复也不丢失，即 Exactly Once 语义</p>
<p>0.11 版本的 Kafka，引入了一项重大特性：幂等性。所谓的幂等性就是指 Producer 不论 向 Server 发送多少次重复数据，Server 端都只会持久化一条。幂等性结合 At Least Once 语 义，就构成了 Kafka 的 Exactly Once 语义。即： At Least Once + 幂等性 = Exactly Once</p>
<p>开启幂等性的 Producer 在 初始化的时候会被分配一个 PID，发往同一 Partition 的消息会附带 Sequence Number。而 Broker 端会对做缓存，当具有相同主键的消息提交时，Broker 只 会持久化一条。</p>
<p>但是 PID 重启就会变化，同时不同的 Partition 也具有不同主键，所以幂等性无法保证跨 分区跨会话的 Exactly Once。</p>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><h3 id="消费方式"><a href="#消费方式" class="headerlink" title="消费方式"></a>消费方式</h3><p>consumer 采用 pull（拉）模式从 broker 中读取数据。 push（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的.pull 模式不足之处是，如果 kafka 没有数据，消费者可能会陷入循环中，一直返回空数据.针对这一点，Kafka 的消费者在消费数据时会传入一个时长参数 timeout，如果当前没有 数据可供消费，consumer 会等待一段时间之后再返回，这段时长即为 timeout。</p>
<h3 id="分区分配策略"><a href="#分区分配策略" class="headerlink" title="分区分配策略"></a>分区分配策略</h3><p>一个 consumer group 中有多个 consumer，一个 topic 有多个 partition，所以必然会涉及 到 partition 的分配问题，即确定那个 partition 由哪个consumer 来消费。Kafka 有两种分配策略RoundRobin和Range。</p>
<p>RoundRobin</p>
<p><img src="/2021/03/14/kafka/image-20210315135548013.png" alt="image-20210315135548013"></p>
<p>Range:如下图，三个消费者均订阅了同一主题，则每个消费者消费到不同的分区；但是<strong>当topic的分区数较大时</strong>，同一个topic的分区，可能在消费者之间<strong>分布得不均衡</strong>。</p>
<p><img src="/2021/03/14/kafka/image-20210315135813065.png" alt="image-20210315135813065"></p>
<h3 id="offset-的维护"><a href="#offset-的维护" class="headerlink" title="offset 的维护"></a>offset 的维护</h3><p>由于 consumer 在消费过程中可能会出现断电宕机等故障，consumer 恢复后，需要从故 障前的位置的继续消费，所以 consumer 需要实时记录自己消费到了哪个 offset，以便故障恢 复后继续消费。</p>
<p>Kafka 0.9 版本之前，consumer 默认将 offset 保存在 Zookeeper 中，从 0.9 版本开始， consumer 默认将 offset 保存在 Kafka 一个内置的 topic 中，该 topic 为__consumer_offsets。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="Producer-事务"><a href="#Producer-事务" class="headerlink" title="Producer 事务"></a>Producer 事务</h3><p>为了实现跨分区跨会话的事务，需要引入一个全局唯一的 Transaction ID，并将 Producer 获得的PID 和Transaction ID 绑定。这样当Producer 重启后就可以通过正在进行的 Transaction ID 获得原来的 PID。</p>
<p>为了管理 Transaction，Kafka 引入了一个新的组件 Transaction Coordinator。Producer 就 是通过和 Transaction Coordinator 交互获得 Transaction ID 对应的任务状态。Transaction Coordinator 还负责将事务所有写入 Kafka 的一个内部 Topic，这样即使整个服务重启，由于 事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。</p>
<h3 id="Consumer事务"><a href="#Consumer事务" class="headerlink" title="Consumer事务"></a>Consumer事务</h3><p>上述事务机制主要是从 Producer 方面考虑，对于 Consumer 而言，事务的保证就会相对 较弱，尤其时无法保证 Commit 的信息被精确消费。这是由于 Consumer 可以通过 offset 访 问任意信息，而且不同的 Segment File 生命周期不同，同一事务的消息可能会出现重启后被 删除的情况。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Producer-API"><a href="#Producer-API" class="headerlink" title="Producer API"></a>Producer API</h3><h4 id="消息发送流程"><a href="#消息发送流程" class="headerlink" title="消息发送流程"></a>消息发送流程</h4><p>Kafka 的 Producer 发送消息采用的是异步发送的方式。在消息发送的过程中，涉及到了 两个线程——main 线程和 Sender 线程，以及一个线程共享变量——RecordAccumulator。 main 线程将消息发送给 RecordAccumulator，Sender 线程不断从 RecordAccumulator 中拉取 消息发送到 Kafka broker。</p>
<p><img src="/2021/03/14/kafka/image-20210315143831877.png" alt="image-20210315143831877"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//kafka 集群，broker-list</span></span><br><span class="line">        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.52.131:9092&quot;</span>);</span><br><span class="line">        <span class="comment">//ack应答级别</span></span><br><span class="line">        props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">        <span class="comment">//重试次数</span></span><br><span class="line">        props.put(<span class="string">&quot;retries&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">//批次大小:一次发送数据的大小</span></span><br><span class="line">        props.put(<span class="string">&quot;batch.size&quot;</span>, <span class="number">16384</span>);</span><br><span class="line">        <span class="comment">//等待时间</span></span><br><span class="line">        props.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//RecordAccumulator 缓冲区大小</span></span><br><span class="line">        props.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">33554432</span>);</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Producer&lt;String, String&gt; myProducer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            myProducer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">&quot;first&quot;</span>,Integer.toString(i), Integer.toString(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不close的话 如果执行时间不到设置的等待时间 或者数据大小不够设置的批次大小 数据会停留在缓存区中不被发送</span></span><br><span class="line">        myProducer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallBackProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;192.168.52.131:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;retries&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        props.put(<span class="string">&quot;batch.size&quot;</span>, <span class="number">16384</span>);</span><br><span class="line">        props.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        props.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">33554432</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span></span><br><span class="line">                KafkaProducer&lt;&gt;(props);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">&quot;first&quot;</span>,</span><br><span class="line">                    Integer.toString(i), Integer.toString(i)), <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">                <span class="comment">//回调函数，该方法会在 Producer 收到 ack 时调用，为异步调用</span></span><br><span class="line">                <span class="comment">//消息发送失败会自动重试</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Exception exception)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (exception == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;success-&gt;&quot;</span> +</span><br><span class="line">                                metadata.offset());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        exception.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h4><p>同步发送的意思就是，一条消息发送之后，会阻塞当前线程，直至返回 ack。 由于 send 方法返回的是一个 Future 对象，根据 Futrue 对象的特点，我们也可以实现同 步发送的效果，只需在调用 Future 对象的 get 方发即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop102:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;retries&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        props.put(<span class="string">&quot;batch.size&quot;</span>, <span class="number">16384</span>);</span><br><span class="line">        props.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        props.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">33554432</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">&quot;first&quot;</span>,</span><br><span class="line">                    Integer.toString(i), Integer.toString(i))).get();</span><br><span class="line">        &#125;</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Consuemr-API"><a href="#Consuemr-API" class="headerlink" title="Consuemr API"></a>Consuemr API</h3><p><strong>自动提交</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;192.168.52.131:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//开启自动提交</span></span><br><span class="line">        props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="comment">//自动提交间隔时间</span></span><br><span class="line">        props.put(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(<span class="string">&quot;first&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;offset = %d, key = %s, value= %s%n&quot;</span>, record.offset(), record.key(), record.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>手动提交</strong></p>
<p>手动提交 offset 的方法有两种：分别是 commitSync（同步提交）和 commitAsync（异步 提交）。两者的相同点是，都会将本次 poll 的一批数据最高的偏移量提交；不同点是， commitSync 阻塞当前线程，一直到提交成功，并且会自动失败重试（由不可控因素导致， 也会出现提交失败）；而 commitAsync 则没有失败重试机制，故有可能提交失败。</p>
<p>同步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;192.168.52.131:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//开启自动提交</span></span><br><span class="line">        props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        <span class="comment">//自动提交间隔时间</span></span><br><span class="line">        props.put(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(<span class="string">&quot;first&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">                    consumer.poll(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s%n&quot;</span>, record.offset(), record.key(), record.value());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//同步提交，当前线程会阻塞直到 offset 提交成功</span></span><br><span class="line">            consumer.commitSync();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;192.168.52.131:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//开启自动提交</span></span><br><span class="line">        props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        <span class="comment">//自动提交间隔时间</span></span><br><span class="line">        props.put(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(<span class="string">&quot;first&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s%n&quot;</span>, record.offset(), record.key(), record.value());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//异步提交</span></span><br><span class="line">            consumer.commitAsync(<span class="keyword">new</span> OffsetCommitCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        System.err.println(<span class="string">&quot;Commit failed for&quot;</span> +</span><br><span class="line">                                offsets);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义-Interceptors"><a href="#自定义-Interceptors" class="headerlink" title="自定义 Interceptors"></a>自定义 Interceptors</h2><p>Producer 拦截器(interceptor)是在 Kafka 0.10 版本被引入的，主要用于实现 clients 端的定 制化控制逻辑。 对于 producer 而言，interceptor 使得用户在消息发送前以及 producer 回调逻辑前有机会 对消息做一些定制化需求，比如修改消息等。同时，producer 允许用户指定多个 interceptor 按序作用于同一条消息从而形成一个拦截链(interceptor chain)。Intercetpor 的实现接口是 org.apache.kafka.clients.producer.ProducerInterceptor，其定义的方法包括：</p>
<ol>
<li>configure(configs):获取配置信息和初始化数据时调用。</li>
<li>onSend(ProducerRecord):该方法封装进 KafkaProducer.send 方法中，即它运行在用户主线程中。Producer 确保在消息被序列化以及计算分区前调用该方法。用户可以在该方法中对消息做任何操作，但最好 保证不要修改消息所属的 topic 和分区，否则会影响目标分区的计算。</li>
<li>onAcknowledgement(RecordMetadata, Exception):该方法会在消息从 RecordAccumulator 成功发送到 Kafka Broker 之后，或者在发送过程 中失败时调用。并且通常都是在 producer 回调逻辑触发之前。onAcknowledgement 运行在 producer 的 IO 线程中，因此不要在该方法中放入很重的逻辑，否则会拖慢 producer 的消息 发送效率。</li>
<li>close:关闭 interceptor，主要用于执行一些资源清理工作</li>
</ol>
<p>实现:实现一个简单的双 interceptor 组成的拦截链。第一个 interceptor 会在消息发送前将时间 戳信息加到消息 value 的最前部；第二个 interceptor 会在消息发送后更新成功发送消息数或 失败发送消息数。</p>
<p>​    </p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ</title>
    <url>/2021/03/14/RocketMQ/</url>
    <content><![CDATA[<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li><p>Producer：消息的发送者；举例：发信者</p>
</li>
<li><p>Consumer：消息接收者；举例：收信者</p>
</li>
<li><p>Broker：暂存和传输消息；举例：邮局</p>
</li>
<li><p>NameServer：管理Broker；举例：各个邮局的管理机构</p>
</li>
<li><p>Topic：区分消息的种类；一个发送者可以发送消息给一个或者多个Topic；一个消息的接收者可以订阅一个或者多个Topic消息；一个topic中可以有多个queue</p>
</li>
<li><p>Message Queue：相当于是Topic的分区；用于并行发送和接收消息；<strong>一个消费者集群多台机器共同消费一个 <code>topic</code> 的多个队列，</strong>一个队列只会被一个消费者消费****</p>
<p><img src="/2021/03/14/RocketMQ/log\source_posts\RocketMQ\image-20210315102610960.png" alt="image-20210315102610960"></p>
</li>
</ul>
<p><img src="/2021/03/14/RocketMQ/log\source_posts\RocketMQ\image-20210315103101346.png" alt="image-20210315103101346"></p>
<h2 id="集群特点"><a href="#集群特点" class="headerlink" title="集群特点"></a>集群特点</h2><ul>
<li><p>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</p>
</li>
<li><p>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。</p>
</li>
<li><p>Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</p>
</li>
<li><p>Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。</p>
</li>
</ul>
<h2 id="Broker集群模式"><a href="#Broker集群模式" class="headerlink" title="Broker集群模式"></a>Broker集群模式</h2><h4 id="1）单Master模式"><a href="#1）单Master模式" class="headerlink" title="1）单Master模式"></a>1）单Master模式</h4><p>这种方式风险较大，一旦Broker重启或者宕机时，会导致整个服务不可用。不建议线上环境使用,可以用于本地测试。</p>
<h4 id="2）多Master模式"><a href="#2）多Master模式" class="headerlink" title="2）多Master模式"></a>2）多Master模式</h4><p>一个集群无Slave，全是Master，例如2个Master或者3个Master，这种模式的优缺点如下：</p>
<ul>
<li>优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；</li>
<li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。</li>
</ul>
<h4 id="3）多Master多Slave模式（异步）"><a href="#3）多Master多Slave模式（异步）" class="headerlink" title="3）多Master多Slave模式（异步）"></a>3）多Master多Slave模式（异步）</h4><p>每个Master配置一个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：</p>
<ul>
<li>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样；</li>
<li>缺点：Master宕机，磁盘损坏情况下会丢失少量消息。</li>
</ul>
<h4 id="4）多Master多Slave模式（同步）"><a href="#4）多Master多Slave模式（同步）" class="headerlink" title="4）多Master多Slave模式（同步）"></a>4）多Master多Slave模式（同步）</h4><p>每个Master配置一个Slave，有多对Master-Slave，HA采用同步双写方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：</p>
<ul>
<li>优点：数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；</li>
<li>缺点：性能比异步复制模式略低（大约低10%左右），发送单个消息的RT会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</li>
</ul>
<h2 id="集群工作流程"><a href="#集群工作流程" class="headerlink" title="集群工作流程"></a>集群工作流程</h2><ol>
<li>启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。</li>
<li>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。</li>
<li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</li>
<li>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。</li>
<li>Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。</li>
</ol>
<h1 id="消息发送案例"><a href="#消息发送案例" class="headerlink" title="消息发送案例"></a>消息发送案例</h1><h2 id="基本样例"><a href="#基本样例" class="headerlink" title="基本样例"></a>基本样例</h2><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><h4 id="1）发送同步消息"><a href="#1）发送同步消息" class="headerlink" title="1）发送同步消息"></a>1）发送同步消息</h4><p>这种可靠性同步地发送方式使用的比较广泛，比如：重要的消息通知，短信通知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建消息生产者producer，并制定生产者组名</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//2.指定Nameserver地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.52.131:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//3.启动producer</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//4.创建消息对象，指定主题Topic、Tag和消息体</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数一：消息主题Topic</span></span><br><span class="line"><span class="comment">             * 参数二：消息Tag</span></span><br><span class="line"><span class="comment">             * 参数三：消息内容</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;springboot-mq&quot;</span>, <span class="string">&quot;Tag1&quot;</span>, (<span class="string">&quot;Hello World&quot;</span> + i).getBytes());</span><br><span class="line">            <span class="comment">//5.发送消息</span></span><br><span class="line">            SendResult result = producer.send(msg);</span><br><span class="line">            <span class="comment">//发送状态</span></span><br><span class="line">            SendStatus status = result.getSendStatus();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;发送结果:&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//线程睡1秒</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭生产者producer</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）发送异步消息"><a href="#2）发送异步消息" class="headerlink" title="2）发送异步消息"></a>2）发送异步消息</h4><p>异步消息通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待Broker的响应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">    	<span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    	<span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            	<span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;TagA&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;OrderID188&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Hello world&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                <span class="comment">// SendCallback接收异步返回结果的回调</span></span><br><span class="line">                producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;%-10d OK %s %n&quot;</span>, index,</span><br><span class="line">                            sendResult.getMsgId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">      	              System.out.printf(<span class="string">&quot;%-10d Exception %s %n&quot;</span>, index, e);</span><br><span class="line">      	              e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">            	&#125;);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    	producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3）单向发送消息"><a href="#3）单向发送消息" class="headerlink" title="3）单向发送消息"></a>3）单向发送消息</h4><p>这种方式主要用在不特别关心发送结果的场景，例如日志发送。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnewayProducer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    	<span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">    	<span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    	<span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        	<span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">        	Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span> ,</span><br><span class="line">                <span class="string">&quot;TagA&quot;</span> ,</span><br><span class="line">                (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET)</span><br><span class="line">        	);</span><br><span class="line">        	<span class="comment">// 发送单向消息，没有任何返回结果</span></span><br><span class="line">        	producer.sendOneway(msg);</span><br><span class="line"></span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    	producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><p>默认是负载均衡模式</p>
<p>1）负载均衡模式</p>
<p>消费者采用负载均衡方式消费消息，多个消费者共同消费队列消息，每个消费者处理的消息不同</p>
<p>2）广播模式</p>
<p>消费者采用广播的方式消费消息，每个消费者消费的消息都是相同的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消息生产者,指定组名</span></span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">    <span class="comment">// 指定Namesrv地址信息.</span></span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    <span class="comment">// 订阅Topic:第一个参数是topic第二个参数是tag</span></span><br><span class="line">    consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="comment">//负载均衡模式消费</span></span><br><span class="line">    consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line">    <span class="comment">//广播模式消费</span></span><br><span class="line">    <span class="comment">//consumer.setMessageModel(MessageModel.BROADCASTING);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册回调函数，处理消息</span></span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, </span><br><span class="line">                              Thread.currentThread().getName(), msgs);</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//启动消息者</span></span><br><span class="line">    consumer.start();</span><br><span class="line">    System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><p>消息有序指的是可以按照消息的发送顺序来消费(FIFO)。RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。</p>
<p>顺序消费的原理解析，在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue(分区队列)；而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。但是如果控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取，则就保证了顺序。当发送和消费参与的queue只有一个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。</p>
<p>下面用订单进行分区有序的示例。一个订单的顺序流程是：创建、付款、推送、完成。订单号相同的消息会被先后发送到同一个队列中，消费时，同一个OrderId获取到的肯定是同一个队列。</p>
<h3 id="顺序消息生产"><a href="#顺序消息生产" class="headerlink" title="顺序消息生产"></a>顺序消息生产</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单构建者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderStep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> orderId;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getOrderId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderId</span><span class="params">(<span class="keyword">long</span> orderId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OrderStep&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;orderId=&quot;</span> + orderId +</span><br><span class="line">                <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;OrderStep&gt; <span class="title">buildOrders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  1039L   : 创建    付款 推送 完成</span></span><br><span class="line">        <span class="comment">//  1065L   ： 创建   付款</span></span><br><span class="line">        <span class="comment">//  7235L   ：创建    付款</span></span><br><span class="line">        List&lt;OrderStep&gt; orderList = <span class="keyword">new</span> ArrayList&lt;OrderStep&gt;();</span><br><span class="line"></span><br><span class="line">        OrderStep orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1039L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;创建&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1065L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;创建&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1039L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;付款&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">7235L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;创建&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1065L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;付款&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">7235L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;付款&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1065L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1039L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;推送&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">7235L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1039L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> orderList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建消息生产者producer，并制定生产者组名</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//2.指定Nameserver地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.25.135:9876;192.168.25.138:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//3.启动producer</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="comment">//构建消息集合</span></span><br><span class="line">        List&lt;OrderStep&gt; orderSteps = OrderStep.buildOrders();</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; orderSteps.size(); i++) &#123;</span><br><span class="line">            String body = orderSteps.get(i) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            Message message = <span class="keyword">new</span> Message(<span class="string">&quot;OrderTopic&quot;</span>, <span class="string">&quot;Order&quot;</span>, <span class="string">&quot;i&quot;</span> + i, body.getBytes());</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数一：消息对象</span></span><br><span class="line"><span class="comment">             * 参数二：消息队列的选择器</span></span><br><span class="line"><span class="comment">             * 参数三：选择队列的业务标识（订单ID）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            SendResult sendResult = producer.send(message, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@param</span> mqs：队列集合</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@param</span> msg：消息对象</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@param</span> arg：业务标识的参数 send的第三个参数</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//选择队列</span></span><br><span class="line">                    <span class="keyword">long</span> index = (<span class="keyword">long</span>) arg % mqs.size();</span><br><span class="line">                    <span class="keyword">return</span> mqs.get((<span class="keyword">int</span>) index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, orderSteps.get(i).getOrderId());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;发送结果：&quot;</span> + sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-顺序消费消息"><a href="#4-2-2-顺序消费消息" class="headerlink" title="4.2.2 顺序消费消息"></a>4.2.2 顺序消费消息</h3><p>一个线程处理一个队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 顺序消息消费，带事务方式（应用可控制Offset什么时候提交）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerInOrder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       DefaultMQPushConsumer consumer = <span class="keyword">new</span> </span><br><span class="line">           DefaultMQPushConsumer(<span class="string">&quot;please_rename_unique_group_name_3&quot;</span>);</span><br><span class="line">       consumer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费&lt;br&gt;</span></span><br><span class="line"><span class="comment">        * 如果非第一次启动，那么按照上次消费的位置继续消费</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">       consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;TagA || TagC || TagD&quot;</span>);</span><br><span class="line"></span><br><span class="line">       consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line"></span><br><span class="line">           Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">               context.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">               <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                   <span class="comment">// 可以看到每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序</span></span><br><span class="line">                   System.out.println(<span class="string">&quot;consumeThread=&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;queueId=&quot;</span> + msg.getQueueId() + <span class="string">&quot;, content:&quot;</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//模拟业务逻辑处理中...</span></span><br><span class="line">                   TimeUnit.SECONDS.sleep(random.nextInt(<span class="number">10</span>));</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       consumer.start();</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;Consumer Started.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h2><p>比如电商里，提交了一个订单就可以发送一个延时消息，1h后去检查这个订单的状态，如果还是未付款就取消订单释放库存。</p>
<h3 id="启动消息消费者"><a href="#启动消息消费者" class="headerlink" title="启动消息消费者"></a>启动消息消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledMessageConsumer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 实例化消费者</span></span><br><span class="line">      DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;ExampleConsumer&quot;</span>);</span><br><span class="line">      <span class="comment">// 订阅Topics</span></span><br><span class="line">      consumer.subscribe(<span class="string">&quot;TestTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">      <span class="comment">// 注册消息监听者</span></span><br><span class="line">      consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; messages, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">for</span> (MessageExt message : messages) &#123;</span><br><span class="line">                  <span class="comment">// Print approximate delay time period</span></span><br><span class="line">                  System.out.println(<span class="string">&quot;Receive message[msgId=&quot;</span> + message.getMsgId() + <span class="string">&quot;] &quot;</span> + (System.currentTimeMillis() - message.getStoreTimestamp()) + <span class="string">&quot;ms later&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 启动消费者</span></span><br><span class="line">      consumer.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送延时消息"><a href="#发送延时消息" class="headerlink" title="发送延时消息"></a>发送延时消息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledMessageProducer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 实例化一个生产者来产生延时消息</span></span><br><span class="line">      DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;ExampleProducerGroup&quot;</span>);</span><br><span class="line">      <span class="comment">// 启动生产者</span></span><br><span class="line">      producer.start();</span><br><span class="line">      <span class="keyword">int</span> totalMessagesToSend = <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">          Message message = <span class="keyword">new</span> Message(<span class="string">&quot;TestTopic&quot;</span>, (<span class="string">&quot;Hello scheduled message &quot;</span> + i).getBytes());</span><br><span class="line">          <span class="comment">// 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)</span></span><br><span class="line">          message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">          <span class="comment">// 发送消息</span></span><br><span class="line">          producer.send(message);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 关闭生产者</span></span><br><span class="line">      producer.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>您将会看到消息的消费比存储时间晚10秒</p>
<h3 id="4-3-4-使用限制"><a href="#4-3-4-使用限制" class="headerlink" title="4.3.4 使用限制"></a>4.3.4 使用限制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org/apache/rocketmq/store/config/MessageStoreConfig.java</span></span><br><span class="line"><span class="keyword">private</span> String messageDelayLevel = <span class="string">&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>现在RocketMq并不支持任意时间的延时，需要设置几个固定的延时等级，从1s到2h分别对应着等级1到18</p>
<h2 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h2><p>批量发送消息能显著提高传递小消息的性能。限制是这些批量消息应该有相同的topic，相同的waitStoreMsgOK，而且不能是延时消息。此外，这一批消息的总大小不应超过4MB。</p>
<h3 id="发送批量消息"><a href="#发送批量消息" class="headerlink" title="发送批量消息"></a>发送批量消息</h3><p>如果您每次只发送不超过4MB的消息，则很容易使用批处理，样例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String topic = <span class="string">&quot;BatchTest&quot;</span>;</span><br><span class="line">List&lt;Message&gt; messages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;OrderID001&quot;</span>, <span class="string">&quot;Hello world 0&quot;</span>.getBytes()));</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;OrderID002&quot;</span>, <span class="string">&quot;Hello world 1&quot;</span>.getBytes()));</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;OrderID003&quot;</span>, <span class="string">&quot;Hello world 2&quot;</span>.getBytes()));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   producer.send(messages);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">   <span class="comment">//处理error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果消息的总长度可能大于4MB时，这时候最好把消息进行分割</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListSplitter</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">List</span>&lt;<span class="title">Message</span>&gt;&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE_LIMIT = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Message&gt; messages;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> currIndex;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ListSplitter</span><span class="params">(List&lt;Message&gt; messages)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.messages = messages;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> currIndex &lt; messages.size();</span><br><span class="line">   &#125;</span><br><span class="line">   	<span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Message&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> nextIndex = currIndex;</span><br><span class="line">       <span class="keyword">int</span> totalSize = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class="line">           Message message = messages.get(nextIndex);</span><br><span class="line">           <span class="keyword">int</span> tmpSize = message.getTopic().length() + message.getBody().length;</span><br><span class="line">           Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">               tmpSize += entry.getKey().length() + entry.getValue().length();</span><br><span class="line">           &#125;</span><br><span class="line">           tmpSize = tmpSize + <span class="number">20</span>; <span class="comment">// 增加日志的开销20字节</span></span><br><span class="line">           <span class="keyword">if</span> (tmpSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">               <span class="comment">//单个消息超过了最大的限制</span></span><br><span class="line">               <span class="comment">//忽略,否则会阻塞分裂的进程</span></span><br><span class="line">               <span class="keyword">if</span> (nextIndex - currIndex == <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">//假如下一个子列表没有元素,则添加这个子列表然后退出循环,否则只是退出循环</span></span><br><span class="line">                  nextIndex++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               totalSize += tmpSize;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;Message&gt; subList = messages.subList(currIndex, nextIndex);</span><br><span class="line">       currIndex = nextIndex;</span><br><span class="line">       <span class="keyword">return</span> subList;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把大的消息分裂成若干个小的消息</span></span><br><span class="line">ListSplitter splitter = <span class="keyword">new</span> ListSplitter(messages);</span><br><span class="line"><span class="keyword">while</span> (splitter.hasNext()) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      List&lt;Message&gt;  listItem = splitter.next();</span><br><span class="line">      producer.send(listItem);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="comment">//处理error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过滤消息"><a href="#过滤消息" class="headerlink" title="过滤消息"></a>过滤消息</h2><p>在大多数情况下，TAG是一个简单而有用的设计，其可以来选择您想要的消息。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;CID_EXAMPLE&quot;</span>);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;TOPIC&quot;</span>, <span class="string">&quot;TAGA || TAGB || TAGC&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>消费者将接收包含TAGA或TAGB或TAGC的消息。但是限制是一个消息只能有一个标签，这对于复杂的场景可能不起作用。在这种情况下，可以使用SQL表达式筛选消息。SQL特性可以通过发送消息时的属性来进行计算。在RocketMQ定义的语法下，可以实现一些简单的逻辑。下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------------</span><br><span class="line">| message  |</span><br><span class="line">|----------|  a &gt; 5 AND b &#x3D; &#39;abc&#39;</span><br><span class="line">| a &#x3D; 10   |  --------------------&gt; Gotten</span><br><span class="line">| b &#x3D; &#39;abc&#39;|</span><br><span class="line">| c &#x3D; true |</span><br><span class="line">------------</span><br><span class="line">------------</span><br><span class="line">| message  |</span><br><span class="line">|----------|   a &gt; 5 AND b &#x3D; &#39;abc&#39;</span><br><span class="line">| a &#x3D; 1    |  --------------------&gt; Missed</span><br><span class="line">| b &#x3D; &#39;abc&#39;|</span><br><span class="line">| c &#x3D; true |</span><br><span class="line">------------</span><br></pre></td></tr></table></figure>

<h3 id="SQL基本语法"><a href="#SQL基本语法" class="headerlink" title="SQL基本语法"></a>SQL基本语法</h3><p>RocketMQ只定义了一些基本语法来支持这个特性。你也可以很容易地扩展它。</p>
<ul>
<li>数值比较，比如：**&gt;，&gt;=，&lt;，&lt;=，BETWEEN，=；**</li>
<li>字符比较，比如：**=，&lt;&gt;，IN；**</li>
<li><strong>IS NULL</strong> 或者 <strong>IS NOT NULL；</strong></li>
<li>逻辑符号 <strong>AND，OR，NOT；</strong></li>
</ul>
<p>常量支持类型为：</p>
<ul>
<li>数值，比如：<strong>123，3.1415；</strong></li>
<li>字符，比如：**’abc’，必须用单引号包裹起来；**</li>
<li><strong>NULL</strong>，特殊的常量</li>
<li>布尔值，<strong>TRUE</strong> 或 <strong>FALSE</strong></li>
</ul>
<p>只有使用push模式的消费者才能用使用SQL92标准的sql语句，接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(finalString topic, <span class="keyword">final</span> MessageSelector messageSelector)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h3><p>发送消息时，你能通过<code>putUserProperty</code>来设置消息的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建消息生产者producer，并制定生产者组名</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//2.指定Nameserver地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.25.135:9876;192.168.25.138:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//3.启动producer</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//4.创建消息对象，指定主题Topic、Tag和消息体</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数一：消息主题Topic</span></span><br><span class="line"><span class="comment">             * 参数二：消息Tag</span></span><br><span class="line"><span class="comment">             * 参数三：消息内容</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;FilterSQLTopic&quot;</span>, <span class="string">&quot;Tag1&quot;</span>, (<span class="string">&quot;Hello World&quot;</span> + i).getBytes());</span><br><span class="line">			<span class="comment">//设置属性</span></span><br><span class="line">            msg.putUserProperty(<span class="string">&quot;i&quot;</span>, String.valueOf(i));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.发送消息</span></span><br><span class="line">            SendResult result = producer.send(msg);</span><br><span class="line">            <span class="comment">//发送状态</span></span><br><span class="line">            SendStatus status = result.getSendStatus();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;发送结果:&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//线程睡1秒</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭生产者producer</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h3><p>用MessageSelector.bySql来使用sql筛选消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建消费者Consumer，制定消费者组名</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//2.指定Nameserver地址</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.25.135:9876;192.168.25.138:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//3.订阅主题Topic和Tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;FilterSQLTopic&quot;</span>, MessageSelector.bySql(<span class="string">&quot;i&gt;5&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.设置回调函数，处理消息</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接受消息内容</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;consumeThread=&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;,&quot;</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//5.启动消费者consumer</span></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p><img src="/2021/03/14/RocketMQ/log\source_posts\RocketMQ\事务消息.png"></p>
<p>上图说明了事务消息的大致方案，其中分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。</p>
<h4 id="1）事务消息发送及提交"><a href="#1）事务消息发送及提交" class="headerlink" title="1）事务消息发送及提交"></a><strong>1）事务消息发送及提交</strong></h4><p>(1) 发送消息（half消息）。</p>
<p>(2) 服务端响应消息写入结果。</p>
<p>(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p>
<p>(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p>
<h4 id="2）事务补偿"><a href="#2）事务补偿" class="headerlink" title="2）事务补偿"></a>2）<strong>事务补偿</strong></h4><p>(1) 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</p>
<p>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态</p>
<p>(3) 根据本地事务状态，重新Commit或者Rollback</p>
<p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p>
<h4 id="3）事务消息状态"><a href="#3）事务消息状态" class="headerlink" title="3）事务消息状态"></a>3）事务消息状态</h4><p>事务消息共有三种状态，提交状态、回滚状态、中间状态：</p>
<ul>
<li>TransactionStatus.CommitTransaction: 提交事务，它允许消费者消费此消息。</li>
<li>TransactionStatus.RollbackTransaction: 回滚事务，它代表该消息将被删除，不允许被消费。</li>
<li>TransactionStatus.Unknown: 中间状态，它代表需要检查消息队列来确定状态。</li>
</ul>
<h3 id="发送事务消息"><a href="#发送事务消息" class="headerlink" title="发送事务消息"></a>发送事务消息</h3><h4 id="1-创建事务性生产者"><a href="#1-创建事务性生产者" class="headerlink" title="1) 创建事务性生产者"></a>1) 创建事务性生产者</h4><p>使用 <code>TransactionMQProducer</code>类创建生产者，并指定唯一的 <code>ProducerGroup</code>，就可以设置自定义线程池来处理这些检查请求。执行本地事务后、需要根据执行结果对消息队列进行回复。回传的事务状态在请参考前一节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建消息生产者producer，并制定生产者组名</span></span><br><span class="line">        TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">&quot;group5&quot;</span>);</span><br><span class="line">        <span class="comment">//2.指定Nameserver地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.25.135:9876;192.168.25.138:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加事务监听器</span></span><br><span class="line">        producer.setTransactionListener(<span class="keyword">new</span> TransactionListener() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 在该方法中执行本地事务</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> arg</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGA&quot;</span>, msg.getTags())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGB&quot;</span>, msg.getTags())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGC&quot;</span>, msg.getTags())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 该方法时MQ进行消息事务状态回查</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息的Tag:&quot;</span> + msg.getTags());</span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.启动producer</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        String[] tags = &#123;<span class="string">&quot;TAGA&quot;</span>, <span class="string">&quot;TAGB&quot;</span>, <span class="string">&quot;TAGC&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//4.创建消息对象，指定主题Topic、Tag和消息体</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数一：消息主题Topic</span></span><br><span class="line"><span class="comment">             * 参数二：消息Tag</span></span><br><span class="line"><span class="comment">             * 参数三：消息内容</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TransactionTopic&quot;</span>, tags[i], (<span class="string">&quot;Hello World&quot;</span> + i).getBytes());</span><br><span class="line">            <span class="comment">//5.发送消息</span></span><br><span class="line">            SendResult result = producer.sendMessageInTransaction(msg, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//发送状态</span></span><br><span class="line">            SendStatus status = result.getSendStatus();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;发送结果:&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//线程睡1秒</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭生产者producer</span></span><br><span class="line">        <span class="comment">//producer.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2）实现事务的监听接口"><a href="#2）实现事务的监听接口" class="headerlink" title="2）实现事务的监听接口"></a>2）实现事务的监听接口</h4><p>当发送半消息成功时，我们使用 <code>executeLocalTransaction</code> 方法来执行本地事务。它返回前一节中提到的三个事务状态之一。<code>checkLocalTranscation</code> 方法用于检查本地事务状态，并回应消息队列的检查请求。它也是返回前一节中提到的三个事务状态之一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建消费者Consumer，制定消费者组名</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//2.指定Nameserver地址</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.25.135:9876;192.168.25.138:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//3.订阅主题Topic和Tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TransactionTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.设置回调函数，处理消息</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接受消息内容</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;consumeThread=&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;,&quot;</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//5.启动消费者consumer</span></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;生产者启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><ol>
<li>事务消息不支持延时消息和批量消息。</li>
<li>为了避免单个消息被检查太多次而导致半队列消息累积，我们默认将单个消息的检查次数限制为 15 次，但是用户可以通过 Broker 配置文件的 <code>transactionCheckMax</code>参数来修改此限制。如果已经检查某条消息超过 N 次的话（ N = <code>transactionCheckMax</code> ） 则 Broker 将丢弃此消息，并在默认情况下同时打印错误日志。用户可以通过重写 <code>AbstractTransactionCheckListener</code> 类来修改这个行为。</li>
<li>事务消息将在 Broker 配置文件中的参数 transactionMsgTimeout 这样的特定时间长度之后被检查。当发送事务消息时，用户还可以通过设置用户属性 CHECK_IMMUNITY_TIME_IN_SECONDS 来改变这个限制，该参数优先于 <code>transactionMsgTimeout</code> 参数。</li>
<li>事务性消息可能不止一次被检查或消费。</li>
<li>提交给用户的目标主题消息可能会失败，目前这依日志的记录而定。它的高可用性通过 RocketMQ 本身的高可用性机制来保证，如果希望确保事务消息不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制。</li>
<li>事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享。与其他类型的消息不同，事务消息允许反向查询、MQ服务器能通过它们的生产者 ID 查询到消费者。</li>
</ol>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>linux笔记</title>
    <url>/2021/03/23/linux%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="在线求助"><a href="#在线求助" class="headerlink" title="在线求助"></a>在线求助</h1><ul>
<li>man command</li>
<li>command –help</li>
<li>info command</li>
</ul>
<h1 id="正确关机的方法"><a href="#正确关机的方法" class="headerlink" title="正确关机的方法"></a>正确关机的方法</h1><p>sync：数据同步写入磁盘</p>
<p>shutdown</p>
<p><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210323161537168.png" alt="image-20210323161537168"></p>
<p>reboot：重启</p>
<p>halt：系统停止</p>
<p>poweoff：系统关机</p>
<h1 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h1><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210323163238399.png" alt="image-20210323163238399"></p>
<p>第一个字符如果是-则是文件d则是目录 l为link file</p>
<p>chgrp：</p>
<p><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210323163837943.png" alt="image-20210323163837943"></p>
<p>chown：</p>
<p><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210323163858673.png" alt="image-20210323163858673"></p>
<p>chmod：</p>
<ul>
<li>r:4 w:2 x:1</li>
<li><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210323164137541.png" alt="image-20210323164137541"></li>
<li>chmod u=rwx,go=rx test</li>
<li>chmod a-x test</li>
</ul>
<h3 id="目录权限"><a href="#目录权限" class="headerlink" title="目录权限"></a>目录权限</h3><p><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210323164503845.png" alt="image-20210323164503845"></p>
<p><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210323164618407.png" alt="image-20210323164618407"></p>
<p>x代表的是用户能否进入该目录成为工作目录</p>
<h2 id="目录和文件操作"><a href="#目录和文件操作" class="headerlink" title="目录和文件操作"></a>目录和文件操作</h2><p>cd：切换目录</p>
<p>pwd：显示当前目录</p>
<p>mkdir：创建新目录</p>
<p>rmdir：删除空目录</p>
<p>ls</p>
<ul>
<li>-a : 列出全部的文件 包括隐藏档(开头为.的文件)</li>
<li>-d：仅列出目录本身 </li>
<li>-l：列出文件的属性和权限等数据</li>
</ul>
<p>cp：复制</p>
<p>rm：删除</p>
<p>mv：移动</p>
<p>获得文件名和目录名</p>
<p><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210323165540449.png" alt="image-20210323165540449"></p>
<h2 id="文件查阅"><a href="#文件查阅" class="headerlink" title="文件查阅"></a>文件查阅</h2><p>cat</p>
<ul>
<li>-n：打印出行号 </li>
<li>-b：列出行号 但是空白行跳过</li>
</ul>
<p>head -n number fileName ：取出前几行</p>
<p>tail -n number fileName：取出后几行</p>
<p>more和less可以一行一行翻阅</p>
<p>touch：创建文件</p>
<p>file fileName：查看文件类型</p>
<h2 id="指令与文件搜寻"><a href="#指令与文件搜寻" class="headerlink" title="指令与文件搜寻"></a>指令与文件搜寻</h2><p>which：搜寻指令的文件名</p>
<p>whereis：在特定目录中查找文件名</p>
<p><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210326194047411.png" alt="image-20210326194047411"></p>
<p>locate：根据/var/lib/mlocate内的数据库的记载，找出用户输入的关键词(keyword)文件名。默认一天更新一次数据库</p>
<ul>
<li><p><img src="/2021/03/23/linux%E7%AC%94%E8%AE%B0/log\source_posts\linux笔记\image-20210326194533561.png" alt="image-20210326194533561"></p>
</li>
<li><p>updated：手动更新，根据/etc/updatedb.conf的设定去搜寻系统硬盘内的文件名，并更新mlocate内的数据库文件。</p>
</li>
</ul>
<p>find</p>
<p>​    </p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat</title>
    <url>/2021/03/18/tomcat/</url>
    <content><![CDATA[<h1 id="Tomcat基础"><a href="#Tomcat基础" class="headerlink" title="Tomcat基础"></a>Tomcat基础</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><strong>http服务器请求处理</strong></p>
<p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210318143747952.png" alt="image-20210318143747952"></p>
<p>HTTP服务器不直接调用业务类，而是把请求交给容器来处理，容器通过 Servlet接口调用业务类。</p>
<p>因此Servlet接口和Servlet容器的出现，达到了HTTP服务器与 业务类解耦的目的。而Servlet接口和Servlet容器这一整套规范叫作Servlet规范。 Tomcat按照Servlet规范的要求实现了Servlet容器，同时它们也具有HTTP服务器的功能。作为Java程序员，如果我们要实现新的业务功能，只需要实现一个Servlet，并把它 注册到Tomcat（Servlet容器）中，剩下的事情就由Tomcat帮我们处理了。</p>
<p><strong>Tomcat整体架构</strong></p>
<p>tomcat实现两个核心功能： </p>
<ul>
<li><p>处理Socket连接，负责网络字节流与Request和Response对象的转化。</p>
</li>
<li><p>加载和管理Servlet，以及具体处理Request请求。</p>
</li>
</ul>
<p>因此Tomcat设计了两个核心组件连接器（Connector）和容器（Container）来分别做这 两件事情。连接器负责对外交流，容器负责内部处理。</p>
<p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210318144050969.png" alt="image-20210318144050969"></p>
<h2 id="IO模型与协议"><a href="#IO模型与协议" class="headerlink" title="IO模型与协议"></a>IO模型与协议</h2><p>在Coyote中 ， Tomcat支持的多种I/O模型和应用层协议，具体包含哪些IO模型和应用层 协议，请看下表：</p>
<p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210318150203575.png" alt="image-20210318150203575"></p>
<p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210318150221296.png" alt="image-20210318150221296"></p>
<h2 id="连接器Coyote"><a href="#连接器Coyote" class="headerlink" title="连接器Coyote"></a>连接器Coyote</h2><p>Coyote 是Tomcat的连接器框架的名称 , 是Tomcat服务器提供的供客户端访问的外部接口。客户端通过Coyote与服务器建立连接、发送请求并接受响应 。</p>
<p>Coyote 封装了底层的网络通信（Socket 请求及响应处理），为Catalina 容器提供了统一的接口，使Catalina 容器与具体的请求协议及IO操作方式完全解耦。Coyote 将Socket 输入转换封装为 Request 对象，交由Catalina 容器进行处理，处理请求完成后, Catalina通过Coyote 提供的Response 对象将结果写入输出流 。</p>
<p>Coyote 作为独立的模块，只负责具体协议和IO的相关操作， 与Servlet 规范实现没有直 接关系，因此即便是 Request 和 Response 对象也并未实现Servlet规范对应的接口， 而是在Catalina 中将他们进一步封装为ServletRequest 和 ServletResponse 。</p>
<p>Tomcat为了实现支持多种I/O模型和应用层协议，一个容器可能对接多个连接器，就好比 一个房间有多个门。但是单独的连接器或者容器都不能对外提供服务，需要把它们组装 起来才能工作，组装后这个整体叫作Service组件。这里请你注意，Service本身没有做什么重要的事情，只是在连接器和容器外面多包了一层，把它们组装在一起。Tomcat内可能有多个Service，这样的设计也是出于灵活性的考虑。通过在Tomcat中配置多个 Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。</p>
<p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210318144407639.png" alt="image-20210318144407639"></p>
<h3 id="连接器组件"><a href="#连接器组件" class="headerlink" title="连接器组件"></a>连接器组件</h3><p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210318144839639.png" alt="image-20210318144839639"></p>
<p><strong>EndPoint</strong>:Coyote 通信端点，即通信监听的接口，是具体Socket接收和发送处理器，是对传输层的抽象，因此EndPoint用来实现TCP/IP协议的。Tomcat 并没有EndPoint 接口，而是提供了一个抽象类AbstractEndpoint ， 里面定义了两个内部类：Acceptor和SocketProcessor。Acceptor用于监听Socket连接请求。 SocketProcessor用于处理接收到的Socket请求，它实现Runnable接口，在Run方法里调用协议处理组件Processor进行处理。为了提高处理能力，SocketProcessor被提交到线程池来执行。而这个线程池叫作执行器（Executor)</p>
<p><strong>Processor</strong>:Coyote 协议处理接口 ，如果说EndPoint是用来实现TCP/IP协议的，那么 Processor用来实现HTTP协议，Processor接收来自EndPoint的Socket，读取字节流解 析成Tomcat Request和Response对象，并通过Adapter将其提交到容器处理， Processor是对应用层协议的抽象</p>
<p><strong>ProtocolHandler</strong>:Coyote 协议接口， 通过Endpoint 和 Processor ，实现针对具体协议的处理能力。Tomcat 按照协议和I/O 提供了6个实现类 ： AjpNioProtocol ， AjpAprProtocol， AjpNio2Protocol ， Http11NioProtocol ，Http11Nio2Protocol,Http11AprProtocol。我们在配置tomcat/conf/server.xml 时 ， 至少要指定具体的 ProtocolHandler , 当然也可以指定协议名称 ， 如 ： HTTP/1.1</p>
<p><strong>Adapter</strong>:由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat定义了自己的Request类 来“存放”这些请求信息。ProtocolHandler接口负责解析请求并生成Tomcat Request类。 但是这个Request对象不是标准的ServletRequest，也就意味着，不能用Tomcat Request作为参数来调用容器。Tomcat设计者的解决方案是引入CoyoteAdapter，这是 适配器模式的经典运用，连接器调用CoyoteAdapter的Sevice方法，传入的是Tomcat Request对象，CoyoteAdapter负责将Tomcat Request转成ServletRequest，再调用容 器的Service方法。</p>
<h2 id="容器Catalina"><a href="#容器Catalina" class="headerlink" title="容器Catalina"></a>容器Catalina</h2><p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210319145215568.png" alt="image-20210319145215568"></p>
<p>Tomcat 本质上就是一款 Servlet 容器， 因此Catalina 才是 Tomcat 的核心 ， 其他模块 都是为Catalina 提供支撑的。 比如 ： 通过Coyote 模块提供链接通信，Jasper 模块提供 JSP引擎，Naming 提供JNDI 服务，Juli 提供日志服务。</p>
<h3 id="Catalina-的主要组件"><a href="#Catalina-的主要组件" class="headerlink" title="Catalina 的主要组件"></a>Catalina 的主要组件</h3><p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210319145258094.png" alt="image-20210319145258094"></p>
<p>如上图所示，Catalina负责管理Server（tomcat服务器），而Server表示着整个服务器。Server下面有多个 服务Service，每个服务都包含着多个连接器组件Connector（Coyote 实现）和<strong>一个</strong>容器 组件Container。在Tomcat 启动的时候， 会初始化一个Catalina的实例。</p>
<p>Catalina 各个组件的职责：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td>Catalina</td>
<td>负责解析Tomcat的配置文件 , 以此来创建服务器Server组件，并根据 命令来对其进行管理</td>
</tr>
<tr>
<td>Server</td>
<td>服务器表示整个Catalina Servlet容器以及其它组件，负责组装并启动 Servlet引擎,Tomcat连接器。Server通过实现Lifecycle接口，提供了 一种优雅的启动和关闭整个系统的方式</td>
</tr>
<tr>
<td>Service</td>
<td>服务是Server内部的组件，一个Server包含多个Service。它将若干个 Connector组件绑定到一个Container（Engine）上</td>
</tr>
<tr>
<td>Connector</td>
<td>连接器，处理与客户端的通信，它负责接收客户请求，然后转给相关 的容器处理，最后向客户返回响应结果</td>
</tr>
<tr>
<td>Container</td>
<td>容器，负责处理用户的servlet请求，并返回对象给web用户的模块</td>
</tr>
</tbody></table>
<p>Tomcat设计了4种容器，分别是Engine、Host、Context和Wrapper。这4种容器不是平行关系，而是父子关系。Tomcat通过一种分层的架构，使得Servlet容器具有很好的灵活性。</p>
<p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210319213053382.png" alt="image-20210319213053382"></p>
<table>
<thead>
<tr>
<th>容器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Engine</td>
<td>表示整个Catalina的Servlet引擎，用来管理多个虚拟站点，一个Service 最多只能有一个Engine，但是一个引擎可包含多个Host</td>
</tr>
<tr>
<td>Host</td>
<td>表示一个虚拟主机，或者说一个站点，可以给Tomcat配置多个虚拟主机地址，而一个虚拟主机下可包含多个Context</td>
</tr>
<tr>
<td>Context</td>
<td>表示一个Web应用程序， 一个Web应用可包含多个Wrapper</td>
</tr>
<tr>
<td>Wrapper</td>
<td>表示一个Servlet，Wrapper 作为容器中的最底层，不能包含子容器</td>
</tr>
</tbody></table>
<p>那么，Tomcat是怎么管理这些容器的呢？你会发现这些容器具有父子关系，形成一个树形结构，你可能马上就想到了设计模式中的组合模式。没错，Tomcat就是用组合模式来管理这些容器的。具体实现方法是，所有容器组件都实现了Container接口，因此组合模式可以使得用户对单容器对象和组合容器对象的使用具有一致性。这里单容器对象指的是最底层的Wrapper，组合容器对象指的是上面的Context、Host或者Engine</p>
<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210319221358739.png" alt="image-20210319221358739"></p>
<p>ProtocalHandler再继续初始化EndPoint  endpoint绑定并监听相应的端口号</p>
<p>ProtocalHandler继续调用Endpoint的start方法 ：开启线程，接受客户端请求</p>
<p>加载Tomcat的配置文件，初始化容器组件 ，监听对应的端口号， 准备接受客户端请求</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="LifeCycle"><a href="#LifeCycle" class="headerlink" title="LifeCycle"></a>LifeCycle</h4><p>由于所有的组件均存在初始化、启动、停止等生命周期方法，拥有生命周期管理的特 性， 所以Tomcat在设计的时候， 基于生命周期管理抽象成了一个接口 Lifecycle ，而组件Server、Service、Container、Executor、Connector 组件 ， 都实现了一个生命周期 的接口，从而具有了以下生命周期中的核心方法：</p>
<ul>
<li>init：初始化组件</li>
<li>start：启动组件</li>
<li>stop：停止组件</li>
<li>destory：销毁组件</li>
</ul>
<p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210320154226705.png" alt="image-20210320154226705"></p>
<h4 id="各组件的默认实现"><a href="#各组件的默认实现" class="headerlink" title="各组件的默认实现"></a>各组件的默认实现</h4><p>上面我们提到的Server、Service、Engine、Host、Context都是接口， 下图中罗列了这 些接口的默认实现类。当前对于 Endpoint组件来说，在Tomcat中没有对应的Endpoint 接口， 但是有一个抽象类 AbstractEndpoint ，其下有三个实现类： NioEndpoint、 Nio2Endpoint、AprEndpoint ， 这三个实现类，分别对应于前面讲解链接器 Coyote 时， 提到的链接器支持的三种IO模型：NIO，NIO2，APR ， Tomcat8.5版本中，默认采 用的是 NioEndpoint</p>
<p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210320154207762.png" alt="image-20210320154207762"></p>
<p>ProtocolHandler ： Coyote协议接口，通过封装Endpoint和Processor ， 实现针对具体 协议的处理功能。Tomcat按照协议和IO提供了6个实现类</p>
<p>AJP协议：</p>
<ul>
<li><p>AjpNioProtocol ：采用NIO的IO模型。 </p>
</li>
<li><p>AjpNio2Protocol：采用NIO2的IO模型</p>
</li>
<li><p>AjpAprProtocol ：采用APR的IO模型，需要依赖于APR库。</p>
<p>HTTP协议：</p>
</li>
<li><p>Http11NioProtocol ：采用NIO的IO模型，默认使用的协议（如果服务器没有安装 APR）。</p>
</li>
<li><p>Http11Nio2Protocol：采用NIO2的IO模型。</p>
</li>
<li><p>Http11AprProtocol ：采用APR的IO模型，需要依赖于APR库。</p>
</li>
</ul>
<p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210320155257146.png" alt="image-20210320155257146"></p>
<h2 id="请求处理流程"><a href="#请求处理流程" class="headerlink" title="请求处理流程"></a>请求处理流程</h2><h3 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h3><p>设计了这么多层次的容器，Tomcat是怎么确定每一个请求应该由哪个Wrapper容器里的 Servlet来处理的呢？答案是，Tomcat是用Mapper组件来完成这个任务的。</p>
<p>Mapper组件的功能就是将用户请求的URL定位到一个Servlet，它的工作原理是： Mapper组件里保存了Web应用的配置信息，其实就是容器组件与访问路径的映射关系， 比如Host容器里配置的域名、Context容器里的Web应用路径，以及Wrapper容器里 Servlet映射的路径，你可以想象这些配置信息就是一个多层次的Map。</p>
<p>当一个请求到来时，Mapper组件通过解析请求URL里的域名和路径，再到自己保存的 Map里去查找，就能定位到一个Servlet。一个请求URL最后只会定位到一个 Wrapper容器，也就是一个Servlet。</p>
<p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210320181856246.png" alt="image-20210320181856246"></p>
<p><img src="/2021/03/18/tomcat/log\source_posts\tomcat\image-20210320183445781.png" alt="image-20210320183445781"></p>
<p>步骤如下: </p>
<ul>
<li>Connector组件Endpoint中的Acceptor监听客户端套接字连接并接收Socket。</li>
<li>将连接交给线程池Executor处理，开始执行请求响应任务。</li>
<li>Processor组件读取消息报文，解析请求行、请求体、请求头，封装成Request对象。</li>
<li>Mapper组件根据请求行的URL值和请求头的Host值匹配由哪个Host容器、Context容器、Wrapper容器处理请求。</li>
<li>CoyoteAdaptor组件负责将Connector组件和Engine容器关联起来，把生成的 Request对象和响应对象Response传递到Engine容器中，调用 Pipeline。</li>
<li>Engine容器的管道开始处理，管道中包含若干个Valve、每个Valve负责部分处理逻辑。执行完Valve后会执行基础的 Valve–StandardEngineValve，负责调用Host容器的 Pipeline。</li>
<li>Host容器的管道开始处理，流程类似，最后执行 Context容器的Pipeline。</li>
<li>Context容器的管道开始处理，流程类似，最后执行 Wrapper容器的Pipeline。</li>
<li>Wrapper容器的管道开始处理，流程类似，最后执行 Wrapper容器对应的Servlet对象的处理方法。</li>
</ul>
<p>在Tomcat中定义了Pipeline 和 Valve 两个接口，Pipeline 用于构建责任链， 后者代表责 任链上的每个处理器。Pipeline 中维护了一个基础的Valve，它始终位于Pipeline的末端 （最后执行），封装了具体的请求处理和输出响应的过程。当然，我们也可以调用 addValve()方法， 为Pipeline 添加其他的Valve， 后添加的Valve 位于基础的Valve之 前，并按照添加顺序执行。Pipiline通过获得首个Valve来启动整合链条的执行 。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>尚硅谷面试题</title>
    <url>/2021/04/08/%E5%B0%9A%E7%A1%85%E8%B0%B7%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="第一季"><a href="#第一季" class="headerlink" title="第一季"></a>第一季</h1><h2 id="解决spring-mvc乱码问题"><a href="#解决spring-mvc乱码问题" class="headerlink" title="解决spring mvc乱码问题"></a>解决spring mvc乱码问题</h2><p>post请求乱码:在web.xml中配置过滤器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>get请求乱码：修改tomcat的conf目录下的server.xml文件，把第一个Connection标签的URIEncoding的值改为UTF-8</p>
<h2 id="Mybatis中实体类的属性名和表中的字段名不一样怎么办"><a href="#Mybatis中实体类的属性名和表中的字段名不一样怎么办" class="headerlink" title="Mybatis中实体类的属性名和表中的字段名不一样怎么办"></a>Mybatis中实体类的属性名和表中的字段名不一样怎么办</h2><ol>
<li><p>写sql语句的时候起别名 别名为实体类中的属性名</p>
</li>
<li><p>在mybatis的全局配置文件中开启驼峰命名规则</p>
<ol>
<li><pre><code class="xml">&lt;configuration&gt;
    &lt;settings&gt;
        &lt;!-- 数据库中的last_name会被映射成lastName--&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;&gt;&lt;/setting&gt;
    &lt;/settings&gt;
&lt;/configuration&gt;</code></pre>
</li>
</ol>
</li>
<li><p>在mapper映射文件中使用resultMap来自定映射规则</p>
<ol>
<li><img src="/2021/04/08/%E5%B0%9A%E7%A1%85%E8%B0%B7%E9%9D%A2%E8%AF%95%E9%A2%98/log\source_posts\尚硅谷面试题\image-20210408225345722.png" alt="image-20210408225345722"></li>
</ol>
</li>
</ol>
<h2 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h2><ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段应该创建索引</li>
<li>查询中与其它表关联的字段，外键关系建立索引</li>
<li>单键/组合索引的选择问题，组合索引性价比更高</li>
<li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li>
<li>查询中统计或者分组字段</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>秒杀项目</title>
    <url>/2021/03/26/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>使用Mybatis-generator生成数据库文件的映射</p>
<p>密码单独存放一张表</p>
<p><img src="/2021/03/26/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/log\source_posts\秒杀项目\image-20210326161412600.png" alt="image-20210326161412600"></p>
<p>创建一个model 用于封装用户信息和密码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;性别不能不填写&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Byte gender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;年龄不能不填写&quot;)</span></span><br><span class="line">    <span class="meta">@Min(value = 0, message = &quot;年龄必须大于0岁&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 150, message = &quot;年龄必须小于150岁&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;手机号不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String telphone;</span><br><span class="line">    <span class="keyword">private</span> String regisitMode;</span><br><span class="line">    <span class="keyword">private</span> Integer thirdPartyId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String encrptPassword;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>展示用户信息的时候不应该把密码展示出来 所以创建一个viewObject</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Byte gender;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String telphone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/2021/03/17/Servlet/</url>
    <content><![CDATA[<h1 id="接口实现类开发步骤"><a href="#接口实现类开发步骤" class="headerlink" title="接口实现类开发步骤"></a>接口实现类开发步骤</h1><p><img src="/2021/03/17/Servlet/image-20210317215123604.png" alt="image-20210317215123604"></p>
<p><strong>首先实现servlet类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i am get&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i am post&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tomcat调用Servlet接口实现类的规则：</p>
<ul>
<li>tomcat有权创建Servlet接口实现类实例对象 Servlet servlet = new OneServlet();</li>
<li>tomcat根据实例对象调用service方法处理当前请求 servlet.service();</li>
</ul>
<p>HttpServlet类中对service方法进行了实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String method = req.getMethod();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// servlet doesn&#x27;t support if-modified-since, no reason</span></span><br><span class="line">            <span class="comment">// to go through further expensive logic</span></span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                maybeSetLastModified(resp, lastModified);</span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Note that this means NO servlet supports whatever</span></span><br><span class="line">        <span class="comment">// method was requested, anywhere on this server.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        String errMsg = lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">        errArgs[<span class="number">0</span>] = method;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        </span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质是调用doGet doPost方法 所以要在自定义的Servlet类中要实现doGet和doPost方法</p>
<p><strong>对servlet实现类进行配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    将servlet接口实现类路径地址交给tomcat tomcat中的存储格式为String one = &quot;com.baobingjiang.controller.OneServlet&quot;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>one<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.baobingjiang.controller.OneServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    为了降低用户访问Servlet接口实现类难度 需要设置简短请求别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>one<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/one<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置好tomcat并启动 访问 <a href="http://localhost:8080/myWeb/one%E5%8D%B3%E5%8F%AF%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9C%8B%E5%88%B0%E6%89%93%E5%8D%B0%E7%9A%84%E6%B6%88%E6%81%AF">http://localhost:8080/myWeb/one即可在控制台看到打印的消息</a></p>
<h1 id="Servlet对象生命周期"><a href="#Servlet对象生命周期" class="headerlink" title="Servlet对象生命周期"></a>Servlet对象生命周期</h1><p>1.网站中所有的servlet接口实现类的实例对象，只能由Http服务器负责创建。开发人员不能手动创建servlet接口实现类的实例对象</p>
<p>2.在默认的情况下，http服务器接收到对于当前servlet接口实现类第一次请求时自动创建这个servlet接口实现类的实例对象</p>
<p>可以通过手动配置 要求http服务器在启动时自动创建某个Servlet接口实现类的实例对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>one<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.baobingjiang.controller.OneServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--填写一个大于0的整数即可--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在http服务器运行期间 ，一个servlet接口实现类只能被创建出一个实例对象</p>
<p>http服务器关闭的时候 会将网站中所有servlet对象全部销毁</p>
<h1 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h1><p>主要功能：</p>
<ul>
<li>将执行结果以二进制形式写入到【响应体】</li>
<li>设置响应头中[content-type]属性值，从而控制浏览器使用对应编译器将响应体二进制数据编译为【文字，图片，视频，命令】</li>
<li>设置响应头中【location】属性，将一个请求地址赋值给location.从而控制浏览器向指定服务器发送请求</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String message = <span class="string">&quot;hello &lt;br/&gt; world&quot;</span>;</span><br><span class="line">        <span class="comment">//通过tomcat的输出流 将执行结果以二进制的形式写入到响应体</span></span><br><span class="line">        <span class="comment">//ContentType指定文本格式和字符集</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        resp.getWriter().print(message);</span><br><span class="line">        <span class="comment">//doGet执行完毕后，tomcat将相应包推送给浏览器</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String url = <span class="string">&quot;http://www.baidu.com?username=bob&quot;</span>;</span><br><span class="line">    resp.sendRedirect(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h1><ul>
<li><p>可以读取Http请求协议包中【请求行】信息</p>
</li>
<li><p>可以读取保存在Http请求协议包中【请求头】或则【请求体】中请求参数信息</p>
</li>
<li><p>可以代替浏览器向Http服务器申请资源文件调用</p>
</li>
</ul>
<p>浏览器以get方式发送请求 参数在请求头中 当http请求协议包到达http服务器之后 由tomcat对二进制内容进行解码 tomcat默认字符集为utf-8所以不会乱码</p>
<p>浏览器以post方式发送请求 参数在请求体中 当http请求协议包到达http服务器之后 由当前请求对象(request)对二进制内容进行解码 默认使用的是ISO-8859-1字符集 如果是中文会出现乱码 解决方法：在读取请求体内容之前 应该通知请求对象使用utf-8字符集对请求体内容进行一次重新解码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="comment">//读取请求行中的信息</span></span><br><span class="line">    req.getRequestURL();</span><br><span class="line">    req.getMethod();</span><br><span class="line">    <span class="comment">//读取参数</span></span><br><span class="line">    String username = req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    System.out.println(username);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="请求对象与响应对象的生命周期"><a href="#请求对象与响应对象的生命周期" class="headerlink" title="请求对象与响应对象的生命周期"></a>请求对象与响应对象的生命周期</h1><p>1.在Http服务器接收到浏览器发送的【Http请求协议包】之后，自动为当前的【Http请求协议包】生成一个【请求对象】和一个【响应对象】</p>
<p> 2.在Http服务器调用doGet/doPost方法时，负责将【请求对象】和【响应对象】作为实参传递到方法，确保doGet/doPost正确执行</p>
<p> 3.在Http服务器准备推送Http响应协议包之前，负责将本次请求关联的【请求对象】和【响应对象】销毁</p>
<p><img src="/2021/03/17/Servlet/image-20210318125647204.png" alt="image-20210318125647204"></p>
<h1 id="欢迎资源文件"><a href="#欢迎资源文件" class="headerlink" title="欢迎资源文件"></a>欢迎资源文件</h1><p>用户发送了一个针对某个网站的【默认请求】时，此时由Http服务器自动从当前网站返回的资源文件</p>
<ul>
<li>正常请求： <a href="http://localhost:8080/myWeb/index.html">http://localhost:8080/myWeb/index.html</a></li>
<li>默认请求： <a href="http://localhost:8080/myWeb/">http://localhost:8080/myWeb/</a>        </li>
</ul>
<p>默认配置：自上向下进行查找 如果没有找到就返回一个404状态码</p>
<welcome-file-list>
    <welcome-file>index.html</welcome-file>
    <welcome-file>index.htm</welcome-file>
    <welcome-file>index.jsp</welcome-file>
</welcome-file-list>

<p>自定义配置：在web.xml中进行配置 默认配置将失效</p>
<welcome-file-list>
    <welcome-file>login.html</welcome-file>
</welcome-file-list>

<h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><p>Http服务器在推送响应包之前，根据本次请求处理情况将Http状态码写入到响应包中【状态行】上</p>
<ul>
<li><p>1XX :最有特征 100; 通知浏览器本次返回的资源文件并不是一个独立的资源文件，需要浏览器在接收 响应包之后，继续向Http服务器所要依赖的其他资源文件</p>
</li>
<li><p>2XX:最有特征200，通知浏览器本次返回的资源文件是一个 完整独立资源文件，浏览器在接收到之后不需要所要  其他关联文件* </p>
</li>
<li><p>3XX:最有特征302，通知浏览器本次返回的不是一个资源文件内容 而是一个资源文件地址，需要浏览器根据这个地址自动发起 请求来索要这个资源文件</p>
</li>
<li><p>4XX:</p>
<ul>
<li>404: 通知浏览器，由于在服务端没有定位到被访问的资源文件因此无法提供帮助</li>
<li>405：通知浏览器，在服务端已经定位到被访问的资源文件（Servlet）但是这个Servlet对于浏览器采用的请求方式不能处理</li>
</ul>
</li>
<li><p>5XX:通知浏览器，在服务端已经定位到被访问的资源文件（Servlet） 这个Servlet可以接收浏览器采用请求方式，但是Servlet在处理 请求期间，由于Java异常导致处理失败</p>
</li>
</ul>
<h1 id="多个Servlet之间调用"><a href="#多个Servlet之间调用" class="headerlink" title="多个Servlet之间调用"></a>多个Servlet之间调用</h1><p>某些来自于浏览器发送请求，往往需要服务端中多个Servlet协同处理。 但是浏览器一次只能访问一个Servlet，导致用户需要手动通过浏览器 发起多次请求才能得到服务。 这样增加用户获得服务难度，导致用户放弃访问当前网站</p>
<p>解决：无论本次请求涉及到多少个Servlet,用户只需要【手动】通知浏览器发起一次请求即可</p>
<p>多个Servlet之间调用规则</p>
<ul>
<li>重定向 </li>
<li>请求转发</li>
</ul>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>用户第一次通过【手动方式】通知浏览器访问OneServlet。 OneServlet工作完毕后，将TwoServlet地址写入到响应头 location属性中，导致Tomcat将302状态码写入到状态行。 在浏览器接收到响应包之后，会读取到302状态。此时浏览器 自动根据响应头中location属性地址发起第二次请求，访问 TwoServlet去完成请求中剩余任务</p>
<p>实现命令：response.sendRedirect(“请求地址”) 既可以把当前网站内部的资源文件地址发送给浏览器也可以把其他网站资源文件地址发送给浏览器</p>
<p>请求方式：重定向解决方案中，通过地址栏通知浏览器发起下一次请求，因此通过重定向解决方案调用的资源文件接收的请求方式一定是【GET】</p>
<h1 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h1><p>用户第一次通过手动方式要求浏览器访问OneServlet。 OneServlet工作完毕后，通过当前的请求对象代替浏览器 向Tomcat发送请求，申请调用TwoServlet。 Tomcat在接收到这个请求之后，自动调用TwoServlet来 完成剩余任务</p>
<p>实现命令： request.getRequestDispathcer(“/资源文件名”) 只能向Tomcat服务器申请调用当前网站下资源文件地址，不要写网站名</p>
<p>请求方式：在请求转发过程中，浏览器只发送一个了个Http请求协议包。 参与本次请求的所有Servlet共享同一个请求协议包，因此这些Servlet接收的请求方式应与浏览器发送的请求方式保持一致</p>
<h1 id="多个Servlet之间数据共享"><a href="#多个Servlet之间数据共享" class="headerlink" title="多个Servlet之间数据共享"></a>多个Servlet之间数据共享</h1><p>四种数据共享方案</p>
<ul>
<li>ServletContext接口</li>
<li>Cookie类</li>
<li>HttpSession接口</li>
<li>HttpServletRequest接口</li>
</ul>
<h2 id="ServletContext-全局作用域对象"><a href="#ServletContext-全局作用域对象" class="headerlink" title="ServletContext(全局作用域对象)"></a>ServletContext(全局作用域对象)</h2><p>如果两个Servlet来自于同一个网站。彼此之间可以通过网站的ServletContext实例对象实现数据共享</p>
<p>工作原理：每一个网站都存在一个全局作用域对象。 这个全局作用域对象相当于一个Map. 在这个网站中OneServlet可以将一个数据 存入到全局作用域对象，当前网站中其他 Servlet此时都可以从全局作用域对象得到 这个数据进行使用</p>
<p>ServletContext生命周期：在Http服务器启动过程中，自动为当前网站在内存中创建 一个全局作用域对象，在Http服务器运行期间时，一个网站只有一个全局作用域对象。在Http服务器准备关闭时，负责将当前网站中全局作用域对象 进行销毁处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext application=req.getServletContext();</span><br><span class="line">        application.setAttribute(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext application=req.getServletContext();</span><br><span class="line">        <span class="comment">//2.从全局作用域对象得到指定关键字对应数据</span></span><br><span class="line">        Object vale = application.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，此时借助于Cookie对象进行数据共享</p>
<p>Cookie存放当前用户的私人数据，在共享数据过程中提高服务质量</p>
<p><img src="/2021/03/17/Servlet/image-20210319133749797.png" alt="image-20210319133749797"></p>
<p>用户通过浏览器第一次向MyWeb网站发送请求申请OneServlet。OneServlet在运行期间创建一个Cookie存储与当前用户相关数据OneServlet工作完毕后，【将Cookie写入到响应头】交还给当前浏览器。浏览器收到响应响应包之后，将cookie存储在浏览器的缓存<br>一段时间之后，用户通过【同一个浏览器】再次向【myWeb网站】发送请求申请TwoServlet时。【浏览器需要无条件的将myWeb网站之前推送过来的Cookie，写入到请求头】发送过去 此时TwoServlet在运行时，就可以通过读取请求头中cookie中信息，得到OneServlet提供的共享数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        Cookie card=<span class="keyword">new</span> Cookie(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        Cookie card1=<span class="keyword">new</span> Cookie(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;efg&quot;</span>);</span><br><span class="line">        <span class="comment">//2.【发卡】将cookie写入到响应头，交给浏览器</span></span><br><span class="line">        resp.addCookie(card);</span><br><span class="line">        resp.addCookie(card1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//2.循环遍历数据得到每一个cookie的key与value</span></span><br><span class="line">        Cookie cookieArray[]=req.getCookies();</span><br><span class="line">        <span class="keyword">for</span>(Cookie card:cookieArray)&#123;</span><br><span class="line">            String key=card.getName();</span><br><span class="line">            String value=card.getValue();</span><br><span class="line">            System.out.println(key + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在默认情况下，Cookie对象存放在浏览器的缓存中 因此只要浏览器关闭，Cookie对象就被销毁掉</p>
<p>在手动设置情况下，可以要求浏览器将接收的Cookie 存放在客户端计算机上硬盘上，同时需要指定Cookie 在硬盘上存活时间。在存活时间范围内，关闭浏览器 关闭客户端计算机，关闭服务器，都不会导致Cookie 被销毁。在存活时间到达时，Cookie自动从硬盘上被 删除</p>
<p>cookie.setMaxAge(60) 单位是s</p>
<h2 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h2><p>如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，此时 借助于HttpSession对象进行数据共享</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        HttpSession session=req.getSession();</span><br><span class="line">        <span class="comment">//cookie只可以存放字符串类型 session可以存储任意类型</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;key1&quot;</span>,<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        HttpSession session=req.getSession();</span><br><span class="line">        Object res =session.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<ul>
<li><p>getSession():如果当前用户在服务端已经拥有了自己的私人储物柜. 要求tomcat将这个私人储物柜进行返回 如果当前用户在服务端尚未拥有自己的私人储物柜 要求tocmat为当前用户创建一个全新的私人储物柜</p>
</li>
<li><p>getSession(false):如果当前用户在服务端已经拥有了自己的私人储物柜. 要求tomcat将这个私人储物柜进行返回 如果当前用户在服务端尚未拥有自己的私人储物柜 此时Tomcat将返回null</p>
</li>
</ul>
<p>http服务器使用cookie将用户与HttpSession关联起来 在浏览器关闭时，意味着用户与他的HttpSession关系被切断 由于Tomcat无法检测浏览器何时关闭，因此在浏览器关闭时并不会导致Tomcat将浏览器关联的HttpSession进行销毁 为了解决这个问题，Tomcat为每一个HttpSession对象设置【空闲时间】 这个空闲时间默认30分钟，如果当前HttpSession对象空闲时间达到30分钟 此时Tomcat认为用户已经放弃了自己的HttpSession，此时Tomcat就会销毁 掉这个HttpSession</p>
<p>可以在web.xml中进行手动设置</p>
<session-config>
            <session-timeout>5</session-timeout><!--当前网站中每一个session最大空闲时间5分钟-->
</session-config>

<h2 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h2><p>在同一个网站中，如果两个Servlet之间通过【请求转发】方式进行调用， 彼此之间共享同一个请求协议包。而一个请求协议包只对应一个请求对象 因此servlet之间共享同一个请求对象，此时可以利用这个请求对象在两个Servlet之间实现数据共享</p>
<h1 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h1><p>监听器接口用于监控【作用域对象生命周期变化时刻】以及【作用域对象共享数据变化时刻】</p>
<p>在Servlet规范中，认为在服务端内存中可以在某些条件下为两个Servlet之间提供数据共享方案的对象，被称为【作用域对象】</p>
<p>Servlet规范下作用域对象:</p>
<ul>
<li>ServletContext：全局作用域对象</li>
<li>HttpSession:会话作用域对象</li>
<li>HttpServletRequest:请求作用域对象</li>
</ul>
<p>监听器接口实现类开发规范：</p>
<ul>
<li><p>根据监听的实际情况，选择对应监听器接口进行实现</p>
</li>
<li><p>重写监听器接口声明【监听事件处理方法】</p>
</li>
<li><p>在web.xml文件将监听器接口实现类注册到Http服务器</p>
</li>
</ul>
<p>ServletContextListener接口：通过这个接口合法的检测全局作用域对象被初始化时刻以及被销毁时刻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在全局作用域对象被Http服务器初始化被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在全局作用域对象被Http服务器销毁时候触发调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.ServletContextAttributeListener接口:通过这个接口合法的检测全局作用域对象共享数据变化时刻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ServletContextAttributeListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在全局作用域对象添加共享数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletContextAttributeEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在全局作用域对象更新共享数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletContextAttributeEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在全局作用域对象删除共享数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletContextAttributeEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在web.xml中进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.baobingjiang.listener.MyListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><p>Filter接口在Http服务器调用资源文件之前，对Http服务器进行拦截</p>
<p>Filter接口实现类开发步骤：三步</p>
<ul>
<li>创建一个Java类实现Filter接口</li>
<li>重写Filter接口中doFilter方法</li>
<li>web.xml将过滤器接口实现类注册到Http服务器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在web.xml中进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.baobingjiang.filter.MyFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        当tomcat调用img下的任意文件的时候调用myFilter进行拦截--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/img/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2021/03/19/docker/</url>
    <content><![CDATA[<h1 id="名词概念"><a href="#名词概念" class="headerlink" title="名词概念"></a>名词概念</h1><p>镜像(image):好比一个模板 可以通过这个模板来创建容器服务 tomcat镜像 ===&gt;run ==&gt;tomcat01容器 ,通过这个镜像可以创建多个容器</p>
<p>容器:docker利用容器技术 独立运行一个或者一组应用 通过镜像来创建</p>
<p>仓库:存放镜像 分为公有仓库和私有仓库</p>
<h1 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h1><p>在linux上安装docker：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p>
<p>docker info 可以查看docker的信息 docker version可以查看docker版本</p>
<p>安装要使用国内的镜像地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>如果运行的镜像没有 会从中央仓库下载 指令 <code>docker images </code> 查看镜像</p>
<p>启动docker:<code>systemctl start docker</code></p>
<p>查看版本:<code>docker -v</code></p>
<p>配置镜像加速</p>
<ul>
<li>mkdir -p /etc/docker</li>
<li>vim /etc/docker/daemon.json.rpmsave<ul>
<li><img src="/2021/03/19/docker/image-20201106103334369.png" alt="image-20201106103334369"></li>
</ul>
</li>
<li>systemctl daemon-reload</li>
<li>systemctl restart docker</li>
</ul>
<h1 id="docker原理"><a href="#docker原理" class="headerlink" title="docker原理"></a>docker原理</h1><p><img src="/2021/03/19/docker/log\source_posts\docker\image-20210326144801192.png" alt="image-20210326144801192"></p>
<p>docker为什么比vm快</p>
<ul>
<li>Docker有着比虚拟机更少的抽象层</li>
<li>docker利用的是宿主机的内核，vm需要Guest OS（虚拟机中的系统）</li>
</ul>
<p><img src="/2021/03/19/docker/log\source_posts\docker\image-20210326144957674.png" alt="image-20210326144957674"></p>
<h1 id="镜像的基本命令"><a href="#镜像的基本命令" class="headerlink" title="镜像的基本命令"></a>镜像的基本命令</h1><p>参考文档：<a href="https://docs.docker.com/engine/reference/commandline/docker/">https://docs.docker.com/engine/reference/commandline/docker/</a></p>
<p>docker images 显示镜像信息 </p>
<ul>
<li>-q只显示镜像的id </li>
<li>-a显示全部镜像</li>
<li>–digests:显示镜像的摘要信息</li>
<li>–no-trunc:显示完整的镜像信息</li>
</ul>
<p>docker search 搜索镜像</p>
<ul>
<li>-s n 收藏数不小于n的镜像</li>
<li>–no-trunc:显示完整的镜像信息</li>
<li>–automated:只列出automated build类型的镜像</li>
</ul>
<p>docker pull 拉取镜像 默认拉取最新版本</p>
<p>docker rmi 删除镜像 默认删除最新版本 需要先把容器停止 或者使用-f强制删除</p>
<ul>
<li>删除全部 docker -rmi -f $(docker images -qa)</li>
</ul>
<h1 id="容器的基本命令"><a href="#容器的基本命令" class="headerlink" title="容器的基本命令"></a>容器的基本命令</h1><p>新建容器并启动：docker run [可选参数] image</p>
<ul>
<li>–name = ‘’容器名字’’  为容器起一个名字如果不指定 随机分配一个名字</li>
<li>-d 后台方式运行</li>
<li>-i 使用交互方式运行 </li>
<li>-t 为容器重新分配一个伪输入端口 通常与i同时使用</li>
<li>-p:指定容器的端口</li>
<li>-P:随机端口映射</li>
<li>-p 主机端口:docker容器端口</li>
</ul>
<p>退出容器</p>
<ul>
<li>exit:容器停止并退出</li>
<li>crtl+p+q:容器不停止退出</li>
</ul>
<p>查看正在运行的容器：docker ps</p>
<ul>
<li>-a:列出当前所有正在运行的容器+历史上运行过的</li>
<li>-l:显示最近创建的容器</li>
<li>-n:显示最近n个创建的容器</li>
<li>-q:静默模式，只显示容器编号</li>
<li>–no-trunc:不截断输出</li>
</ul>
<p>启动容器docker start</p>
<p>重启容器docker restart</p>
<p>停止容器docker stop</p>
<p>强制停止容器docker kill</p>
<p>删除已停止的容器docker rm 容器id 加上参数-f可以强制删除</p>
<ul>
<li>一次性删除多个容器<ul>
<li>docker rm -f ${docker ps -a -q}</li>
<li>docker ps -a -q|xargs docker rm</li>
</ul>
</li>
</ul>
<p>查看容器日志docker logs -f -t –tail n 容器id </p>
<ul>
<li>-f可以不停的追加 实时显示日志信息</li>
</ul>
<p>查看容器内运行的进程 docke top 容器id</p>
<p>查看容器内部细节：docker inspect id</p>
<p>进入正在运行的容器并以命令行方式交互</p>
<ul>
<li><p>命令一：<code>docker exec -it 容器id /bin/bash</code>   进去容器后开启一个新的终端 可以在里面进行一些操作</p>
</li>
<li><p>命令二：<code>docker attach 容器id</code>      进入容器正在执行的终端 不会启动新的进程</p>
</li>
</ul>
<h1 id="从容器内拷贝文件到主机"><a href="#从容器内拷贝文件到主机" class="headerlink" title="从容器内拷贝文件到主机"></a>从容器内拷贝文件到主机</h1><p><img src="/2021/03/19/docker/log\source_posts\docker\image-20210326144737928.png" alt="image-20210326144737928"></p>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="部署mongodb"><a href="#部署mongodb" class="headerlink" title="部署mongodb"></a>部署mongodb</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">pull</span> <span class="selector-tag">mongo</span><span class="selector-pseudo">:latest</span></span><br><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">run</span> <span class="selector-tag">-itd</span> <span class="selector-tag">--name</span> <span class="selector-tag">mongo</span> <span class="selector-tag">-p</span> 27017<span class="selector-pseudo">:27017</span> <span class="selector-tag">mongo</span> <span class="selector-tag">--auth</span> <span class="selector-id">#--auth</span>表示需要密码才能访问容器服务</span><br><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">exec</span> <span class="selector-tag">-it</span> <span class="selector-tag">mongo</span> <span class="selector-tag">mongo</span> <span class="selector-tag">admin</span></span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.createUser</span>(&#123; <span class="attribute">user</span>:<span class="string">&#x27;admin&#x27;</span>,pwd:<span class="string">&#x27;admin&#x27;</span>,roles:[ &#123; role:<span class="string">&#x27;userAdminAnyDatabase&#x27;</span>, db: <span class="string">&#x27;admin&#x27;</span>&#125;,&quot;<span class="selector-tag">readWriteAnyDatabase</span>&quot;]&#125;);</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.admin</span>(&quot;<span class="selector-tag">admin</span>&quot;,&quot;<span class="selector-tag">admin</span>&quot;)</span><br></pre></td></tr></table></figure>

<p>部署rabbitmq</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> run -dit --name rabbitmq -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p <span class="number">15672</span>:<span class="number">15672</span> -p <span class="number">5672</span>:<span class="number">5672</span> <span class="number">867</span>da<span class="number">7</span>fcdf<span class="number">92</span></span><br></pre></td></tr></table></figure>

<h2 id="部署zookeeper"><a href="#部署zookeeper" class="headerlink" title="部署zookeeper"></a>部署zookeeper</h2><p>docker run -d –name zookeeper -p 2181:2181 -t wurstmeister/zookeeper</p>
<h2 id="部署kafka"><a href="#部署kafka" class="headerlink" title="部署kafka"></a>部署kafka</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span>  -d --name kafka -p 9092:9092 -e <span class="attribute">KAFKA_BROKER_ID</span>=0 -e <span class="attribute">KAFKA_ZOOKEEPER_CONNECT</span>=192.168.52.131:2181  -e <span class="attribute">KAFKA_ADVERTISED_LISTENERS</span>=PLAINTEXT://192.168.52.131:9092 -e <span class="attribute">KAFKA_LISTENERS</span>=PLAINTEXT://0.0.0.0:9092 -t wurstmeister/kafka </span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/lblblblblzdx/article/details/80548294?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs">参考文章</a></p>
<p>进入容器执行命令：<a href="https://www.hangge.com/blog/cache/detail_2791.html">https://www.hangge.com/blog/cache/detail_2791.html</a></p>
<h2 id="部署nginx"><a href="#部署nginx" class="headerlink" title="部署nginx"></a>部署nginx</h2><p>拉取镜像 docker pull nginx</p>
<p>启动容器 docker run -d –name nginx01 -p 80:80 nginx 在容器外访问3304可以访问到容器内的80端口</p>
<p>访问：crul localhost:3304 </p>
<h2 id="部署tomcat"><a href="#部署tomcat" class="headerlink" title="部署tomcat"></a>部署tomcat</h2><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200926194534367.png" alt="image-20200926194534367"></p>
<p>启动：docker run -d -p 3355:8080 –name tomcat01 tomcat</p>
<p>这个tomcat是极简版的 要把webapps.dist的文件拷贝到webapps</p>
<p>进入容器并复制：cp -r webapps.dist/* webapps</p>
<h2 id="部署es-kibana"><a href="#部署es-kibana" class="headerlink" title="部署es+kibana"></a>部署es+kibana</h2><p>启动es：<code>docker run -d --name elasticsearch -p9200:9200 -p9300:9300 -e &quot;discovery.type=single-node&quot;  elasticsearch:7.6.1</code></p>
<p>启动kibana：<code>docker run -d -p 5601:5601 --name kibana --link elasticsearch:elasticsearch docker.io/kibana:7.6.1</code></p>
<p>修改kibana容器中kibana.yml  把hosts改为自己的ip</p>
<p><img src="/2021/03/19/docker/kuangshen-notes\docker\image-20201107203220774.png" alt="image-20201107203220774"></p>
<p>es镜像的缺点：暴漏十分多的接口  十分耗内存 es的数据一般要放置在安全目录 </p>
<p>查看容器资源利用率:docker stats</p>
<p>关闭容器 修改配置文件 增加内存的限制 -e 环境配置修改</p>
<p>​    <code>docker run -d --name elasticsearch     -p9200:9200 -p9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.1</code></p>
<p><strong>安装ik分词器</strong></p>
<p>首先在docker中部署好es和kibana</p>
<p>在es中添加ik分词器插件:elasticsearch-plugin install <a href="https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.6.1/e">https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.6.1/e</a></p>
<p>重启es：docker restart id</p>
<h2 id="部署redis"><a href="#部署redis" class="headerlink" title="部署redis"></a>部署redis</h2><p>启动：docker run -p 6379:6379 -v /home/redis/data:/data -v /home/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis redis-server /usr/local/etc/redis/redis.conf –appendonly yes</p>
<p>执行客户端：docker exec -it id redis-cli</p>
<h2 id="部署RocketMQ"><a href="#部署RocketMQ" class="headerlink" title="部署RocketMQ"></a>部署RocketMQ</h2><p><strong>启动NameServer：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9876:9876 --name rmqserver  foxiswho/rocketmq:server-4.5.1</span><br></pre></td></tr></table></figure>

<p>启动broker：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 10911:10911 -p 10909:10909\</span><br><span class="line"> --name rmqbroker --link rmqserver:namesrv\</span><br><span class="line"> -e <span class="string">&quot;NAMESRV_ADDR=namesrv:9876&quot;</span> -e <span class="string">&quot;JAVA_OPTS=-Duser.home=/opt&quot;</span>\</span><br><span class="line"> -e <span class="string">&quot;JAVA_OPT_EXT=-server -Xms128m -Xmx128m&quot;</span>\</span><br><span class="line"> foxiswho/rocketmq:broker-4.5.1</span><br></pre></td></tr></table></figure>

<p>启动rocketmq console</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name rmqconsole -p 8180:8080 --link rmqserver:namesrv\</span><br><span class="line"> -e <span class="string">&quot;JAVA_OPTS=-Drocketmq.namesrv.addr=namesrv:9876\</span></span><br><span class="line"><span class="string"> -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot;</span>\</span><br><span class="line"> -t styletang/rocketmq-console-ng</span><br></pre></td></tr></table></figure>

<p>查询启动情况：docker ps|grep rocketmq</p>
<h2 id="Portainer可视化面板安装"><a href="#Portainer可视化面板安装" class="headerlink" title="Portainer可视化面板安装"></a>Portainer可视化面板安装</h2><p>安装：<code>docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</code></p>
<p>访问192.168.52.128:8088 选择本地连接</p>
<h1 id="镜像原理"><a href="#镜像原理" class="headerlink" title="镜像原理"></a>镜像原理</h1><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p>
<p>UnionFS (联合文件系统） :Union文件系统( UnionFS )是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtualfilesystem)。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>特性︰一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>
<h2 id="镜像加载原理"><a href="#镜像加载原理" class="headerlink" title="镜像加载原理"></a>镜像加载原理</h2><h3 id="联合文件系统"><a href="#联合文件系统" class="headerlink" title="联合文件系统"></a>联合文件系统</h3><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927094142961.png" alt="image-20200927094142961"></p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927094216063.png" alt="image-20200927094216063"></p>
<h3 id="分层理解"><a href="#分层理解" class="headerlink" title="分层理解"></a>分层理解</h3><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927094617723.png" alt="image-20200927094617723"></p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927094704724.png" alt="image-20200927094704724"></p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927094741483.png" alt="image-20200927094741483"></p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927094849878.png" alt="image-20200927094849878"></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927095058156.png" alt="image-20200927095058156"></p>
<h1 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h1><p>docker commit 提交容器成为一个新的副本</p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927114921514.png" alt="image-20200927114921514"></p>
<h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><h2 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h2><p>​    <img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927115914744.png" alt="image-20200927115914744"></p>
<p>作用：容器的持久化和同步操作，容器间数据共享</p>
<h2 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h2><p>使用命令挂载 -v : docker run -it -v  主机目录：容器内目录 <code>docker run -it -v /home/test:/home centos /bin/bash</code></p>
<p>容器的/home和主机上的home/test双向同步 无论修改哪个目录 会被同步到另一个目录</p>
<h2 id="实战：mysql同步数据"><a href="#实战：mysql同步数据" class="headerlink" title="实战：mysql同步数据"></a>实战：mysql同步数据</h2><p>启动mysql <code>docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=Bbj0611.. --name mysql01 mysql:5.7</code></p>
<h2 id="具名挂载和匿名挂载"><a href="#具名挂载和匿名挂载" class="headerlink" title="具名挂载和匿名挂载"></a>具名挂载和匿名挂载</h2><p>匿名挂载：-v 容器内目录 自动在主机生成一个目录    </p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927124330680.png" alt="image-20200927124330680"></p>
<p>具名挂载：-v 卷名：容器内路径</p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927124407311.png" alt="image-20200927124407311"></p>
<p>查看卷</p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927124449253.png" alt="image-20200927124449253"></p>
<p>拓展</p>
<p>​    <img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927124639590.png" alt="image-20200927124639590"></p>
<p>默认是rw</p>
<h2 id="使用dockerFile添加数据卷"><a href="#使用dockerFile添加数据卷" class="headerlink" title="使用dockerFile添加数据卷"></a>使用dockerFile添加数据卷</h2><p>创建/mydocker并进入 创建dockerfile</p>
<p><img src="/2021/03/19/docker/log\source_posts\docker\image-20210326150236879.png" alt="image-20210326150236879"></p>
<p>因为不同主机 目录不同 为了移植性更高 使用volueme只指定容器中的卷</p>
<p>使用build在当前目录下创建新的镜像：docker build -f /mydocker/dockerfile -t baobingjiang/centos .</p>
<h2 id="容器间传递共享"><a href="#容器间传递共享" class="headerlink" title="容器间传递共享"></a>容器间传递共享</h2><p>先启动一个父容器centos1:docker run -d -it –name centos1 62bb58c893b3 </p>
<p>再启动一个子容器centos2:docker run -d -it –volumes-from centos1 –name centos2 62bb58c893b3 </p>
<p>再创建一个子容器centos3</p>
<p>父子容器之间可以共享 父容器删除后子容器之间也可以共享</p>
<p>结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止</p>
<h1 id="DockFile"><a href="#DockFile" class="headerlink" title="DockFile"></a>DockFile</h1><p>dockerfile中的每条指令都会创建一个新的镜像层 并对镜像进行提交</p>
<p>保留字指令</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span>    基础镜像，当前新镜像是基于哪个镜像的。</span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span>    镜像维护者名字和邮箱地址</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">    容器构建时需要运行的命令 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span>     当期容器对外暴露的端口</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash">    指定在创建容器后，终端默认登陆进来工作的目录，一个落脚点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span>     用来在构建的过程中设置环境变量，这个环境变量可以在后续的任何 <span class="keyword">RUN</span><span class="bash"> 指令中使用，这就如同在命令前面指定了环境变量前缀一样；也可以直接在其他指令中使用这些变量.</span></span><br><span class="line">        比如:  前面写有 EVN  MY_PATH /home            使用： <span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$MY_PATH</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash">     将宿主机目录下的文件拷贝进镜像，且ADD命令会自动处理URL和解压tar压缩包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash">    类似ADD命令，拷贝文件和目录到镜像中，将构建上下文目录中&lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt; 位置</span></span><br><span class="line">　　　　 使用方式 <span class="number">1</span>. <span class="keyword">COPY</span><span class="bash"> 源路径  目标路径    2. COPY[<span class="string">&quot;源路径&quot;</span>,<span class="string">&quot;目标路径&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash">  容器数据卷，用于数据保存和持久化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash">    指定一个容器启动时需要运行的命令，Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run 后面的参数替换</span></span><br><span class="line"></span><br><span class="line">ENTPYPOINT 指定一个容器启动时需要运行的命令，ENTPYPOINT和<span class="keyword">CMD</span><span class="bash">一样都是在指定容器启动程序及参数。区别在于CMD只有最后一个生效， ENTPYPOINT 在docker run 后面追加参数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ONBUILD</span>   当构建一个被集成的Dockerfile时运行，父镜像在被子镜像集成后，父镜像的<span class="keyword">ONBUILD</span>会被触发</span><br></pre></td></tr></table></figure>

<p>onbuild:子镜像构建的时候 父镜像会打出这句话</p>
<p><img src="/2021/03/19/docker/kuangshen-notes\docker\image-20201107140036356.png" alt="image-20201107140036356"></p>
<h2 id="CMD和ENTRYPOINT的区别"><a href="#CMD和ENTRYPOINT的区别" class="headerlink" title="CMD和ENTRYPOINT的区别"></a>CMD和ENTRYPOINT的区别</h2><p>cmd</p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927161923734.png" alt="image-20200927161923734"></p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927161936716.png" alt="image-20200927161936716"></p>
<p>entrypoint</p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927161959296.png" alt="image-20200927161959296"></p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927162020831.png" alt="image-20200927162020831"></p>
<p>​    追加命令相当于执行了 ls -al</p>
<h1 id="构建自己的centos"><a href="#构建自己的centos" class="headerlink" title="构建自己的centos"></a>构建自己的centos</h1><p>创建dockfile</p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927160225714.png" alt="image-20200927160225714"></p>
<p>创建容器</p>
<p>​    <img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927160327806.png" alt="image-20200927160327806"></p>
<p>​    关于最后面的. ：<a href="https://blog.csdn.net/weixin_43002202/article/details/108735549">https://blog.csdn.net/weixin_43002202/article/details/108735549</a></p>
<p>启动容器 发现自动进入 /usr/local</p>
<p>通过docker history 查看镜像的构建过程</p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927161313804.png" alt="image-20200927161313804"></p>
<h1 id="构建自己的tomcat"><a href="#构建自己的tomcat" class="headerlink" title="构建自己的tomcat"></a>构建自己的tomcat</h1><p>dockerfile文件命名为Dockerfiles build会自动寻找这个文件 就不需要-f指定了</p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927175737851.png" alt="image-20200927175737851"></p>
<p>jdk和tomcat包都在当前目录下</p>
<p>启动</p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927180241076.png" alt="image-20200927180241076"></p>
<h1 id="发布镜像到docker-hub"><a href="#发布镜像到docker-hub" class="headerlink" title="发布镜像到docker hub"></a>发布镜像到docker hub</h1><p>登录docker hub账户 <code>docker login -u baobingjiang</code></p>
<p>给image设置一个tag：<code>docker tag 9b072cf047b2 baobingjiang/mycentos</code></p>
<p>push:<code> docker push baobingjiang/mycentos</code> </p>
<h1 id="发布镜像到阿里云容器服务"><a href="#发布镜像到阿里云容器服务" class="headerlink" title="发布镜像到阿里云容器服务"></a>发布镜像到阿里云容器服务</h1><p>创建命名空间</p>
<p>创建镜像仓库：本地的</p>
<p>将镜像推送到registry</p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927184738709.png" alt="image-20200927184738709"></p>
<h1 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h1><p>每启动一个docker容器     docker就会给docker容器分配一个ip 只要安装了docker 就会分配一个桥接模式网卡docker0 使用的技术是evth-pair</p>
<p>evth-pair:是一对的虚拟设备接口 他们都是成对出现的 一端连着协议 一端彼此相连 它可以充当一个桥梁 连接各种虚拟网络设备</p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927190719361.png" alt="image-20200927190719361"></p>
<p>原理图</p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927191252374.png" alt="image-20200927191252374"></p>
<p>所有的容器在不指定网络的情况下 都是docker0路由的 docker会给我们的容器分配一个默认的可用ip</p>
<h1 id="容器互联–link"><a href="#容器互联–link" class="headerlink" title="容器互联–link"></a>容器互联–link</h1><p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927192711585.png" alt="image-20200927192711585"></p>
<p>docker network ls 列出网卡</p>
<p>docker network inspect id查看网卡信息</p>
<p>通过docker inspect 容器id 可以看到再tomcat03中配置了tomcat02</p>
<p><img src="/2021/03/19/docker/kuangshen-notes\docker\image-20201107152325685.png" alt="image-20201107152325685"></p>
<p>通过docker exec -it tomcat03 cat /etc/hosts可以看到–link在hosts中增加了一个映射 </p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927193234115.png" alt="image-20200927193234115"></p>
<p>不建议使用–link  现在推荐使用自定义网络 因为docker0 不支持容器名连接访问</p>
<h1 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h1><p>网络模式</p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927194632317.png" alt="image-20200927194632317"></p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927194641080.png" alt="image-20200927194641080"></p>
<p>创建自定义网络：<code>docker network create --driver bridge  --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet </code></p>
<p>查看mynet信息：<code>docker network inspect mynet</code></p>
<p>通过自定义网路创建容器:<code>docker run -d -P --name tomcat01 --net mynet tomcat</code></p>
<p>自定义网络中 不同容器之间不仅可以通过ip地址ping通 还可以通过容器名ping通</p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927195532016.png" alt="image-20200927195532016"></p>
<h1 id="网络联通"><a href="#网络联通" class="headerlink" title="网络联通"></a>网络联通</h1><p>创建三个tomcat-net-01和tomcat-net-02在mynet下,tomcat01在docker0下 想让tomcat01和其他两个tomcat通信可以使用connect指令</p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200927200250001.png" alt="image-20200927200250001"></p>
<p>相当于一个容器有两个ip地址</p>
<h1 id="部署redis集群"><a href="#部署redis集群" class="headerlink" title="部署redis集群"></a>部署redis集群</h1><p>创建一个网络 <code>docker network create redisnet --subnet 172.38.0.0/16</code></p>
<p>通过脚本创建6个redis服务在/mydata下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for port in $(seq 1 6); \</span><br><span class="line">do \</span><br><span class="line">mkdir -p /mydata/redis/node-$&#123;port&#125;/conf</span><br><span class="line">touch /mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">cat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">port 6379 </span><br><span class="line">bind 0.0.0.0</span><br><span class="line">cluster-enabled yes </span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">cluster-announce-ip 172.38.0.1$&#123;port&#125;</span><br><span class="line">cluster-announce-port 6379</span><br><span class="line">cluster-announce-bus-port 16379</span><br><span class="line">appendonly yes</span><br><span class="line">EOF</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -p 6371:6379 -p 16371:16379 --name redis-1 \</span><br><span class="line">  -v /mydata/redis/node-1/data:/data \</span><br><span class="line">  -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">  -d --net redisnet --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>



<p>进入redis 使用的是sh：<code>docker exec -it redis-1 /bin/sh</code></p>
<p>建立集群 <code>redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379  172.38.0.13:6379  172.38.0.14:6379  172.38.0.15:6379  172.38.0.16:6379 -- cluster-replicas 1 </code></p>
<h1 id="SpringBoot微服务打包docker镜像"><a href="#SpringBoot微服务打包docker镜像" class="headerlink" title="SpringBoot微服务打包docker镜像"></a>SpringBoot微服务打包docker镜像</h1><p>创建一个project 并打包</p>
<p>创建一个Dockerfile文件</p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200928074944874.png" alt="image-20200928074944874"></p>
<p>将project的jar包和Dockerfile文件上传到linux的目录中</p>
<p>创建images</p>
<p><img src="/2021/03/19/docker/Users\baobingjiang\AppData\Roaming\Typora\typora-user-images\image-20200928075241846.png" alt="image-20200928075241846"></p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>面经总结</title>
    <url>/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="Mybatis一级、二级缓存"><a href="#Mybatis一级、二级缓存" class="headerlink" title="Mybatis一级、二级缓存"></a>Mybatis一级、二级缓存</h2><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>　Mybatis对缓存提供支持，但是在没有配置的默认情况下，它只开启一级缓存，一级缓存只是相对于同一个SqlSession而言。所以在参数和SQL完全一样的情况下，我们使用同一个SqlSession对象调用一个Mapper方法，往往只执行一次SQL，因为使用SelSession第一次查询后，MyBatis会将其放在缓存中，以后再查询的时候，如果没有声明需要刷新，并且缓存没有超时的情况下，SqlSession都会取出当前缓存的数据，而不会再次发送SQL到数据库。</p>
<p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210406141934323.png" alt="image-20210406141934323"></p>
<p>一级缓存的生命周期：当SqlSession调用close方法和clearCache方法或者执行更新操作 会使缓存失效</p>
<p>如何判断完全相同的两次查询</p>
<ul>
<li>传入的statementId</li>
<li>查询时要求的结果集中的结果范围<ul>
<li>sql语句和参数</li>
</ul>
</li>
</ul>
<h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>　MyBatis的二级缓存是Application级别的缓存，它可以提高对数据库查询的效率，以提高应用的性能</p>
<p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210406142221333.png" alt="image-20210406142221333"></p>
<p>SqlSessionFactory层面上的二级缓存默认是不开启的，二级缓存的开启需要进行配置，实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的。 也就是要求实现Serializable接口，配置方法很简单，只需要在映射XML文件配置就可以开启缓存了<cache>，如果我们配置了二级缓存就意味着：</cache></p>
<ul>
<li>映射语句文件中的所有select语句将会被缓存。</li>
<li>映射语句文件中的所有insert、update和delete语句会刷新缓存。</li>
<li>缓存会使用默认的Least Recently Used（LRU，最近最少使用的）算法来收回。</li>
<li>缓存会存储列表集合或对象(无论查询方法返回什么)的1024个引用</li>
<li>缓存会被视为是read/write(可读/可写)的缓存，意味着对象检索不是共享的，而且可以安全的被调用者修改，不干扰其他调用者或线程所做的潜在修改。</li>
</ul>
<p>除了在映射配置文件中设置开启缓存 还要在全局配置中开启</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个配置使全局的映射器(二级缓存)启用或禁用缓存--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        .....</span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    ....</span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Ping过程及其原理"><a href="#Ping过程及其原理" class="headerlink" title="Ping过程及其原理"></a>Ping过程及其原理</h2><p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210406144955826.png" alt="image-20210406144955826"></p>
<p>同一网段ping：如果主机A，要去 ping主机B，那么主机A，就要封装二层报文，他会先查自己的arp缓存表，如果没有B的MAC地址，就会向外发送一个ARP广播包</p>
<p>跨网段ping：如果主机A要ping主机C,那么主机A发现主机C的IP和自己不是同一网段,他就去找 <strong>网关</strong> 转发,但是他也不知道网关的MAC情况下呢?他就会向之前那个步骤一样 <strong>先发送一个ARP广播,学到网关的MAC,再发封装ICMP报文给网关路由器.**当路由器收到主机A发过来的ICMP报文,发现自己的目的地址是其本身MAC地址,根据目的的IP2.1.1.1,查路由表,发现2.1.1.1/24的路由表项,得到一个出口指针,去掉原来的MAC头部.加上自己的MAC地址向主机C转发( **如果网关也没有主机C的MAC地址,还是要向前面一个步骤一样,ARP广播一下即可相互学到….路由器2端口能学到主机D的MAC,主机D也能学到路由器2端口的MAC.</strong> .) </p>
<h2 id="ping命令使用的协议"><a href="#ping命令使用的协议" class="headerlink" title="ping命令使用的协议"></a>ping命令使用的协议</h2><p>使用的是<a href="http://www.so.com/s?q=ICMP&ie=utf-8&src=internal_wenda_recommend_text">ICMP</a>协议，是“Internet Control Message Protocol”（Internet控制消息协议）的缩写，是<a href="http://www.so.com/s?q=TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F&ie=utf-8&src=internal_wenda_recommend_text">TCP/IP协议族</a>的一个子协议，用于在IP主机、<a href="http://www.so.com/s?q=%E8%B7%AF%E7%94%B1%E5%99%A8&ie=utf-8&src=internal_wenda_recommend_text">路由器</a>之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。<br>它是用来检查网络是否通畅或者网络连接速度的命令。它所利用的原理是这样的：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少。</p>
<p>ICMP是网络层协议</p>
<h2 id="dns域名解析过程"><a href="#dns域名解析过程" class="headerlink" title="dns域名解析过程"></a><a href="https://blog.csdn.net/baidu_37964071/article/details/80500825?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&dist_request_id=1331974.5978.16185553650719277&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">dns域名解析过程</a></h2><h2 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h2><p>为什么要做主从复制？</p>
<p>1、在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p>
<p>2、做数据的热备</p>
<p>3、架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</p>
<p><strong>原理</strong></p>
<p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210406145829715.png" alt="image-20210406145829715"></p>
<ul>
<li>步骤一：主库db的更新事件(update、insert、delete)被写到binlog</li>
<li>步骤二：从库发起连接，连接到主库</li>
<li>步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库</li>
<li>步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log</li>
<li>步骤五：还会创建一个SQL线程，从relay log里面读取内容，从<strong>Exec_Master_Log_Pos</strong>位置开始执行读取到的更新事件，将更新内容写入到slave的db</li>
</ul>
<p>注：上面的解释是解释每一步做了什么，整个mysql主从复制是异步的，不是按照上面的步骤执行的。</p>
<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>序列化和反序列化的定义：</p>
<p>(1)Java序列化就是指把Java对象转换为字节序列的过程</p>
<p>​    Java反序列化就是指把字节序列恢复为Java对象的过程。</p>
<p>(2)序列化最重要的作用：在传递和保存对象时.保证对象的完整性和可传递性。对象转换为有序字节流,以便在网络上传输或者保存在本地文件中。</p>
<p>​    反序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。  </p>
<p>(3)序列化和反序列化的注意点：</p>
<p>​    ①序列化时，只对对象的状态进行保存，而不管对象的方法；</p>
<p>​    ②当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</p>
<p>​    ③当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；这是能用序列化解决深拷贝的重要原因；</p>
<p>​    ④并非所有的对象都可以序列化，至于为什么不可以，有很多原因了，比如：</p>
<p>​        安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列    化进行传输的过程中，这个对象的private等域是不受保护的；</p>
<p>​        资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现；</p>
<p>​    ⑤声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。</p>
<p>​    ⑥序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。为它赋予明确的值。显式地定义serialVersionUID有两种用途：在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</p>
<p>​    ⑦Java有很多基础类已经实现了serializable接口，比如String,Vector等。但是也有一些没有实现serializable接口的；</p>
<h2 id="JDBC原理"><a href="#JDBC原理" class="headerlink" title="JDBC原理"></a><a href="https://www.cnblogs.com/qlqwjy/p/8227665.html"><strong>JDBC原理</strong></a></h2><h2 id="java三大特性"><a href="#java三大特性" class="headerlink" title="java三大特性"></a>java三大特性</h2><p><strong>封装</strong></p>
<p>封装也称信息隐藏，是指利用抽象数据类型把数据和基于数据的操作封装起来，使其成为一个不可分割的整体，数据隐藏在抽象数据内部，尽可能的隐藏数据细节，只保留一些接口使其与外界发生联系。也就是说用户无需知道内部的数据和方法的具体实现细节，只需根据留在外部的接口进行操作就行。</p>
<p>为了保证属性的安全性可以把属性的访问修饰符改为private 通过setter和getter 方法访问和复制</p>
<p><strong>继承</strong></p>
<p>多个类具有共同的属性（成员变量）与行为（成员方法）的时候，将这些共同的部分抽取出来定义到一个公共的类中，其他及各类可以与这个公共的类形成继承关系，从而在多个类中不需要重 复定义公共部分。这个公共的类就是父类，其他的类就是子类。子类可以直接访问父类的非私有化成员变量，访问父类的私有化成员变量可以使用super.get()方法。</p>
<p>继承的特点：</p>
<p>（1）子类比父类强大<br>（2）java是单继承，不能进行多继承。但是可以继承多层子类（<strong>不建议继承超过3层</strong>）<br>（3）子类继承父类，但是对父类的成员变量是无法直接操作，只能通过父类继承过来的setter和getter方法.</p>
<p><strong>多态</strong></p>
<p>java程序中定义的引用变量所指向的具体类型和通过该引用类型发出的方法在调用时不确定，该引用变量发出的方法到底调用哪个类的实现的方法，必须在程序运行期间才能决定</p>
<p>多态有两种：引用多态和方法多态</p>
<h2 id="Object类中的方法"><a href="#Object类中的方法" class="headerlink" title="Object类中的方法"></a><a href="https://blog.csdn.net/qq_42570601/article/details/104049532">Object类中的方法</a></h2><h2 id="HashMap为什么使用拉链法解决地址冲突"><a href="#HashMap为什么使用拉链法解决地址冲突" class="headerlink" title="HashMap为什么使用拉链法解决地址冲突"></a>HashMap为什么使用拉链法解决地址冲突</h2><p>不用的key，可能会有相同的hashcode</p>
<h2 id="TCP和UDP的应用"><a href="#TCP和UDP的应用" class="headerlink" title="TCP和UDP的应用"></a>TCP和UDP的应用</h2><p>|||</p>
<p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210407215856506.png" alt="image-20210407215856506"></p>
<h2 id="数据先写Redis还是DB？redis缓存一致性问题？"><a href="#数据先写Redis还是DB？redis缓存一致性问题？" class="headerlink" title="数据先写Redis还是DB？redis缓存一致性问题？"></a><a href="https://blog.csdn.net/qq_20597727/article/details/88652045?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujs&dist_request_id=1330144.34982.16182132035436085&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujs">数据先写Redis还是DB？redis缓存一致性问题？</a></h2><h2 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a><a href="https://www.jianshu.com/p/47fd7f86c848">redis分布式锁</a></h2><h2 id="操作系统缓存一致性问题"><a href="#操作系统缓存一致性问题" class="headerlink" title="操作系统缓存一致性问题"></a><a href="https://www.cnblogs.com/HuiH/p/12690598.html">操作系统缓存一致性问题</a></h2><h2 id="有没有了解其他的缓存中间件？"><a href="#有没有了解其他的缓存中间件？" class="headerlink" title="有没有了解其他的缓存中间件？"></a>有没有了解其他的缓存中间件？</h2><p>1、MemCached介绍<br>MemCached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。它便于快速开发，减轻开发难度，解决了大数据量缓存的很多问题，本质上，它是一个简洁的key-value存储系统</p>
<p>2、MemCached工作原理<br>主要通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度。</p>
<p>Redis与MemCached的区别<br>（1）Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等；<br>（2）Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；<br>（3）虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘；<br>（4）分布式集群部署：<br>a、memcache集群节点间的数据是独立的，不能相互通讯，但可以利用magent开源软件解决 ;<br>b、Redis高可用的，可以做一主多从，主从之间进行数据同步。 当Master宕机后，通过选举算法(Paxos、Raft)从slave中选举出新Master继续对外提供服务，主机恢复后以slave的身份重新加入<br>（5）存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）；<br>（6）灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；</p>
<h2 id="分布式-session"><a href="#分布式-session" class="headerlink" title="分布式 session"></a><a href="https://blog.csdn.net/qq_35620501/article/details/95047642?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control">分布式 session</a></h2><h2 id="Spring-bean的循环依赖以及解决方式"><a href="#Spring-bean的循环依赖以及解决方式" class="headerlink" title="Spring-bean的循环依赖以及解决方式"></a><a href="https://louyuting.blog.csdn.net/article/details/77940767?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs&dist_request_id=1330147.35086.16182171424877071&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs">Spring-bean的循环依赖以及解决方式</a></h2><h2 id="为什么需要三层缓存？两层或者一层行不行"><a href="#为什么需要三层缓存？两层或者一层行不行" class="headerlink" title="为什么需要三层缓存？两层或者一层行不行"></a><a href="https://blog.csdn.net/zhangmingan123/article/details/111178263">为什么需要三层缓存？两层或者一层行不行</a></h2><h2 id="Java进程CPU占用率高的排查和常见解决方案"><a href="#Java进程CPU占用率高的排查和常见解决方案" class="headerlink" title="Java进程CPU占用率高的排查和常见解决方案"></a><a href="https://wangcw.blog.csdn.net/article/details/86242263?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-8.baidujs&dist_request_id=1330147.36178.16182310883074655&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-8.baidujs">Java进程CPU占用率高的排查和常见解决方案</a></h2><h2 id="给定-a、b-两个文件，各存放-50-亿个-URL，每个-URL-各占-64B，内存限制是-4G。请找出-a、b-两个文件共同的-URL"><a href="#给定-a、b-两个文件，各存放-50-亿个-URL，每个-URL-各占-64B，内存限制是-4G。请找出-a、b-两个文件共同的-URL" class="headerlink" title="给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL"></a><a href="https://www.cnblogs.com/aspirant/p/7154551.html">给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL</a></h2><h2 id="https的加密过程"><a href="#https的加密过程" class="headerlink" title="https的加密过程"></a><a href="https://blog.csdn.net/qq_32998153/article/details/80022489">https的加密过程</a></h2><h2 id="HTTPS的数字证书验证原理"><a href="#HTTPS的数字证书验证原理" class="headerlink" title="HTTPS的数字证书验证原理"></a><a href="https://blog.csdn.net/liuxingrong666/article/details/83869161?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">HTTPS的数字证书验证原理</a></h2><p>根据这篇文章回答这两个问题:客户端拿到服务端的证书后是怎么验证证书的合法性？证书有什么内容？</p>
<h2 id="InnoDB怎么解决幻读问题"><a href="#InnoDB怎么解决幻读问题" class="headerlink" title="InnoDB怎么解决幻读问题"></a>InnoDB怎么解决幻读问题</h2><p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/log\source_posts\面经总结\image-20210520171632061.png" alt="image-20210520171632061"></p>
<h2 id="Http，TCP，Socker之间的区别和联系"><a href="#Http，TCP，Socker之间的区别和联系" class="headerlink" title="Http，TCP，Socker之间的区别和联系"></a><a href="https://www.cnblogs.com/jing99/p/6181488.html">Http，TCP，Socker之间的区别和联系</a></h2><h2 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a><a href="https://www.cnblogs.com/q2546/p/11394723.html">List和Set的区别</a></h2><h2 id="HashMap查询复杂度"><a href="#HashMap查询复杂度" class="headerlink" title="HashMap查询复杂度"></a>HashMap查询复杂度</h2><p>面试官问了这么一个问题：你说HashMap的get迭代了一个链表，那怎么保证HashMap的时间复杂度O(1)?链表的查找的时间复杂度又是多少？</p>
<p>HashMap的get方法源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jdk1.7</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">return</span> getForNullKey();  </span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());  </span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];  </span><br><span class="line">         e != <span class="keyword">null</span>;  </span><br><span class="line">         e = e.next) &#123;  </span><br><span class="line">        Object k;  </span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))  </span><br><span class="line">            <span class="keyword">return</span> e.value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>分四步：<br>1.判断key，根据key算出索引。<br>2.根据索引获得索引位置所对应的键值对链表。<br>3.遍历键值对链表，根据key找到对应的Entry键值对。<br>4.拿到value。<br>分析：<br>以上四步要保证HashMap的时间复杂度O(1)，需要保证每一步都是O(1)，现在看起来就第三步对链表的循环的时间复杂度影响最大，链表查找的时间复杂度为O(n)，与链表长度有关。我们要保证那个链表长度为1，才可以说时间复杂度能满足O(1)。但这么说来只有那个hash算法尽量减少冲突，才能使链表长度尽可能短，理想状态为1。因此可以得出结论：HashMap的查找时间复杂度只有在最理想的情况下才会为O(1)，而要保证这个理想状态不是我们开发者控制的。</p>
<p>在jdk1.8中 如果链表长度超过8会转换为红黑树 时间复杂度为log(n)</p>
<h2 id="数组实现扩容栈"><a href="#数组实现扩容栈" class="headerlink" title="数组实现扩容栈"></a>数组实现扩容栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个数组容器 用于存储栈元素 data.length是最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [] data;</span><br><span class="line">    <span class="comment">//栈顶标记 用于标记栈顶元素的位置 当栈为空时,top=-1,栈中有效元素的个数是top+1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//默认最大容量为10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     创建一个默认容量为10的栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data=<span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     创建一个指定容量为capacity的栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(capacity&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            capacity=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.data=<span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将元素e入栈,如果当前的栈已经满了,则扩容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 用户指定入栈的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top+<span class="number">1</span>==data.length)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] newData = Arrays.copyOf(data,top * <span class="number">2</span>);</span><br><span class="line">            data = newData;</span><br><span class="line">        &#125;</span><br><span class="line">        data[++top]=e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     从栈中弹出一个元素,如果栈已经是空,则返回-1即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回当前栈顶的元素,如果栈为空则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top==-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈为空，无法弹栈元素&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[top--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     获取当前栈顶元素，如果栈为空，则返回-1即可</span></span><br><span class="line"><span class="comment">     <span class="doctag">@return</span> 返回当前栈顶元素，如果栈为空,如果栈为空,则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top==-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[top];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     判断当前栈是否为空</span></span><br><span class="line"><span class="comment">     <span class="doctag">@return</span> true表示栈空,否则栈不为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     清空当前的栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        top=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     获取栈中有效元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap不安全的原因"><a href="#HashMap不安全的原因" class="headerlink" title="HashMap不安全的原因"></a><a href="https://blog.csdn.net/swpu_ocean/article/details/88917958?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">HashMap不安全的原因</a></h2><h2 id="PriorityQueue原理"><a href="#PriorityQueue原理" class="headerlink" title="PriorityQueue原理"></a><a href="https://blog.csdn.net/u010623927/article/details/87179364">PriorityQueue原理</a></h2><h2 id="进程有哪些状态？是如何进行切换的"><a href="#进程有哪些状态？是如何进行切换的" class="headerlink" title="进程有哪些状态？是如何进行切换的"></a>进程有哪些状态？是如何进行切换的</h2><p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210415132137774.png" alt="image-20210415132137774"></p>
<h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h2><p> 存放进程的管理和控制信息的数据结构称为进程控制块。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。</p>
<p>在不同的操作系统中对进程的控制和管理机制不同，PCB中的信息多少也不一样，通常PCB应包含如下一些信息。</p>
<p>1、进程标识符 name：每个进程都必须有一个唯一的标识符，可以是字符串，也可以是一个数字。UNIX系统中就是一个整型数。在进程创建时由系统赋予。</p>
<p>2、进程当前状态 status：说明进程当前所处的状态。为了管理的方便，系统设计时会将相同的状态的进程组成一个队列，如就绪进程队列，等待进程则要根据等待的事件组成多个等待队列，如等待打印机队列、等待磁盘I/O完成队列等等。</p>
<p>3、进程相应的程序和数据地址，以便把PCB与其程序和数据联系起来。</p>
<p>4、进程资源清单。列出所拥有的除CPU外的资源记录，如拥有的I/O设备，打开的文件列表等。</p>
<p>5、进程优先级 priority：进程的优先级反映进程的紧迫程序，通常由用户指定和系统设置。UNIX系统采用用户设置和系统计算相结合的方式确定进程的优先级 。 </p>
<p>6、CPU现场保护区 cpustatus：当进程因某种原因不能继续占用CPU时（等待打印机），释放CPU，这时就要将CPU的各种状态信息保护起来，为将来再次得到处理机恢复CPU的各种状态，继续运行。</p>
<p>7、进程同步与通信机制 用于实现进程间互斥、同步和通信所需的信号量等。</p>
<p>8、进程所在队列PCB的链接字   根据进程所处的现行状态，进程相应的PCB参加到不同队列中。PCB链接字指出该进程所在队列中下一个进程PCB的首地址。</p>
<p>9、与进程有关的其他信息。 如进程记账信息，进程占用CPU的时间等。</p>
<h2 id="为什么要划分内核态和用户态"><a href="#为什么要划分内核态和用户态" class="headerlink" title="为什么要划分内核态和用户态"></a><a href="https://blog.csdn.net/qq_29996285/article/details/88078906?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs&dist_request_id=1331647.20720.16184648700343463&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs">为什么要划分内核态和用户态</a></h2><h2 id="操作系统用户态和内核态之间的切换过程"><a href="#操作系统用户态和内核态之间的切换过程" class="headerlink" title="操作系统用户态和内核态之间的切换过程"></a><a href="https://blog.csdn.net/ddna/article/details/4941373?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs">操作系统用户态和内核态之间的切换过程</a></h2><h2 id="内核线程的作用"><a href="#内核线程的作用" class="headerlink" title="内核线程的作用"></a>内核线程的作用</h2><ol>
<li>周期性的将dirty内存页同步到磁盘设备上。 比如 bpflush线程周期性的把dirty数据写回磁盘</li>
<li>内存页很少的情况下，把内存page 交换到磁盘空间。 比如kswapd，系统会为每一个NUMA创建一个kswapd进程，但是在非NUMA系统上，则仅有一个kswapd</li>
<li>管理延时动作</li>
<li>实现文件系统的事物日志</li>
</ol>
<h2 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a><a href="https://blog.csdn.net/xifeijian/article/details/8209783?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs">进程上下文切换</a></h2><h2 id="线程上下文切换和进程上下文切换的区别"><a href="#线程上下文切换和进程上下文切换的区别" class="headerlink" title="线程上下文切换和进程上下文切换的区别"></a><a href="https://www.msdn.hk/jshtml/jswz/752.html">线程上下文切换和进程上下文切换的区别</a></h2><h2 id="进程上下文切换频繁的后果"><a href="#进程上下文切换频繁的后果" class="headerlink" title="进程上下文切换频繁的后果"></a>进程上下文切换频繁的后果</h2><p>context switch过高会导致CPU频繁在寄存器和运行队列之间奔波 ，更多的时间花在了进程切换，而不是真正工作的进程上。直接的消耗包括CPU寄存器需要保存和加载，系统调度器的代码需要执行。间接消耗在于多核cache之间的共享数据。</p>
<h2 id="大量close-wait对系统影响"><a href="#大量close-wait对系统影响" class="headerlink" title="大量close_wait对系统影响"></a>大量close_wait对系统影响</h2><p>在服务器与客户端通信过程中，因服务器发生了socket未关导致的closed_wait发生</p>
<ol>
<li>导致服务器资源消耗过大</li>
<li>如果连接数满了，服务端进程将无法新建socket来响应新的请求。</li>
<li>假设你的程序会去连接另一个服务，而未正常关闭，那么可能导致你的程序超过最大连接数的时候报异常，引起连锁反应甚至导致程序崩溃</li>
</ol>
<h2 id="三次握手第三次报文丢失怎么办"><a href="#三次握手第三次报文丢失怎么办" class="headerlink" title="三次握手第三次报文丢失怎么办"></a>三次握手第三次报文丢失怎么办</h2><p><strong>Server端</strong></p>
<p>第三次的ACK在网络中丢失，那么Server 端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。 而Server重发SYN+ACK包的次数，可以通过设置</p>
<p>/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5. 如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。</p>
<p><strong>Client 端</strong></p>
<p>在linux c 中，client 一般是通过 connect() 函数来连接服务器的，而connect()是在 TCP的三次握手的第二次握手完成后就成功返回值。也就是说 client 在接收到 SYN+ACK包，它的TCP连接状态就为 established （已连接），表示该连接已经建立。那么如果 第三次握手中的ACK包丢失的情况下，Client 向 server端发送数据，Server端将以 RST包响应，方能感知到Server的错误。</p>
<p>关于rst包：<a href="https://blog.csdn.net/a_tu_/article/details/80389878">https://blog.csdn.net/a_tu_/article/details/80389878</a></p>
<h2 id="三次握手第二次报文丢失怎么办"><a href="#三次握手第二次报文丢失怎么办" class="headerlink" title="三次握手第二次报文丢失怎么办"></a>三次握手第二次报文丢失怎么办</h2><p>在发送完ACK+SYN报文后会启动一个定时器，超时没有收到ACK确认，会再次发送，会进行多次重试。超时时间依旧每次翻倍，重试次数可设置</p>
<h2 id="tcp的push标志位"><a href="#tcp的push标志位" class="headerlink" title="tcp的push标志位"></a><a href="https://blog.csdn.net/javajiawei/article/details/81987949">tcp的push标志位</a></h2><p>数据包先存放在tcp接受缓冲区中 收到带有push的报文后 在发送给应用层</p>
<h2 id="TCP的发送缓冲区和接收缓冲区"><a href="#TCP的发送缓冲区和接收缓冲区" class="headerlink" title="TCP的发送缓冲区和接收缓冲区"></a><a href="https://blog.csdn.net/kesenzhang/article/details/104881397">TCP的发送缓冲区和接收缓冲区</a></h2><h2 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a><a href="https://blog.csdn.net/baidu_17611285/article/details/80171239">TCP头部</a></h2><h2 id="UDP头部"><a href="#UDP头部" class="headerlink" title="UDP头部"></a><a href="https://blog.csdn.net/ASJBFJSB/article/details/80357111">UDP头部</a></h2><h2 id="偏向锁升级到轻量级锁"><a href="#偏向锁升级到轻量级锁" class="headerlink" title="偏向锁升级到轻量级锁"></a>偏向锁升级到轻量级锁</h2><ol>
<li><p>首先获取锁对象的 Markword，判断是否处于可偏向状态。（biased_lock=1、且 ThreadId 为空）</p>
</li>
<li><p>如果是可偏向状态，则通过 CAS 操作，把当前线程的 ID 写入到 MarkWord ，如果 cas 成功，表示已经获得了锁对象的偏向锁，接着执行同步代码块，如果 cas 失败，说明有其他线程已经获得了偏向锁， 这种情况说明当前锁存在竞争，需要撤销已获得偏向 锁的线程，并且把它持有的锁升级为轻量级锁（这个 操作需要等到全局安全点，也就是没有线程在执行字 节码）才能执行</p>
</li>
<li><p>如果是已偏向状态，需要检查 markword 中存储的 ThreadID 是否等于当前线程的 ThreadID a) 如果相等，不需要再次获得锁，可直接执行同步代码 块 b) 如果不相等，说明当前锁偏向于其他线程，需要撤销 偏向锁并升级到轻量级锁</p>
</li>
</ol>
<h2 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a><a href="https://blog.csdn.net/tjiyu/article/details/52959418?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">五种IO模型</a></h2><h2 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a><a href="https://www.jianshu.com/p/47fd7f86c848">Redis实现分布式锁</a></h2><h2 id="Redis主从同步"><a href="#Redis主从同步" class="headerlink" title="Redis主从同步"></a><a href="https://www.cnblogs.com/daofaziran/p/10978628.html">Redis主从同步</a></h2><h2 id="谈谈你对-Springboot-的理解？为什么要用-Springboot？"><a href="#谈谈你对-Springboot-的理解？为什么要用-Springboot？" class="headerlink" title="谈谈你对 Springboot 的理解？为什么要用 Springboot？"></a>谈谈你对 Springboot 的理解？为什么要用 Springboot？</h2><p>spring boot 是微服务框架的起点，他简化了配置过程、部署过程、监控过程。<br>它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了很多的框架，同时 将其他技术同spring结合起来。<br>为什么使用springboot：<br>其实就是简单、快速、方便！平时如果我们需要搭建一个spring web项目的时候需要怎么做呢？</p>
<p>1）配置web.xml，加载spring和spring mvc<br>2）配置数据库连接、配置spring事务<br>3）配置加载配置文件的读取，开启注解<br>4）配置日志文件<br>…<br>配置完成之后部署tomcat 调试<br>…<br>但是如果使用spring boot呢？</p>
<p>很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套web项目或者是构建一个微服务！</p>
<h2 id="springboot的配置方式有哪些"><a href="#springboot的配置方式有哪些" class="headerlink" title="springboot的配置方式有哪些"></a><a href="https://blog.csdn.net/weixin_43809795/article/details/109206340">springboot的配置方式有哪些</a></h2><h2 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h2><p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210416164524307.png" alt="image-20210416164524307"></p>
<h2 id="java垃圾回收机制"><a href="#java垃圾回收机制" class="headerlink" title="java垃圾回收机制"></a>java垃圾回收机制</h2><p>程序员不需要去关心内存动态分配和垃圾回收的问题，这一切都交给了JVM来处理.回收机制使用可达性分析算法判断哪些是垃圾对象，并把堆分为年轻代和老年代，分别用不同的垃圾回收算法进行垃圾回收</p>
<h2 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a><a href="https://blog.csdn.net/weixin_42228338/article/details/97684517?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&dist_request_id=1331978.491.16185720218088971&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">B树和B+树</a></h2><h2 id="redo日志的刷盘策略"><a href="#redo日志的刷盘策略" class="headerlink" title="redo日志的刷盘策略"></a><a href="https://blog.csdn.net/weixin_38629422/article/details/105813338">redo日志的刷盘策略</a></h2><h2 id="hashmap为何引入红黑树"><a href="#hashmap为何引入红黑树" class="headerlink" title="hashmap为何引入红黑树"></a><a href="https://blog.csdn.net/weixin_43258908/article/details/89174471">hashmap为何引入红黑树</a></h2><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a><a href="https://www.cnblogs.com/heyouxin/p/13037146.html">公平锁和非公平锁</a></h2><p>ReentrantLock怎么实现公平锁和非公平锁，底层？</p>
<h2 id="生产者消费者模式为什么使用notifyAll而不是notify-考虑了什么"><a href="#生产者消费者模式为什么使用notifyAll而不是notify-考虑了什么" class="headerlink" title="生产者消费者模式为什么使用notifyAll而不是notify 考虑了什么"></a><a href="https://blog.csdn.net/chenchaofuck1/article/details/51660119?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.baidujs">生产者消费者模式为什么使用notifyAll而不是notify 考虑了什么</a></h2><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a><a href="https://blog.csdn.net/yzpbright/article/details/112675352?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-1&spm=1001.2101.3001.4242">阻塞队列</a></h2><h2 id="spring事务"><a href="#spring事务" class="headerlink" title="spring事务"></a><a href="https://www.cnblogs.com/mseddl/p/11577846.html">spring事务</a></h2><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a><a href="https://www.jianshu.com/p/6dde7f92951e">协程</a></h2><h2 id="可重复读隔离级别的实现原理"><a href="#可重复读隔离级别的实现原理" class="headerlink" title="可重复读隔离级别的实现原理"></a><a href="https://www.cnblogs.com/lmj612/p/10598971.html">可重复读隔离级别的实现原理</a></h2><h2 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a><a href="https://blog.csdn.net/jisuanji12306/article/details/86363390">线程间的通信</a></h2><h2 id="mmap为什么效率高"><a href="#mmap为什么效率高" class="headerlink" title="mmap为什么效率高"></a><a href="https://blog.csdn.net/mg0832058/article/details/5890688?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.baidujs">mmap为什么效率高</a></h2><p>用户空间的虚拟内存中的虚拟地址 通过mmu转换为物理地址 然后再物理内存中进行查找 如果该页被缓存则直接返回 否则换页 </p>
<h2 id="虚拟内存？细说"><a href="#虚拟内存？细说" class="headerlink" title="虚拟内存？细说"></a><a href="https://www.cnblogs.com/yaoxiaowen/p/7805964.html">虚拟内存？细说</a></h2><h2 id="java负数的二进制表示"><a href="#java负数的二进制表示" class="headerlink" title="java负数的二进制表示"></a><a href="https://blog.csdn.net/zgrjkflmkyc/article/details/12185143">java负数的二进制表示</a></h2><h2 id="数据库四种锁"><a href="#数据库四种锁" class="headerlink" title="数据库四种锁"></a>数据库四种锁</h2><p>（1）共享锁(S锁, 读锁)<br>共享锁锁定的资源可以被其它用户读取，但其它用户不能修改它。在SELECT 命令执行时，SQL Server 通常会对对象进行共享锁锁定。通常加共享锁的数据页被读取完毕后，共享锁就会立即被释放。</p>
<p>（2）排他锁(X锁，写锁)<br>排他锁锁定的资源只允许进行锁定操作的程序使用，其它任何对该资源的操作均不会被接受。执行数据更新命令，即INSERT、UPDATE 或DELETE 命令时，SQL Server 会自动使用排他锁。但当对象上有其它锁存在时，无法对其加排他锁。排他锁一直到事务结束才能被释放。共享锁可以一层套一层的上锁，但排他锁只能加一个。</p>
<p>（3）乐观锁<br>总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现。</p>
<p>version方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p>（4）悲观锁<br>总是假设最坏的情况，每次取数据时都认为其他线程会修改该数据，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。根据范围，锁还可以划分成行级锁和表锁。</p>
<h2 id="隔离级别实现原理"><a href="#隔离级别实现原理" class="headerlink" title="隔离级别实现原理"></a><a href="https://www.cnblogs.com/wajika/p/6680200.html">隔离级别实现原理</a></h2><h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a><a href="https://www.jianshu.com/p/7a5b0043b035">什么是面向对象</a></h2><p>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</p>
<p>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</p>
<p>面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们我们使用的就是面向对象了。</p>
<p>面向过程：</p>
<p>优点：性能比面向对象好，因为类调用时需要实例化，开销比较大，比较消耗资源。<br>缺点：不易维护、不易复用、不易扩展.</p>
<p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 .<br>缺点：性能比面向过程差</p>
<h2 id="如何实现负载均衡"><a href="#如何实现负载均衡" class="headerlink" title="如何实现负载均衡"></a><a href="https://blog.csdn.net/wenjianfeng/article/details/92033268">如何实现负载均衡</a></h2><h2 id="同步队列和等待队列"><a href="#同步队列和等待队列" class="headerlink" title="同步队列和等待队列"></a><a href="https://blog.csdn.net/makecontral/article/details/78135531">同步队列和等待队列</a></h2><h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a><a href="https://segmentfault.com/a/1190000013075736">中间人攻击</a></h2><h2 id="实现BST"><a href="#实现BST" class="headerlink" title="实现BST"></a>实现BST</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BstTree</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getMin</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">while</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getMax</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">while</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">insertIntoBST</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        root = insertIntoBST(root, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">            root.right=  insertIntoBST(root.right,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        root = deleteNode(root, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete 考虑不同分支情况， 删除操作也需要自顶向下遍历查找到待删除节点位置</span></span><br><span class="line">    <span class="comment">// 0. 待删除节点为根节点</span></span><br><span class="line">    <span class="comment">// 1. 待删除节点无左孩子，用右孩子替代删除节点</span></span><br><span class="line">    <span class="comment">// 2. 待删除节点无右孩子，用左孩子替代删除节点</span></span><br><span class="line">    <span class="comment">// 3. 待删除节点既有右孩子又有左孩子，找到右子树的最小值替换待删除节点，然后删除右子树最小值</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">            root.right= deleteNode(root.right,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">            root.left = deleteNode(root.left,val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.right ==<span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode minNode = getMin(root);</span><br><span class="line">                root.val = minNode.val;</span><br><span class="line">                root.right = deleteNode(root.right,val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchBST</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        TreeNode target = searchBST(root, val);</span><br><span class="line">        <span class="keyword">return</span> target == <span class="keyword">null</span> ? -<span class="number">1</span> : target.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &gt; root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/huangdingsheng/article/details/99843453">参考博客1</a>        <a href="https://blog.csdn.net/sheepmu/article/details/38407221?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">参考博客2</a></p>
<h2 id="GCRoot有哪些"><a href="#GCRoot有哪些" class="headerlink" title="GCRoot有哪些"></a>GCRoot有哪些</h2><p> JVM垃圾回收的根对象的范围有以下几种：</p>
<p>（1）虚拟机栈和本地方法栈中引用的对象<br>（2）方法区中的类静态属性和常量引用的对象</p>
<h2 id="对多线程的理解"><a href="#对多线程的理解" class="headerlink" title="对多线程的理解"></a>对多线程的理解</h2><p><strong>多线程指的是在单个程序中可以同时运行多个不同的线程，执行不同的任务</strong></p>
<p>多线程并发编程是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。</p>
<p>并发编程三要素：原子性，可见性，有序性 。从这三个要素说一下如何保证多线程运行安全</p>
<h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。</p>
<p>索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。索引提供指向存储在表的指定列中的数据值的指针，然后根据您指定的排序顺序对这些指针排序。</p>
<h2 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a><a href="https://blog.csdn.net/MoreeVan/article/details/11977115?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs">AOP原理</a></h2><h2 id="三种垃圾收集算法的优劣"><a href="#三种垃圾收集算法的优劣" class="headerlink" title="三种垃圾收集算法的优劣"></a>三种垃圾收集算法的优劣</h2><p><strong>标记清除算法</strong></p>
<p>​    优点：标记-清除算法实现起来比较容易</p>
<p>​    缺点：但是有一个比较严重的问题就是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。</p>
<p><strong>复制算法</strong></p>
<pre><code> 优点：这种算法虽然实现简单，运行高效且不容易产生内存碎片。

 缺点：但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。</code></pre>
<p><strong>标记整理算法</strong></p>
<p>​    优点：碎片少 内存利用率高</p>
<p>​    缺点：算法复杂度大，执行步骤较多</p>
<h2 id="TCP和HTTP的区别"><a href="#TCP和HTTP的区别" class="headerlink" title="TCP和HTTP的区别"></a>TCP和HTTP的区别</h2><p> http是要基于TCP连接基础上的，简单的说，TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http是用来收发数据，即实际应用上来的。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理的代理类是实现了一个InvocationHandler的接口，我们通过reflect.Proxy的类的newProxyInstance方法就可以得到这个接口的实例，然后再来作为参数传递进去，这里每一个在代理类上处理的东西也会被重定向到调用处理器上。</p>
<p><img src="/2021/04/06/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/image-20210423105943552.png" alt="image-20210423105943552"></p>
<p>如果一个对象的a方法调用b方法不会触发动态代理 因为没有调用对象的代理类 </p>
<h2 id="JVM频繁Full-GC的解决经验"><a href="#JVM频繁Full-GC的解决经验" class="headerlink" title="JVM频繁Full GC的解决经验"></a><a href="https://blog.csdn.net/zhangfengaiwuyan/article/details/89380008">JVM频繁Full GC的解决经验</a></h2><h2 id="为什么会有STW"><a href="#为什么会有STW" class="headerlink" title="为什么会有STW"></a>为什么会有STW</h2><p>在进行标记的时候，如果工作线程不停止的话，那么肯定会有新对象生成。这些对象是没有被标记的，里面可能有存活的对象，也可能有已经没有被引用的垃圾对象。那么在标记完后，进行回收时。要如何回收？</p>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a><a href="https://blog.csdn.net/u011726984/article/details/79320004?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">CompletableFuture</a></h2><h2 id="为什么在-JDK8-中要将-HashMap-的链表转为红黑树"><a href="#为什么在-JDK8-中要将-HashMap-的链表转为红黑树" class="headerlink" title="为什么在 JDK8 中要将 HashMap 的链表转为红黑树"></a>为什么在 JDK8 中要将 HashMap 的链表转为红黑树</h2><p>因为通常情况下，链表长度很难达到8，但是特殊情况下链表长度为8，哈希表容量又很大，造成链表性能很差的时候，只能采用红黑树提高性能，这是一种应对策略。</p>
<h2 id="用-token-来验证信息和用密码登录的区别"><a href="#用-token-来验证信息和用密码登录的区别" class="headerlink" title="用 token 来验证信息和用密码登录的区别"></a><a href="https://blog.csdn.net/ly_twt/article/details/102217361">用 token 来验证信息和用密码登录的区别</a></h2><h2 id="oss和Oauth2-0"><a href="#oss和Oauth2-0" class="headerlink" title="oss和Oauth2.0"></a>oss和Oauth2.0</h2><p>OAuth2.0</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></li>
<li><a href="https://www.cnblogs.com/flashsun/p/7424071.html">https://www.cnblogs.com/flashsun/p/7424071.html</a></li>
<li>代码实现：<a href="https://www.zifangsky.cn/1313.html">https://www.zifangsky.cn/1313.html</a></li>
</ul>
<p>OSS</p>
<ul>
<li><a href="https://www.zifangsky.cn/1313.html">https://www.zifangsky.cn/1313.html</a></li>
<li>代码：<a href="https://gitee.com/zifangsky/OAuth2.0Demo/tree/master#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D">https://gitee.com/zifangsky/OAuth2.0Demo/tree/master#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D</a></li>
</ul>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ol>
<li><p>介绍一下项目</p>
</li>
<li><p>项目对JVM内存方面的考虑？</p>
</li>
<li><p>Redis存了啥？为什么要这么存？</p>
</li>
<li><p>项目有没有安全性考虑</p>
</li>
<li><p><strong>你的优势和劣势？</strong></p>
<ol>
<li>自学能力强、抗压能力强、能理解他人 懂得换位思考、责任心强、善于决策,独立思考</li>
<li>不注重细节、喜欢争论、过于理想化、不愿意承认失败、太追求细节导致拖延、不善于决策、不愿意寻求帮助、</li>
</ol>
</li>
<li><p>业余爱好</p>
</li>
<li><p>这几年的职业规划</p>
<ol>
<li>我今年刚毕业，对于工作方面的事情还没有一个很清楚的概念，不过我会在工作中不断的学习，切实的去了解工作当中所需要的技能。<br>更了解这个行业之后，我也会有针对性的改变自己的学习计划，使自己更加适应这个行业，朝着行业的大方向去发展。</li>
</ol>
</li>
</ol>
<ol start="8">
<li></li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="七大设计原则"><a href="#七大设计原则" class="headerlink" title="七大设计原则"></a>七大设计原则</h1><p>设计模式的目的：代码重用性高 可读性强 可扩展 可靠性高 使程序高内聚 低耦合</p>
<p>设计原则是各种设计模式的基础</p>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>对类来说 一个类应该只负责一项职责 </p>
<p>例如：类A负责两个不同职责a，b当a需求变更而改变A时 可能造成b执行错误 所以将类A的粒度分解成A1，A2</p>
<p>注意事项</p>
<ul>
<li>降低类的复杂度 一个类只负责一项职责</li>
<li>提高类的可选性，可维护性</li>
<li>降低变更而引起的影响</li>
</ul>
<p>方案一：在方式1的run方法中，违反了单一职责原则.解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility1</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">      vehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">      vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">      vehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交通工具类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">      System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案二：遵守单一职责原则但是这样做的改动很大，即将类分解，同时修改客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      RoadVehicle roadVehicle = <span class="keyword">new</span> RoadVehicle();</span><br><span class="line">      roadVehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line"></span><br><span class="line">      AirVehicle airVehicle = <span class="keyword">new</span> AirVehicle();</span><br><span class="line">      airVehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      WaterVehicle waterVehicle = <span class="keyword">new</span> WaterVehicle();</span><br><span class="line">      waterVehicle.run(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadVehicle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">      System.out.println(vehicle + <span class="string">&quot;公路运行&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirVehicle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">      System.out.println(vehicle + <span class="string">&quot;天空运行&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterVehicle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">      System.out.println(vehicle + <span class="string">&quot;水中运行&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案三：这种修改方法没有对原来的类做大的修改，只是增加方法，这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      Vehicle2 vehicle2  = <span class="keyword">new</span> Vehicle2();</span><br><span class="line">      vehicle2.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">      vehicle2.runWater(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">      vehicle2.runAir(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">      System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAir</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">      System.out.println(vehicle + <span class="string">&quot; 在天空上运行....&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runWater</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">      System.out.println(vehicle + <span class="string">&quot; 在水中行....&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>客户端不应该依赖其他不需要的接口 即一个类对另一个类的依赖应该建立在最小的接口上</p>
<p> <img src="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210322144710531.png" alt="image-20210322144710531"></p>
<p>Interface1对于AC不是最小接口并且BD必须去实现他们不需要的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;B 实现了 operation4&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;B 实现了 operation5&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;D 实现了 operation1&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;D 实现了 operation2&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;D 实现了 operation3&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;D 实现了 operation4&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;D 实现了 operation5&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A 类通过接口Interface1 依赖(使用) B类，但是只会用到1,2,3方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">      i.operation1();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">      i.operation2();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">      i.operation3();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C 类通过接口Interface1 依赖(使用) D类，但是只会用到1,4,5方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">      i.operation1();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">      i.operation4();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">      i.operation5();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法：将接口Interface1拆分为独立的几个接口，类A和类c分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则<br><img src="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210322144907809.png" alt="image-20210322144907809"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface3</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface3</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;D 实现了 operation1&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;D 实现了 operation4&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;D 实现了 operation5&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">      i.operation1();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface2 i)</span> </span>&#123;</span><br><span class="line">      i.operation2();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface2 i)</span> </span>&#123;</span><br><span class="line">      i.operation3();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><ol>
<li><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象</p>
</li>
<li><p>依赖倒转的中心思想是面向接口编程</p>
</li>
<li><p>依赖倒转原则是基于这样的设计理念:相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类,细节就是具体的实现类</p>
</li>
<li><p>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</p>
</li>
</ol>
<p><img src="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210322150008224.png" alt="image-20210322150008224"></p>
<p>注意事项</p>
<ul>
<li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.</li>
<li>变量的声明类型尽量是抽象类或接口,这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化</li>
<li>继承时遵循里氏替换原则</li>
</ul>
<p>方法一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完成Person接收消息的功能</span></span><br><span class="line"><span class="comment">//1. 简单，比较容易想到</span></span><br><span class="line"><span class="comment">//2. 如果我们获取的对象是 微信，短信等等，则需要新增类，同时Perons也要增加相应的接收方法</span></span><br><span class="line"><span class="comment">//3. 解决思路：引入一个抽象的接口IReceiver, 表示接收者, 这样Person类与接口IReceiver发生依赖</span></span><br><span class="line"><span class="comment">//   因为Email, WeeiiXiin 等等属于接收的范围，他们各自实现IReceiver 接口就ok, 这样我们就符号依赖倒转原则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Email email )</span> </span>&#123;</span><br><span class="line">      System.out.println(email.getInfo());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//客户端无需改变</span></span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		person.receive(<span class="keyword">new</span> Email());</span><br><span class="line"></span><br><span class="line">		person.receive(<span class="keyword">new</span> WeiXin());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加微信</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiXin</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;微信信息: hello,ok&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里我们是对接口的依赖</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceiver receiver )</span> </span>&#123;</span><br><span class="line">		System.out.println(receiver.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><ol>
<li>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</li>
<li>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法</li>
<li>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合,依赖来解决问题。</li>
</ol>
<p>方案一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Liskov</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      A a = <span class="keyword">new</span> A();</span><br><span class="line">      System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">      B b = <span class="keyword">new</span> B();</span><br><span class="line">      System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11-3</span></span><br><span class="line">      System.out.println(<span class="string">&quot;1-8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1-8</span></span><br><span class="line">      System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 返回两个数的差</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 - num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这里，重写了A类的方法, 可能是无意的</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Liskov</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      A a = <span class="keyword">new</span> A();</span><br><span class="line">      System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">      B b = <span class="keyword">new</span> B();</span><br><span class="line">      <span class="comment">//因为B类不再继承A类，因此调用者，不会再func1是求减法</span></span><br><span class="line">      <span class="comment">//调用完成的功能就会很明确</span></span><br><span class="line">      System.out.println(<span class="string">&quot;11+3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11+3</span></span><br><span class="line">      System.out.println(<span class="string">&quot;1+8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1+8</span></span><br><span class="line">      System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//使用组合仍然可以使用到A类相关方法</span></span><br><span class="line">      System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func3(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">// 这里本意是求出11-3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个更加基础的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">   <span class="comment">//把更加基础的方法和成员写到Base类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 返回两个数的差</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 - num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">   <span class="comment">//如果B需要使用A类的方法,使用组合关系</span></span><br><span class="line">   <span class="keyword">private</span> A a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//我们仍然想使用A的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.a.func1(a, b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节。</p>
<p>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
<p> 方法一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//使用看看存在的问题</span></span><br><span class="line">      GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">   <span class="comment">//接收Shape对象，然后根据type，来绘制不同的图形</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (s.m_type == <span class="number">1</span>)</span><br><span class="line">         drawRectangle(s);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>)</span><br><span class="line">         drawCircle(s);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">3</span>)</span><br><span class="line">         drawTriangle(s);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//绘制矩形</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//绘制圆形</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//绘制三角形</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTriangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   Rectangle() &#123;</span><br><span class="line">      <span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   Circle() &#123;</span><br><span class="line">      <span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   Triangle() &#123;</span><br><span class="line">      <span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//使用看看存在的问题</span></span><br><span class="line">      GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> OtherGraphic());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">   <span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">      s.draw();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"><span class="comment">// int m_type;</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"><span class="comment">// Rectangle() &#123;</span></span><br><span class="line"><span class="comment">//    super.m_type = 1;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"><span class="comment">// Circle() &#123;</span></span><br><span class="line"><span class="comment">//    super.m_type = 2;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"><span class="comment">// Triangle() &#123;</span></span><br><span class="line"><span class="comment">//    super.m_type = 3;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增一个图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherGraphic</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"><span class="comment">// OtherGraphic() &#123;</span></span><br><span class="line"><span class="comment">//    super.m_type = 4;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制其它图形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><ol>
<li>一个对象应该对其他对象保持最少的了解类与类关系越密切，耦合度越大</li>
<li>迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息</li>
<li>迪米特法则还有个更简单的定义:只与直接的朋友通信</li>
<li>直接的朋友:每个对象都会与其他对象耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</li>
</ol>
<p>方法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">      SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">      <span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">      schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">   <span class="comment">//返回学院的所有员工</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">         CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">         emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">         list.add(emp);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">   <span class="comment">//返回学校总部的员工</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">         Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">         emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">         list.add(emp);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//分析问题</span></span><br><span class="line">      <span class="comment">//1. 这里的 CollegeEmployee 不是  SchoolManager的直接朋友</span></span><br><span class="line">      <span class="comment">//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager</span></span><br><span class="line">      <span class="comment">//3. 违反了 迪米特法则</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取到学院员工</span></span><br><span class="line">      List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();</span><br><span class="line">      System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">         System.out.println(e.getId());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//获取到学校总部员工</span></span><br><span class="line">      List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">      System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">         System.out.println(e.getId());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;~~~使用迪米特法则的改进~~~&quot;</span>);</span><br><span class="line">      <span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">      SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">      <span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">      schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">   <span class="comment">//返回学院的所有员工</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">         CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">         emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">         list.add(emp);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//输出学院员工的信息</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//获取到学院员工</span></span><br><span class="line">      List&lt;CollegeEmployee&gt; list1 = getAllEmployee();</span><br><span class="line">      System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">         System.out.println(e.getId());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">   <span class="comment">//返回学校总部的员工</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">         Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">         emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">         list.add(emp);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//分析问题</span></span><br><span class="line">      <span class="comment">//1. 将输出学院的员工方法，封装到CollegeManager</span></span><br><span class="line">      sub.printEmployee();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取到学校总部员工</span></span><br><span class="line">      List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">      System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">         System.out.println(e.getId());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>尽量使用合成/聚合的方式 而不是使用继承</p>
<p>博客：<a href="https://blog.csdn.net/u012361379/article/details/88605867">https://blog.csdn.net/u012361379/article/details/88605867</a></p>
<h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><p><a href="https://blog.csdn.net/tianhai110/article/details/6339565">继承、实现、依赖、关联、聚合、组合的联系与区别 </a></p>
<p>依赖关系：只要在类中用到了对方 他们之间就存在依赖关系 可以是成员属性 方法的返回类型 方法的参数</p>
<p>泛化关系：实际上就是继承关系 是依赖关系的特列</p>
<p>实现关系：A类实现B类 是依赖关系的特列</p>
<p>关联关系：他是依赖关系的特列 是一种拥有的关系,它使一个类知道另一个类的属性和方法。关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</p>
<p>  <img src="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210323141002509.png" alt="image-20210323141002509"></p>
<p>聚合关系：表现的是整体与部分的关系 是关联关系的特例 有导航性和多重性 如果整体与部分可以分开就是聚合 不能分开就是组合</p>
<p>组合关系：整体与部分的关系  但是整体与部分不可分开</p>
<p>组合和聚合的区别: <a href="https://blog.csdn.net/willlu10/article/details/79346948">https://blog.csdn.net/willlu10/article/details/79346948</a></p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>模式是解决某类问题的通用解决方法</p>
<p>设计模式分为三种类型 共23种（实际开发中 不止23种 可能会有其他变种 要灵活运用）</p>
<ul>
<li>创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。</li>
<li>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</li>
<li>行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式(Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)。</li>
</ul>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>概念：采取一定的方法保证在整个的软件系统中 对某个类只能存在一个对象实例 并且改类只提供一个取得其对象实例的方法</p>
<p>单列模式有以下八种方式</p>
<h3 id="饿汉式-静态常量"><a href="#饿汉式-静态常量" class="headerlink" title="饿汉式 静态常量"></a>饿汉式 静态常量</h3><p>这种方式在类加载的时候就完成实例化 避免了线程同步问题 如果从始至终从未使用过这个类 则会造成内存浪费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1. 构造器私有化, 外部能new</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="饿汉式-静态代码块"><a href="#饿汉式-静态代码块" class="headerlink" title="饿汉式 静态代码块"></a>饿汉式 静态代码块</h3><p>这种方式和上一种优缺点相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式(静态变量)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1. 构造器私有化, 外部能new</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">   <span class="keyword">private</span>  <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123; <span class="comment">// 在静态代码块中，创建单例对象</span></span><br><span class="line">      instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式 线程不安全"></a>懒汉式 线程不安全</h3><p>只能在单线程下使用 如果多线程下 一个线程进入判断语句 还未来得及往下执行 另一个线程也通过了这个判断语句 就会产生多个实例 所以在多线程环境下不可使用这种方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建 instance</span></span><br><span class="line">   <span class="comment">//即懒汉式</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="懒汉式-线程安全-同步方法"><a href="#懒汉式-线程安全-同步方法" class="headerlink" title="懒汉式 线程安全 同步方法"></a>懒汉式 线程安全 同步方法</h3><p>虽然解决线程不安全问题 但是效率太低 每次获得类的实例都要进行同步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">   <span class="comment">//即懒汉式</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="懒汉式-线程安全-同步代码块"><a href="#懒汉式-线程安全-同步代码块" class="headerlink" title="懒汉式 线程安全 同步代码块"></a>懒汉式 线程安全 同步代码块</h3><p> 这种方法不能起到线程同步的作用 假如一个线程进入了if判断 还没来得及向下执行 其他线程也通过了这个if会创建多个实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h3><p>实例化代码块只执行一次 后面再次访问时直接返回实例化对象 也避免了反复进行同步 线程安全 延迟加载 效率较高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span></span><br><span class="line">   <span class="comment">//同时保证了效率, 推荐使用</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">               instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>线程安全 延迟加载 效率较高 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态内部类完成， 推荐使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//构造器私有化</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//写一个静态内部类,该类中有一个静态属性 Singleton</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用枚举，可以实现单例, 推荐</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   INSTANCE; <span class="comment">//属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能<br>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new </p>
<p>单例模式使用的场景:需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即:重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session工厂等)</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="简单工厂模式-静态工厂方法"><a href="#简单工厂模式-静态工厂方法" class="headerlink" title="简单工厂模式/ 静态工厂方法"></a>简单工厂模式/ 静态工厂方法</h3><p>定义了一个创建对象的类 由这个类来封装实例化对象的行为</p>
<p>违反了开闭原则</p>
<p><a href="https://www.jianshu.com/p/5cb52d84bd6d">博客(静态工厂)</a></p>
<p><a href="https://www.runoob.com/design-pattern/factory-pattern.html">菜鸟教程（非静态）</a></p>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p><strong>工厂父类负责定义创建产品对象的公共接口</strong>，而工厂子类则负责生成具体的产品对象，这样做的目的是<strong>将产品类的实例化操作延迟到工厂子类中完成</strong>，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>
<p><a href="https://www.jianshu.com/p/c33e0848341e">博客</a></p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂是创建型设计模式，它强调了一系列相关产品对象（属于同一个产品族）的创建过程，它和工厂方法模式]的侧重点不同，工厂方法模式更加侧重于同一产品等级，而抽象工厂模式侧重的是同一产品族</p>
<p><a href="https://blog.csdn.net/start_mao/article/details/85946950?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase">博客 </a>     </p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式(Prototype模式)是指:用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象<br>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象,无需知道如何创建的细节<br>工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone()</p>
<p>关于深拷贝：<a href="https://www.cnblogs.com/xinruyi/p/11537963.html">https://www.cnblogs.com/xinruyi/p/11537963.html</a></p>
<p>博客：<a href="https://www.runoob.com/design-pattern/prototype-pattern.html">https://www.runoob.com/design-pattern/prototype-pattern.html</a></p>
<p>实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">private</span> String color;</span><br><span class="line">   <span class="keyword">private</span> String address = <span class="string">&quot;蒙古羊&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> Sheep friend; <span class="comment">//是对象, 克隆是会如何处理</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name, <span class="keyword">int</span> age, String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">      <span class="keyword">this</span>.color = color;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> color;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.color = color;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Sheep [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, color=&quot;</span> + color + <span class="string">&quot;, address=&quot;</span> + address + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">      Sheep sheep = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         sheep = (Sheep)<span class="keyword">super</span>.clone();</span><br><span class="line">         sheep.friend = (Sheep)friend.clone();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">         System.out.println(e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      <span class="keyword">return</span> sheep;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;原型模式完成对象的创建&quot;</span>);</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">&quot;tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line"></span><br><span class="line">      sheep.friend = <span class="keyword">new</span> Sheep(<span class="string">&quot;jack&quot;</span>, <span class="number">2</span>, <span class="string">&quot;黑色&quot;</span>);</span><br><span class="line"></span><br><span class="line">      Sheep sheep2 = (Sheep)sheep.clone();</span><br><span class="line">      Sheep sheep3 = (Sheep)sheep.clone();</span><br><span class="line">      Sheep sheep4 = (Sheep)sheep.clone();</span><br><span class="line">      Sheep sheep5 = (Sheep)sheep.clone();</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;sheep2 =&quot;</span> + sheep2 + <span class="string">&quot;sheep2.friend=&quot;</span> + sheep2.friend.hashCode());</span><br><span class="line">      System.out.println(<span class="string">&quot;sheep3 =&quot;</span> + sheep3 + <span class="string">&quot;sheep3.friend=&quot;</span> + sheep3.friend.hashCode());</span><br><span class="line">      System.out.println(<span class="string">&quot;sheep4 =&quot;</span> + sheep4 + <span class="string">&quot;sheep4.friend=&quot;</span> + sheep4.friend.hashCode());</span><br><span class="line">      System.out.println(<span class="string">&quot;sheep5 =&quot;</span> + sheep5 + <span class="string">&quot;sheep5.friend=&quot;</span> + sheep5.friend.hashCode());</span><br><span class="line">      System.out.println(sheep3.friend == sheep4.friend);</span><br><span class="line">      System.out.println(sheep3 == sheep4);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦,使得相同的创建过程可以创建不同的产品对象<br>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象<br>可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程<br>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”</p>
<p>四个角色：</p>
<ul>
<li>Product：一个具体的产品对象</li>
<li>Builder：创建一个Product对象的各个部件指定的接口/抽象类</li>
<li>ConcreteBuidler：实现接口 ，构建和装配各个部件</li>
<li>Director：构建一个使用Builder接口的对象，它主要用于创建一个复杂的对象，有两个主要作用</li>
<li>隔离了客户与对象的生产过程<ul>
<li>负责控制产品对象的生产过程</li>
</ul>
</li>
</ul>
<p><img src="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210324095013395.png" alt="image-20210324095013395"></p>
<p>博客：<a href="https://www.jianshu.com/p/3d1c9ffb0a28">https://www.jianshu.com/p/3d1c9ffb0a28</a></p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p> 基本介绍</p>
<ul>
<li>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)</li>
<li>主要分为三类：类适配器模式，对象适配器模式，接口适配器模式</li>
</ul>
<p>原理</p>
<ul>
<li>将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容</li>
<li>从用户的角度看不到被适配者，是解耦的</li>
<li>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</li>
<li>用户收到反馈结果，感觉只是和目标接口交互，如图</li>
</ul>
<p><img src="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210324095934939.png" alt="image-20210324095934939"></p>
<h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><p> Adapter类通过继承src类并实现dst接口 完成src-&gt;dst的适配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">   <span class="comment">//输出220V的电压</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;电压=&quot;</span> + src + <span class="string">&quot;伏&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> src;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dst</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      <span class="comment">//获取到220V电压</span></span><br><span class="line">      <span class="keyword">int</span> srcV = output220V();</span><br><span class="line">      <span class="keyword">int</span> dstV = srcV / <span class="number">44</span> ; <span class="comment">//转成 5v</span></span><br><span class="line">      <span class="keyword">return</span> dstV;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//充电</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charging</span><span class="params">(IVoltage5V iVoltage5V)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(iVoltage5V.output5V() == <span class="number">5</span>) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;电压为5V, 可以充电~~&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iVoltage5V.output5V() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;电压大于5V, 不能充电~~&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot; === 类适配器模式 ====&quot;</span>);</span><br><span class="line">      Phone phone = <span class="keyword">new</span> Phone();	</span><br><span class="line">      phone.charging(<span class="keyword">new</span> VoltageAdapter());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点</p>
<ul>
<li>Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点，因为这要求dst必须是接口，有一定局限性;</li>
<li>src类的方法在Adapter中都会暴露出来，也增加了使用的成本。</li>
<li>由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。</li>
</ul>
<h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p>基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题。即:持有src类，实现 dst类接口，完成src-&gt;dst的适配。根据合成复用原则，使用组合替代继承，所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口。使用成本更低，更灵活</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">   <span class="comment">//输出220V的电压，不变</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;电压=&quot;</span> + src + <span class="string">&quot;伏&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> src;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dst</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span>  <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Voltage220V voltage220V; <span class="comment">// 关联关系-聚合</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//通过构造器，传入一个 Voltage220V 实例</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter</span><span class="params">(Voltage220V voltage220v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.voltage220V = voltage220v;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> dst = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">null</span> != voltage220V) &#123;</span><br><span class="line">         <span class="keyword">int</span> src = voltage220V.output220V();<span class="comment">//获取220V 电压</span></span><br><span class="line">         System.out.println(<span class="string">&quot;使用对象适配器，进行适配~~&quot;</span>);</span><br><span class="line">         dst = src / <span class="number">44</span>;</span><br><span class="line">         System.out.println(<span class="string">&quot;适配完成，输出的电压为=&quot;</span> + dst);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> dst;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//充电</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charging</span><span class="params">(IVoltage5V iVoltage5V)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(iVoltage5V.output5V() == <span class="number">5</span>) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;电压为5V, 可以充电~~&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iVoltage5V.output5V() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;电压大于5V, 不能充电~~&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot; === 对象适配器模式 ====&quot;</span>);</span><br><span class="line">      Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">      phone.charging(<span class="keyword">new</span> VoltageAdapter(<span class="keyword">new</span> Voltage220V()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口适配器"><a href="#接口适配器" class="headerlink" title="接口适配器"></a>接口适配器</h3><p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法)，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求<br>适用于一个接口不想使用其所有的方法的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface4</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在AbsAdapter 我们将 Interface4 的方法进行默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsAdapter</span> <span class="keyword">implements</span> <span class="title">Interface4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//默认实现</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      AbsAdapter absAdapter = <span class="keyword">new</span> AbsAdapter() &#123;</span><br><span class="line">         <span class="comment">//只需要去覆盖我们 需要使用 接口方法</span></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">            System.out.println(<span class="string">&quot;使用了m1的方法&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      absAdapter.m1();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接模式(Bridge模式)是指:将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。<br>Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展</p>
<p>菜鸟教程：<a href="https://www.runoob.com/w3cnote/bridge-pattern2.html">https://www.runoob.com/w3cnote/bridge-pattern2.html</a></p>
<p> 角色：</p>
<ul>
<li><strong>Abstraction</strong>：抽象类。</li>
<li><strong>RefinedAbstraction</strong>：扩充抽象类。</li>
<li><strong>Implementor</strong>：实现类接口。</li>
<li><strong>ConcreteImplementor</strong>：具体实现类 。 </li>
</ul>
<p><img src="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210324101521361.png" alt="image-20210324101521361"></p>
<p><img src="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210324101528021.png" alt="image-20210324101528021"></p>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p><a href="https://www.runoob.com/design-pattern/decorator-pattern.html">https://www.runoob.com/design-pattern/decorator-pattern.html</a></p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</p>
<p><a href="https://www.runoob.com/design-pattern/composite-pattern.html">菜鸟教程</a></p>
<p>简化客户端操作:客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。<br>具有较强的扩展性:当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动.<br>方便创建出复杂的层次结构:客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构<br>需要遍历组织机构，或者处理的对象具有树形结构时，非常适合使用组合模式.要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式</p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p> 外观模式( Facade)，也叫“过程模式:外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用<br>外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节</p>
<p><a href="https://www.runoob.com/design-pattern/facade-pattern.html">菜鸟教程</a></p>
<p>外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性<br>外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展通过合理的使用外观模式，可以帮我们更好的划分访问的层次<br>当系统需要进行分层设计时，可以考虑使用Facade模式<br>在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性<br>不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的。</p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p> 享元模式（Flyweight Pattern)也叫蝇量模式:运用共享技术有效地支持大量细粒度的对象<br>常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象,可以从缓冲池里拿。这样可以降低系统内存，同时提高效率<br>享元模式经典的应用场景就是池技术了，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式</p>
<p> <a href="https://www.runoob.com/design-pattern/flyweight-pattern.html">菜鸟教程</a></p>
<p>享元模式提出了两个要求:细粒度和共享对象。这里就涉及到内部状态和外部状态了，即将对象的信息分为两个部分:内部状态和外部状态<br>内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。</p>
<p>比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点，所以棋子颜色就是棋子的内部状态﹔而各个棋子之间的差别就是位置的不同，当我们落子后，落子颜色是定的，但位置是变化的，所以棋子坐标就是棋子的外部状态</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>模板方法模式（Template Method Pattern），又叫模板模式(Template Pattern),在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。<br>简单说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤</p>
<p>钩子方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类，表示豆浆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SoyaMilk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//模板方法, make , 模板方法可以做成final , 不让子类去覆盖.</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      select();</span><br><span class="line">      <span class="keyword">if</span>(customerWantCondiments()) &#123;</span><br><span class="line">         addCondiments();</span><br><span class="line">      &#125;</span><br><span class="line">      soak();</span><br><span class="line">      beat();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//选材料</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;第一步：选择好的新鲜黄豆  &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//添加不同的配料， 抽象方法, 子类具体实现</span></span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//浸泡</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">soak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;第三步， 黄豆和配料开始浸泡， 需要3小时 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">beat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;第四步：黄豆和配料放到豆浆机去打碎  &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//钩子方法，决定是否需要添加配料</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">customerWantCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeanutSoyaMilk</span> <span class="keyword">extends</span> <span class="title">SoyaMilk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot; 加入上好的花生 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBeanSoyaMilk</span> <span class="keyword">extends</span> <span class="title">SoyaMilk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot; 加入上好的红豆 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PureSoyaMilk</span> <span class="keyword">extends</span> <span class="title">SoyaMilk</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      <span class="comment">//空实现</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">customerWantCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      <span class="comment">//制作红豆豆浆</span></span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;----制作红豆豆浆----&quot;</span>);</span><br><span class="line">      SoyaMilk redBeanSoyaMilk = <span class="keyword">new</span> RedBeanSoyaMilk();</span><br><span class="line">      redBeanSoyaMilk.make();</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;----制作花生豆浆----&quot;</span>);</span><br><span class="line">      SoyaMilk peanutSoyaMilk = <span class="keyword">new</span> PeanutSoyaMilk();</span><br><span class="line">      peanutSoyaMilk.make();</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;----制作纯豆浆----&quot;</span>);</span><br><span class="line">      SoyaMilk pureSoyaMilk = <span class="keyword">new</span> PureSoyaMilk();</span><br><span class="line">      pureSoyaMilk.make();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式(Command Pattern):在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，<br>我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计<br>命名模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。<br>在命名模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求(即命名)，同时命令模式也支持可撤销的操作。</p>
<p><a href="https://www.runoob.com/design-pattern/command-pattern.html">菜鸟教程</a></p>
<p>查看项目_1DesignPattern中命令模式的代码</p>
<p><img src="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210325094557402.png" alt="image-20210325094557402"></p>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>访问者模式(Visitor Pattern)，封装一些作用于某种数据结构的各元素的操作,它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。<br>主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题</p>
<p> <a href="https://www.runoob.com/design-pattern/visitor-pattern.html">菜鸟教程</a></p>
<p>具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的，这样造成了具体元素变更比较困难<br>违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素<br>因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的.</p>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>如果我们的集合元素是用不同的方式实现的，有数组，还有java的集合类,或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。<br>迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即:不暴露其内部的结构。</p>
<p> <a href="https://www.runoob.com/design-pattern/iterator-pattern.html">菜鸟教程</a></p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p> <a href="https://www.runoob.com/design-pattern/observer-pattern.html">菜鸟教程</a></p>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式(Mediator Pattern)，用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</p>
<p>博客：<a href="http://c.biancheng.net/view/1393.html">http://c.biancheng.net/view/1393.html</a></p>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>菜鸟：<a href="https://www.runoob.com/design-pattern/memento-pattern.html">https://www.runoob.com/design-pattern/memento-pattern.html</a></p>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>菜鸟</p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>菜鸟</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>菜鸟</p>
<p>状态模式和策略模式的区别：<a href="https://www.runoob.com/w3cnote/state-vs-strategy.html">https://www.runoob.com/w3cnote/state-vs-strategy.html</a></p>
<h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><p> 菜鸟</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>thrift</title>
    <url>/2021/05/08/thrift/</url>
    <content><![CDATA[<h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><p>代码：ThriftDemo</p>
<p>创建一个maven项目</p>
<p>导入jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>libthrift<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建thrift文件</p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span>  <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> sayHello(<span class="number">1</span>:<span class="built_in">string</span> username)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>thrift-0.9.0.exe 是官网提供的windows下编译工具，运用这个工具生成相关代码</p>
<p>在cmd中切换目录到thrift文件的根目录 进行编译：thrift-0.9.0.exe -r -gen java DemoHello.thrift</p>
<h1 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h1><p>代码：ThriftDemo</p>
<p>参考：<a href="https://segmentfault.com/a/1190000019752111">https://segmentfault.com/a/1190000019752111</a></p>
]]></content>
  </entry>
  <entry>
    <title>工作笔记</title>
    <url>/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="账号"><a href="#账号" class="headerlink" title="账号"></a>账号</h1><p>OA:     <a href="http://oa.bluefocusgroup.com:8088/">http://oa.bluefocusgroup.com:8088/</a>       303098  Bbj0611..</p>
<p>邮箱：<a href="https://mail.domob.cn/">https://mail.domob.cn/</a>  <a href="mailto:&#98;&#x69;&#x6e;&#103;&#106;&#x69;&#x61;&#110;&#103;&#46;&#98;&#97;&#x6f;&#x40;&#x64;&#111;&#109;&#111;&#98;&#x2e;&#x63;&#110;">&#98;&#x69;&#x6e;&#103;&#106;&#x69;&#x61;&#110;&#103;&#46;&#98;&#97;&#x6f;&#x40;&#x64;&#111;&#109;&#111;&#98;&#x2e;&#x63;&#110;</a> Bbj0611..</p>
<p> wifi : bingjiang.bao   Bfc@114912</p>
<p>上线环境跳板机：<a href="https://jms.domob-inc.com/">https://jms.domob-inc.com/</a>   bingjiang.bao   Bbj0611..</p>
<p>办公环境跳板机：bingjiang.bao     Bbj0611..</p>
<p>跳板机使用说明：Jumpserver跳板机使用说明.docx</p>
<p>上线atlantis：<a href="http://atlantis.domob-inc.cn/module/release_manager/707/">http://atlantis.domob-inc.cn/module/release_manager/707/</a>   <a href="mailto:&#x62;&#x69;&#x6e;&#103;&#106;&#105;&#x61;&#110;&#x67;&#x2e;&#x62;&#x61;&#x6f;&#x40;&#x64;&#111;&#x6d;&#x6f;&#98;&#x2e;&#x63;&#x6e;">&#x62;&#x69;&#x6e;&#103;&#106;&#105;&#x61;&#110;&#x67;&#x2e;&#x62;&#x61;&#x6f;&#x40;&#x64;&#111;&#x6d;&#x6f;&#98;&#x2e;&#x63;&#x6e;</a>     bingjiang.bao@DM#0510</p>
<p>gitlab:bingjiang.bao  Bbj0611..</p>
<p>jenkins：<a href="http://jenkins.domob-inc.cn/jenkins/">http://jenkins.domob-inc.cn/jenkins/</a>         <a href="mailto:&#x62;&#105;&#x6e;&#103;&#106;&#105;&#97;&#x6e;&#x67;&#46;&#x62;&#97;&#x6f;&#64;&#x64;&#x6f;&#109;&#111;&#x62;&#x2e;&#x63;&#x6e;">&#x62;&#105;&#x6e;&#103;&#106;&#105;&#97;&#x6e;&#x67;&#46;&#x62;&#97;&#x6f;&#64;&#x64;&#x6f;&#109;&#111;&#x62;&#x2e;&#x63;&#x6e;</a>     bingjiang.bao@DM#0510</p>
<p>服务器：bingjiang.bao    bingjiang.bao@DM#0510</p>
<p>​    开发机服务器：10.0.0.206</p>
<p>​    测试服务器：10.0.0.203</p>
<p>​    默认上传下载目录/home/bingjiang.bao</p>
<p>模块</p>
<ul>
<li><a href="http://git.domob-inc.cn/domobrta/rta_stats_collector.git">http://git.domob-inc.cn/domobrta/rta_stats_collector.git</a></li>
<li><a href="http://git.domob-inc.cn/domobrta/rta_stats_sync.git">http://git.domob-inc.cn/domobrta/rta_stats_sync.git</a></li>
<li><a href="http://git.domob-inc.cn/domobrtb/rtb-adinfo.git">http://git.domob-inc.cn/domobrtb/rtb-adinfo.git</a></li>
</ul>
<h1 id="week1"><a href="#week1" class="headerlink" title="week1"></a>week1</h1><h2 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h2><h3 id="修改代码并上传"><a href="#修改代码并上传" class="headerlink" title="修改代码并上传"></a>修改代码并上传</h3><p>把代码clone到linux /home/bingjiang.bao目录下 进行修改</p>
<p>修改代码之后 使用git flow 上传</p>
<p>git flow init</p>
<p>git flow feature start timeLogFeature</p>
<p>git flow feature publish timeLogFeature</p>
<p>提交到远程仓库 提交compare给群里的成员review</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510161845764.png" alt="image-20210510161845764"></p>
<p>没有问题之后结束feature：git flow feature finish timeLogFeature</p>
<p>提交到develop：git push origin develop</p>
<p>在gitlab上提交merge申请</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210519182634460.png" alt="image-20210519182634460"></p>
<h3 id="上传配置"><a href="#上传配置" class="headerlink" title="上传配置"></a>上传配置</h3><p>登录atlantis 进入负责的模块</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510161256085.png" alt="image-20210510161256085"></p>
<p>在linux上clone配置文件仓库</p>
<p>在仓库目录下 上传项目中的配置</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510160958148.png" alt="image-20210510160958148"><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510161028144.png" alt="image-20210510161028144"></p>
<p>并上传到配置仓库</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">git</span> <span class="string">clone http://atlantis.domob-inc.cn/git/module/707.git rta_stats_sync_conf</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">rta_stats_sync_conf</span></span><br><span class="line"><span class="attr">touch</span> <span class="string">README.md</span></span><br><span class="line"><span class="attr">git</span> <span class="string">add README.md</span></span><br><span class="line"><span class="attr">git</span> <span class="string">commit -m &#x27;first commit&#x27;</span></span><br><span class="line"><span class="attr">git</span> <span class="string">push -u origin master</span></span><br></pre></td></tr></table></figure>

<p>之后在配置管理中打tag并编辑配置</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510161409881.png" alt="image-20210510161409881"></p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510161417897.png" alt="image-20210510161417897"></p>
<h3 id="上线"><a href="#上线" class="headerlink" title="上线"></a>上线</h3><p>merge请求被通过之后 会触发钩子函数 发送请求到jenkins<strong>做一些事情</strong>比如从github上下载文件 执行build.sh等事情</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510172549747.png" alt="image-20210510172549747"></p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510172602515.png" alt="image-20210510172602515"></p>
<p>进行上线</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510172122005.png" alt="image-20210510172122005"></p>
<p>添加进程：添加一台服务器</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510172148413.png" alt="image-20210510172148413"></p>
<p>可以对进程进行分组管理</p>
<p>在上线管理中进行上线</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510172239565.png" alt="image-20210510172239565"></p>
<p>准备上线 -&gt; 选择要上线的服务</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510172310334.png" alt="image-20210510172310334"></p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210510172329595.png" alt="image-20210510172329595"></p>
<p>添加配置标签和版本号 上线前动作没意义 上线重启</p>
<h2 id="day02"><a href="#day02" class="headerlink" title="day02"></a>day02</h2><p>熟悉rta_stats_sync模块</p>
<p>在linux搭建运行环境</p>
<p>编辑.bash_profile 配置运行环境</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210511150758962.png" alt="image-20210511150758962"></p>
<p>执行source .bash_profile 刷新配置</p>
<p>拷贝.m2文件 用于maven</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210511150905097.png" alt="image-20210511150905097"></p>
<p>创建target目录</p>
<p>执行build.sh skip</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PNAME=RTBAdInfo</span><br><span class="line"></span><br><span class="line">VERSION=1.73.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SKIP=$@</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">maven编译生成target及lib目录</span></span><br><span class="line">if [ &quot;$SKIP&quot; = &quot;skip&quot; ]; then</span><br><span class="line">    mvn clean package -Dmaven.test.skip=true</span><br><span class="line">else</span><br><span class="line">    mvn clean package</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cd target</span><br><span class="line">VERSION=1.73.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SKIP=$@</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">maven编译生成target及lib目录</span></span><br><span class="line">if [ &quot;$SKIP&quot; = &quot;skip&quot; ]; then</span><br><span class="line">    mvn clean package -Dmaven.test.skip=true</span><br><span class="line">else</span><br><span class="line">    mvn clean package</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cd target</span><br><span class="line">SCRATCH_DIR=$PNAME-$VERSION</span><br><span class="line"></span><br><span class="line">if [ ! -f &quot;$SCRATCH_DIR&quot;.tar.gz ]; then</span><br><span class="line">   echo &quot;$SCRATCH_DIR&quot;.tar.gz does not exist!</span><br><span class="line">   exit -1</span><br><span class="line">tar -xvf &quot;$SCRATCH_DIR&quot;.tar.gz</span><br><span class="line">rm -rf &quot;$SCRATCH_DIR&quot;/config</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">对发布的文件做一些处理，版本号替换，修改权限等</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PNAME=RTBAdInfo</span><br><span class="line"></span><br><span class="line">VERSION=1.73.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SKIP=$@</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">maven编译生成target及lib目录</span></span><br><span class="line">if [ &quot;$SKIP&quot; = &quot;skip&quot; ]; then</span><br><span class="line">    mvn clean package -Dmaven.test.skip=true</span><br><span class="line">else</span><br><span class="line">    mvn clean package</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cd target</span><br><span class="line">SCRATCH_DIR=$PNAME-$VERSION</span><br><span class="line"></span><br><span class="line">if [ ! -f &quot;$SCRATCH_DIR&quot;.tar.gz ]; then</span><br><span class="line">   echo &quot;$SCRATCH_DIR&quot;.tar.gz does not exist!</span><br><span class="line">   exit -1</span><br><span class="line">tar -xvf &quot;$SCRATCH_DIR&quot;.tar.gz</span><br><span class="line">rm -rf &quot;$SCRATCH_DIR&quot;/config</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">对发布的文件做一些处理，版本号替换，修改权限等</span></span><br><span class="line">sed -i -e &quot;s/__BUILD_VERSION__/$VERSION/&quot; $SCRATCH_DIR/bin/RTBAdInfo</span><br><span class="line">find $SCRATCH_DIR/&#123;bin,lib&#125; -name &#x27;*.sh&#x27; -exec chmod +x &#123;&#125; \;</span><br><span class="line">find $SCRATCH_DIR/&#123;bin,lib&#125; -name &#x27;*.py&#x27; -exec chmod +x &#123;&#125; \;</span><br><span class="line">chmod +x $SCRATCH_DIR/bin/*</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">fpm --epoch `date +%s` -s dir -t rpm -n <span class="variable">$PNAME</span> -v <span class="variable">$VERSION</span> --rpm-defattrfile=0775 --prefix=/usr/<span class="built_in">local</span>/domob/prog.d <span class="variable">$SCRATCH_DIR</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">rm -rf <span class="variable">$SCRATCH_DIR</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生成一条软链 ln -s target/RTBAdinfo-1.73.2 current</p>
<p>从shell可以看到删除了当前文件夹下的配置文件 所以要拷贝linux中tmp下的配置文件到当前目录</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210511153436476.png" alt="image-20210511153436476"></p>
<p>再拷贝tmp下的RTBAdinfo.sh到当前目录</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210511153521966.png" alt="image-20210511153521966"></p>
<p>这个shell中通过软链启动项目 执行命令./RTBAdInfo.sh start 真正执行的是RTBAdinfo-1.73.2/bin/RTBAdinfo</p>
<p><strong>学习rta_Adinfo代码</strong></p>
<h2 id="day03"><a href="#day03" class="headerlink" title="day03"></a>day03</h2><p>学习rta_collect模块 改成mod模式 并提交</p>
<p>rta_collect模块上线</p>
<p>go项目在linux环境下  执行build.sh文件 生成可执行文件 然后执行即可</p>
<p>上线的时候 不要提交.idea vendors(依赖包目录) target bin 目录</p>
<h2 id="day04"><a href="#day04" class="headerlink" title="day04"></a>day04</h2><p>可以基于媒体x客户来，自定义的配置出价阈值。如果低于阈值，就触发报警。</p>
<p>报警的方式：通过飞书的Webhook</p>
<p>创建Webhook报警<a href="https://help.aliyun.com/document_detail/173081.html">https://help.aliyun.com/document_detail/173081.html</a></p>
<h1 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h1><h2 id="day01-1"><a href="#day01-1" class="headerlink" title="day01"></a>day01</h2><p>开发rta_stats_sync 出价率监控预警功能</p>
<p>go配置文件中不能使用运算符 否则读不到该配置</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210518132133637.png" alt="image-20210518132133637"></p>
<p>线上监控：<a href="https://jms.domob-inc.com/">https://jms.domob-inc.com</a></p>
<p>连接到该主机</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210520103003590.png" alt="image-20210520103003590"></p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210520103038680.png" alt="image-20210520103038680"></p>
<p>切换到该目录下</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210520103115469.png" alt="image-20210520103115469"></p>
<p>查看日志 判断是否符合预期</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210520105913264.png" alt="image-20210520105913264"></p>
<p>每次做修改之后再上线需要修改build.sh中的version版本 不然再次上线的时候 做的修改不会生效</p>
<p>切换go的版本为1.12 是线上环境的版本</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210522104817225.png" alt="image-20210522104817225"></p>
<h2 id="day02-1"><a href="#day02-1" class="headerlink" title="day02"></a>day02</h2><p>上线出价率预警功能</p>
<p>提交到develop的代码merge到master分支的时候显示有冲突：说明本地master已经领先develop 需要merge到develop</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210521180037592.png" alt="image-20210521180037592"></p>
<p>再push就可以提交merge请求了</p>
<h1 id="week3"><a href="#week3" class="headerlink" title="week3"></a>week3</h1><h2 id="day01-2"><a href="#day01-2" class="headerlink" title="day01"></a>day01</h2><p>测试出价率预警功能并修改</p>
<p>rta_stats_collector模块:从oss下载文件解析的时候 不需要创建一个个小文件然后再merge这种情况下 merge会消耗大量时间改为解析文件的时候就存储在一个大文件中 文件以时间和日期命名 没隔一小时创建一个新的文件 如果一小时之内文件大小超过10G 就把当前文件重命名(文件名后面加上当前时间戳) 并以当前的时间和日期创建一个新文件</p>
<ul>
<li>创建文件的时候 如果用Open创建文件 默认是不可写的 所以要手动赋予权限<ul>
<li><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210524211621865.png" alt="image-20210524211621865"></li>
</ul>
</li>
<li>函数结束后 函数中的协程还在继续 除非这个函数是main函数</li>
</ul>
<p>超过10G的文件或者超过n小时没有写入的文件要移动到线上环境的hivemerge目录下 </p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210527101646748.png" alt="image-20210527101646748"></p>
<h2 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h2><p>rta_open_processor模块</p>
<p><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210525112226370.png" alt="image-20210525112226370"></p>
<p>这里希望增加一个预估量级字段，并且能监控起来</p>
<ul>
<li>go context:<a href="https://www.cnblogs.com/zhangboyu/p/7456606.html">https://www.cnblogs.com/zhangboyu/p/7456606.html</a></li>
<li>GIN<ul>
<li><a href="https://www.jianshu.com/p/93b5cdd458b4">https://www.jianshu.com/p/93b5cdd458b4</a></li>
<li><a href="https://www.jianshu.com/p/98965b3ff638">https://www.jianshu.com/p/98965b3ff638</a></li>
<li>中间件：<a href="https://blog.csdn.net/yang1018679/article/details/97409507">https://blog.csdn.net/yang1018679/article/details/97409507</a></li>
</ul>
</li>
<li>prometheus:<a href="https://www.cnblogs.com/momoyan/p/9943268.html">https://www.cnblogs.com/momoyan/p/9943268.html</a></li>
</ul>
<p>通过发送预估数量级对象集合到某个接口 这个接口再把预估数量级写入db中</p>
<h1 id="question"><a href="#question" class="headerlink" title="question"></a>question</h1><ol>
<li>结构体中的互斥锁加锁的时候锁住了什么：相当于一个普通的互斥锁而已</li>
<li>多个协程在写文件 当有一个协程锁住这个文件的时候 其他协程会等待解锁因为 操作的是同一个文件 </li>
<li>go中结构体相当于一个类 该结构体被所有该类中创建的协程共享<ol>
<li><img src="/2021/05/10/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/log\source_posts\工作笔记\image-20210527114031763.png" alt="image-20210527114031763"></li>
</ol>
</li>
<li></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>golang</title>
    <url>/2021/05/09/golang/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h2><p>Go语言保证了既能到达静态编译语言的安全和性能，又达到了动态语言开发维护的高效率，使用一个表达式来形容Go语言:Go = C+ Python,说明Go语言既有c静态语言程序的运行速度，又能达到Python动态语言的快速开发。</p>
<ul>
<li>从c语言中继承了很多理念，包括表达式语法，控制结构，基础数据类型，调用参数传值，指针等等，也保留了和c语言一样的编译执行方式及弱化的指针。<br>引</li>
<li>入包的概念，用于组织程序结构，Go语言的一个文件都要归属于一个包，而不能单独存在。</li>
<li>垃圾回收机制，内存自动回收，不需开发人员管理</li>
<li>天然并发(重要特点)<ul>
<li>从语言层面支持并发，实现简单</li>
<li>goroutine轻量级线程，可实现大并发处理，高效利用多核</li>
<li>基于CPS并发模型实现</li>
</ul>
</li>
<li>吸收了管道通信机制，形成go语言特有的通道channel。通过管道channel，可以实现不同的goroute之间的相互通信</li>
<li>函数可以返回多个值</li>
<li>新的创新：切片 延时执行defer</li>
</ul>
<h2 id="编译和执行"><a href="#编译和执行" class="headerlink" title="编译和执行"></a>编译和执行</h2><ul>
<li>有了go源文件，通过编译器将其编译成机器可以识别的二进制码文件</li>
<li>在该源文件目录下，通过go build对 hello.go文件进行编译。可以指定生成的可执行文件名，在windows下必须是.exe后缀。<ul>
<li>go build -o myhello.exe hello.go</li>
</ul>
</li>
<li>如果程序没有任何错误就没有任何提示，会在当前目录下出现一个可执行文件，该文件是二进制文件。如果程序有错误 编译时，会在错误的那行报错</li>
<li>也可以使用go run指令 直接执行源码。这种方式需要在go环境下执行，可执行文件的执行不需要go环境但是编译器会将程序运行的依赖的库文件包含在可执行文件中，所以，可执行文件变大了很多</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>go编译器是对文件一行一行进行编译的 所以不要把多条语句写在同一行</p>
<p>go语言定义的变量或者import的包如果没有使用到 不能通过编译</p>
<p>注释与java一样</p>
<p>转义符：\t：制表符，\n：换行符，\r：回车</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">   <span class="comment">//如果不赋值 则使用默认值 </span></span><br><span class="line">   i = <span class="number">10</span></span><br><span class="line">   fmt.Println(i)</span><br><span class="line">   <span class="comment">//如果不声明数据类型 则根据值自动判定类型</span></span><br><span class="line">   <span class="keyword">var</span> x = <span class="number">11</span></span><br><span class="line">   fmt.Println(x)</span><br><span class="line">   <span class="comment">//这种方式等同于 var y int = 11</span></span><br><span class="line">   y := <span class="number">11</span></span><br><span class="line">   fmt.Println(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时声明多个变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一次性声明全局变量</span></span><br><span class="line"><span class="comment">//全局变量作用据在整个包都有效，如果首字母大写 则在整个程序有效</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> Sex = <span class="string">&quot;male&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   y    = <span class="number">100</span></span><br><span class="line">   sex2 = <span class="string">&quot;female&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//一次性声明局部变量</span></span><br><span class="line">   <span class="keyword">var</span> n1, n2, n3 <span class="keyword">int</span></span><br><span class="line">   fmt.Println(n1, n2, n3)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> m1, name, m3 = <span class="number">100</span>, <span class="string">&quot;bob&quot;</span>, <span class="number">23</span></span><br><span class="line">   fmt.Println(m1, name, m3)</span><br><span class="line"></span><br><span class="line">   b1, name, b3 := <span class="number">22</span>, <span class="string">&quot;tom&quot;</span>, <span class="number">23</span></span><br><span class="line">   fmt.Println(b1, name, b3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量在同一作用域数据类型不能变化，值可以变化</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="/2021/05/09/golang/log\source_posts\golang\image-20210512131113419.png" alt="image-20210512131113419"></p>
<p>int默认是int32</p>
<p>其他数值型</p>
<p><img src="/2021/05/09/golang/log\source_posts\golang\image-20210509122839263.png" alt="image-20210509122839263"></p>
<p>float64比float32精准 默认也是float64</p>
<p>浮点数常量有两种表示形式</p>
<ul>
<li>十进制数形式：5.12    .512</li>
<li>科学计数法形式：5.1234e2    5.12E-2</li>
</ul>
<p><strong>字符</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> c <span class="keyword">byte</span> = <span class="string">&#x27;s&#x27;</span></span><br><span class="line">   <span class="comment">//如果保存的字符对应值大于255 可以考虑使用int 一个汉字3字节</span></span><br><span class="line">   <span class="comment">//在go中 字符的本质是一个整数 输出的是该字符对应的utf8编码的码值</span></span><br><span class="line">   <span class="keyword">var</span> x <span class="keyword">int</span> = <span class="string">&#x27;你&#x27;</span></span><br><span class="line">   <span class="comment">//可以对整数进行格式化输出 输出的是该数字对应的unicode字符</span></span><br><span class="line">   <span class="keyword">var</span> y <span class="keyword">int</span> = <span class="number">20320</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//字符类型可以进行运算</span></span><br><span class="line">   <span class="keyword">var</span> n = c + <span class="number">10</span></span><br><span class="line">   fmt.Println(c, x) <span class="comment">//115 20320</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;y = %c\n&quot;</span>, y) <span class="comment">//y = 你</span></span><br><span class="line">   fmt.Println(n)  <span class="comment">//123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字符串</strong>:go语言的编码都统一成了utf-8 没有乱码问题</p>
<p>字符串类型是不可变的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> address = <span class="string">&quot;hello&quot;</span></span><br><span class="line">   address[<span class="number">0</span>] = <span class="string">&#x27;q&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果x想修改字符串可以转换成byte 和rune</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> str = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">   arr := []<span class="keyword">byte</span>(str)</span><br><span class="line">   arr[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span></span><br><span class="line">   str = <span class="keyword">string</span>(arr)</span><br><span class="line">   <span class="comment">//这种方式不能处理中文 会出现乱码 使用rune可以解决 rune按字符处理</span></span><br><span class="line">   arr2 := []<span class="keyword">rune</span>(str)</span><br><span class="line">   arr2[<span class="number">0</span>] = <span class="string">&#x27;就&#x27;</span></span><br><span class="line">   str = <span class="keyword">string</span>(arr2)</span><br><span class="line">   fmt.Println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bool类型占一个字节 只允许取值false和true</p>
<p>字符串的两种表现形式</p>
<ul>
<li>双引号 会识别转义字符 </li>
<li>反引号：以字符串的原生形式输出 包括换行和特殊字符 可以实现防止攻击 输出源代码等效果</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   str2 := <span class="string">&quot;abc\nabc&quot;</span></span><br><span class="line">   fmt.Println(str2)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//使用的反引号 ``</span></span><br><span class="line">   str3 := <span class="string">` </span></span><br><span class="line"><span class="string">   package main</span></span><br><span class="line"><span class="string">   import (</span></span><br><span class="line"><span class="string">      &quot;fmt&quot;</span></span><br><span class="line"><span class="string">      &quot;unsafe&quot;</span></span><br><span class="line"><span class="string">   )</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">   //演示golang中bool类型使用</span></span><br><span class="line"><span class="string">   func main() &#123;</span></span><br><span class="line"><span class="string">      var b = false</span></span><br><span class="line"><span class="string">      fmt.Println(&quot;b=&quot;, b)</span></span><br><span class="line"><span class="string">      //注意事项</span></span><br><span class="line"><span class="string">      //1. bool类型占用存储空间是1个字节</span></span><br><span class="line"><span class="string">      fmt.Println(&quot;b 的占用空间 =&quot;, unsafe.Sizeof(b) )</span></span><br><span class="line"><span class="string">      //2. bool类型只能取true或者false</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">   &#125;`</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(str3)</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>当一个字符串太长 可以分行写 但是注意 +号要留在上一行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//当一个拼接的操作很长时，怎么办，可以分行写,但是注意，需要将+保留在上一行.</span></span><br><span class="line">	str4 := <span class="string">&quot;hello &quot;</span> + <span class="string">&quot;world&quot;</span> + <span class="string">&quot;hello &quot;</span> + <span class="string">&quot;world&quot;</span> + <span class="string">&quot;hello &quot;</span> + </span><br><span class="line">	<span class="string">&quot;world&quot;</span> + <span class="string">&quot;hello &quot;</span> + <span class="string">&quot;world&quot;</span> + <span class="string">&quot;hello &quot;</span> + <span class="string">&quot;world&quot;</span> + </span><br><span class="line">	<span class="string">&quot;hello &quot;</span> + <span class="string">&quot;world&quot;</span></span><br><span class="line">	fmt.Println(str4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基本数据类型的默认值</strong>:整形和浮点型为0 字符串为”” 布尔类型为false</p>
<p><strong>基本数据类型的相互转换</strong></p>
<p>go在不同类型的变量之间赋值时需要显示转换 不能自动转换</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">23</span></span><br><span class="line">   <span class="keyword">var</span> j <span class="keyword">float64</span> = <span class="keyword">float64</span>(i)</span><br><span class="line">   fmt.Println(j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据类型转换可以从大到小 也可以从小到大 但是从大到小转换的时候会做溢出处理 </p>
<p>被转换的是变量存储的数据 变量本身的数据类型没有变化</p>
<p>基本类型转string类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">23</span></span><br><span class="line">    <span class="keyword">var</span> num2 <span class="keyword">float64</span> = <span class="number">32.3</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> myChar <span class="keyword">byte</span> = <span class="string">&#x27;s&#x27;</span></span><br><span class="line">    <span class="comment">//方法一：使用fmt.Sprintf函数</span></span><br><span class="line">    str = fmt.Sprintf(<span class="string">&quot;%d&quot;</span>,num)</span><br><span class="line">    str = fmt.Sprintf(<span class="string">&quot;%f&quot;</span>,num2)</span><br><span class="line">    str = fmt.Sprintf(<span class="string">&quot;%t&quot;</span>,b)</span><br><span class="line">    str = fmt.Sprintf(<span class="string">&quot;%c&quot;</span>,myChar)</span><br><span class="line">    <span class="comment">//方法二：使用strconv中的函数</span></span><br><span class="line">    str = strconv.FormatInt(<span class="keyword">int64</span>(num),<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    str = strconv.FormatFloat(num2,<span class="string">&#x27;f&#x27;</span>,<span class="number">10</span>,<span class="number">64</span>) <span class="comment">//10表示保留小数点10为 64表示float64</span></span><br><span class="line">    </span><br><span class="line">    str = strconv.FormatBool(b)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//int64转换为int</span></span><br><span class="line">    <span class="keyword">var</span> num5 <span class="keyword">int64</span> = <span class="number">4567</span></span><br><span class="line">	str = strconv.Itoa(<span class="keyword">int</span>(num5))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>string转基本类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">&quot;101&quot;</span></span><br><span class="line">   <span class="keyword">var</span> x <span class="keyword">int64</span></span><br><span class="line">   <span class="comment">//第二个参数是机制 第三个参数是默认值 如果转换不成数字返回结果为默认值</span></span><br><span class="line">   x,_ = strconv.ParseInt(str,<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line">   fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">23</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//&amp;：获取变量的地址</span></span><br><span class="line">	<span class="comment">//*int表示指针类型</span></span><br><span class="line">	<span class="keyword">var</span> ptr *<span class="keyword">int</span> = &amp;i</span><br><span class="line"></span><br><span class="line">	fmt.Println(&amp;i) <span class="comment">//0xc0000ac058</span></span><br><span class="line">	<span class="comment">//ptr指向的地址</span></span><br><span class="line">	fmt.Println(ptr) <span class="comment">//0xc0000ac058</span></span><br><span class="line">	<span class="comment">//ptr的地址</span></span><br><span class="line">	fmt.Println(&amp;ptr) <span class="comment">//0xc0000d8018</span></span><br><span class="line">	<span class="comment">//ptr指向的地址上面值 使用*获取指针类型所指向的值</span></span><br><span class="line">	fmt.Println(*ptr) <span class="comment">//23</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改之后i的值会变化</span></span><br><span class="line">	*ptr = <span class="number">10</span></span><br><span class="line">	fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值类型和引用类型</p>
<p><img src="/2021/05/09/golang/log\source_posts\golang\image-20210509132923543.png" alt="image-20210509132923543"></p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>运算符与java差不多但是不支持三元运算符</p>
<p>golang的自增和自减只能当作一个独立语言使用 并且只能写在变量后面</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//在golang中，++ 和 -- 只能独立使用.</span></span><br><span class="line">   <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">8</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line">   a = i++ <span class="comment">//错误，i++只能独立使用</span></span><br><span class="line">   a = i-- <span class="comment">//错误, i--只能独立使用</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> i++ &gt; <span class="number">0</span> &#123; <span class="comment">//错误</span></span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">   i++</span><br><span class="line">   ++i <span class="comment">// 错误，在golang没有 前++</span></span><br><span class="line">   i--</span><br><span class="line">   --i <span class="comment">// 错误，在golang没有 前--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h2><p>fmt.scanln和fmt.scanf</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;请输入姓名：&quot;</span>)</span><br><span class="line">   fmt.Scanln(&amp;name)</span><br><span class="line">    </span><br><span class="line">   fmt.Println(<span class="string">&quot;请输入姓名：&quot;</span>)</span><br><span class="line">   fmt.Scnaf(<span class="string">&quot;%s&quot;</span>,&amp;name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//二进制</span></span><br><span class="line">   <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;%b\n&quot;</span>,i)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//八进制</span></span><br><span class="line">   <span class="keyword">var</span> j <span class="keyword">int</span> = <span class="number">011</span></span><br><span class="line">   fmt.Println(j)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//十六进制</span></span><br><span class="line">   <span class="keyword">var</span> k <span class="keyword">int</span> = <span class="number">0x11</span></span><br><span class="line">   fmt.Println(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="程序流程控制"><a href="#程序流程控制" class="headerlink" title="程序流程控制"></a>程序流程控制</h1><p><strong>if</strong>：if中可以定义变量 但是作用域只在if块内有效</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> age := <span class="number">20</span>; age &gt; <span class="number">18</span> &#123;</span><br><span class="line">      fmt.Print(<span class="string">&quot;已成年&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>switch</strong></p>
<ul>
<li>case后的表达式可以有多个，使用逗号间隔</li>
<li>case语句不需要写break 默认会有</li>
<li>case后面表达式的类型必须与switch后表达式的类型相同</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> n1 <span class="keyword">int</span> = <span class="number">23</span></span><br><span class="line">   <span class="keyword">var</span> n2 <span class="keyword">int</span> = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> n1 &#123;</span><br><span class="line">      <span class="keyword">case</span> n2, <span class="number">5</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;没有匹配到&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch后面也可以不带表达式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">23</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> age &gt; <span class="number">18</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;已成年&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> age &lt; <span class="number">3</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;小孩&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;未成年&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch穿透：如果在case语句块后增加fallthrough 则会继续执行下一个case</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">23</span></span><br><span class="line">	<span class="comment">//会打印出已成年和小孩</span></span><br><span class="line">   <span class="keyword">switch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> age &gt; <span class="number">18</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;已成年&quot;</span>)</span><br><span class="line">         <span class="keyword">fallthrough</span></span><br><span class="line">      <span class="keyword">case</span> age &lt; <span class="number">3</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;小孩&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;未成年&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>for</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//第一种写法</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>;i &lt;= <span class="number">10</span>;i++ &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//第二种写法</span></span><br><span class="line">   j := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> j &lt;= <span class="number">10</span> &#123;</span><br><span class="line"></span><br><span class="line">      j++</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//第三种写法</span></span><br><span class="line">   k := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> k &lt; <span class="number">10</span> &#123;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      k++</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历字符串</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   str := <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(str);i++ &#123;</span><br><span class="line">      fmt.Println(str[i])</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用上面这种方式遍历字符串时 如果字符串中有中文会出现乱码 因为是按字节遍历</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//按字符遍历</span></span><br><span class="line">   str2 := <span class="string">&quot;您好&quot;</span></span><br><span class="line">   <span class="keyword">for</span> index,value := <span class="keyword">range</span> str2 &#123;</span><br><span class="line">      fmt.Println(index,value)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>go中没有while 和 do while</p>
<p>break跳出循环 continue结束本轮循环</p>
<p>goto：可以跳转到任意一行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="number">30</span></span><br><span class="line">   <span class="keyword">if</span> n &gt; <span class="number">20</span> &#123;</span><br><span class="line">      <span class="keyword">goto</span> label</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="number">2</span>)</span><br><span class="line">   label:</span><br><span class="line">      fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>return：用在main中表示中止程序</p>
<h1 id="函数，包和错误处理"><a href="#函数，包和错误处理" class="headerlink" title="函数，包和错误处理"></a>函数，包和错误处理</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>如果函数返回多个值，在接收时希望忽略某个返回值使用_符号</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndSub</span><span class="params">(a <span class="keyword">int</span>,b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + b,a -b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line">   _,a = SumAndSub(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">   fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的基本类型和数组都是值传递:如果希望传入函数内的变量能修改函数外的变量可以传入变量的地址&amp;,函数内以指针的方式操作变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   *a = *a + <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">12</span></span><br><span class="line">   test(&amp;a)</span><br><span class="line">   fmt.Println(a) <span class="comment">//22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>go函数不支持重载</p>
<p>函数也是一种数据类型 可以作为赋值给其他变量也可以作为参数传入其他函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   z := test.Cal</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%T&quot;</span>, z) <span class="comment">//func(int, int) int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>type自定义类型:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//go认为myint和int是两个类型</span></span><br><span class="line">   <span class="keyword">type</span> myint <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">var</span> num1 <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">   <span class="keyword">var</span> num2 myint = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">   num2 = myint(num1)</span><br><span class="line">   fmt.Println(num2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>支持对返回值命名</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a <span class="keyword">int</span> ,b <span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>,sub <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   sum = a + b</span><br><span class="line">   sub = a - b</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>支持可变参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//args是slice切片 如果一个函数有多个参数 可变参数要放在最后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(args... <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(args);i++ &#123;</span><br><span class="line">      sum += i</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>init函数</strong></p>
<p>每一个源文件都可以包含一个init函数，该函数会在main函数执行前，被Go运行框架调用，也就是说init会在main函数前被调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个文件同时包含全局变量定义，init函数和main函数 则执行流程是全局变量定义-&gt; init -&gt; main</p>
<p>面试题：如果main目录下的main.go和utils目录下的utils.go都含有变量定义 init函数 那么执行流程是？</p>
<p><img src="/2021/05/09/golang/log\source_posts\golang\image-20210512145932411.png" alt="image-20210512145932411"></p>
<p><strong>匿名函数</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> x = <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span> ,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b</span><br><span class="line">   &#125;(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将匿名函数赋给一个变量然后通过这个变量调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   x := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span> ,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b</span><br><span class="line">   &#125;</span><br><span class="line">   z := x(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局匿名函数：将匿名函数赋值给一个全局变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun1 = <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="keyword">int</span> ,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> n1 * n2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   x := fun1(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">   fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>闭包</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUpper</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="comment">//这个匿名函数引用到函数外的n 因此这个匿名函数就和n形成一个整体，构成闭包</span></span><br><span class="line">   <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      n += x</span><br><span class="line">      <span class="keyword">return</span> n</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   f := AddUpper()</span><br><span class="line">   fmt.Println(f(<span class="number">1</span>))</span><br><span class="line">   fmt.Println(f(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以理解为 闭包是类 函数时操作 变量是字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果名字没有指定的后缀就加上 然后返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSuffix</span><span class="params">(suffix <span class="keyword">string</span>)</span> <span class="title">func</span> <span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="comment">//参数suffix和返回的匿名函数构成闭包</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> !strings.HasSuffix(name,suffix)&#123;</span><br><span class="line">         <span class="keyword">return</span> name + suffix</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> name</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   f := makeSuffix(<span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">   fmt.Println(f(<span class="string">&quot;picture1&quot;</span>))</span><br><span class="line">   fmt.Println(f(<span class="string">&quot;picture1.jpg&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的defer:一种延时机制 为了在函数执行完毕后 及时的释放资源</p>
<p><img src="/2021/05/09/golang/log\source_posts\golang\image-20210509154701654.png" alt="image-20210509154701654"></p>
<p>defer语句放入栈时 相关的值拷贝也同时入栈</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="keyword">int</span> ,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="comment">//将defer后面的语句压入到独立的栈 当函数执行完毕后 再从defer栈按照先入后出的方式出栈，执行</span></span><br><span class="line">   <span class="comment">//相关的值拷贝也入栈</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(n1)</span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(n2)</span><br><span class="line">   n1++</span><br><span class="line">   <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   sum(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串常用系统函数"><a href="#字符串常用系统函数" class="headerlink" title="字符串常用系统函数"></a><strong>字符串常用系统函数</strong></h3><p>具体参考stirngs包</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//查找子串是否在指定的字符串中: strings.Contains(&quot;seafood&quot;, &quot;foo&quot;) //true</span></span><br><span class="line">   b := strings.Contains(<span class="string">&quot;seafood&quot;</span>, <span class="string">&quot;mary&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//统计一个字符串有几个指定的子串 ： strings.Count(&quot;ceheese&quot;, &quot;e&quot;) //4</span></span><br><span class="line">   num := strings.Count(<span class="string">&quot;ceheese&quot;</span>, <span class="string">&quot;e&quot;</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;num=%v\n&quot;</span>, num)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//10)不区分大小写的字符串比较(==是区分字母大小写的): fmt.Println(strings.EqualFold(&quot;abc&quot;, &quot;Abc&quot;)) // true</span></span><br><span class="line">   b = strings.EqualFold(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;Abc&quot;</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;b=%v\n&quot;</span>, b) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//11)返回子串在字符串第一次出现的index值，如果没有返回-1 : </span></span><br><span class="line">   <span class="comment">//strings.Index(&quot;NLT_abc&quot;, &quot;abc&quot;) // 4</span></span><br><span class="line">   index := strings.Index(<span class="string">&quot;NLT_abcabcabc&quot;</span>, <span class="string">&quot;abc&quot;</span>) <span class="comment">// 4</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;index=%v\n&quot;</span>,index)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//12)返回子串在字符串最后一次出现的index，</span></span><br><span class="line">   <span class="comment">//如没有返回-1 : strings.LastIndex(&quot;go golang&quot;, &quot;go&quot;)</span></span><br><span class="line">   index = strings.LastIndex(<span class="string">&quot;go golang&quot;</span>, <span class="string">&quot;go&quot;</span>) <span class="comment">//3</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;index=%v\n&quot;</span>,index)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将指定的子串替换成 另外一个子串: strings.Replace(&quot;go go hello&quot;, &quot;go&quot;, &quot;go语言&quot;, n) </span></span><br><span class="line">   <span class="comment">//n可以指定你希望替换几个，如果n=-1表示全部替换</span></span><br><span class="line"></span><br><span class="line">   str2 := <span class="string">&quot;go go hello&quot;</span></span><br><span class="line">   str := strings.Replace(str2, <span class="string">&quot;go&quot;</span>, <span class="string">&quot;北京&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str=%v str2=%v\n&quot;</span>, str, str2)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//按照指定的某个字符，为分割标识，将一个字符串拆分成字符串数组： </span></span><br><span class="line">   <span class="comment">//strings.Split(&quot;hello,wrold,ok&quot;, &quot;,&quot;)</span></span><br><span class="line">   strArr := strings.Split(<span class="string">&quot;hello,wrold,ok&quot;</span>, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(strArr); i++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;str[%v]=%v\n&quot;</span>, i, strArr[i])</span><br><span class="line">   &#125; </span><br><span class="line">   fmt.Printf(<span class="string">&quot;strArr=%v\n&quot;</span>, strArr)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//15)将字符串的字母进行大小写的转换: </span></span><br><span class="line">   <span class="comment">//strings.ToLower(&quot;Go&quot;) // go strings.ToUpper(&quot;Go&quot;) // GO</span></span><br><span class="line"></span><br><span class="line">   str = <span class="string">&quot;goLang Hello&quot;</span></span><br><span class="line">   str = strings.ToLower(str) </span><br><span class="line">   str = strings.ToUpper(str) </span><br><span class="line">   fmt.Printf(<span class="string">&quot;str=%v\n&quot;</span>, str) <span class="comment">//golang hello</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//将字符串左右两边的空格去掉： strings.TrimSpace(&quot; tn a lone gopher ntrn   &quot;)</span></span><br><span class="line">   str = strings.TrimSpace(<span class="string">&quot; tn a lone gopher ntrn   &quot;</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str=%q\n&quot;</span>, str)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//17)将字符串左右两边指定的字符去掉 ： </span></span><br><span class="line">   <span class="comment">//strings.Trim(&quot;! hello! &quot;, &quot; !&quot;)  // [&quot;hello&quot;] //将左右两边 ! 和 &quot; &quot;去掉</span></span><br><span class="line">   str = strings.Trim(<span class="string">&quot;! he!llo! &quot;</span>, <span class="string">&quot; !&quot;</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str=%q\n&quot;</span>, str)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//20)判断字符串是否以指定的字符串开头: </span></span><br><span class="line">   <span class="comment">//strings.HasPrefix(&quot;ftp://192.168.10.1&quot;, &quot;ftp&quot;) // true</span></span><br><span class="line"></span><br><span class="line">   b = strings.HasPrefix(<span class="string">&quot;ftp://192.168.10.1&quot;</span>, <span class="string">&quot;hsp&quot;</span>) <span class="comment">//true</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;b=%v\n&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间日期常用函数"><a href="#时间日期常用函数" class="headerlink" title="时间日期常用函数"></a>时间日期常用函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//看看日期和时间相关函数和方法使用</span></span><br><span class="line">   <span class="comment">//1. 获取当前时间</span></span><br><span class="line">   now := time.Now()</span><br><span class="line">   fmt.Printf(<span class="string">&quot;now=%v now type=%T\n&quot;</span>, now, now)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.通过now可以获取到年月日，时分秒</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;年=%v\n&quot;</span>, now.Year())</span><br><span class="line">   fmt.Printf(<span class="string">&quot;月=%v\n&quot;</span>, now.Month())</span><br><span class="line">   fmt.Printf(<span class="string">&quot;月=%v\n&quot;</span>, <span class="keyword">int</span>(now.Month()))</span><br><span class="line">   fmt.Printf(<span class="string">&quot;日=%v\n&quot;</span>, now.Day())</span><br><span class="line">   fmt.Printf(<span class="string">&quot;时=%v\n&quot;</span>, now.Hour())</span><br><span class="line">   fmt.Printf(<span class="string">&quot;分=%v\n&quot;</span>, now.Minute())</span><br><span class="line">   fmt.Printf(<span class="string">&quot;秒=%v\n&quot;</span>, now.Second())</span><br><span class="line"></span><br><span class="line">   <span class="comment">//格式化日期时间</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;当前年月日 %d-%d-%d %d:%d:%d \n&quot;</span>, now.Year(), </span><br><span class="line">   now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second())</span><br><span class="line"></span><br><span class="line">   dateStr := fmt.Sprintf(<span class="string">&quot;当前年月日 %d-%d-%d %d:%d:%d \n&quot;</span>, now.Year(), </span><br><span class="line">   now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second())</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;dateStr=%v\n&quot;</span>, dateStr)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//格式化日期时间的第二种方式</span></span><br><span class="line">   fmt.Printf(now.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">   fmt.Println()</span><br><span class="line">   fmt.Printf(now.Format(<span class="string">&quot;2006-01-02&quot;</span>))</span><br><span class="line">   fmt.Println()</span><br><span class="line">   fmt.Printf(now.Format(<span class="string">&quot;15:04:05&quot;</span>))</span><br><span class="line">   fmt.Println()</span><br><span class="line"></span><br><span class="line">   fmt.Printf(now.Format(<span class="string">&quot;2006&quot;</span>))</span><br><span class="line">   fmt.Println()</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//Unix和UnixNano的使用</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;unix时间戳=%v unixnano时间戳=%v\n&quot;</span>, now.Unix(), now.UnixNano())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间的常量</p>
<p><img src="/2021/05/09/golang/log\source_posts\golang\image-20210509161046950.png" alt="image-20210509161046950"></p>
<p>常量的作用：在程序中可用于获取指定时间单位的时间，比如想获得100毫秒 100 * time.Millisecond</p>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a><strong>内置函数</strong></h3><p>这些函数不用导包可以直接使用</p>
<ul>
<li>len：用来求长度</li>
<li>new：用来分配内存，返回的是指针</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   num1 := <span class="number">100</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;num1的类型%T , num1的值=%v , num1的地址%v\n&quot;</span>, num1, num1, &amp;num1)</span><br><span class="line"></span><br><span class="line">   num2 := <span class="built_in">new</span>(<span class="keyword">int</span>) <span class="comment">// *int</span></span><br><span class="line">   <span class="comment">//num2的类型%T =&gt; *int</span></span><br><span class="line">   <span class="comment">//num2的值 = 地址 0xc04204c098 （这个地址是系统分配）</span></span><br><span class="line">   <span class="comment">//num2的地址%v = 地址 0xc04206a020  (这个地址是系统分配)</span></span><br><span class="line">   <span class="comment">//num2指向的值 = 100</span></span><br><span class="line">   *num2  = <span class="number">100</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;num2的类型%T , num2的值=%v , num2的地址%v\n num2这个指针，指向的值=%v&quot;</span>, </span><br><span class="line">      num2, num2, &amp;num2, *num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h2><p>GO中处理异常的方式：defer，panic，recover</p>
<p>go中可以抛出一个panic的异常 然后在defer中通过recover不会这个异常 然后正常处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      err := <span class="built_in">recover</span>() <span class="comment">//捕获异常</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;err&quot;</span>,err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   num1 := <span class="number">10</span></span><br><span class="line">   num2 := <span class="number">0</span></span><br><span class="line">   res := num1 / num2</span><br><span class="line">   fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>go中也支持自定义错误 ，使用errors.New(返回一个error类型的值，表示一个错误)和panic内置函数(接受一个interface{}类型的值作为参数，可以接收error类型的变量，输出错误信息，并退出程序)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数去读取以配置文件init.conf的信息</span></span><br><span class="line"><span class="comment">//如果文件名传入不正确，我们就返回一个自定义的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readConf</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> name == <span class="string">&quot;config.ini&quot;</span> &#123;</span><br><span class="line">      <span class="comment">//读取...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//返回一个自定义错误</span></span><br><span class="line">      <span class="keyword">return</span> errors.New(<span class="string">&quot;读取文件错误..&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   err := readConf(<span class="string">&quot;config2.ini&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">//如果读取文件发送错误，就输出这个错误，并终止程序</span></span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;test02()继续执行....&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>在import时，路径从$GOPATH的src下开始 不用带src</p>
<p>如果报名较长，可以取别名，取别名后原来的包名就不能用了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">    util <span class="string">&quot;go_code/utils&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>同一个包下不能有相同的函数名</p>
<p>为了让其他包的文件 可以访问到本包下的函数 该函数的首字母要大写</p>
<p>如果要编译一个可执行程序文件，就需要将包声明为 main</p>
<h1 id="数组与切片"><a href="#数组与切片" class="headerlink" title="数组与切片"></a>数组与切片</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>go中 数组是值类型</p>
<p>如果想在其他函数中修改原阿里的数组可以使用引用传递</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(arr *[3]<span class="keyword">int</span>)</span></span> &#123; <span class="comment">//3可以省略</span></span><br><span class="line">   (*arr)[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">   test(&amp;arr)</span><br><span class="line">   fmt.Println(arr[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组的定义：var 数组名 [数组大小]数据类型</p>
<p>数组创建后如果没赋值 有默认值</p>
<p>数组的第一个元素的地址就是数组的地址</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">      arr[i] = i</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println</span>(&amp;arr)</span><br><span class="line">   <span class="built_in">println</span>(&amp;arr[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组初始化的四种方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> arr1 [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">   <span class="keyword">var</span> arr2 = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">   <span class="keyword">var</span> arr3 = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">   <span class="keyword">var</span> arr4 = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">200</span>,<span class="number">0</span>:<span class="number">100</span>,<span class="number">3</span>:<span class="number">300</span>&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for-range循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> arr2 = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> index,val := <span class="keyword">range</span> arr2 &#123;</span><br><span class="line">      fmt.Println(index,val)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>长度是数组类型的一部分 传参的时候如果长度不一致会编译错误</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片是数组的一个引用，因此切片是引用类型，在进行传递时，遵守引用传递的机制。切片的使用和数组类似，遍历切片、访问切片的元素和求切片长度len(slice)都一样。切片的长度是可以变化的，因此切片是一个可以动态变化数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> arr = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">	<span class="comment">//定义一个切片 起始下标为1 结束下标为3但不包括3</span></span><br><span class="line">	slice := arr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">	slice[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">	fmt.Println(slice)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(slice))</span><br><span class="line">	fmt.Println(<span class="built_in">cap</span>(slice))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>slice是一个引用类型 底层是一个结构体 对切片的修改 会改变数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">   ptr *[<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">   <span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">   <span class="built_in">cap</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过make创建切片：var 切片名 []type  = make([]type,len,[cap])</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//第二个参数是len 第三个参数是cap</span></span><br><span class="line">   <span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int64</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">   slice[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义切片的时候指定具体数组 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> slice = []<span class="keyword">string</span>&#123;<span class="string">&quot;12&quot;</span>,<span class="string">&quot;to,&quot;</span>&#125;</span><br><span class="line">   fmt.Println(<span class="built_in">cap</span>(slice))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切片的遍历与数组的遍历相似 切片可以继续切片</p>
<p>使用append函数可以对切片进行动态追加</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> slice = []<span class="keyword">string</span>&#123;<span class="string">&quot;12&quot;</span>,<span class="string">&quot;to,&quot;</span>&#125;</span><br><span class="line">   slice1 := <span class="built_in">append</span>(slice,<span class="string">&quot;sfs&quot;</span>,<span class="string">&quot;as&quot;</span>)</span><br><span class="line">    <span class="comment">//追加切片</span></span><br><span class="line">   slice = <span class="built_in">append</span>(slice,slice1...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切片的拷贝操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> slice = []<span class="keyword">string</span>&#123;<span class="string">&quot;12&quot;</span>,<span class="string">&quot;to,&quot;</span>&#125;</span><br><span class="line">   <span class="keyword">var</span> slice2 = <span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="number">10</span>)</span><br><span class="line">   <span class="comment">//slice与slice2空间是独立的 互补影响</span></span><br><span class="line">   <span class="built_in">copy</span>(slice2,slice)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>string底层是一个数据 也可以进行切片 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   str := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">   slice := str[<span class="number">2</span>:]</span><br><span class="line">   <span class="built_in">println</span>(<span class="built_in">len</span>(slice))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组 : var arr [2][2]int </p>
<p>二维数组的声明和一维数组的几种方法相同</p>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>key不可以是slice，map，function因为这几个没法用==判断</p>
<p>value的类型和key差不多</p>
<p>声明map后 需要用make初始化 分配内存后才能赋值和使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">   a = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">   a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">   a[<span class="number">1</span>] =<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    person := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;person1&quot;</span> : <span class="string">&quot;bob&quot;</span></span><br><span class="line">        <span class="string">&quot;person2&quot;</span> : <span class="string">&quot;tom&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    person[<span class="string">&quot;person1&quot;</span>] = <span class="string">&quot;jack&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map的删除：没有办法一次删除全部key  可以make一个新的map 让之前那个成为垃圾 被回收</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">map</span> [<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">   a = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">   a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">   a[<span class="number">1</span>] =<span class="number">1</span></span><br><span class="line">   <span class="comment">//当指定的key不存在 删除不会操作也不会报错</span></span><br><span class="line">   <span class="built_in">delete</span>(a,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map的查找</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">map</span> [<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">   a = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">   a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">   a[<span class="number">1</span>] =<span class="number">1</span></span><br><span class="line"></span><br><span class="line">   val,ok := a[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      </span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(val)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map的遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">map</span> [<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">   a = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">   a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">   a[<span class="number">1</span>] =<span class="number">1</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> key,val := <span class="keyword">range</span> a &#123;</span><br><span class="line">      fmt.Println(key,val)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果切片类型是map，map个数可以动态变化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> monster = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">2</span>)</span><br><span class="line">   <span class="keyword">if</span> monster[<span class="number">0</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">      monster[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">3</span>)</span><br><span class="line">      monster[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;bob&quot;</span></span><br><span class="line">      monster[<span class="number">0</span>][<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;23&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> monster[<span class="number">1</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">      monster[<span class="number">1</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">3</span>)</span><br><span class="line">      monster[<span class="number">1</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;bob&quot;</span></span><br><span class="line">      monster[<span class="number">1</span>][<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;24&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/09/golang/log\source_posts\golang\image-20210509183134360.png" alt="image-20210509183134360"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> monster = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">2</span>)</span><br><span class="line">   <span class="keyword">if</span> monster[<span class="number">0</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">      monster[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">3</span>)</span><br><span class="line">      monster[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;bob&quot;</span></span><br><span class="line">      monster[<span class="number">0</span>][<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;23&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> monster[<span class="number">1</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">      monster[<span class="number">1</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">3</span>)</span><br><span class="line">      monster[<span class="number">1</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;bob&quot;</span></span><br><span class="line">      monster[<span class="number">1</span>][<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;24&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   newMonster := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span> : <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">      <span class="string">&quot;age&quot;</span> : <span class="string">&quot;23&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   monster = <span class="built_in">append</span>(monster,newMonster)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map排序</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//按照key的顺序输出val</span></span><br><span class="line">   map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">   map1[<span class="number">10</span>] = <span class="number">100</span></span><br><span class="line">   map1[<span class="number">1</span>] = <span class="number">13</span></span><br><span class="line">   map1[<span class="number">4</span>] = <span class="number">56</span></span><br><span class="line">   map1[<span class="number">8</span>] = <span class="number">90</span></span><br><span class="line"></span><br><span class="line">   fmt.Println(map1)</span><br><span class="line">   <span class="comment">//先把key放在切片中 然后对切片就行排序 最后遍历切片</span></span><br><span class="line">   <span class="keyword">var</span> keys []<span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> k, _ := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">      keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">   &#125;</span><br><span class="line">   sort.Ints(keys)</span><br><span class="line">   fmt.Println(keys)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, val := <span class="keyword">range</span> keys &#123;</span><br><span class="line">      fmt.Println(val, map1[val])</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>map达到一定容量的时候 会自动扩容</p>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>struct和java中的类有同等的地位</p>
<p>结构体：字段如果没有赋值则是默认值 如果是引用类型 比如slice，map则为null</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	xiaoming := Cat&#123;<span class="string">&quot;xiaoming&quot;</span>, <span class="number">2</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> cat2 Cat</span><br><span class="line">	cat2.name = <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">	cat2.age = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(cat2.name)</span><br><span class="line">	<span class="built_in">println</span>(xiaoming.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   cat1 := Cat&#123;<span class="string">&quot;xiaoming&quot;</span>,<span class="number">23</span>&#125;</span><br><span class="line">   cat2 := cat1</span><br><span class="line">   <span class="comment">//不同结构体变量的字段是独立的 互不影响</span></span><br><span class="line">   cat2.age = <span class="number">12</span></span><br><span class="line">   fmt.Println(cat1.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他声明方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> cat1 *Cat = <span class="built_in">new</span>(Cat)</span><br><span class="line">   (*cat1).name = <span class="string">&quot;bob&quot;</span></span><br><span class="line">   <span class="comment">//也可以这样写 go底层对进行了处理</span></span><br><span class="line">   cat1.name = <span class="string">&quot;tom&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> cat2 *Cat = &amp;Cat&#123;<span class="string">&quot;blb&quot;</span>,<span class="number">23</span>&#125;</span><br><span class="line">   (*cat2).name = <span class="string">&quot;bob&quot;</span></span><br><span class="line">   <span class="comment">//也可以这样写 go底层对进行了处理</span></span><br><span class="line">   cat2.name = <span class="string">&quot;tom&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体中所有字段在内存中是连续的 但是引用类型指向的地址不一定是连续的</p>
<p>结构体之间的转换</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a Cat</span><br><span class="line">   <span class="keyword">var</span> b Animal</span><br><span class="line"></span><br><span class="line">   a = Cat(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义方法:方法作用在指定的数据类型上，自定义类型都可以有方法 不限于struct</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span>  <span class="title">getName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体是值类型所以要传递指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span> <span class="title">setName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	c.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := Cat&#123;<span class="string">&quot;tom&quot;</span>,<span class="number">23</span>&#125;</span><br><span class="line">	c.setName(<span class="string">&quot;bob&quot;</span>)</span><br><span class="line">	name := c.getName()</span><br><span class="line">	fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法和函数的区别:调用和传参机制基本相同，不一样的地方是方法调用时，会将调用方法的变量当作实参也传递给方法</p>
<p>方法的注意事项和细节：首字母小写只能在本包访问</p>
<p>自定义类型也可以定义方法</p>
<p>如果一个类型实现了String方法 fmt.Println默认会调用该方法</p>
<p>创建struct时指定值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="keyword">string</span></span><br><span class="line">   age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   c1 := Cat&#123;<span class="string">&quot;bob&quot;</span>,<span class="number">23</span>&#125;</span><br><span class="line"></span><br><span class="line">   c2 := Cat&#123;</span><br><span class="line">      age : <span class="number">21</span>,</span><br><span class="line">      name : <span class="string">&quot;bob&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   c3 := &amp;Cat&#123;<span class="string">&quot;bob&quot;</span>,<span class="number">23</span>&#125;</span><br><span class="line">   c4 := &amp;Cat&#123;</span><br><span class="line">      age : <span class="number">21</span>,</span><br><span class="line">      name : <span class="string">&quot;bob&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(c1,c2,*c3,*c4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>model/student.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment">//首字母小写 只能在model下使用</span></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name <span class="keyword">string</span></span><br><span class="line">   Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过工厂模式 让其他包可以使用student</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">student</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;student&#123;name,age&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main/main.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;hello/model&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用工厂模式方式创建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   person := model.NewPerson(<span class="string">&quot;bob&quot;</span>, <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>将结构体字段的首字母小写 其他包不能使用 (类似private)</p>
<p>给结构体所在包提供一个工厂模式的函数(类似构造函数)</p>
<p>提供Get Set方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="keyword">string</span></span><br><span class="line">   age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">student</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;student&#123;name,age&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span> <span class="title">SetName</span><span class="params">(name <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">   s.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>结构体可以使用嵌套匿名结构体所有的字段和方法 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="keyword">string</span></span><br><span class="line">   age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">   A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> b B</span><br><span class="line">   b.A.age = <span class="number">23</span></span><br><span class="line">   b.A.name = <span class="string">&quot;bob&quot;</span></span><br><span class="line">    <span class="comment">//可以简化 :编译器先看B有没有age 如果没有再看A 再没有就报错</span></span><br><span class="line">    <span class="comment">//当结构体和匿名结构体有相同的字段就就近访问 如果希望访问匿名结构体中的字段可以b.A.age</span></span><br><span class="line">   age := b.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体如果嵌入多个匿名结构体 且两个匿名结构体有相同的字段和方法 且结构体本身没有 在访问时必须指定匿名结构体名字否则编译报错</p>
<p>如果一个struct嵌入了一个又名结构体 这种模式是组合 那么在范根组合的结构体的字段或方法时 必须带上结构体的名字</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="keyword">string</span></span><br><span class="line">   age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//组合</span></span><br><span class="line">    a A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> b B</span><br><span class="line">   b.a.age = <span class="number">23</span></span><br><span class="line">   b.a.name = <span class="string">&quot;bob&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嵌套匿名结构体后，可以在创建结构体变量时，直接指定各个匿名结构体字段的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="keyword">string</span></span><br><span class="line">   age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//组合</span></span><br><span class="line">    A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//组合</span></span><br><span class="line">   *A</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   b := B&#123;A&#123;<span class="string">&quot;bob&quot;</span>,<span class="number">23</span>&#125;&#125;</span><br><span class="line">   c := B&#123;A&#123;<span class="string">&quot;bob&quot;</span>,<span class="number">23</span>&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>只要是自定义类型就可以实现接口 不限于结构体，可以实现多个接口</p>
<p>接口中不能有变量</p>
<p>要实现了接口的所有方法</p>
<p>只有实现了接口才能把自定义数据类型的实例赋值给接口类型</p>
<p>可以把任何变量赋值给空接口</p>
<p>接口类型默认是指针</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是通过接口实现的 可以按照统一的接口来调用不同的实现 这是接口变量就呈现不同的形态</p>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="keyword">string</span></span><br><span class="line">   age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> inter <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">var</span> cat Cat = Cat&#123;<span class="string">&quot;bob&quot;</span>,<span class="number">23</span>&#125;</span><br><span class="line">   inter = cat</span><br><span class="line">   <span class="keyword">var</span> b Cat</span><br><span class="line">   <span class="comment">//使用类型断言 判断inter的类型 在进行赋值</span></span><br><span class="line">   b = inter.(Cat)</span><br><span class="line">   fmt.Println(b)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//带检测到类型断言</span></span><br><span class="line">   <span class="keyword">if</span> y,ok := inter.(Cat); ok &#123;</span><br><span class="line">      fmt.Println(y)</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;转换失败&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>参考：<a href="https://www.cnblogs.com/louis181214/p/10309601.html">https://www.cnblogs.com/louis181214/p/10309601.html</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//得到文件对象</span></span><br><span class="line">   file, err := os.Open(<span class="string">&quot;D:/test.txt&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">   &#125;</span><br><span class="line">   file.Close()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//读取到的内容显示到终端</span></span><br><span class="line">   data, err := ioutil.ReadFile(<span class="string">&quot;D:/test.txt&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(fmt.Println(<span class="keyword">string</span>(bytes)))</span><br><span class="line"></span><br><span class="line">   <span class="comment">//写文件 第二个参数是文件打开模式 可以组合 第三个参数是权限控制 (linux)</span></span><br><span class="line">   openFile, err := os.OpenFile(<span class="string">&quot;D:/test.txt&quot;</span>, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> openFile.Close()</span><br><span class="line">   str := <span class="string">&quot;i am bob&quot;</span></span><br><span class="line">   <span class="comment">//使用带缓存的write</span></span><br><span class="line">   writer := bufio.NewWriter(openFile)</span><br><span class="line">   writer.WriteString(str)</span><br><span class="line">   writer.Flush()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//把一个文件的内容写入到另一个文件</span></span><br><span class="line">   file1Path := <span class="string">&quot;D:/test.txt&quot;</span></span><br><span class="line">   file2Path := <span class="string">&quot;D:/b.txt&quot;</span></span><br><span class="line">   data, err := ioutil.ReadFile(file1Path)</span><br><span class="line">   ioutil.WriteFile(file2Path,data,<span class="number">0666</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//判断文件或文件夹是否存在</span></span><br><span class="line">   _, err = os.Stat(file2Path)</span><br><span class="line">   <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">//文件存在</span></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">if</span>(os.isNotExist(err))&#123;</span><br><span class="line">        <span class="comment">//文件不存在</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h1><p>序列化 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//想要序列化的值必须首字母大写</span></span><br><span class="line">   <span class="comment">//json可以指定序列化后的key</span></span><br><span class="line">   Name <span class="keyword">string</span> <span class="string">`json:&quot;cat_name&quot;`</span></span><br><span class="line">   Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//struct序列化</span></span><br><span class="line">   cat := Cat&#123;</span><br><span class="line">      Name : <span class="string">&quot;bob&quot;</span>,</span><br><span class="line">      Age : <span class="number">12</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   bytes, _ := json.Marshal(&amp;cat)</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="keyword">string</span>(bytes))</span><br><span class="line"></span><br><span class="line">   <span class="comment">//map序列化</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   a =<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">   a[<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;北京&quot;</span></span><br><span class="line">   a[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;bob&quot;</span></span><br><span class="line">   a[<span class="string">&quot;age&quot;</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">   data, _ := json.Marshal(&amp;a)</span><br><span class="line">   fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//对slice进行序列化</span></span><br><span class="line">   <span class="keyword">var</span> slice []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   <span class="comment">//使用map前，需要先make</span></span><br><span class="line">   m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">   m1[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;jack&quot;</span></span><br><span class="line">   m1[<span class="string">&quot;age&quot;</span>] = <span class="number">7</span></span><br><span class="line">   m1[<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;北京&quot;</span></span><br><span class="line">   slice = <span class="built_in">append</span>(slice, m1)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> m2 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   <span class="comment">//使用map前，需要先make</span></span><br><span class="line">   m2 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">   m2[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;tom&quot;</span></span><br><span class="line">   m2[<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;20&quot;</span></span><br><span class="line">   m2[<span class="string">&quot;address&quot;</span>] = [<span class="number">2</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;墨西哥&quot;</span>,<span class="string">&quot;夏威夷&quot;</span>&#125;</span><br><span class="line">   slice = <span class="built_in">append</span>(slice, m2)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将切片进行序列化操作</span></span><br><span class="line">   data, err := json.Marshal(slice)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;序列化错误 err=%v\n&quot;</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//输出序列化后的结果</span></span><br><span class="line">   fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反序列化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//想要序列化的值必须首字母大写</span></span><br><span class="line">   <span class="comment">//json可以指定序列化后的key</span></span><br><span class="line">   Name <span class="keyword">string</span> <span class="string">`json:&quot;cat_name&quot;`</span></span><br><span class="line">   Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//注意name这个字段</span></span><br><span class="line">   str := <span class="string">&quot;&#123;\&quot;cat_name\&quot;:\&quot;bob\&quot;,\&quot;Age\&quot;:12&#125;&quot;</span></span><br><span class="line">   <span class="keyword">var</span> cat Cat</span><br><span class="line">   err := json.Unmarshal([]<span class="keyword">byte</span>(str),&amp;cat)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//反序列化map</span></span><br><span class="line">   str1 := <span class="string">&quot;&#123;\&quot;address\&quot;:\&quot;北京\&quot;,\&quot;age\&quot;:2,\&quot;name\&quot;:\&quot;bob\&quot;&#125;&quot;</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   _ = json.Unmarshal([]<span class="keyword">byte</span>(str1), &amp;a)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//反序列化slice</span></span><br><span class="line">   str2 := <span class="string">&quot;[&#123;\&quot;address\&quot;:\&quot;北京\&quot;,\&quot;age\&quot;:7,\&quot;name\&quot;:\&quot;jack\&quot;&#125;,&#123;\&quot;address\&quot;:[\&quot;墨西哥\&quot;,\&quot;夏威夷\&quot;],\&quot;age\&quot;:\&quot;20\&quot;,\&quot;name\&quot;:\&quot;tom\&quot;&#125;]&quot;</span></span><br><span class="line">   <span class="keyword">var</span> slice []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   _ = json.Unmarshal([]<span class="keyword">byte</span>(str2), &amp;slice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>sum.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(a <span class="keyword">int</span> ,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sum_test.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSum</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   res := Sum(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">   <span class="keyword">if</span> res != <span class="number">3</span> &#123;</span><br><span class="line">      t.Fatalf(<span class="string">&quot;Sum(1,2) 执行错误，期望值=%v 实际值=%v\n&quot;</span>, <span class="number">3</span>, res)</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      t.Logf(<span class="string">&quot;执行正确&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试文件必须以_test.go结尾 </p>
<p>测试用例函数必须以Test开头 测试函数形参类型必须是*testing.T</p>
<p>一个测试文件中可以有多个测试用例函数</p>
<p>执行：在命令行输入命令 go test 错误会输出日志 正确不会 如果带上参数-v无论对错都输出日志</p>
<p>当出现错误可以使用t.FatalF格式化 输出错误信息 并退出程序</p>
<p>t.logF可以输出相应的日志</p>
<p>可以只测试目录下的单个文件 go test -v sum_test.go</p>
<h1 id="goroutine和channel"><a href="#goroutine和channel" class="headerlink" title="goroutine和channel"></a>goroutine和channel</h1><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>一个go线程上可以起多个协程，写成是轻量级的线程</p>
<p>go协程的特点</p>
<ul>
<li>有独立的栈空间</li>
<li>共享程序堆空间</li>
<li>调度由用户控制</li>
<li>协程是轻量级的线程</li>
</ul>
<p>设置cpu</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   cpuNum := runtime.NumCPU()</span><br><span class="line">   fmt.Println(<span class="string">&quot;cpuNum=&quot;</span>, cpuNum)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//可以自己设置使用多个cpu</span></span><br><span class="line">   runtime.GOMAXPROCS(cpuNum - <span class="number">1</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="number">10</span>;i++ &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;test&quot;</span>,i)</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//开启一个协程</span></span><br><span class="line">   <span class="keyword">go</span> test()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="number">10</span>;i++ &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;main&quot;</span>,i)</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;![image<span class="number">-20210510140138756</span>](D:\log\source\_posts\golang\image<span class="number">-20210510140138756.</span>png)</span><br></pre></td></tr></table></figure>

<h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>channle本质是一个队列 是线程安全的多个goroutine访问时不需要加锁</p>
<p>channel是有类型的 一个类型的channel只能存放该类型的数据</p>
<p>channel是引用类型 且必须make之后才能使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> intChannel <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">   intChannel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//想channel写入数据</span></span><br><span class="line">   intChannel &lt;- <span class="number">10</span></span><br><span class="line">   num := <span class="number">21</span></span><br><span class="line">   intChannel &lt;- num</span><br><span class="line"></span><br><span class="line">   <span class="comment">//从管道取出数据</span></span><br><span class="line">   num2 := &lt;- intChannel</span><br><span class="line">   fmt.Println(num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//创建一个可以存放任意类型的channel</span></span><br><span class="line">   <span class="keyword">var</span> intChannel <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   intChannel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">   cat := Cat&#123;<span class="string">&quot;bob&quot;</span>,<span class="number">23</span>&#125;</span><br><span class="line">   intChannel &lt;- cat</span><br><span class="line">   intChannel &lt;- <span class="number">10</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">var</span> cat3 Cat</span><br><span class="line">   <span class="comment">//取出的时候要断言</span></span><br><span class="line">   cat3 = (&lt;-intChannel).(Cat)</span><br><span class="line">   fmt.Println(cat3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>channel的关闭:使用内置函数close管理channel 关闭后不能像channel中写入数据 但是仍然可以从channel中读取数据</p>
<p>channel的遍历：遍历时如果没有关闭channel会报错</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//创建一个可以存放任意类型的channel</span></span><br><span class="line">   <span class="keyword">var</span> intChannel <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   intChannel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">   cat := Cat&#123;<span class="string">&quot;bob&quot;</span>,<span class="number">23</span>&#125;</span><br><span class="line">   intChannel &lt;- cat</span><br><span class="line">   intChannel &lt;- <span class="number">10</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">close</span>(intChannel)</span><br><span class="line">   <span class="keyword">for</span> v := <span class="keyword">range</span> intChannel &#123;</span><br><span class="line">      fmt.Println(v)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明管道为只读或只写</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//声明只读管道</span></span><br><span class="line">   <span class="keyword">var</span> readOnlyChannel <span class="keyword">chan</span>&lt;- <span class="keyword">int</span></span><br><span class="line">   <span class="comment">//声明只写管道</span></span><br><span class="line">   <span class="keyword">var</span> writeOnlyChannel  &lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>select解决从管道读取数据阻塞的问题</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//创建一个可以存放任意类型的channel</span></span><br><span class="line">   <span class="keyword">var</span> intChannel <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">   intChannel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">   intChannel &lt;- <span class="number">20</span></span><br><span class="line">   intChannel &lt;- <span class="number">10</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> stringChannel <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">   stringChannel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">   stringChannel &lt;- <span class="string">&quot;bob&quot;</span></span><br><span class="line">   stringChannel &lt;- <span class="string">&quot;tom&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> v:= &lt;-intChannel:</span><br><span class="line">            fmt.Println(<span class="string">&quot;从intChannel中读取数据&quot;</span>,v)</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">         <span class="keyword">case</span> v:= &lt;-stringChannel:</span><br><span class="line">            fmt.Println(<span class="string">&quot;从stringChannel中读取数据&quot;</span>,v)</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;结束&quot;</span>)</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在goroutine中使用recover解决写成中出现panic导致程序崩溃的问题</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFor</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="number">10</span>;i++ &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;test&quot;</span>,i)</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> err:=<span class="built_in">recover</span>();err != <span class="literal">nil</span> &#123;&#125;</span><br><span class="line">      fmt.Println(<span class="string">&quot;发生错误&quot;</span>)</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   a := <span class="number">2</span></span><br><span class="line">   b := <span class="number">0</span></span><br><span class="line">   c := a / b</span><br><span class="line">   fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">go</span> myFor()</span><br><span class="line">   <span class="keyword">go</span> test()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">10</span> ;i++ &#123;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>reflect.TyepOf()：获取变量的类型 返回reflect.Type类型</p>
<p>reflect.ValueOf()：获取变量的值 ，返回reflect.Value类型 (是一个结构体 可以获取到关于该变量的很多信息)</p>
<p>变量，interface{}，reflect.Value可以相互转换</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//想要序列化的值必须首字母大写</span></span><br><span class="line">   <span class="comment">//json可以指定序列化后的key</span></span><br><span class="line">   Name <span class="keyword">string</span> <span class="string">`json:&quot;cat_name&quot;`</span></span><br><span class="line">   Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="comment">//interface转换成reflect.Value</span></span><br><span class="line">   rVal := reflect.ValueOf(b)</span><br><span class="line">   <span class="comment">//reflect.Value转换为interface</span></span><br><span class="line">   inter := rVal.Interface()</span><br><span class="line">   <span class="comment">//interface转换为变量</span></span><br><span class="line">   value := inter.(Cat)</span><br><span class="line">   fmt.Println(value)</span><br><span class="line">   fmt.Println(reflect.TypeOf(b).Name())</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   cat := Cat&#123;<span class="string">&quot;bob&quot;</span>,<span class="number">23</span>&#125;</span><br><span class="line">   test(cat)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>反射的注意事项和细节</p>
<ul>
<li>reflect.Value.Kind：获取变量的类型 返回一个常量</li>
<li>Type和Kind的区别：Type是类型，Kind是类型 两者又是相同 比如int类型，有时不同 比如type Cat struct 。kind返回struct，Type返回Cat</li>
</ul>
<p>通过反射来修改变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   val := reflect.ValueOf(b)</span><br><span class="line">   val.Elem().SetInt(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line">   test(&amp;a)</span><br><span class="line">   fmt.Println(a)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>reflect.Value.Elem()：Elem returns the value that the interface v contains or that the pointer v points to.</p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p> server.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span>&#123;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">//从conn中读取 如果客户端没有write则阻塞</span></span><br><span class="line">		n,err := conn.Read(buf)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;发生错误1&quot;</span>,err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Println(<span class="keyword">string</span>(buf[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8888&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;发生错误2&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> listen.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		conn, err := listen.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;发生错误3&quot;</span>,err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> process(conn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8888&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	reader := bufio.NewReader(os.Stdin)</span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		<span class="comment">//从终端读取一行用户输入 发送给服务器</span></span><br><span class="line">		line,err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">		line = strings.Trim(line,<span class="string">&quot; \r\n&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> line == <span class="string">&quot;exit&quot;</span>&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;客户端退出&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//发送line给服务器</span></span><br><span class="line">		_, err = conn.Write([]<span class="keyword">byte</span>(line)) <span class="comment">//第一个返回参数是字节数</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Go连接到redis"><a href="#Go连接到redis" class="headerlink" title="Go连接到redis"></a>Go连接到redis</h1><p>安装redis包</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/<span class="keyword">go</span>-redis/redis</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//创建redis线程池</span></span><br><span class="line">   client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">      Addr:     <span class="string">&quot;192.168.52.131:6379&quot;</span>,</span><br><span class="line">      Password: <span class="string">&quot;&quot;</span>, <span class="comment">// no password set</span></span><br><span class="line">      DB:       <span class="number">0</span>,  <span class="comment">// use default DB</span></span><br><span class="line">      PoolSize: <span class="number">500</span>,  <span class="comment">// Redis连接池大小</span></span><br><span class="line">      MaxRetries: <span class="number">500</span>,           <span class="comment">// 最大重试次数</span></span><br><span class="line">      IdleTimeout: <span class="number">600</span> * time.Second,          <span class="comment">// 空闲链接超时时间</span></span><br><span class="line">   &#125;)</span><br><span class="line">   client.Set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;bob&quot;</span>, <span class="number">0</span>)</span><br><span class="line">   result, _ := client.Get(<span class="string">&quot;name&quot;</span>).Result()</span><br><span class="line"></span><br><span class="line">   fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Go连接到mysql"><a href="#Go连接到mysql" class="headerlink" title="Go连接到mysql"></a>Go连接到mysql</h1><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/<span class="keyword">go</span>-sql-driver/mysql</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;database/sql&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="comment">//import 下划线（如：import _ github/demo）的作用：当导入一个包时，该包下的文件里所有init()函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行init()函数而已。这个时候就可以使用 import _ 引用该包。</span></span><br><span class="line">	_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	db,_:=sql.Open(<span class="string">&quot;mysql&quot;</span>,<span class="string">&quot;root:Bbj0611..@tcp(192.168.52.131:3306)/exercise&quot;</span>)</span><br><span class="line"></span><br><span class="line">	err := db.Ping()</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;数据库链接失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//多行查询</span></span><br><span class="line">	rows,_:=db.Query(<span class="string">&quot;select * from grade&quot;</span>)</span><br><span class="line">	<span class="keyword">var</span> id,level <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> rows.Next()&#123;</span><br><span class="line">		rows.Scan(&amp;id,&amp;level)</span><br><span class="line">		 fmt.Println(id,level)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="GIN"><a href="#GIN" class="headerlink" title="GIN"></a>GIN</h1>]]></content>
  </entry>
  <entry>
    <title>grpc</title>
    <url>/2021/05/16/grpc/</url>
    <content><![CDATA[<p>参考：<a href="https://www.cnblogs.com/oolo/p/11840305.html">https://www.cnblogs.com/oolo/p/11840305.html</a></p>
<p>代码：grpc</p>
<p><img src="/2021/05/16/grpc/log\source_posts\grpc\image-20210516104041823.png" alt="image-20210516104041823"></p>
<p>安装grpc和编译插件</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> google.golang.org/grpc</span><br><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span> github.<span class="keyword">com</span>/golang/protobuf/protoc-gen-<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>创建一个protobuf文件</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;./proto&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">StringMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">repeated</span> StringSingle ss = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">StringSingle</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Empty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">MaxSize</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Echo(Empty) <span class="keyword">returns</span> (stream StringMessage) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行命令进行编译该文件：protoc –go_out=plugins=grpc:. service.proto</p>
<p>应用：<a href="https://segmentfault.com/a/1190000015135650/">https://segmentfault.com/a/1190000015135650/</a></p>
]]></content>
  </entry>
</search>
